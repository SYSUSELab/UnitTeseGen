{
  "batch-processing-gateway": {
    "project-name": "batch-processing-gateway",
    "project-url": "batch-processing-gateway",
    "focal-methods": [
      {
        "id": "SparkPodSpec_copyFrom",
        "package": "com.apple.spark.operator",
        "class": "com.apple.spark.operator.SparkPodSpec",
        "test-class": "com.apple.spark.operator.SparkPodSpec_copyFrom_Test",
        "method-name": "copyFrom(SparkPodSpec)",
        "source-path": "src/main/java/com/apple/spark/operator/SparkPodSpec.java",
        "test-path": "src/test/java/com/apple/spark/operator/SparkPodSpec_copyFrom_Test.java",
        "focal-method": "protected void copyFrom(SparkPodSpec another) {\r\n    if (another.cores != null) {\r\n        this.cores = another.cores;\r\n    }\r\n    if (another.coreLimit != null) {\r\n        this.coreLimit = another.coreLimit;\r\n    }\r\n    if (another.memory != null) {\r\n        this.memory = another.memory;\r\n    }\r\n    if (another.memoryOverhead != null) {\r\n        this.memoryOverhead = another.memoryOverhead;\r\n    }\r\n    if (another.image != null) {\r\n        this.image = another.image;\r\n    }\r\n    if (another.env == null) {\r\n        this.env = null;\r\n    } else {\r\n        this.env = new ArrayList<>(another.env);\r\n    }\r\n    if (another.labels == null) {\r\n        this.labels = null;\r\n    } else {\r\n        this.labels = new HashMap<>(another.labels);\r\n    }\r\n    if (another.annotations == null) {\r\n        this.annotations = null;\r\n    } else {\r\n        this.annotations = new HashMap<>(another.annotations);\r\n    }\r\n    this.terminationGracePeriodSeconds = another.terminationGracePeriodSeconds;\r\n    this.serviceAccount = another.serviceAccount;\r\n    if (another.volumeMounts == null) {\r\n        this.volumeMounts = null;\r\n    } else {\r\n        this.volumeMounts = new ArrayList<>(another.volumeMounts);\r\n    }\r\n    this.securityContext = another.securityContext;\r\n    this.affinity = another.affinity;\r\n    this.coreRequest = another.coreRequest;\r\n    this.javaOptions = another.javaOptions;\r\n}",
        "class-code": "package com.apple.spark.operator;\nimport io.swagger.v3.oas.annotations.Hidden;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport java.util.List;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport java.util.Map;\nimport io.fabric8.kubernetes.api.model.PodDNSConfig;\n@JsonInclude(Include.NON_NULL)\r\n@JsonIgnoreProperties(ignoreUnknown = true)\r\npublic class SparkPodSpec {\n    private Integer cores;\n    private String coreRequest;\n    private String coreLimit;\n    private String memory;\n    private String memoryOverhead;\n    private String image;\n    private List<EnvVar> env;\n    private Map<String, String> labels;\n    private Map<String, String> annotations;\n    @Hidden\r\nprivate Long terminationGracePeriodSeconds;\n    @Hidden\r\nprivate String serviceAccount;\n    @Hidden\r\nprivate List<VolumeMount> volumeMounts;\n    @Hidden\r\nprivate SecurityContext securityContext;\n    @Hidden\r\nprivate Affinity affinity;\n    @Hidden\r\nprivate String javaOptions;\n    protected void copyFrom(SparkPodSpec another) {\r\n        if (another.cores != null) {\r\n            this.cores = another.cores;\r\n        }\r\n        if (another.coreLimit != null) {\r\n            this.coreLimit = another.coreLimit;\r\n        }\r\n        if (another.memory != null) {\r\n            this.memory = another.memory;\r\n        }\r\n        if (another.memoryOverhead != null) {\r\n            this.memoryOverhead = another.memoryOverhead;\r\n        }\r\n        if (another.image != null) {\r\n            this.image = another.image;\r\n        }\r\n        if (another.env == null) {\r\n            this.env = null;\r\n        } else {\r\n            this.env = new ArrayList<>(another.env);\r\n        }\r\n        if (another.labels == null) {\r\n            this.labels = null;\r\n        } else {\r\n            this.labels = new HashMap<>(another.labels);\r\n        }\r\n        if (another.annotations == null) {\r\n            this.annotations = null;\r\n        } else {\r\n            this.annotations = new HashMap<>(another.annotations);\r\n        }\r\n        this.terminationGracePeriodSeconds = another.terminationGracePeriodSeconds;\r\n        this.serviceAccount = another.serviceAccount;\r\n        if (another.volumeMounts == null) {\r\n            this.volumeMounts = null;\r\n        } else {\r\n            this.volumeMounts = new ArrayList<>(another.volumeMounts);\r\n        }\r\n        this.securityContext = another.securityContext;\r\n        this.affinity = another.affinity;\r\n        this.coreRequest = another.coreRequest;\r\n        this.javaOptions = another.javaOptions;\r\n    }\npublic Affinity getAffinity();\n    public Map<String, String> getAnnotations();\n    public String getCoreLimit();\n    public String getCoreRequest();\n    public Integer getCores();\n    public PodDNSConfig getDnsConfig();\n    public List<EnvVar> getEnv();\n    public String getImage();\n    public String getJavaOptions();\n    public Map<String, String> getLabels();\n    public String getMemory();\n    public String getMemoryOverhead();\n    public SecurityContext getSecurityContext();\n    public String getServiceAccount();\n    public Long getTerminationGracePeriodSeconds();\n    public List<VolumeMount> getVolumeMounts();\n    public void setAffinity(Affinity affinity);\n    public void setAnnotations(Map<String, String> annotations);\n    public void setCoreLimit(String coreLimit);\n    public void setCoreRequest(String coreRequest);\n    public void setCores(Integer cores);\n    public void setDnsConfig(PodDNSConfig dnsConfig);\n    public void setEnv(List<EnvVar> env);\n    public void setImage(String image);\n    public void setJavaOptions(String javaOptions);\n    public void setLabels(Map<String, String> labels);\n    public void setMemory(String memory);\n    public void setMemoryOverhead(String memoryOverhead);\n    public void setSecurityContext(SecurityContext securityContext);\n    public void setServiceAccount(String serviceAccount);\n    public void setTerminationGracePeriodSeconds(Long terminationGracePeriodSeconds);\n    public void setVolumeMounts(List<VolumeMount> volumeMounts);\n}"
      },
      {
        "id": "ApplicationSubmissionHelper_getSparkConf",
        "package": "com.apple.spark.core",
        "class": "com.apple.spark.core.ApplicationSubmissionHelper",
        "test-class": "com.apple.spark.core.ApplicationSubmissionHelper_getSparkConf_Test",
        "method-name": "getSparkConf(String, SubmitApplicationRequest, AppConfig, AppConfig.SparkCluster)",
        "source-path": "src/main/java/com/apple/spark/core/ApplicationSubmissionHelper.java",
        "test-path": "src/test/java/com/apple/spark/core/ApplicationSubmissionHelper_getSparkConf_Test.java",
        "focal-method": "public static Map<String, String> getSparkConf(String submissionId, SubmitApplicationRequest request, AppConfig appConfig, AppConfig.SparkCluster sparkCluster) {\r\n    Map<String, String> sparkConf = null;\r\n    Map<String, String> defaultSparkConf = appConfig.getDefaultSparkConf();\r\n    Map<String, String> fixedSparkConf = appConfig.getFixedSparkConf();\r\n    if (defaultSparkConf != null) {\r\n        if (sparkConf == null) {\r\n            sparkConf = new HashMap<>();\r\n        }\r\n        Map<String, String> filteredDefaultSparkConf = applyFeatureGate(request, defaultSparkConf);\r\n        for (Map.Entry<String, String> entry : filteredDefaultSparkConf.entrySet()) {\r\n            sparkConf.put(entry.getKey(), substitutionSparkConfigValue(entry.getValue(), submissionId));\r\n        }\r\n    }\r\n    if (sparkCluster.getSparkConf() != null) {\r\n        if (sparkConf == null) {\r\n            sparkConf = new HashMap<>();\r\n        }\r\n        for (Map.Entry<String, String> entry : sparkCluster.getSparkConf().entrySet()) {\r\n            sparkConf.put(entry.getKey(), substitutionSparkConfigValue(entry.getValue(), submissionId));\r\n        }\r\n    }\r\n    if (request.getSparkConf() != null) {\r\n        if (sparkConf == null) {\r\n            sparkConf = new HashMap<>();\r\n        }\r\n        for (Map.Entry<String, String> entry : request.getSparkConf().entrySet()) {\r\n            sparkConf.put(entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n    if (fixedSparkConf != null) {\r\n        if (sparkConf == null) {\r\n            sparkConf = new HashMap<>();\r\n        }\r\n        sparkConf.putAll(fixedSparkConf);\r\n    }\r\n    if (!StringUtils.isEmpty(request.getApplicationName())) {\r\n        if (sparkConf == null) {\r\n            sparkConf = new HashMap<>();\r\n        }\r\n        sparkConf.put(SparkConstants.SPARK_APP_NAME_CONFIG, request.getApplicationName());\r\n    }\r\n    return sparkConf;\r\n}",
        "class-code": "package com.apple.spark.core;\nimport com.apple.spark.operator.NodeAffinity;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_ROOT_QUEUE;\nimport com.apple.spark.api.SubmitApplicationRequest;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLGenerator;\nimport java.util.HashMap;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_SPARK_DEFAULT_QUEUE;\nimport java.util.ArrayList;\nimport com.apple.spark.util.ExceptionUtils;\nimport org.slf4j.Logger;\nimport com.apple.spark.operator.SparkApplicationSpec;\nimport static com.apple.spark.core.SparkConstants.DRIVER_MEM_BUFFER_RATIO;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_MEM_BUFFER_RATIO;\nimport com.apple.spark.operator.ExecutorSpec;\nimport static com.apple.spark.core.BatchSchedulerConstants.PLACEHOLDER_TIMEOUT_IN_SECONDS;\nimport org.apache.commons.lang3.StringUtils;\nimport com.apple.spark.operator.NodeSelectorTerm;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.apple.spark.operator.DriverSpec;\nimport com.apple.spark.operator.BatchSchedulerConfiguration;\nimport java.util.List;\nimport java.util.UUID;\nimport static com.apple.spark.core.SparkConstants.DRIVER_CPU_BUFFER_RATIO;\nimport org.slf4j.LoggerFactory;\nimport com.apple.spark.operator.NodeSelectorOperator;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.util.Collections;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.Optional;\nimport com.apple.spark.AppConfig;\nimport com.apple.spark.operator.RequiredDuringSchedulingIgnoredDuringExecutionTerm;\nimport com.apple.spark.operator.NodeSelectorRequirement;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_CPU_BUFFER_RATIO;\nimport io.fabric8.kubernetes.api.model.PodDNSConfig;\nimport com.apple.spark.operator.Volume;\nimport javax.ws.rs.core.Response;\nimport static com.apple.spark.core.Constants.*;\nimport io.fabric8.kubernetes.api.model.PodDNSConfigOption;\nimport com.apple.spark.operator.SparkUIConfiguration;\nimport com.apple.spark.operator.Affinity;\nimport javax.ws.rs.WebApplicationException;\nimport com.apple.spark.AppConfig.SparkCluster;\nimport java.util.Map;\nimport java.util.Arrays;\nimport static com.apple.spark.core.SparkConstants.CORE_LIMIT_RATIO;\npublic class ApplicationSubmissionHelper {\n    \n    public static Map<String, String> getSparkConf(String submissionId, SubmitApplicationRequest request, AppConfig appConfig, AppConfig.SparkCluster sparkCluster) {\r\n        Map<String, String> sparkConf = null;\r\n        Map<String, String> defaultSparkConf = appConfig.getDefaultSparkConf();\r\n        Map<String, String> fixedSparkConf = appConfig.getFixedSparkConf();\r\n        if (defaultSparkConf != null) {\r\n            if (sparkConf == null) {\r\n                sparkConf = new HashMap<>();\r\n            }\r\n            Map<String, String> filteredDefaultSparkConf = applyFeatureGate(request, defaultSparkConf);\r\n            for (Map.Entry<String, String> entry : filteredDefaultSparkConf.entrySet()) {\r\n                sparkConf.put(entry.getKey(), substitutionSparkConfigValue(entry.getValue(), submissionId));\r\n            }\r\n        }\r\n        if (sparkCluster.getSparkConf() != null) {\r\n            if (sparkConf == null) {\r\n                sparkConf = new HashMap<>();\r\n            }\r\n            for (Map.Entry<String, String> entry : sparkCluster.getSparkConf().entrySet()) {\r\n                sparkConf.put(entry.getKey(), substitutionSparkConfigValue(entry.getValue(), submissionId));\r\n            }\r\n        }\r\n        if (request.getSparkConf() != null) {\r\n            if (sparkConf == null) {\r\n                sparkConf = new HashMap<>();\r\n            }\r\n            for (Map.Entry<String, String> entry : request.getSparkConf().entrySet()) {\r\n                sparkConf.put(entry.getKey(), entry.getValue());\r\n            }\r\n        }\r\n        if (fixedSparkConf != null) {\r\n            if (sparkConf == null) {\r\n                sparkConf = new HashMap<>();\r\n            }\r\n            sparkConf.putAll(fixedSparkConf);\r\n        }\r\n        if (!StringUtils.isEmpty(request.getApplicationName())) {\r\n            if (sparkConf == null) {\r\n                sparkConf = new HashMap<>();\r\n            }\r\n            sparkConf.put(SparkConstants.SPARK_APP_NAME_CONFIG, request.getApplicationName());\r\n        }\r\n        return sparkConf;\r\n    }\nstatic Map<String, String> applyFeatureGate(SubmitApplicationRequest request, Map<String, String> conf);\n    public static String generateSubmissionId(String clusterId);\n    public static String generateSubmissionId(String clusterId, String submissionIdSuffix);\n    public static String getClusterIdFromSubmissionId(String submissionId);\n    public static DriverSpec getDriverSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster);\n    public static ExecutorSpec getExecutorSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster);\n    public static String getImage(AppConfig appConfig, SubmitApplicationRequest request, String type, String sparkVersion, String proxyUser);\n    public static String getProxyUser(String user, String dagUser);\n    public static SparkUIConfiguration getSparkUIConfiguration(String submissionId, AppConfig.SparkCluster sparkCluster);\n    public static String getType(String specifiedType, String mainClass);\n    public static List<Volume> getVolumes(SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster);\n    public static BatchSchedulerConfiguration getYuniKornSchedulerConfig(String queue);\n    public static boolean looksLikeFilePath(String requestBody);\n    public static SubmitApplicationRequest parseSubmitRequest(String requestBody, String contentType);\n    public static void populateEnv(SparkApplicationSpec sparkSpec, SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster);\n    private static String substitutionSparkConfigValue(String value, String submissionId);\n    public static void validateQueueToken(String queue, String queueToken, AppConfig appConfig);\n}"
      },
      {
        "id": "SubmissionSummary_copyFrom",
        "package": "com.apple.spark.api",
        "class": "com.apple.spark.api.SubmissionSummary",
        "test-class": "com.apple.spark.api.SubmissionSummary_copyFrom_Test",
        "method-name": "copyFrom(SparkApplication)",
        "source-path": "src/main/java/com/apple/spark/api/SubmissionSummary.java",
        "test-path": "src/test/java/com/apple/spark/api/SubmissionSummary_copyFrom_Test.java",
        "focal-method": "@Override\r\npublic void copyFrom(SparkApplication sparkApplicationResource) {\r\n    super.copyFrom(sparkApplicationResource);\r\n    setSubmissionId(sparkApplicationResource.getMetadata().getName());\r\n    if (sparkApplicationResource.getMetadata().getLabels() != null) {\r\n        String user = sparkApplicationResource.getMetadata().getLabels().get(Constants.PROXY_USER_LABEL);\r\n        String queue = \"\";\r\n        if (sparkApplicationResource.getMetadata().getLabels().containsKey(Constants.QUEUE_LABEL)) {\r\n            queue = sparkApplicationResource.getMetadata().getLabels().get(Constants.QUEUE_LABEL);\r\n        }\r\n        String dagName = \"\";\r\n        int driverCores = 1;\r\n        Long driverMemoryGB = 0L;\r\n        int executorInstances = 1;\r\n        int executorCores = 1;\r\n        Long executorMemoryGB = 0L;\r\n        if (sparkApplicationResource.getSpec().getDriver().getLabels() != null) {\r\n            if (sparkApplicationResource.getSpec().getDriver().getLabels().containsKey(Constants.DAG_NAME_LABEL)) {\r\n                dagName = sparkApplicationResource.getSpec().getDriver().getLabels().get(Constants.DAG_NAME_LABEL);\r\n            }\r\n        }\r\n        if (sparkApplicationResource.getSpec().getDriver().getMemory() != null) {\r\n            try {\r\n                driverMemoryGB = byteStringAsGb(sparkApplicationResource.getSpec().getDriver().getMemory());\r\n            } catch (Exception e) {\r\n                logger.info(\"Cannot convert Driver memory size string to Gb for {}, {}.\", submissionId, e.toString());\r\n            }\r\n        }\r\n        if (sparkApplicationResource.getSpec().getDriver().getCores() != null) {\r\n            driverCores = sparkApplicationResource.getSpec().getDriver().getCores();\r\n        }\r\n        if (sparkApplicationResource.getSpec().getExecutor().getCores() != null) {\r\n            executorCores = sparkApplicationResource.getSpec().getExecutor().getCores();\r\n        }\r\n        if (sparkApplicationResource.getSpec().getExecutor().getInstances() != null) {\r\n            executorInstances = sparkApplicationResource.getSpec().getExecutor().getInstances();\r\n        }\r\n        if (sparkApplicationResource.getSpec().getExecutor().getMemory() != null) {\r\n            try {\r\n                executorMemoryGB = byteStringAsGb(sparkApplicationResource.getSpec().getExecutor().getMemory());\r\n            } catch (Exception e) {\r\n                logger.info(\"Cannot convert Executor memory size string to Gb for {}, {}.\", submissionId, e.toString());\r\n            }\r\n        }\r\n        setDriverMemoryGB(driverMemoryGB);\r\n        setDriverCores(driverCores);\r\n        setExecutorInstances(executorInstances);\r\n        setExecutorMemoryGB(executorMemoryGB);\r\n        setExecutorCores(executorCores);\r\n        setTotalMemoryGB((executorInstances * executorMemoryGB) + driverMemoryGB);\r\n        setTotalCores((executorInstances * executorCores) + driverCores);\r\n        if (user != null) {\r\n            setUser(user);\r\n        }\r\n        if (queue != null) {\r\n            setQueue(queue);\r\n        }\r\n        if (dagName != null) {\r\n            setDagName(dagName);\r\n        }\r\n    }\r\n    SparkApplicationSpec spec = sparkApplicationResource.getSpec();\r\n    if (spec != null) {\r\n        setSparkVersion(spec.getSparkVersion());\r\n        setApplicationArguments(spec.getArguments());\r\n        if (spec.getSparkConf() != null) {\r\n            String appNameConfigValue = spec.getSparkConf().get(SparkConstants.SPARK_APP_NAME_CONFIG);\r\n            if (appNameConfigValue != null) {\r\n                setApplicationName(appNameConfigValue);\r\n            }\r\n        }\r\n    }\r\n}",
        "class-code": "package com.apple.spark.api;\nimport static org.apache.spark.network.util.JavaUtils.byteStringAsGb;\nimport com.apple.spark.AppConfig;\nimport com.apple.spark.core.Constants;\nimport com.apple.spark.util.ConfigUtil;\nimport org.apache.commons.lang3.StringUtils;\nimport com.apple.spark.core.SparkConstants;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport java.util.List;\nimport com.apple.spark.operator.SparkApplication;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.apple.spark.operator.SparkApplicationSpec;\n@JsonInclude(Include.NON_NULL)\r\npublic class SubmissionSummary extends SubmissionStatus {\n    private static final Logger logger = LoggerFactory.getLogger(SubmissionSummary.class);\n    private String submissionId;\n    @Override\r\n    public void copyFrom(SparkApplication sparkApplicationResource) {\r\n        super.copyFrom(sparkApplicationResource);\r\n        setSubmissionId(sparkApplicationResource.getMetadata().getName());\r\n        if (sparkApplicationResource.getMetadata().getLabels() != null) {\r\n            String user = sparkApplicationResource.getMetadata().getLabels().get(Constants.PROXY_USER_LABEL);\r\n            String queue = \"\";\r\n            if (sparkApplicationResource.getMetadata().getLabels().containsKey(Constants.QUEUE_LABEL)) {\r\n                queue = sparkApplicationResource.getMetadata().getLabels().get(Constants.QUEUE_LABEL);\r\n            }\r\n            String dagName = \"\";\r\n            int driverCores = 1;\r\n            Long driverMemoryGB = 0L;\r\n            int executorInstances = 1;\r\n            int executorCores = 1;\r\n            Long executorMemoryGB = 0L;\r\n            if (sparkApplicationResource.getSpec().getDriver().getLabels() != null) {\r\n                if (sparkApplicationResource.getSpec().getDriver().getLabels().containsKey(Constants.DAG_NAME_LABEL)) {\r\n                    dagName = sparkApplicationResource.getSpec().getDriver().getLabels().get(Constants.DAG_NAME_LABEL);\r\n                }\r\n            }\r\n            if (sparkApplicationResource.getSpec().getDriver().getMemory() != null) {\r\n                try {\r\n                    driverMemoryGB = byteStringAsGb(sparkApplicationResource.getSpec().getDriver().getMemory());\r\n                } catch (Exception e) {\r\n                    logger.info(\"Cannot convert Driver memory size string to Gb for {}, {}.\", submissionId, e.toString());\r\n                }\r\n            }\r\n            if (sparkApplicationResource.getSpec().getDriver().getCores() != null) {\r\n                driverCores = sparkApplicationResource.getSpec().getDriver().getCores();\r\n            }\r\n            if (sparkApplicationResource.getSpec().getExecutor().getCores() != null) {\r\n                executorCores = sparkApplicationResource.getSpec().getExecutor().getCores();\r\n            }\r\n            if (sparkApplicationResource.getSpec().getExecutor().getInstances() != null) {\r\n                executorInstances = sparkApplicationResource.getSpec().getExecutor().getInstances();\r\n            }\r\n            if (sparkApplicationResource.getSpec().getExecutor().getMemory() != null) {\r\n                try {\r\n                    executorMemoryGB = byteStringAsGb(sparkApplicationResource.getSpec().getExecutor().getMemory());\r\n                } catch (Exception e) {\r\n                    logger.info(\"Cannot convert Executor memory size string to Gb for {}, {}.\", submissionId, e.toString());\r\n                }\r\n            }\r\n            setDriverMemoryGB(driverMemoryGB);\r\n            setDriverCores(driverCores);\r\n            setExecutorInstances(executorInstances);\r\n            setExecutorMemoryGB(executorMemoryGB);\r\n            setExecutorCores(executorCores);\r\n            setTotalMemoryGB((executorInstances * executorMemoryGB) + driverMemoryGB);\r\n            setTotalCores((executorInstances * executorCores) + driverCores);\r\n            if (user != null) {\r\n                setUser(user);\r\n            }\r\n            if (queue != null) {\r\n                setQueue(queue);\r\n            }\r\n            if (dagName != null) {\r\n                setDagName(dagName);\r\n            }\r\n        }\r\n        SparkApplicationSpec spec = sparkApplicationResource.getSpec();\r\n        if (spec != null) {\r\n            setSparkVersion(spec.getSparkVersion());\r\n            setApplicationArguments(spec.getArguments());\r\n            if (spec.getSparkConf() != null) {\r\n                String appNameConfigValue = spec.getSparkConf().get(SparkConstants.SPARK_APP_NAME_CONFIG);\r\n                if (appNameConfigValue != null) {\r\n                    setApplicationName(appNameConfigValue);\r\n                }\r\n            }\r\n        }\r\n    }\npublic void copyFrom(SparkApplication sparkApplicationResource, AppConfig.SparkCluster sparkCluster, AppConfig appConfig);\n    public List<String> getApplicationArguments();\n    public String getApplicationName();\n    public String getDagName();\n    public int getDriverCores();\n    public Long getDriverMemoryGB();\n    public int getExecutorCores();\n    public int getExecutorInstances();\n    public Long getExecutorMemoryGB();\n    public String getQueue();\n    public String getSparkUIUrl();\n    public String getSparkVersion();\n    public String getSubmissionId();\n    public int getTotalCores();\n    public Long getTotalMemoryGB();\n    public String getUser();\n    public void setApplicationArguments(List<String> applicationArguments);\n    public void setApplicationName(String applicationName);\n    public void setDagName(String dagName);\n    public void setDriverCores(int driverCores);\n    public void setDriverMemoryGB(Long driverMemoryGB);\n    public void setExecutorCores(int executorCores);\n    public void setExecutorInstances(int executorInstances);\n    public void setExecutorMemoryGB(Long executorMemoryGB);\n    public void setQueue(String queue);\n    public void setSparkUIUrl(String sparkUIUrl);\n    public void setSparkVersion(String sparkVersion);\n    public void setSubmissionId(String submissionId);\n    public void setTotalCores(int totalCores);\n    public void setTotalMemoryGB(Long totalMemoryGB);\n    public void setUser(String user);\n}"
      },
      {
        "id": "ApplicationSubmissionHelper_getDriverSpec",
        "package": "com.apple.spark.core",
        "class": "com.apple.spark.core.ApplicationSubmissionHelper",
        "test-class": "com.apple.spark.core.ApplicationSubmissionHelper_getDriverSpec_Test",
        "method-name": "getDriverSpec(SubmitApplicationRequest, AppConfig, String, SparkCluster)",
        "source-path": "src/main/java/com/apple/spark/core/ApplicationSubmissionHelper.java",
        "test-path": "src/test/java/com/apple/spark/core/ApplicationSubmissionHelper_getDriverSpec_Test.java",
        "focal-method": "public static DriverSpec getDriverSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster) {\r\n    DriverSpec driverSpec = new DriverSpec();\r\n    if (request.getDriver() != null) {\r\n        driverSpec.copyFrom(request.getDriver());\r\n        Map<String, String> driverLabels = request.getDriver().getLabels();\r\n        if (driverLabels != null) {\r\n            Map<String, String> labels = new HashMap<>();\r\n            if (driverLabels.containsKey(DAG_NAME_LABEL)) {\r\n                labels.put(DAG_NAME_LABEL, KubernetesHelper.normalizeLabelValue(driverLabels.get(DAG_NAME_LABEL)));\r\n            }\r\n            if (driverLabels.containsKey(TASK_NAME_LABEL)) {\r\n                labels.put(TASK_NAME_LABEL, KubernetesHelper.normalizeLabelValue(driverLabels.get(TASK_NAME_LABEL)));\r\n            }\r\n            driverLabels.putAll(labels);\r\n            driverSpec.setLabels(driverLabels);\r\n        }\r\n    }\r\n    // if there's any volumes and volume mounts specified, add them to driver spec\r\n    // mounts specified in requests have higher priority\r\n    if (((request.getDriver() != null) && (request.getVolumes() != null)) && (!request.getVolumes().isEmpty())) {\r\n        driverSpec.setVolumeMounts(request.getDriver().getVolumeMounts());\r\n    } else if (((sparkCluster.getDriver() != null) && (sparkCluster.getVolumes() != null)) && (!sparkCluster.getVolumes().isEmpty())) {\r\n        driverSpec.setVolumeMounts(sparkCluster.getDriver().getVolumeMounts());\r\n    }\r\n    double driverCpuBufferRatioQueue = getDriverCPUBufferForQueue(appConfig, parentQueue);\r\n    double driverMemBufferRatioQueue = getDriverMemBufferForQueue(appConfig, parentQueue);\r\n    if ((driverSpec.getServiceAccount() == null) || driverSpec.getServiceAccount().isEmpty()) {\r\n        driverSpec.setServiceAccount(sparkCluster.getSparkServiceAccount());\r\n    }\r\n    int originalDriverCores = driverSpec.getCores();\r\n    long adjustedDriverCores = Math.round(originalDriverCores * driverCpuBufferRatioQueue);\r\n    driverSpec.setCores(((int) (adjustedDriverCores)));\r\n    logger.info(\"Setting driver core to {}\", adjustedDriverCores);\r\n    if ((driverSpec.getCoreLimit() == null) || driverSpec.getCoreLimit().isEmpty()) {\r\n        driverSpec.setCoreLimit(String.format(\"%sm\", Math.ceil((driverSpec.getCores() * CORE_LIMIT_RATIO) * driverCpuBufferRatioQueue)));\r\n    } else {\r\n        long originalDriverCoreLimit = Long.parseLong(driverSpec.getCoreLimit());\r\n        long adjustedDriverCoreLimit = Math.round(originalDriverCoreLimit * driverCpuBufferRatioQueue);\r\n        driverSpec.setCoreLimit(String.valueOf(adjustedDriverCoreLimit));\r\n        logger.info(\"Setting driver core limits to {}\", adjustedDriverCoreLimit);\r\n    }\r\n    long originalDriverMem = getMemNumFromRequestStr(driverSpec.getMemory());\r\n    long adjustedDriverMem = ((long) (Math.ceil(originalDriverMem * driverMemBufferRatioQueue)));\r\n    String memUnit = getMemUnitFromRequestStr(driverSpec.getMemory());\r\n    driverSpec.setMemory(adjustedDriverMem + memUnit);\r\n    logger.info(\"Setting driver memory to {}{}\", adjustedDriverMem, memUnit);\r\n    // set annotations to driver pod to avoid scale-in from KubeC\r\n    Map<String, String> driverAnnotations = (driverSpec.getAnnotations() == null) ? new HashMap<>() : driverSpec.getAnnotations();\r\n    driverAnnotations.put(KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_KEY, KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_VALUE);\r\n    driverSpec.setAnnotations(driverAnnotations);\r\n    // Driver affinity is for all drivers to share the same node group, with only scaling up\r\n    // this is to prevent driver pods from being killed when nodes are being scaling down\r\n    if (driverSpec.getAffinity() == null) {\r\n        List<String> driverNodeLabelValues = getDriverNodeLabelValuesForQueue(appConfig, parentQueue);\r\n        String nodeLabelKey = getDriverNodeLabelKeyForQueue(appConfig, parentQueue);\r\n        if ((driverNodeLabelValues != null) && (driverNodeLabelValues.size() > 0)) {\r\n            // set hard requiredDuringSchedulingIgnoredDuringExecutionTerm to driver\r\n            NodeSelectorRequirement nodeSelectorRequirement = new NodeSelectorRequirement(nodeLabelKey, NodeSelectorOperator.NodeSelectorOpIn.toString(), driverNodeLabelValues.toArray(new String[0]));// set \"spark_driver\" as nodeselctor\r\n\r\n            NodeSelectorTerm nodeSelectorTermOnDriver = new NodeSelectorTerm(new NodeSelectorRequirement[]{ nodeSelectorRequirement });\r\n            RequiredDuringSchedulingIgnoredDuringExecutionTerm requiredSchedulingTerm = new RequiredDuringSchedulingIgnoredDuringExecutionTerm(new NodeSelectorTerm[]{ nodeSelectorTermOnDriver });\r\n            // attach required affinity only to driver\r\n            NodeAffinity nodeAffinity = new NodeAffinity(requiredSchedulingTerm);\r\n            driverSpec.setAffinity(new Affinity(nodeAffinity));\r\n        }\r\n    }\r\n    return driverSpec;\r\n}",
        "class-code": "package com.apple.spark.core;\nimport com.apple.spark.operator.NodeAffinity;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_ROOT_QUEUE;\nimport com.apple.spark.api.SubmitApplicationRequest;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLGenerator;\nimport java.util.HashMap;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_SPARK_DEFAULT_QUEUE;\nimport java.util.ArrayList;\nimport com.apple.spark.util.ExceptionUtils;\nimport org.slf4j.Logger;\nimport com.apple.spark.operator.SparkApplicationSpec;\nimport static com.apple.spark.core.SparkConstants.DRIVER_MEM_BUFFER_RATIO;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_MEM_BUFFER_RATIO;\nimport com.apple.spark.operator.ExecutorSpec;\nimport static com.apple.spark.core.BatchSchedulerConstants.PLACEHOLDER_TIMEOUT_IN_SECONDS;\nimport org.apache.commons.lang3.StringUtils;\nimport com.apple.spark.operator.NodeSelectorTerm;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.apple.spark.operator.DriverSpec;\nimport com.apple.spark.operator.BatchSchedulerConfiguration;\nimport java.util.List;\nimport java.util.UUID;\nimport static com.apple.spark.core.SparkConstants.DRIVER_CPU_BUFFER_RATIO;\nimport org.slf4j.LoggerFactory;\nimport com.apple.spark.operator.NodeSelectorOperator;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.util.Collections;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.Optional;\nimport com.apple.spark.AppConfig;\nimport com.apple.spark.operator.RequiredDuringSchedulingIgnoredDuringExecutionTerm;\nimport com.apple.spark.operator.NodeSelectorRequirement;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_CPU_BUFFER_RATIO;\nimport io.fabric8.kubernetes.api.model.PodDNSConfig;\nimport com.apple.spark.operator.Volume;\nimport javax.ws.rs.core.Response;\nimport static com.apple.spark.core.Constants.*;\nimport io.fabric8.kubernetes.api.model.PodDNSConfigOption;\nimport com.apple.spark.operator.SparkUIConfiguration;\nimport com.apple.spark.operator.Affinity;\nimport javax.ws.rs.WebApplicationException;\nimport com.apple.spark.AppConfig.SparkCluster;\nimport java.util.Map;\nimport java.util.Arrays;\nimport static com.apple.spark.core.SparkConstants.CORE_LIMIT_RATIO;\npublic class ApplicationSubmissionHelper {\n    private static final Logger logger = LoggerFactory.getLogger(ApplicationSubmissionHelper.class);\n    public static DriverSpec getDriverSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster) {\r\n        DriverSpec driverSpec = new DriverSpec();\r\n        if (request.getDriver() != null) {\r\n            driverSpec.copyFrom(request.getDriver());\r\n            Map<String, String> driverLabels = request.getDriver().getLabels();\r\n            if (driverLabels != null) {\r\n                Map<String, String> labels = new HashMap<>();\r\n                if (driverLabels.containsKey(DAG_NAME_LABEL)) {\r\n                    labels.put(DAG_NAME_LABEL, KubernetesHelper.normalizeLabelValue(driverLabels.get(DAG_NAME_LABEL)));\r\n                }\r\n                if (driverLabels.containsKey(TASK_NAME_LABEL)) {\r\n                    labels.put(TASK_NAME_LABEL, KubernetesHelper.normalizeLabelValue(driverLabels.get(TASK_NAME_LABEL)));\r\n                }\r\n                driverLabels.putAll(labels);\r\n                driverSpec.setLabels(driverLabels);\r\n            }\r\n        }\r\n        // if there's any volumes and volume mounts specified, add them to driver spec\r\n        // mounts specified in requests have higher priority\r\n        if (((request.getDriver() != null) && (request.getVolumes() != null)) && (!request.getVolumes().isEmpty())) {\r\n            driverSpec.setVolumeMounts(request.getDriver().getVolumeMounts());\r\n        } else if (((sparkCluster.getDriver() != null) && (sparkCluster.getVolumes() != null)) && (!sparkCluster.getVolumes().isEmpty())) {\r\n            driverSpec.setVolumeMounts(sparkCluster.getDriver().getVolumeMounts());\r\n        }\r\n        double driverCpuBufferRatioQueue = getDriverCPUBufferForQueue(appConfig, parentQueue);\r\n        double driverMemBufferRatioQueue = getDriverMemBufferForQueue(appConfig, parentQueue);\r\n        if ((driverSpec.getServiceAccount() == null) || driverSpec.getServiceAccount().isEmpty()) {\r\n            driverSpec.setServiceAccount(sparkCluster.getSparkServiceAccount());\r\n        }\r\n        int originalDriverCores = driverSpec.getCores();\r\n        long adjustedDriverCores = Math.round(originalDriverCores * driverCpuBufferRatioQueue);\r\n        driverSpec.setCores(((int) (adjustedDriverCores)));\r\n        logger.info(\"Setting driver core to {}\", adjustedDriverCores);\r\n        if ((driverSpec.getCoreLimit() == null) || driverSpec.getCoreLimit().isEmpty()) {\r\n            driverSpec.setCoreLimit(String.format(\"%sm\", Math.ceil((driverSpec.getCores() * CORE_LIMIT_RATIO) * driverCpuBufferRatioQueue)));\r\n        } else {\r\n            long originalDriverCoreLimit = Long.parseLong(driverSpec.getCoreLimit());\r\n            long adjustedDriverCoreLimit = Math.round(originalDriverCoreLimit * driverCpuBufferRatioQueue);\r\n            driverSpec.setCoreLimit(String.valueOf(adjustedDriverCoreLimit));\r\n            logger.info(\"Setting driver core limits to {}\", adjustedDriverCoreLimit);\r\n        }\r\n        long originalDriverMem = getMemNumFromRequestStr(driverSpec.getMemory());\r\n        long adjustedDriverMem = ((long) (Math.ceil(originalDriverMem * driverMemBufferRatioQueue)));\r\n        String memUnit = getMemUnitFromRequestStr(driverSpec.getMemory());\r\n        driverSpec.setMemory(adjustedDriverMem + memUnit);\r\n        logger.info(\"Setting driver memory to {}{}\", adjustedDriverMem, memUnit);\r\n        // set annotations to driver pod to avoid scale-in from KubeC\r\n        Map<String, String> driverAnnotations = (driverSpec.getAnnotations() == null) ? new HashMap<>() : driverSpec.getAnnotations();\r\n        driverAnnotations.put(KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_KEY, KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_VALUE);\r\n        driverSpec.setAnnotations(driverAnnotations);\r\n        // Driver affinity is for all drivers to share the same node group, with only scaling up\r\n        // this is to prevent driver pods from being killed when nodes are being scaling down\r\n        if (driverSpec.getAffinity() == null) {\r\n            List<String> driverNodeLabelValues = getDriverNodeLabelValuesForQueue(appConfig, parentQueue);\r\n            String nodeLabelKey = getDriverNodeLabelKeyForQueue(appConfig, parentQueue);\r\n            if ((driverNodeLabelValues != null) && (driverNodeLabelValues.size() > 0)) {\r\n                // set hard requiredDuringSchedulingIgnoredDuringExecutionTerm to driver\r\n                NodeSelectorRequirement nodeSelectorRequirement = new NodeSelectorRequirement(nodeLabelKey, NodeSelectorOperator.NodeSelectorOpIn.toString(), driverNodeLabelValues.toArray(new String[0]));// set \"spark_driver\" as nodeselctor\r\n    \r\n                NodeSelectorTerm nodeSelectorTermOnDriver = new NodeSelectorTerm(new NodeSelectorRequirement[]{ nodeSelectorRequirement });\r\n                RequiredDuringSchedulingIgnoredDuringExecutionTerm requiredSchedulingTerm = new RequiredDuringSchedulingIgnoredDuringExecutionTerm(new NodeSelectorTerm[]{ nodeSelectorTermOnDriver });\r\n                // attach required affinity only to driver\r\n                NodeAffinity nodeAffinity = new NodeAffinity(requiredSchedulingTerm);\r\n                driverSpec.setAffinity(new Affinity(nodeAffinity));\r\n            }\r\n        }\r\n        return driverSpec;\r\n    }\nstatic Map<String, String> applyFeatureGate(SubmitApplicationRequest request, Map<String, String> conf);\n    public static String generateSubmissionId(String clusterId);\n    public static String generateSubmissionId(String clusterId, String submissionIdSuffix);\n    public static String getClusterIdFromSubmissionId(String submissionId);\n    private static double getDriverCPUBufferForQueue(AppConfig appConfig, String queue);\n    private static double getDriverMemBufferForQueue(AppConfig appConfig, String queue);\n    private static String getDriverNodeLabelKeyForQueue(AppConfig appConfig, String queue);\n    private static List<String> getDriverNodeLabelValuesForQueue(AppConfig appConfig, String queue);\n    public static ExecutorSpec getExecutorSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster);\n    public static String getImage(AppConfig appConfig, SubmitApplicationRequest request, String type, String sparkVersion, String proxyUser);\n    private static long getMemNumFromRequestStr(String memStr);\n    private static String getMemUnitFromRequestStr(String memStr);\n    public static String getProxyUser(String user, String dagUser);\n    public static Map<String, String> getSparkConf(String submissionId, SubmitApplicationRequest request, AppConfig appConfig, AppConfig.SparkCluster sparkCluster);\n    public static SparkUIConfiguration getSparkUIConfiguration(String submissionId, AppConfig.SparkCluster sparkCluster);\n    public static String getType(String specifiedType, String mainClass);\n    public static List<Volume> getVolumes(SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster);\n    public static BatchSchedulerConfiguration getYuniKornSchedulerConfig(String queue);\n    public static boolean looksLikeFilePath(String requestBody);\n    public static SubmitApplicationRequest parseSubmitRequest(String requestBody, String contentType);\n    public static void populateEnv(SparkApplicationSpec sparkSpec, SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster);\n    public static void validateQueueToken(String queue, String queueToken, AppConfig appConfig);\n}"
      },
      {
        "id": "ApplicationSubmissionHelper_populateEnv",
        "package": "com.apple.spark.core",
        "class": "com.apple.spark.core.ApplicationSubmissionHelper",
        "test-class": "com.apple.spark.core.ApplicationSubmissionHelper_populateEnv_Test",
        "method-name": "populateEnv(SparkApplicationSpec, SubmitApplicationRequest, AppConfig.SparkCluster)",
        "source-path": "src/main/java/com/apple/spark/core/ApplicationSubmissionHelper.java",
        "test-path": "src/test/java/com/apple/spark/core/ApplicationSubmissionHelper_populateEnv_Test.java",
        "focal-method": "public static void populateEnv(SparkApplicationSpec sparkSpec, SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster) {\r\n    if ((sparkCluster.getDriver() != null) && (sparkCluster.getDriver().getEnv() != null)) {\r\n        // there is env in spark cluster driver configure, copy it to spark spec\r\n        if (sparkSpec.getDriver() == null) {\r\n            sparkSpec.setDriver(new DriverSpec());\r\n        }\r\n        if (sparkSpec.getDriver().getEnv() == null) {\r\n            sparkSpec.getDriver().setEnv(new ArrayList<>());\r\n        }\r\n        SparkSpecHelper.copyEnv(sparkCluster.getDriver().getEnv(), sparkSpec.getDriver().getEnv());\r\n    }\r\n    if ((request.getDriver() != null) && (request.getDriver().getEnv() != null)) {\r\n        // there is env in request driver configure, copy it to spark spec\r\n        if (sparkSpec.getDriver() == null) {\r\n            sparkSpec.setDriver(new DriverSpec());\r\n        }\r\n        if (sparkSpec.getDriver().getEnv() == null) {\r\n            sparkSpec.getDriver().setEnv(new ArrayList<>());\r\n        }\r\n        SparkSpecHelper.copyEnv(request.getDriver().getEnv(), sparkSpec.getDriver().getEnv());\r\n    }\r\n    if ((sparkCluster.getExecutor() != null) && (sparkCluster.getExecutor().getEnv() != null)) {\r\n        // there is env in spark cluster executor configure, copy it to spark spec\r\n        if (sparkSpec.getExecutor() == null) {\r\n            sparkSpec.setExecutor(new ExecutorSpec());\r\n        }\r\n        if (sparkSpec.getExecutor().getEnv() == null) {\r\n            sparkSpec.getExecutor().setEnv(new ArrayList<>());\r\n        }\r\n        SparkSpecHelper.copyEnv(sparkCluster.getExecutor().getEnv(), sparkSpec.getExecutor().getEnv());\r\n    }\r\n    if ((request.getExecutor() != null) && (request.getExecutor().getEnv() != null)) {\r\n        // there is env in request executor configure, copy it to spark spec\r\n        if (sparkSpec.getExecutor() == null) {\r\n            sparkSpec.setExecutor(new ExecutorSpec());\r\n        }\r\n        if (sparkSpec.getExecutor().getEnv() == null) {\r\n            sparkSpec.getExecutor().setEnv(new ArrayList<>());\r\n        }\r\n        SparkSpecHelper.copyEnv(request.getExecutor().getEnv(), sparkSpec.getExecutor().getEnv());\r\n    }\r\n}",
        "class-code": "package com.apple.spark.core;\nimport com.apple.spark.operator.NodeAffinity;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_ROOT_QUEUE;\nimport com.apple.spark.api.SubmitApplicationRequest;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLGenerator;\nimport java.util.HashMap;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_SPARK_DEFAULT_QUEUE;\nimport java.util.ArrayList;\nimport com.apple.spark.util.ExceptionUtils;\nimport org.slf4j.Logger;\nimport com.apple.spark.operator.SparkApplicationSpec;\nimport static com.apple.spark.core.SparkConstants.DRIVER_MEM_BUFFER_RATIO;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_MEM_BUFFER_RATIO;\nimport com.apple.spark.operator.ExecutorSpec;\nimport static com.apple.spark.core.BatchSchedulerConstants.PLACEHOLDER_TIMEOUT_IN_SECONDS;\nimport org.apache.commons.lang3.StringUtils;\nimport com.apple.spark.operator.NodeSelectorTerm;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.apple.spark.operator.DriverSpec;\nimport com.apple.spark.operator.BatchSchedulerConfiguration;\nimport java.util.List;\nimport java.util.UUID;\nimport static com.apple.spark.core.SparkConstants.DRIVER_CPU_BUFFER_RATIO;\nimport org.slf4j.LoggerFactory;\nimport com.apple.spark.operator.NodeSelectorOperator;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.util.Collections;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.Optional;\nimport com.apple.spark.AppConfig;\nimport com.apple.spark.operator.RequiredDuringSchedulingIgnoredDuringExecutionTerm;\nimport com.apple.spark.operator.NodeSelectorRequirement;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_CPU_BUFFER_RATIO;\nimport io.fabric8.kubernetes.api.model.PodDNSConfig;\nimport com.apple.spark.operator.Volume;\nimport javax.ws.rs.core.Response;\nimport static com.apple.spark.core.Constants.*;\nimport io.fabric8.kubernetes.api.model.PodDNSConfigOption;\nimport com.apple.spark.operator.SparkUIConfiguration;\nimport com.apple.spark.operator.Affinity;\nimport javax.ws.rs.WebApplicationException;\nimport com.apple.spark.AppConfig.SparkCluster;\nimport java.util.Map;\nimport java.util.Arrays;\nimport static com.apple.spark.core.SparkConstants.CORE_LIMIT_RATIO;\npublic class ApplicationSubmissionHelper {\n    \n    public static void populateEnv(SparkApplicationSpec sparkSpec, SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster) {\r\n        if ((sparkCluster.getDriver() != null) && (sparkCluster.getDriver().getEnv() != null)) {\r\n            // there is env in spark cluster driver configure, copy it to spark spec\r\n            if (sparkSpec.getDriver() == null) {\r\n                sparkSpec.setDriver(new DriverSpec());\r\n            }\r\n            if (sparkSpec.getDriver().getEnv() == null) {\r\n                sparkSpec.getDriver().setEnv(new ArrayList<>());\r\n            }\r\n            SparkSpecHelper.copyEnv(sparkCluster.getDriver().getEnv(), sparkSpec.getDriver().getEnv());\r\n        }\r\n        if ((request.getDriver() != null) && (request.getDriver().getEnv() != null)) {\r\n            // there is env in request driver configure, copy it to spark spec\r\n            if (sparkSpec.getDriver() == null) {\r\n                sparkSpec.setDriver(new DriverSpec());\r\n            }\r\n            if (sparkSpec.getDriver().getEnv() == null) {\r\n                sparkSpec.getDriver().setEnv(new ArrayList<>());\r\n            }\r\n            SparkSpecHelper.copyEnv(request.getDriver().getEnv(), sparkSpec.getDriver().getEnv());\r\n        }\r\n        if ((sparkCluster.getExecutor() != null) && (sparkCluster.getExecutor().getEnv() != null)) {\r\n            // there is env in spark cluster executor configure, copy it to spark spec\r\n            if (sparkSpec.getExecutor() == null) {\r\n                sparkSpec.setExecutor(new ExecutorSpec());\r\n            }\r\n            if (sparkSpec.getExecutor().getEnv() == null) {\r\n                sparkSpec.getExecutor().setEnv(new ArrayList<>());\r\n            }\r\n            SparkSpecHelper.copyEnv(sparkCluster.getExecutor().getEnv(), sparkSpec.getExecutor().getEnv());\r\n        }\r\n        if ((request.getExecutor() != null) && (request.getExecutor().getEnv() != null)) {\r\n            // there is env in request executor configure, copy it to spark spec\r\n            if (sparkSpec.getExecutor() == null) {\r\n                sparkSpec.setExecutor(new ExecutorSpec());\r\n            }\r\n            if (sparkSpec.getExecutor().getEnv() == null) {\r\n                sparkSpec.getExecutor().setEnv(new ArrayList<>());\r\n            }\r\n            SparkSpecHelper.copyEnv(request.getExecutor().getEnv(), sparkSpec.getExecutor().getEnv());\r\n        }\r\n    }\nstatic Map<String, String> applyFeatureGate(SubmitApplicationRequest request, Map<String, String> conf);\n    public static String generateSubmissionId(String clusterId);\n    public static String generateSubmissionId(String clusterId, String submissionIdSuffix);\n    public static String getClusterIdFromSubmissionId(String submissionId);\n    public static DriverSpec getDriverSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster);\n    public static ExecutorSpec getExecutorSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster);\n    public static String getImage(AppConfig appConfig, SubmitApplicationRequest request, String type, String sparkVersion, String proxyUser);\n    public static String getProxyUser(String user, String dagUser);\n    public static Map<String, String> getSparkConf(String submissionId, SubmitApplicationRequest request, AppConfig appConfig, AppConfig.SparkCluster sparkCluster);\n    public static SparkUIConfiguration getSparkUIConfiguration(String submissionId, AppConfig.SparkCluster sparkCluster);\n    public static String getType(String specifiedType, String mainClass);\n    public static List<Volume> getVolumes(SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster);\n    public static BatchSchedulerConfiguration getYuniKornSchedulerConfig(String queue);\n    public static boolean looksLikeFilePath(String requestBody);\n    public static SubmitApplicationRequest parseSubmitRequest(String requestBody, String contentType);\n    public static void validateQueueToken(String queue, String queueToken, AppConfig appConfig);\n}"
      },
      {
        "id": "ApplicationSubmissionHelper_getExecutorSpec",
        "package": "com.apple.spark.core",
        "class": "com.apple.spark.core.ApplicationSubmissionHelper",
        "test-class": "com.apple.spark.core.ApplicationSubmissionHelper_getExecutorSpec_Test",
        "method-name": "getExecutorSpec(SubmitApplicationRequest, AppConfig, String, SparkCluster)",
        "source-path": "src/main/java/com/apple/spark/core/ApplicationSubmissionHelper.java",
        "test-path": "src/test/java/com/apple/spark/core/ApplicationSubmissionHelper_getExecutorSpec_Test.java",
        "focal-method": "public static ExecutorSpec getExecutorSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster) {\r\n    ExecutorSpec executorSpec = new ExecutorSpec();\r\n    if (request.getExecutor() != null) {\r\n        executorSpec.copyFrom(request.getExecutor());\r\n        Map<String, String> executorLabels = request.getExecutor().getLabels();\r\n        if (executorLabels != null) {\r\n            Map<String, String> labels = new HashMap<>();\r\n            if (executorLabels.containsKey(DAG_NAME_LABEL)) {\r\n                labels.put(DAG_NAME_LABEL, KubernetesHelper.normalizeLabelValue(executorLabels.get(DAG_NAME_LABEL)));\r\n            }\r\n            if (executorLabels.containsKey(TASK_NAME_LABEL)) {\r\n                labels.put(TASK_NAME_LABEL, KubernetesHelper.normalizeLabelValue(executorLabels.get(TASK_NAME_LABEL)));\r\n            }\r\n            executorLabels.putAll(labels);\r\n            executorSpec.setLabels(executorLabels);\r\n        }\r\n    }\r\n    // if there's any volumes and volume mounts specified, add them to executor spec\r\n    // mounts specified in requests have higher priority\r\n    if (((request.getExecutor() != null) && (request.getVolumes() != null)) && (!request.getVolumes().isEmpty())) {\r\n        executorSpec.setVolumeMounts(request.getExecutor().getVolumeMounts());\r\n    } else if (((sparkCluster.getExecutor() != null) && (sparkCluster.getVolumes() != null)) && (!sparkCluster.getVolumes().isEmpty())) {\r\n        executorSpec.setVolumeMounts(sparkCluster.getExecutor().getVolumeMounts());\r\n    }\r\n    double executorCpuBufferRatioQueue = getExecutorCPUBufferForQueue(appConfig, parentQueue);\r\n    double executorMemBufferRatioQueue = getExecutorMemBufferForQueue(appConfig, parentQueue);\r\n    int originalExecutorCores = executorSpec.getCores();\r\n    long adjustedExecutorCores = Math.round(originalExecutorCores * executorCpuBufferRatioQueue);\r\n    executorSpec.setCores(((int) (adjustedExecutorCores)));\r\n    logger.info(\"Setting executor core to {}\", adjustedExecutorCores);\r\n    if ((executorSpec.getCoreLimit() == null) || executorSpec.getCoreLimit().isEmpty()) {\r\n        executorSpec.setCoreLimit(String.format(\"%sm\", Math.ceil((executorSpec.getCores() * CORE_LIMIT_RATIO) * executorCpuBufferRatioQueue)));\r\n    } else {\r\n        long originalExecutorCoreLimit = Long.parseLong(executorSpec.getCoreLimit());\r\n        long adjustedExecutorCoreLimit = Math.round(originalExecutorCoreLimit * executorCpuBufferRatioQueue);\r\n        executorSpec.setCoreLimit(String.valueOf(adjustedExecutorCoreLimit));\r\n        logger.info(\"Setting executor core limits to {}\", adjustedExecutorCoreLimit);\r\n    }\r\n    long originalExecutorMem = getMemNumFromRequestStr(executorSpec.getMemory());\r\n    long adjustedExecutorMem = ((long) (Math.ceil(originalExecutorMem * executorMemBufferRatioQueue)));\r\n    String memUnit = getMemUnitFromRequestStr(executorSpec.getMemory());\r\n    executorSpec.setMemory(adjustedExecutorMem + memUnit);\r\n    logger.info(\"Setting executor memory to {}{}\", adjustedExecutorMem, memUnit);\r\n    // set annotations to executor pod to avoid scale-in from KubeCA\r\n    if (executorSpec.getAnnotations() == null) {\r\n        Map<String, String> executorAnnotations = new HashMap<>();\r\n        executorAnnotations.put(KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_KEY, KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_VALUE);\r\n        executorSpec.setAnnotations(executorAnnotations);\r\n    }\r\n    if (executorSpec.getAffinity() == null) {\r\n        List<String> executorNodeLabelValues = new ArrayList<>();\r\n        if (request.getSpotInstance()) {\r\n            executorNodeLabelValues = getExecutorSpotNodeLabelValuesForQueue(appConfig, parentQueue);\r\n        } else {\r\n            executorNodeLabelValues = getExecutorNodeLabelValuesForQueue(appConfig, parentQueue);\r\n        }\r\n        String nodeLabelKey = getExecutorNodeLabelKeyForQueue(appConfig, parentQueue);\r\n        if ((executorNodeLabelValues != null) && (executorNodeLabelValues.size() > 0)) {\r\n            // set hard requiredDuringSchedulingIgnoredDuringExecutionTerm to executor\r\n            NodeSelectorRequirement nodeSelectorRequirement = new NodeSelectorRequirement(nodeLabelKey, NodeSelectorOperator.NodeSelectorOpIn.toString(), executorNodeLabelValues.toArray(new String[0]));\r\n            NodeSelectorTerm nodeSelectorTermOnExecutor = new NodeSelectorTerm(new NodeSelectorRequirement[]{ nodeSelectorRequirement });\r\n            RequiredDuringSchedulingIgnoredDuringExecutionTerm requiredSchedulingTermOnExecutor = new RequiredDuringSchedulingIgnoredDuringExecutionTerm(new NodeSelectorTerm[]{ nodeSelectorTermOnExecutor });\r\n            // attach required affinity only to executor\r\n            NodeAffinity nodeAffinityOnExecutor = new NodeAffinity(requiredSchedulingTermOnExecutor);\r\n            executorSpec.setAffinity(new Affinity(nodeAffinityOnExecutor));\r\n        }\r\n    }\r\n    PodDNSConfig executorPodDNSConfig = new PodDNSConfig();\r\n    executorPodDNSConfig.setOptions(Collections.singletonList(new PodDNSConfigOption(DNS_CONFIG_OPTION_NDOTS_NAME, DNS_CONFIG_OPTION_NDOTS_VALUE)));\r\n    executorSpec.setDnsConfig(executorPodDNSConfig);\r\n    return executorSpec;\r\n}",
        "class-code": "package com.apple.spark.core;\nimport com.apple.spark.operator.NodeAffinity;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_ROOT_QUEUE;\nimport com.apple.spark.api.SubmitApplicationRequest;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLGenerator;\nimport java.util.HashMap;\nimport static com.apple.spark.core.BatchSchedulerConstants.YUNIKORN_SPARK_DEFAULT_QUEUE;\nimport java.util.ArrayList;\nimport com.apple.spark.util.ExceptionUtils;\nimport org.slf4j.Logger;\nimport com.apple.spark.operator.SparkApplicationSpec;\nimport static com.apple.spark.core.SparkConstants.DRIVER_MEM_BUFFER_RATIO;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_MEM_BUFFER_RATIO;\nimport com.apple.spark.operator.ExecutorSpec;\nimport static com.apple.spark.core.BatchSchedulerConstants.PLACEHOLDER_TIMEOUT_IN_SECONDS;\nimport org.apache.commons.lang3.StringUtils;\nimport com.apple.spark.operator.NodeSelectorTerm;\nimport com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\nimport com.apple.spark.operator.DriverSpec;\nimport com.apple.spark.operator.BatchSchedulerConfiguration;\nimport java.util.List;\nimport java.util.UUID;\nimport static com.apple.spark.core.SparkConstants.DRIVER_CPU_BUFFER_RATIO;\nimport org.slf4j.LoggerFactory;\nimport com.apple.spark.operator.NodeSelectorOperator;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.util.Collections;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.Optional;\nimport com.apple.spark.AppConfig;\nimport com.apple.spark.operator.RequiredDuringSchedulingIgnoredDuringExecutionTerm;\nimport com.apple.spark.operator.NodeSelectorRequirement;\nimport static com.apple.spark.core.SparkConstants.EXECUTOR_CPU_BUFFER_RATIO;\nimport io.fabric8.kubernetes.api.model.PodDNSConfig;\nimport com.apple.spark.operator.Volume;\nimport javax.ws.rs.core.Response;\nimport static com.apple.spark.core.Constants.*;\nimport io.fabric8.kubernetes.api.model.PodDNSConfigOption;\nimport com.apple.spark.operator.SparkUIConfiguration;\nimport com.apple.spark.operator.Affinity;\nimport javax.ws.rs.WebApplicationException;\nimport com.apple.spark.AppConfig.SparkCluster;\nimport java.util.Map;\nimport java.util.Arrays;\nimport static com.apple.spark.core.SparkConstants.CORE_LIMIT_RATIO;\npublic class ApplicationSubmissionHelper {\n    private static final Logger logger = LoggerFactory.getLogger(ApplicationSubmissionHelper.class);\n    public static ExecutorSpec getExecutorSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster) {\r\n        ExecutorSpec executorSpec = new ExecutorSpec();\r\n        if (request.getExecutor() != null) {\r\n            executorSpec.copyFrom(request.getExecutor());\r\n            Map<String, String> executorLabels = request.getExecutor().getLabels();\r\n            if (executorLabels != null) {\r\n                Map<String, String> labels = new HashMap<>();\r\n                if (executorLabels.containsKey(DAG_NAME_LABEL)) {\r\n                    labels.put(DAG_NAME_LABEL, KubernetesHelper.normalizeLabelValue(executorLabels.get(DAG_NAME_LABEL)));\r\n                }\r\n                if (executorLabels.containsKey(TASK_NAME_LABEL)) {\r\n                    labels.put(TASK_NAME_LABEL, KubernetesHelper.normalizeLabelValue(executorLabels.get(TASK_NAME_LABEL)));\r\n                }\r\n                executorLabels.putAll(labels);\r\n                executorSpec.setLabels(executorLabels);\r\n            }\r\n        }\r\n        // if there's any volumes and volume mounts specified, add them to executor spec\r\n        // mounts specified in requests have higher priority\r\n        if (((request.getExecutor() != null) && (request.getVolumes() != null)) && (!request.getVolumes().isEmpty())) {\r\n            executorSpec.setVolumeMounts(request.getExecutor().getVolumeMounts());\r\n        } else if (((sparkCluster.getExecutor() != null) && (sparkCluster.getVolumes() != null)) && (!sparkCluster.getVolumes().isEmpty())) {\r\n            executorSpec.setVolumeMounts(sparkCluster.getExecutor().getVolumeMounts());\r\n        }\r\n        double executorCpuBufferRatioQueue = getExecutorCPUBufferForQueue(appConfig, parentQueue);\r\n        double executorMemBufferRatioQueue = getExecutorMemBufferForQueue(appConfig, parentQueue);\r\n        int originalExecutorCores = executorSpec.getCores();\r\n        long adjustedExecutorCores = Math.round(originalExecutorCores * executorCpuBufferRatioQueue);\r\n        executorSpec.setCores(((int) (adjustedExecutorCores)));\r\n        logger.info(\"Setting executor core to {}\", adjustedExecutorCores);\r\n        if ((executorSpec.getCoreLimit() == null) || executorSpec.getCoreLimit().isEmpty()) {\r\n            executorSpec.setCoreLimit(String.format(\"%sm\", Math.ceil((executorSpec.getCores() * CORE_LIMIT_RATIO) * executorCpuBufferRatioQueue)));\r\n        } else {\r\n            long originalExecutorCoreLimit = Long.parseLong(executorSpec.getCoreLimit());\r\n            long adjustedExecutorCoreLimit = Math.round(originalExecutorCoreLimit * executorCpuBufferRatioQueue);\r\n            executorSpec.setCoreLimit(String.valueOf(adjustedExecutorCoreLimit));\r\n            logger.info(\"Setting executor core limits to {}\", adjustedExecutorCoreLimit);\r\n        }\r\n        long originalExecutorMem = getMemNumFromRequestStr(executorSpec.getMemory());\r\n        long adjustedExecutorMem = ((long) (Math.ceil(originalExecutorMem * executorMemBufferRatioQueue)));\r\n        String memUnit = getMemUnitFromRequestStr(executorSpec.getMemory());\r\n        executorSpec.setMemory(adjustedExecutorMem + memUnit);\r\n        logger.info(\"Setting executor memory to {}{}\", adjustedExecutorMem, memUnit);\r\n        // set annotations to executor pod to avoid scale-in from KubeCA\r\n        if (executorSpec.getAnnotations() == null) {\r\n            Map<String, String> executorAnnotations = new HashMap<>();\r\n            executorAnnotations.put(KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_KEY, KUBE_CLUSTER_AUTOSCALER_SCALE_IN_ANNOTATION_VALUE);\r\n            executorSpec.setAnnotations(executorAnnotations);\r\n        }\r\n        if (executorSpec.getAffinity() == null) {\r\n            List<String> executorNodeLabelValues = new ArrayList<>();\r\n            if (request.getSpotInstance()) {\r\n                executorNodeLabelValues = getExecutorSpotNodeLabelValuesForQueue(appConfig, parentQueue);\r\n            } else {\r\n                executorNodeLabelValues = getExecutorNodeLabelValuesForQueue(appConfig, parentQueue);\r\n            }\r\n            String nodeLabelKey = getExecutorNodeLabelKeyForQueue(appConfig, parentQueue);\r\n            if ((executorNodeLabelValues != null) && (executorNodeLabelValues.size() > 0)) {\r\n                // set hard requiredDuringSchedulingIgnoredDuringExecutionTerm to executor\r\n                NodeSelectorRequirement nodeSelectorRequirement = new NodeSelectorRequirement(nodeLabelKey, NodeSelectorOperator.NodeSelectorOpIn.toString(), executorNodeLabelValues.toArray(new String[0]));\r\n                NodeSelectorTerm nodeSelectorTermOnExecutor = new NodeSelectorTerm(new NodeSelectorRequirement[]{ nodeSelectorRequirement });\r\n                RequiredDuringSchedulingIgnoredDuringExecutionTerm requiredSchedulingTermOnExecutor = new RequiredDuringSchedulingIgnoredDuringExecutionTerm(new NodeSelectorTerm[]{ nodeSelectorTermOnExecutor });\r\n                // attach required affinity only to executor\r\n                NodeAffinity nodeAffinityOnExecutor = new NodeAffinity(requiredSchedulingTermOnExecutor);\r\n                executorSpec.setAffinity(new Affinity(nodeAffinityOnExecutor));\r\n            }\r\n        }\r\n        PodDNSConfig executorPodDNSConfig = new PodDNSConfig();\r\n        executorPodDNSConfig.setOptions(Collections.singletonList(new PodDNSConfigOption(DNS_CONFIG_OPTION_NDOTS_NAME, DNS_CONFIG_OPTION_NDOTS_VALUE)));\r\n        executorSpec.setDnsConfig(executorPodDNSConfig);\r\n        return executorSpec;\r\n    }\nstatic Map<String, String> applyFeatureGate(SubmitApplicationRequest request, Map<String, String> conf);\n    public static String generateSubmissionId(String clusterId);\n    public static String generateSubmissionId(String clusterId, String submissionIdSuffix);\n    public static String getClusterIdFromSubmissionId(String submissionId);\n    public static DriverSpec getDriverSpec(SubmitApplicationRequest request, AppConfig appConfig, String parentQueue, SparkCluster sparkCluster);\n    private static double getExecutorCPUBufferForQueue(AppConfig appConfig, String queue);\n    private static double getExecutorMemBufferForQueue(AppConfig appConfig, String queue);\n    private static String getExecutorNodeLabelKeyForQueue(AppConfig appConfig, String queue);\n    private static List<String> getExecutorNodeLabelValuesForQueue(AppConfig appConfig, String queue);\n    private static List<String> getExecutorSpotNodeLabelValuesForQueue(AppConfig appConfig, String queue);\n    public static String getImage(AppConfig appConfig, SubmitApplicationRequest request, String type, String sparkVersion, String proxyUser);\n    private static long getMemNumFromRequestStr(String memStr);\n    private static String getMemUnitFromRequestStr(String memStr);\n    public static String getProxyUser(String user, String dagUser);\n    public static Map<String, String> getSparkConf(String submissionId, SubmitApplicationRequest request, AppConfig appConfig, AppConfig.SparkCluster sparkCluster);\n    public static SparkUIConfiguration getSparkUIConfiguration(String submissionId, AppConfig.SparkCluster sparkCluster);\n    public static String getType(String specifiedType, String mainClass);\n    public static List<Volume> getVolumes(SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster);\n    public static BatchSchedulerConfiguration getYuniKornSchedulerConfig(String queue);\n    public static boolean looksLikeFilePath(String requestBody);\n    public static SubmitApplicationRequest parseSubmitRequest(String requestBody, String contentType);\n    public static void populateEnv(SparkApplicationSpec sparkSpec, SubmitApplicationRequest request, AppConfig.SparkCluster sparkCluster);\n    public static void validateQueueToken(String queue, String queueToken, AppConfig appConfig);\n}"
      }
    ]
  },
  "commons-cli": {
    "project-name": "commons-cli",
    "project-url": "commons-cli",
    "focal-methods": [
      {
        "id": "HelpFormatter_renderOptions",
        "package": "org.apache.commons.cli",
        "class": "org.apache.commons.cli.HelpFormatter",
        "test-class": "org.apache.commons.cli.HelpFormatter_renderOptions_Test",
        "method-name": "renderOptions(StringBuffer, int, Options, int, int)",
        "source-path": "src/main/java/org/apache/commons/cli/HelpFormatter.java",
        "test-path": "src/test/java/org/apache/commons/cli/HelpFormatter_renderOptions_Test.java",
        "focal-method": "protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\r\n    final String lpad = createPadding(leftPad);\r\n    final String dpad = createPadding(descPad);\r\n    // first create list containing only <lpad>-a,--aaa where\r\n    // -a is opt and --aaa is long opt; in parallel look for\r\n    // the longest opt string this list will be then used to\r\n    // sort options ascending\r\n    int max = 0;\r\n    final List<StringBuffer> prefixList = new ArrayList<>();\r\n    final List<Option> optList = options.helpOptions();\r\n    if (getOptionComparator() != null) {\r\n        Collections.sort(optList, getOptionComparator());\r\n    }\r\n    for (final Option option : optList) {\r\n        final StringBuffer optBuf = new StringBuffer();\r\n        if (option.getOpt() == null) {\r\n            optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\r\n        } else {\r\n            optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\r\n            if (option.hasLongOpt()) {\r\n                optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\r\n            }\r\n        }\r\n        if (option.hasArg()) {\r\n            final String argName = option.getArgName();\r\n            if ((argName != null) && argName.isEmpty()) {\r\n                // if the option has a blank argname\r\n                optBuf.append(' ');\r\n            } else {\r\n                optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\r\n                optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\r\n            }\r\n        }\r\n        prefixList.add(optBuf);\r\n        max = Math.max(optBuf.length(), max);\r\n    }\r\n    int x = 0;\r\n    for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\r\n        final Option option = it.next();\r\n        final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\r\n        if (optBuf.length() < max) {\r\n            optBuf.append(createPadding(max - optBuf.length()));\r\n        }\r\n        optBuf.append(dpad);\r\n        final int nextLineTabStop = max + descPad;\r\n        if (option.getDescription() != null) {\r\n            optBuf.append(option.getDescription());\r\n        }\r\n        renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\r\n        if (it.hasNext()) {\r\n            sb.append(getNewLine());\r\n        }\r\n    }\r\n    return sb;\r\n}",
        "class-code": "package org.apache.commons.cli;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.io.BufferedReader;\nimport java.io.StringReader;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.io.PrintWriter;\nimport java.util.Comparator;\nimport java.util.Collections;\npublic class HelpFormatter {\n    public static final int DEFAULT_WIDTH = 74;\n    public static final int DEFAULT_LEFT_PAD = 1;\n    public static final int DEFAULT_DESC_PAD = 3;\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n    protected Comparator<Option> optionComparator = new OptionComparator();\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\r\n        final String lpad = createPadding(leftPad);\r\n        final String dpad = createPadding(descPad);\r\n        // first create list containing only <lpad>-a,--aaa where\r\n        // -a is opt and --aaa is long opt; in parallel look for\r\n        // the longest opt string this list will be then used to\r\n        // sort options ascending\r\n        int max = 0;\r\n        final List<StringBuffer> prefixList = new ArrayList<>();\r\n        final List<Option> optList = options.helpOptions();\r\n        if (getOptionComparator() != null) {\r\n            Collections.sort(optList, getOptionComparator());\r\n        }\r\n        for (final Option option : optList) {\r\n            final StringBuffer optBuf = new StringBuffer();\r\n            if (option.getOpt() == null) {\r\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\r\n            } else {\r\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\r\n                if (option.hasLongOpt()) {\r\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\r\n                }\r\n            }\r\n            if (option.hasArg()) {\r\n                final String argName = option.getArgName();\r\n                if ((argName != null) && argName.isEmpty()) {\r\n                    // if the option has a blank argname\r\n                    optBuf.append(' ');\r\n                } else {\r\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\r\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\r\n                }\r\n            }\r\n            prefixList.add(optBuf);\r\n            max = Math.max(optBuf.length(), max);\r\n        }\r\n        int x = 0;\r\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\r\n            final Option option = it.next();\r\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\r\n            if (optBuf.length() < max) {\r\n                optBuf.append(createPadding(max - optBuf.length()));\r\n            }\r\n            optBuf.append(dpad);\r\n            final int nextLineTabStop = max + descPad;\r\n            if (option.getDescription() != null) {\r\n                optBuf.append(option.getDescription());\r\n            }\r\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\r\n            if (it.hasNext()) {\r\n                sb.append(getNewLine());\r\n            }\r\n        }\r\n        return sb;\r\n    }\nprotected String createPadding(final int len);\n    protected int findWrapPos(final String text, final int width, final int startPos);\n    public String getArgName();\n    public int getDescPadding();\n    public int getLeftPadding();\n    public String getLongOptPrefix();\n    public String getLongOptSeparator();\n    public String getNewLine();\n    public String getOptPrefix();\n    public Comparator<Option> getOptionComparator();\n    public String getSyntaxPrefix();\n    public int getWidth();\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer);\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage);\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad, final int descPad, final String footer);\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad, final int descPad, final String footer, final boolean autoUsage);\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer);\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage);\n    public void printHelp(final String cmdLineSyntax, final Options options);\n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage);\n    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad);\n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax);\n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options);\n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text);\n    public void printWrapped(final PrintWriter pw, final int width, final String text);\n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, final int nextLineTabStop, final String text);\n    protected String rtrim(final String s);\n    public void setArgName(final String name);\n    public void setDescPadding(final int padding);\n    public void setLeftPadding(final int padding);\n    public void setLongOptPrefix(final String prefix);\n    public void setLongOptSeparator(final String longOptSeparator);\n    public void setNewLine(final String newline);\n    public void setOptPrefix(final String prefix);\n    public void setOptionComparator(final Comparator<Option> comparator);\n    public void setSyntaxPrefix(final String prefix);\n    public void setWidth(final int width);\n}"
      },
      {
        "id": "PatternOptionBuilder_getValueType",
        "package": "org.apache.commons.cli",
        "class": "org.apache.commons.cli.PatternOptionBuilder",
        "test-class": "org.apache.commons.cli.PatternOptionBuilder_getValueType_Test",
        "method-name": "getValueType(char)",
        "source-path": "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java",
        "test-path": "src/test/java/org/apache/commons/cli/PatternOptionBuilder_getValueType_Test.java",
        "focal-method": "public static Class<?> getValueType(final char ch) {\r\n    switch (ch) {\r\n        case '@' :\r\n            return PatternOptionBuilder.OBJECT_VALUE;\r\n        case ':' :\r\n            return PatternOptionBuilder.STRING_VALUE;\r\n        case '%' :\r\n            return PatternOptionBuilder.NUMBER_VALUE;\r\n        case '+' :\r\n            return PatternOptionBuilder.CLASS_VALUE;\r\n        case '#' :\r\n            return PatternOptionBuilder.DATE_VALUE;\r\n        case '<' :\r\n            return PatternOptionBuilder.EXISTING_FILE_VALUE;\r\n        case '>' :\r\n            return PatternOptionBuilder.FILE_VALUE;\r\n        case '*' :\r\n            return PatternOptionBuilder.FILES_VALUE;\r\n        case '/' :\r\n            return PatternOptionBuilder.URL_VALUE;\r\n    }\r\n    return null;\r\n}",
        "class-code": "package org.apache.commons.cli;\nimport java.net.URL;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.Date;\npublic class PatternOptionBuilder {\n    public static final Class<String> STRING_VALUE = String.class;\n    public static final Class<Object> OBJECT_VALUE = Object.class;\n    public static final Class<Number> NUMBER_VALUE = Number.class;\n    public static final Class<Date> DATE_VALUE = Date.class;\n    public static final Class<?> CLASS_VALUE = Class.class;\n    public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n    public static final Class<File> FILE_VALUE = File.class;\n    public static final Class<File[]> FILES_VALUE = File[].class;\n    public static final Class<URL> URL_VALUE = URL.class;\n    static final Converter<?, UnsupportedOperationException> NOT_IMPLEMENTED = s -> {\r\n    throw new UnsupportedOperationException(\"Not yet implemented\");\r\n};\n    public static Class<?> getValueType(final char ch) {\r\n        switch (ch) {\r\n            case '@' :\r\n                return PatternOptionBuilder.OBJECT_VALUE;\r\n            case ':' :\r\n                return PatternOptionBuilder.STRING_VALUE;\r\n            case '%' :\r\n                return PatternOptionBuilder.NUMBER_VALUE;\r\n            case '+' :\r\n                return PatternOptionBuilder.CLASS_VALUE;\r\n            case '#' :\r\n                return PatternOptionBuilder.DATE_VALUE;\r\n            case '<' :\r\n                return PatternOptionBuilder.EXISTING_FILE_VALUE;\r\n            case '>' :\r\n                return PatternOptionBuilder.FILE_VALUE;\r\n            case '*' :\r\n                return PatternOptionBuilder.FILES_VALUE;\r\n            case '/' :\r\n                return PatternOptionBuilder.URL_VALUE;\r\n        }\r\n        return null;\r\n    }\npublic static boolean isValueCode(final char ch);\n    public static Options parsePattern(final String pattern);\n    public static void registerTypes();\n}"
      }
    ]
  },
  "commons-codec": {
    "project-name": "commons-codec",
    "project-url": "commons-codec",
    "focal-methods": [
      {
        "id": "Base64_decode",
        "package": "org.apache.commons.codec.binary",
        "class": "org.apache.commons.codec.binary.Base64",
        "test-class": "org.apache.commons.codec.binary.Base64_decode_Test",
        "method-name": "decode(byte[], int, int, Context)",
        "source-path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "test-path": "src/test/java/org/apache/commons/codec/binary/Base64_decode_Test.java",
        "focal-method": "@Override\r\nvoid decode(final byte[] input, int inPos, final int inAvail, final Context context) {\r\n    if (context.eof) {\r\n        return;\r\n    }\r\n    if (inAvail < 0) {\r\n        context.eof = true;\r\n    }\r\n    final int decodeSize = this.encodeSize - 1;\r\n    for (int i = 0; i < inAvail; i++) {\r\n        final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n        final byte b = input[inPos++];\r\n        if (b == pad) {\r\n            // We're done.\r\n            context.eof = true;\r\n            break;\r\n        }\r\n        if ((b >= 0) && (b < decodeTable.length)) {\r\n            final int result = decodeTable[b];\r\n            if (result >= 0) {\r\n                context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;\r\n                context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\r\n                if (context.modulus == 0) {\r\n                    buffer[context.pos++] = ((byte) ((context.ibitWorkArea >> 16) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.ibitWorkArea >> 8) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) (context.ibitWorkArea & MASK_8BITS));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Two forms of EOF as far as base64 decoder is concerned: actual\r\n    // EOF (-1) and first time '=' character is encountered in stream.\r\n    // This approach makes the '=' padding characters completely optional.\r\n    if (context.eof && (context.modulus != 0)) {\r\n        final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n        // We have some spare bits remaining\r\n        // Output all whole multiples of 8 bits and ignore the rest\r\n        switch (context.modulus) {\r\n            // case 0 : // impossible, as excluded above\r\n            case 1 :\r\n                // 6 bits - either ignore entirely, or raise an exception\r\n                validateTrailingCharacter();\r\n                break;\r\n            case 2 :\r\n                // 12 bits = 8 + 4\r\n                validateCharacter(MASK_4BITS, context);\r\n                context.ibitWorkArea = context.ibitWorkArea >> 4;// dump the extra 4 bits\r\n\r\n                buffer[context.pos++] = ((byte) (context.ibitWorkArea & MASK_8BITS));\r\n                break;\r\n            case 3 :\r\n                // 18 bits = 8 + 8 + 2\r\n                validateCharacter(MASK_2BITS, context);\r\n                context.ibitWorkArea = context.ibitWorkArea >> 2;// dump 2 bits\r\n\r\n                buffer[context.pos++] = ((byte) ((context.ibitWorkArea >> 8) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) (context.ibitWorkArea & MASK_8BITS));\r\n                break;\r\n            default :\r\n                throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n        }\r\n    }\r\n}",
        "class-code": "package org.apache.commons.codec.binary;\nimport java.math.BigInteger;\nimport java.util.Objects;\nimport org.apache.commons.codec.CodecPolicy;\nimport java.util.Arrays;\npublic class Base64 extends BaseNCodec {\n    private static final int BITS_PER_ENCODED_BYTE = 6;\n    private static final int BYTES_PER_ENCODED_BLOCK = 4;\n    private static final int MASK_4BITS = 0xf;\n    private static final int MASK_2BITS = 0x3;\n    private final byte[] decodeTable;\n    private final int encodeSize;\n    @Override\r\n    void decode(final byte[] input, int inPos, final int inAvail, final Context context) {\r\n        if (context.eof) {\r\n            return;\r\n        }\r\n        if (inAvail < 0) {\r\n            context.eof = true;\r\n        }\r\n        final int decodeSize = this.encodeSize - 1;\r\n        for (int i = 0; i < inAvail; i++) {\r\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n            final byte b = input[inPos++];\r\n            if (b == pad) {\r\n                // We're done.\r\n                context.eof = true;\r\n                break;\r\n            }\r\n            if ((b >= 0) && (b < decodeTable.length)) {\r\n                final int result = decodeTable[b];\r\n                if (result >= 0) {\r\n                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;\r\n                    context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\r\n                    if (context.modulus == 0) {\r\n                        buffer[context.pos++] = ((byte) ((context.ibitWorkArea >> 16) & MASK_8BITS));\r\n                        buffer[context.pos++] = ((byte) ((context.ibitWorkArea >> 8) & MASK_8BITS));\r\n                        buffer[context.pos++] = ((byte) (context.ibitWorkArea & MASK_8BITS));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Two forms of EOF as far as base64 decoder is concerned: actual\r\n        // EOF (-1) and first time '=' character is encountered in stream.\r\n        // This approach makes the '=' padding characters completely optional.\r\n        if (context.eof && (context.modulus != 0)) {\r\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n            // We have some spare bits remaining\r\n            // Output all whole multiples of 8 bits and ignore the rest\r\n            switch (context.modulus) {\r\n                // case 0 : // impossible, as excluded above\r\n                case 1 :\r\n                    // 6 bits - either ignore entirely, or raise an exception\r\n                    validateTrailingCharacter();\r\n                    break;\r\n                case 2 :\r\n                    // 12 bits = 8 + 4\r\n                    validateCharacter(MASK_4BITS, context);\r\n                    context.ibitWorkArea = context.ibitWorkArea >> 4;// dump the extra 4 bits\r\n    \r\n                    buffer[context.pos++] = ((byte) (context.ibitWorkArea & MASK_8BITS));\r\n                    break;\r\n                case 3 :\r\n                    // 18 bits = 8 + 8 + 2\r\n                    validateCharacter(MASK_2BITS, context);\r\n                    context.ibitWorkArea = context.ibitWorkArea >> 2;// dump 2 bits\r\n    \r\n                    buffer[context.pos++] = ((byte) ((context.ibitWorkArea >> 8) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) (context.ibitWorkArea & MASK_8BITS));\r\n                    break;\r\n                default :\r\n                    throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n            }\r\n        }\r\n    }\npublic static Builder builder();\n    public static byte[] decodeBase64(final byte[] base64Data);\n    public static byte[] decodeBase64(final String base64String);\n    public static BigInteger decodeInteger(final byte[] pArray);\n    @Override\r\nvoid encode(final byte[] in, int inPos, final int inAvail, final Context context);\n    public static byte[] encodeBase64(final byte[] binaryData);\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked);\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe);\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe, final int maxResultSize);\n    public static byte[] encodeBase64Chunked(final byte[] binaryData);\n    public static String encodeBase64String(final byte[] binaryData);\n    public static byte[] encodeBase64URLSafe(final byte[] binaryData);\n    public static String encodeBase64URLSafeString(final byte[] binaryData);\n    public static byte[] encodeInteger(final BigInteger bigInteger);\n    byte[] getLineSeparator();\n    public static boolean isBase64(final byte octet);\n    public static boolean isBase64(final byte[] arrayOctet);\n    public static boolean isBase64(final String base64);\n    @Override\r\nprotected boolean isInAlphabet(final byte octet);\n    public boolean isUrlSafe();\n    static byte[] toIntegerBytes(final BigInteger bigInt);\n    private void validateCharacter(final int emptyBitsMask, final Context context);\n    private void validateTrailingCharacter();\n}"
      },
      {
        "id": "QuotedPrintableCodec_encodeQuotedPrintable",
        "package": "org.apache.commons.codec.net",
        "class": "org.apache.commons.codec.net.QuotedPrintableCodec",
        "test-class": "org.apache.commons.codec.net.QuotedPrintableCodec_encodeQuotedPrintable_Test",
        "method-name": "encodeQuotedPrintable(BitSet, byte[], boolean)",
        "source-path": "src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java",
        "test-path": "src/test/java/org/apache/commons/codec/net/QuotedPrintableCodec_encodeQuotedPrintable_Test.java",
        "focal-method": "public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\r\n    if (bytes == null) {\r\n        return null;\r\n    }\r\n    if (printable == null) {\r\n        printable = PRINTABLE_CHARS;\r\n    }\r\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    final int bytesLength = bytes.length;\r\n    if (strict) {\r\n        if (bytesLength < MIN_BYTES) {\r\n            return null;\r\n        }\r\n        int pos = 1;\r\n        // encode up to buffer.length - 3, the last three octets will be treated\r\n        // separately for simplification of note #3\r\n        for (int i = 0; i < (bytesLength - 3); i++) {\r\n            final int b = getUnsignedOctet(i, bytes);\r\n            if (pos < SAFE_LENGTH) {\r\n                // up to this length it is safe to add any byte, encoded or not\r\n                pos += encodeByte(b, !printable.get(b), buffer);\r\n            } else {\r\n                // rule #3: whitespace at the end of a line *must* be encoded\r\n                encodeByte(b, (!printable.get(b)) || isWhitespace(b), buffer);\r\n                // rule #5: soft line break\r\n                buffer.write(ESCAPE_CHAR);\r\n                buffer.write(CR);\r\n                buffer.write(LF);\r\n                pos = 1;\r\n            }\r\n        }\r\n        // rule #3: whitespace at the end of a line *must* be encoded\r\n        // if we would do a soft break line after this octet, encode whitespace\r\n        int b = getUnsignedOctet(bytesLength - 3, bytes);\r\n        boolean encode = (!printable.get(b)) || (isWhitespace(b) && (pos > (SAFE_LENGTH - 5)));\r\n        pos += encodeByte(b, encode, buffer);\r\n        // note #3: '=' *must not* be the ultimate or penultimate character\r\n        // simplification: if < 6 bytes left, do a soft line break as we may need\r\n        // exactly 6 bytes space for the last 2 bytes\r\n        if (pos > (SAFE_LENGTH - 2)) {\r\n            buffer.write(ESCAPE_CHAR);\r\n            buffer.write(CR);\r\n            buffer.write(LF);\r\n        }\r\n        for (int i = bytesLength - 2; i < bytesLength; i++) {\r\n            b = getUnsignedOctet(i, bytes);\r\n            // rule #3: trailing whitespace shall be encoded\r\n            encode = (!printable.get(b)) || ((i > (bytesLength - 2)) && isWhitespace(b));\r\n            encodeByte(b, encode, buffer);\r\n        }\r\n    } else {\r\n        for (final byte c : bytes) {\r\n            int b = c;\r\n            if (b < 0) {\r\n                b = 256 + b;\r\n            }\r\n            if (printable.get(b)) {\r\n                buffer.write(b);\r\n            } else {\r\n                encodeQuotedPrintable(b, buffer);\r\n            }\r\n        }\r\n    }\r\n    return buffer.toByteArray();\r\n}",
        "class-code": "package org.apache.commons.codec.net;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.Charset;\nimport org.apache.commons.codec.BinaryDecoder;\nimport java.io.ByteArrayOutputStream;\nimport java.util.BitSet;\nimport org.apache.commons.codec.StringDecoder;\nimport java.nio.charset.IllegalCharsetNameException;\nimport org.apache.commons.codec.BinaryEncoder;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\npublic class QuotedPrintableCodec implements BinaryEncoder , BinaryDecoder , StringEncoder , StringDecoder {\n    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\n    private static final byte ESCAPE_CHAR = '=';\n    private static final byte CR = 13;\n    private static final byte LF = 10;\n    private static final int MIN_BYTES = 3;\n    private static final int SAFE_LENGTH = 73;\n    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\r\n        if (bytes == null) {\r\n            return null;\r\n        }\r\n        if (printable == null) {\r\n            printable = PRINTABLE_CHARS;\r\n        }\r\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n        final int bytesLength = bytes.length;\r\n        if (strict) {\r\n            if (bytesLength < MIN_BYTES) {\r\n                return null;\r\n            }\r\n            int pos = 1;\r\n            // encode up to buffer.length - 3, the last three octets will be treated\r\n            // separately for simplification of note #3\r\n            for (int i = 0; i < (bytesLength - 3); i++) {\r\n                final int b = getUnsignedOctet(i, bytes);\r\n                if (pos < SAFE_LENGTH) {\r\n                    // up to this length it is safe to add any byte, encoded or not\r\n                    pos += encodeByte(b, !printable.get(b), buffer);\r\n                } else {\r\n                    // rule #3: whitespace at the end of a line *must* be encoded\r\n                    encodeByte(b, (!printable.get(b)) || isWhitespace(b), buffer);\r\n                    // rule #5: soft line break\r\n                    buffer.write(ESCAPE_CHAR);\r\n                    buffer.write(CR);\r\n                    buffer.write(LF);\r\n                    pos = 1;\r\n                }\r\n            }\r\n            // rule #3: whitespace at the end of a line *must* be encoded\r\n            // if we would do a soft break line after this octet, encode whitespace\r\n            int b = getUnsignedOctet(bytesLength - 3, bytes);\r\n            boolean encode = (!printable.get(b)) || (isWhitespace(b) && (pos > (SAFE_LENGTH - 5)));\r\n            pos += encodeByte(b, encode, buffer);\r\n            // note #3: '=' *must not* be the ultimate or penultimate character\r\n            // simplification: if < 6 bytes left, do a soft line break as we may need\r\n            // exactly 6 bytes space for the last 2 bytes\r\n            if (pos > (SAFE_LENGTH - 2)) {\r\n                buffer.write(ESCAPE_CHAR);\r\n                buffer.write(CR);\r\n                buffer.write(LF);\r\n            }\r\n            for (int i = bytesLength - 2; i < bytesLength; i++) {\r\n                b = getUnsignedOctet(i, bytes);\r\n                // rule #3: trailing whitespace shall be encoded\r\n                encode = (!printable.get(b)) || ((i > (bytesLength - 2)) && isWhitespace(b));\r\n                encodeByte(b, encode, buffer);\r\n            }\r\n        } else {\r\n            for (final byte c : bytes) {\r\n                int b = c;\r\n                if (b < 0) {\r\n                    b = 256 + b;\r\n                }\r\n                if (printable.get(b)) {\r\n                    buffer.write(b);\r\n                } else {\r\n                    encodeQuotedPrintable(b, buffer);\r\n                }\r\n            }\r\n        }\r\n        return buffer.toByteArray();\r\n    }\n@Override\r\npublic byte[] decode(final byte[] bytes) throws DecoderException;\n    @Override\r\npublic Object decode(final Object obj) throws DecoderException;\n    @Override\r\npublic String decode(final String sourceStr) throws DecoderException;\n    public String decode(final String sourceStr, final String sourceCharset) throws DecoderException, UnsupportedEncodingException;\n    public String decode(final String sourceStr, final Charset sourceCharset) throws DecoderException;\n    public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException;\n    @Override\r\npublic byte[] encode(final byte[] bytes);\n    @Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String sourceStr) throws EncoderException;\n    public String encode(final String sourceStr, final String sourceCharset) throws UnsupportedEncodingException;\n    public String encode(final String sourceStr, final Charset sourceCharset);\n    private static int encodeByte(final int b, final boolean encode, final ByteArrayOutputStream buffer);\n    private static final int encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer);\n    public static final byte[] encodeQuotedPrintable(final BitSet printable, final byte[] bytes);\n    public Charset getCharset();\n    public String getDefaultCharset();\n    private static int getUnsignedOctet(final int index, final byte[] bytes);\n    private static boolean isWhitespace(final int b);\n}"
      },
      {
        "id": "Base32_decode",
        "package": "org.apache.commons.codec.binary",
        "class": "org.apache.commons.codec.binary.Base32",
        "test-class": "org.apache.commons.codec.binary.Base32_decode_Test",
        "method-name": "decode(byte[], int, int, Context)",
        "source-path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "test-path": "src/test/java/org/apache/commons/codec/binary/Base32_decode_Test.java",
        "focal-method": "@Override\r\nvoid decode(final byte[] input, int inPos, final int inAvail, final Context context) {\r\n    // package protected for access from I/O streams\r\n    if (context.eof) {\r\n        return;\r\n    }\r\n    if (inAvail < 0) {\r\n        context.eof = true;\r\n    }\r\n    final int decodeSize = this.encodeSize - 1;\r\n    for (int i = 0; i < inAvail; i++) {\r\n        final byte b = input[inPos++];\r\n        if (b == pad) {\r\n            // We're done.\r\n            context.eof = true;\r\n            break;\r\n        }\r\n        final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n        if ((b >= 0) && (b < this.decodeTable.length)) {\r\n            final int result = this.decodeTable[b];\r\n            if (result >= 0) {\r\n                context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;\r\n                // collect decoded bytes\r\n                context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\r\n                if (context.modulus == 0) {\r\n                    // we can output the 5 bytes\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 32) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 24) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Two forms of EOF as far as Base32 decoder is concerned: actual\r\n    // EOF (-1) and first time '=' character is encountered in stream.\r\n    // This approach makes the '=' padding characters completely optional.\r\n    if (context.eof && (context.modulus > 0)) {\r\n        // if modulus == 0, nothing to do\r\n        final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n        // We ignore partial bytes, i.e. only multiples of 8 count.\r\n        // Any combination not part of a valid encoding is either partially decoded\r\n        // or will raise an exception. Possible trailing characters are 2, 4, 5, 7.\r\n        // It is not possible to encode with 1, 3, 6 trailing characters.\r\n        // For backwards compatibility 3 & 6 chars are decoded anyway rather than discarded.\r\n        // See the encode(byte[]) method EOF section.\r\n        switch (context.modulus) {\r\n            // case 0 : // impossible, as excluded above\r\n            case 1 :\r\n                // 5 bits - either ignore entirely, or raise an exception\r\n                validateTrailingCharacters();\r\n            case 2 :\r\n                // 10 bits, drop 2 and output one byte\r\n                validateCharacter(MASK_2BITS, context);\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 2) & MASK_8BITS));\r\n                break;\r\n            case 3 :\r\n                // 15 bits, drop 7 and output 1 byte, or raise an exception\r\n                validateTrailingCharacters();\r\n                // Not possible from a valid encoding but decode anyway\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 7) & MASK_8BITS));\r\n                break;\r\n            case 4 :\r\n                // 20 bits = 2*8 + 4\r\n                validateCharacter(MASK_4BITS, context);\r\n                context.lbitWorkArea = context.lbitWorkArea >> 4;// drop 4 bits\r\n\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                break;\r\n            case 5 :\r\n                // 25 bits = 3*8 + 1\r\n                validateCharacter(MASK_1BITS, context);\r\n                context.lbitWorkArea = context.lbitWorkArea >> 1;\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                break;\r\n            case 6 :\r\n                // 30 bits = 3*8 + 6, or raise an exception\r\n                validateTrailingCharacters();\r\n                // Not possible from a valid encoding but decode anyway\r\n                context.lbitWorkArea = context.lbitWorkArea >> 6;\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                break;\r\n            case 7 :\r\n                // 35 bits = 4*8 +3\r\n                validateCharacter(MASK_3BITS, context);\r\n                context.lbitWorkArea = context.lbitWorkArea >> 3;\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 24) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                break;\r\n            default :\r\n                // modulus can be 0-7, and we excluded 0,1 already\r\n                throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n        }\r\n    }\r\n}",
        "class-code": "package org.apache.commons.codec.binary;\nimport java.util.Objects;\nimport org.apache.commons.codec.CodecPolicy;\npublic class Base32 extends BaseNCodec {\n    private static final int BITS_PER_ENCODED_BYTE = 5;\n    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n    private static final long MASK_4BITS = 0xfL;\n    private static final long MASK_3BITS = 0x7L;\n    private static final long MASK_2BITS = 0x3L;\n    private static final long MASK_1BITS = 0x1L;\n    private final byte[] decodeTable;\n    private final int encodeSize;\n    @Override\r\n    void decode(final byte[] input, int inPos, final int inAvail, final Context context) {\r\n        // package protected for access from I/O streams\r\n        if (context.eof) {\r\n            return;\r\n        }\r\n        if (inAvail < 0) {\r\n            context.eof = true;\r\n        }\r\n        final int decodeSize = this.encodeSize - 1;\r\n        for (int i = 0; i < inAvail; i++) {\r\n            final byte b = input[inPos++];\r\n            if (b == pad) {\r\n                // We're done.\r\n                context.eof = true;\r\n                break;\r\n            }\r\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n            if ((b >= 0) && (b < this.decodeTable.length)) {\r\n                final int result = this.decodeTable[b];\r\n                if (result >= 0) {\r\n                    context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;\r\n                    // collect decoded bytes\r\n                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\r\n                    if (context.modulus == 0) {\r\n                        // we can output the 5 bytes\r\n                        buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 32) & MASK_8BITS));\r\n                        buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 24) & MASK_8BITS));\r\n                        buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                        buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                        buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Two forms of EOF as far as Base32 decoder is concerned: actual\r\n        // EOF (-1) and first time '=' character is encountered in stream.\r\n        // This approach makes the '=' padding characters completely optional.\r\n        if (context.eof && (context.modulus > 0)) {\r\n            // if modulus == 0, nothing to do\r\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\r\n            // We ignore partial bytes, i.e. only multiples of 8 count.\r\n            // Any combination not part of a valid encoding is either partially decoded\r\n            // or will raise an exception. Possible trailing characters are 2, 4, 5, 7.\r\n            // It is not possible to encode with 1, 3, 6 trailing characters.\r\n            // For backwards compatibility 3 & 6 chars are decoded anyway rather than discarded.\r\n            // See the encode(byte[]) method EOF section.\r\n            switch (context.modulus) {\r\n                // case 0 : // impossible, as excluded above\r\n                case 1 :\r\n                    // 5 bits - either ignore entirely, or raise an exception\r\n                    validateTrailingCharacters();\r\n                case 2 :\r\n                    // 10 bits, drop 2 and output one byte\r\n                    validateCharacter(MASK_2BITS, context);\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 2) & MASK_8BITS));\r\n                    break;\r\n                case 3 :\r\n                    // 15 bits, drop 7 and output 1 byte, or raise an exception\r\n                    validateTrailingCharacters();\r\n                    // Not possible from a valid encoding but decode anyway\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 7) & MASK_8BITS));\r\n                    break;\r\n                case 4 :\r\n                    // 20 bits = 2*8 + 4\r\n                    validateCharacter(MASK_4BITS, context);\r\n                    context.lbitWorkArea = context.lbitWorkArea >> 4;// drop 4 bits\r\n    \r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                    break;\r\n                case 5 :\r\n                    // 25 bits = 3*8 + 1\r\n                    validateCharacter(MASK_1BITS, context);\r\n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                    break;\r\n                case 6 :\r\n                    // 30 bits = 3*8 + 6, or raise an exception\r\n                    validateTrailingCharacters();\r\n                    // Not possible from a valid encoding but decode anyway\r\n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                    break;\r\n                case 7 :\r\n                    // 35 bits = 4*8 +3\r\n                    validateCharacter(MASK_3BITS, context);\r\n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 24) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 16) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) ((context.lbitWorkArea >> 8) & MASK_8BITS));\r\n                    buffer[context.pos++] = ((byte) (context.lbitWorkArea & MASK_8BITS));\r\n                    break;\r\n                default :\r\n                    // modulus can be 0-7, and we excluded 0,1 already\r\n                    throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n            }\r\n        }\r\n    }\npublic static Builder builder();\n    @Override\r\nvoid encode(final byte[] input, int inPos, final int inAvail, final Context context);\n    byte[] getLineSeparator();\n    @Override\r\npublic boolean isInAlphabet(final byte octet);\n    private void validateCharacter(final long emptyBitsMask, final Context context);\n    private void validateTrailingCharacters();\n}"
      },
      {
        "id": "Base64_encode",
        "package": "org.apache.commons.codec.binary",
        "class": "org.apache.commons.codec.binary.Base64",
        "test-class": "org.apache.commons.codec.binary.Base64_encode_Test",
        "method-name": "encode(byte[], int, int, Context)",
        "source-path": "src/main/java/org/apache/commons/codec/binary/Base64.java",
        "test-path": "src/test/java/org/apache/commons/codec/binary/Base64_encode_Test.java",
        "focal-method": "@Override\r\nvoid encode(final byte[] in, int inPos, final int inAvail, final Context context) {\r\n    if (context.eof) {\r\n        return;\r\n    }\r\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\r\n    // encoding.\r\n    if (inAvail < 0) {\r\n        context.eof = true;\r\n        if ((0 == context.modulus) && (lineLength == 0)) {\r\n            return;// no leftovers to process and not using chunking\r\n\r\n        }\r\n        final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n        final int savedPos = context.pos;\r\n        switch (context.modulus) {\r\n            // 0-2\r\n            case 0 :\r\n                // nothing to do here\r\n                break;\r\n            case 1 :\r\n                // 8 bits = 6 + 2\r\n                // top 6 bits:\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];\r\n                // remaining 2:\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\r\n                // URL-SAFE skips the padding to further reduce size.\r\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                }\r\n                break;\r\n            case 2 :\r\n                // 16 bits = 6 + 6 + 4\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\r\n                // URL-SAFE skips the padding to further reduce size.\r\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                    buffer[context.pos++] = pad;\r\n                }\r\n                break;\r\n            default :\r\n                throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n        }\r\n        context.currentLinePos += context.pos - savedPos;// keep track of current line position\r\n\r\n        // if currentPos == 0 we are at the start of a line, so don't add CRLF\r\n        if ((lineLength > 0) && (context.currentLinePos > 0)) {\r\n            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n            context.pos += lineSeparator.length;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < inAvail; i++) {\r\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\r\n            int b = in[inPos++];\r\n            if (b < 0) {\r\n                b += 256;\r\n            }\r\n            context.ibitWorkArea = (context.ibitWorkArea << 8) + b;// BITS_PER_BYTE\r\n\r\n            if (0 == context.modulus) {\r\n                // 3 bytes = 24 bits = 4 * 6 bits to extract\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];\r\n                buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];\r\n                buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];\r\n                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\r\n                if ((lineLength > 0) && (lineLength <= context.currentLinePos)) {\r\n                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n                    context.pos += lineSeparator.length;\r\n                    context.currentLinePos = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
        "class-code": "package org.apache.commons.codec.binary;\nimport java.math.BigInteger;\nimport java.util.Objects;\nimport org.apache.commons.codec.CodecPolicy;\nimport java.util.Arrays;\npublic class Base64 extends BaseNCodec {\n    private static final int BYTES_PER_UNENCODED_BLOCK = 3;\n    private static final int BYTES_PER_ENCODED_BLOCK = 4;\n    private static final byte[] STANDARD_ENCODE_TABLE = new byte[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };\n    private static final int MASK_6BITS = 0x3f;\n    private final byte[] encodeTable;\n    private final byte[] lineSeparator;\n    private final int encodeSize;\n    @Override\r\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\r\n        if (context.eof) {\r\n            return;\r\n        }\r\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\r\n        // encoding.\r\n        if (inAvail < 0) {\r\n            context.eof = true;\r\n            if ((0 == context.modulus) && (lineLength == 0)) {\r\n                return;// no leftovers to process and not using chunking\r\n    \r\n            }\r\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n            final int savedPos = context.pos;\r\n            switch (context.modulus) {\r\n                // 0-2\r\n                case 0 :\r\n                    // nothing to do here\r\n                    break;\r\n                case 1 :\r\n                    // 8 bits = 6 + 2\r\n                    // top 6 bits:\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];\r\n                    // remaining 2:\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\r\n                    // URL-SAFE skips the padding to further reduce size.\r\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                        buffer[context.pos++] = pad;\r\n                        buffer[context.pos++] = pad;\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // 16 bits = 6 + 6 + 4\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\r\n                    // URL-SAFE skips the padding to further reduce size.\r\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                        buffer[context.pos++] = pad;\r\n                    }\r\n                    break;\r\n                default :\r\n                    throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n            }\r\n            context.currentLinePos += context.pos - savedPos;// keep track of current line position\r\n    \r\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\r\n            if ((lineLength > 0) && (context.currentLinePos > 0)) {\r\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n                context.pos += lineSeparator.length;\r\n            }\r\n        } else {\r\n            for (int i = 0; i < inAvail; i++) {\r\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n                context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\r\n                int b = in[inPos++];\r\n                if (b < 0) {\r\n                    b += 256;\r\n                }\r\n                context.ibitWorkArea = (context.ibitWorkArea << 8) + b;// BITS_PER_BYTE\r\n    \r\n                if (0 == context.modulus) {\r\n                    // 3 bytes = 24 bits = 4 * 6 bits to extract\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];\r\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];\r\n                    buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];\r\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\r\n                    if ((lineLength > 0) && (lineLength <= context.currentLinePos)) {\r\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n                        context.pos += lineSeparator.length;\r\n                        context.currentLinePos = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\npublic static Builder builder();\n    @Override\r\nvoid decode(final byte[] input, int inPos, final int inAvail, final Context context);\n    public static byte[] decodeBase64(final byte[] base64Data);\n    public static byte[] decodeBase64(final String base64String);\n    public static BigInteger decodeInteger(final byte[] pArray);\n    public static byte[] encodeBase64(final byte[] binaryData);\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked);\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe);\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe, final int maxResultSize);\n    public static byte[] encodeBase64Chunked(final byte[] binaryData);\n    public static String encodeBase64String(final byte[] binaryData);\n    public static byte[] encodeBase64URLSafe(final byte[] binaryData);\n    public static String encodeBase64URLSafeString(final byte[] binaryData);\n    public static byte[] encodeInteger(final BigInteger bigInteger);\n    byte[] getLineSeparator();\n    public static boolean isBase64(final byte octet);\n    public static boolean isBase64(final byte[] arrayOctet);\n    public static boolean isBase64(final String base64);\n    @Override\r\nprotected boolean isInAlphabet(final byte octet);\n    public boolean isUrlSafe();\n    static byte[] toIntegerBytes(final BigInteger bigInt);\n}"
      },
      {
        "id": "DoubleMetaphone_handleG",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.DoubleMetaphone",
        "test-class": "org.apache.commons.codec.language.DoubleMetaphone_handleG_Test",
        "method-name": "handleG(String, DoubleMetaphoneResult, int, boolean)",
        "source-path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/DoubleMetaphone_handleG_Test.java",
        "focal-method": "private int handleG(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\r\n    if (charAt(value, index + 1) == 'H') {\r\n        index = handleGH(value, result, index);\r\n    } else if (charAt(value, index + 1) == 'N') {\r\n        if (((index == 1) && isVowel(charAt(value, 0))) && (!slavoGermanic)) {\r\n            result.append(\"KN\", \"N\");\r\n        } else if (((!contains(value, index + 2, 2, \"EY\")) && (charAt(value, index + 1) != 'Y')) && (!slavoGermanic)) {\r\n            result.append(\"N\", \"KN\");\r\n        } else {\r\n            result.append(\"KN\");\r\n        }\r\n        index += 2;\r\n    } else if (contains(value, index + 1, 2, \"LI\") && (!slavoGermanic)) {\r\n        result.append(\"KL\", \"L\");\r\n        index += 2;\r\n    } else if ((index == 0) && ((charAt(value, index + 1) == 'Y') || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\r\n        // -- -ges-, -gep-, -gel-, -gie- at beginning --//\r\n        result.append('K', 'J');\r\n        index += 2;\r\n    } else if ((((contains(value, index + 1, 2, \"ER\") || (charAt(value, index + 1) == 'Y')) && (!contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\"))) && (!contains(value, index - 1, 1, \"E\", \"I\"))) && (!contains(value, index - 1, 3, \"RGY\", \"OGY\"))) {\r\n        // -- -ger-, -gy- --//\r\n        result.append('K', 'J');\r\n        index += 2;\r\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\r\n        // -- Italian \"biaggi\" --//\r\n        if ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\r\n            // -- obvious germanic --//\r\n            result.append('K');\r\n        } else if (contains(value, index + 1, 3, \"IER\")) {\r\n            result.append('J');\r\n        } else {\r\n            result.append('J', 'K');\r\n        }\r\n        index += 2;\r\n    } else {\r\n        if (charAt(value, index + 1) == 'G') {\r\n            index += 2;\r\n        } else {\r\n            index++;\r\n        }\r\n        result.append('K');\r\n    }\r\n    return index;\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\npublic class DoubleMetaphone implements StringEncoder {\n    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER = new String[]{ \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };\n        /**\r\n     * Inner class for storing results, since there is the optional alternate encoding.\r\n     */\r\n    public class DoubleMetaphoneResult {\r\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final int maxLength;\r\n    \r\n        public DoubleMetaphoneResult(final int maxLength) {\r\n            this.maxLength = maxLength;\r\n        }\r\n    \r\n        public void append(final char value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final char primary, final char alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void append(final String value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final String primary, final String alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void appendAlternate(final char value) {\r\n            if (this.alternate.length() < this.maxLength) {\r\n                this.alternate.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendAlternate(final String value) {\r\n            final int addChars = this.maxLength - this.alternate.length();\r\n            if (value.length() <= addChars) {\r\n                this.alternate.append(value);\r\n            } else {\r\n                this.alternate.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final char value) {\r\n            if (this.primary.length() < this.maxLength) {\r\n                this.primary.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final String value) {\r\n            final int addChars = this.maxLength - this.primary.length();\r\n            if (value.length() <= addChars) {\r\n                this.primary.append(value);\r\n            } else {\r\n                this.primary.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public String getAlternate() {\r\n            return this.alternate.toString();\r\n        }\r\n    \r\n        public String getPrimary() {\r\n            return this.primary.toString();\r\n        }\r\n    \r\n        public boolean isComplete() {\r\n            return (this.primary.length() >= this.maxLength) && (this.alternate.length() >= this.maxLength);\r\n        }\r\n    }\nprivate int handleG(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\r\n        if (charAt(value, index + 1) == 'H') {\r\n            index = handleGH(value, result, index);\r\n        } else if (charAt(value, index + 1) == 'N') {\r\n            if (((index == 1) && isVowel(charAt(value, 0))) && (!slavoGermanic)) {\r\n                result.append(\"KN\", \"N\");\r\n            } else if (((!contains(value, index + 2, 2, \"EY\")) && (charAt(value, index + 1) != 'Y')) && (!slavoGermanic)) {\r\n                result.append(\"N\", \"KN\");\r\n            } else {\r\n                result.append(\"KN\");\r\n            }\r\n            index += 2;\r\n        } else if (contains(value, index + 1, 2, \"LI\") && (!slavoGermanic)) {\r\n            result.append(\"KL\", \"L\");\r\n            index += 2;\r\n        } else if ((index == 0) && ((charAt(value, index + 1) == 'Y') || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\r\n            // -- -ges-, -gep-, -gel-, -gie- at beginning --//\r\n            result.append('K', 'J');\r\n            index += 2;\r\n        } else if ((((contains(value, index + 1, 2, \"ER\") || (charAt(value, index + 1) == 'Y')) && (!contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\"))) && (!contains(value, index - 1, 1, \"E\", \"I\"))) && (!contains(value, index - 1, 3, \"RGY\", \"OGY\"))) {\r\n            // -- -ger-, -gy- --//\r\n            result.append('K', 'J');\r\n            index += 2;\r\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\r\n            // -- Italian \"biaggi\" --//\r\n            if ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\r\n                // -- obvious germanic --//\r\n                result.append('K');\r\n            } else if (contains(value, index + 1, 3, \"IER\")) {\r\n                result.append('J');\r\n            } else {\r\n                result.append('J', 'K');\r\n            }\r\n            index += 2;\r\n        } else {\r\n            if (charAt(value, index + 1) == 'G') {\r\n                index += 2;\r\n            } else {\r\n                index++;\r\n            }\r\n            result.append('K');\r\n        }\r\n        return index;\r\n    }\nprotected char charAt(final String value, final int index);\n    protected static boolean contains(final String value, final int start, final int length, final String... criteria);\n    public String doubleMetaphone(final String value);\n    public String doubleMetaphone(String value, final boolean alternate);\n    @Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String value);\n    public int getMaxCodeLen();\n    private int handleGH(final String value, final DoubleMetaphoneResult result, int index);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate);\n    private boolean isVowel(final char ch);\n    public void setMaxCodeLen(final int maxCodeLen);\n}"
      },
      {
        "id": "Base32_encode",
        "package": "org.apache.commons.codec.binary",
        "class": "org.apache.commons.codec.binary.Base32",
        "test-class": "org.apache.commons.codec.binary.Base32_encode_Test",
        "method-name": "encode(byte[], int, int, Context)",
        "source-path": "src/main/java/org/apache/commons/codec/binary/Base32.java",
        "test-path": "src/test/java/org/apache/commons/codec/binary/Base32_encode_Test.java",
        "focal-method": "@Override\r\nvoid encode(final byte[] input, int inPos, final int inAvail, final Context context) {\r\n    // package protected for access from I/O streams\r\n    if (context.eof) {\r\n        return;\r\n    }\r\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\r\n    // encoding.\r\n    if (inAvail < 0) {\r\n        context.eof = true;\r\n        if ((0 == context.modulus) && (lineLength == 0)) {\r\n            return;// no leftovers to process and not using chunking\r\n\r\n        }\r\n        final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n        final int savedPos = context.pos;\r\n        switch (context.modulus) {\r\n            // % 5\r\n            case 0 :\r\n                break;\r\n            case 1 :\r\n                // Only 1 octet; take top 5 bits then remainder\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 3)) & MASK_5BITS];// 8-1*5 = 3\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 2)) & MASK_5BITS];// 5-3=2\r\n\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                break;\r\n            case 2 :\r\n                // 2 octets = 16 bits to use\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 11)) & MASK_5BITS];// 16-1*5 = 11\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 6)) & MASK_5BITS];// 16-2*5 = 6\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 1)) & MASK_5BITS];// 16-3*5 = 1\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 4)) & MASK_5BITS];// 5-1 = 4\r\n\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                break;\r\n            case 3 :\r\n                // 3 octets = 24 bits to use\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 19)) & MASK_5BITS];// 24-1*5 = 19\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 14)) & MASK_5BITS];// 24-2*5 = 14\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 9)) & MASK_5BITS];// 24-3*5 = 9\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 4)) & MASK_5BITS];// 24-4*5 = 4\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 1)) & MASK_5BITS];// 5-4 = 1\r\n\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                buffer[context.pos++] = pad;\r\n                break;\r\n            case 4 :\r\n                // 4 octets = 32 bits to use\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 27)) & MASK_5BITS];// 32-1*5 = 27\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 22)) & MASK_5BITS];// 32-2*5 = 22\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 17)) & MASK_5BITS];// 32-3*5 = 17\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 12)) & MASK_5BITS];// 32-4*5 = 12\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 7)) & MASK_5BITS];// 32-5*5 = 7\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 2)) & MASK_5BITS];// 32-6*5 = 2\r\n\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 3)) & MASK_5BITS];// 5-2 = 3\r\n\r\n                buffer[context.pos++] = pad;\r\n                break;\r\n            default :\r\n                throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n        }\r\n        context.currentLinePos += context.pos - savedPos;// keep track of current line position\r\n\r\n        // if currentPos == 0 we are at the start of a line, so don't add CRLF\r\n        if ((lineLength > 0) && (context.currentLinePos > 0)) {\r\n            // add chunk separator if required\r\n            System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n            context.pos += lineSeparator.length;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < inAvail; i++) {\r\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n            context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\r\n            int b = input[inPos++];\r\n            if (b < 0) {\r\n                b += 256;\r\n            }\r\n            context.lbitWorkArea = (context.lbitWorkArea << 8) + b;// BITS_PER_BYTE\r\n\r\n            if (0 == context.modulus) {\r\n                // we have enough bytes to create our output\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 35)) & MASK_5BITS];\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 30)) & MASK_5BITS];\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 25)) & MASK_5BITS];\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 20)) & MASK_5BITS];\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 15)) & MASK_5BITS];\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 10)) & MASK_5BITS];\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 5)) & MASK_5BITS];\r\n                buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea)) & MASK_5BITS];\r\n                context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\r\n                if ((lineLength > 0) && (lineLength <= context.currentLinePos)) {\r\n                    System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n                    context.pos += lineSeparator.length;\r\n                    context.currentLinePos = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
        "class-code": "package org.apache.commons.codec.binary;\nimport java.util.Objects;\nimport org.apache.commons.codec.CodecPolicy;\npublic class Base32 extends BaseNCodec {\n    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n    private static final int BYTES_PER_UNENCODED_BLOCK = 5;\n    private static final int MASK_5BITS = 0x1f;\n    private final int encodeSize;\n    private final byte[] encodeTable;\n    private final byte[] lineSeparator;\n    @Override\r\n    void encode(final byte[] input, int inPos, final int inAvail, final Context context) {\r\n        // package protected for access from I/O streams\r\n        if (context.eof) {\r\n            return;\r\n        }\r\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\r\n        // encoding.\r\n        if (inAvail < 0) {\r\n            context.eof = true;\r\n            if ((0 == context.modulus) && (lineLength == 0)) {\r\n                return;// no leftovers to process and not using chunking\r\n    \r\n            }\r\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n            final int savedPos = context.pos;\r\n            switch (context.modulus) {\r\n                // % 5\r\n                case 0 :\r\n                    break;\r\n                case 1 :\r\n                    // Only 1 octet; take top 5 bits then remainder\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 3)) & MASK_5BITS];// 8-1*5 = 3\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 2)) & MASK_5BITS];// 5-3=2\r\n    \r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    break;\r\n                case 2 :\r\n                    // 2 octets = 16 bits to use\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 11)) & MASK_5BITS];// 16-1*5 = 11\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 6)) & MASK_5BITS];// 16-2*5 = 6\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 1)) & MASK_5BITS];// 16-3*5 = 1\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 4)) & MASK_5BITS];// 5-1 = 4\r\n    \r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    break;\r\n                case 3 :\r\n                    // 3 octets = 24 bits to use\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 19)) & MASK_5BITS];// 24-1*5 = 19\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 14)) & MASK_5BITS];// 24-2*5 = 14\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 9)) & MASK_5BITS];// 24-3*5 = 9\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 4)) & MASK_5BITS];// 24-4*5 = 4\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 1)) & MASK_5BITS];// 5-4 = 1\r\n    \r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    buffer[context.pos++] = pad;\r\n                    break;\r\n                case 4 :\r\n                    // 4 octets = 32 bits to use\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 27)) & MASK_5BITS];// 32-1*5 = 27\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 22)) & MASK_5BITS];// 32-2*5 = 22\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 17)) & MASK_5BITS];// 32-3*5 = 17\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 12)) & MASK_5BITS];// 32-4*5 = 12\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 7)) & MASK_5BITS];// 32-5*5 = 7\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 2)) & MASK_5BITS];// 32-6*5 = 2\r\n    \r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea << 3)) & MASK_5BITS];// 5-2 = 3\r\n    \r\n                    buffer[context.pos++] = pad;\r\n                    break;\r\n                default :\r\n                    throw new IllegalStateException(\"Impossible modulus \" + context.modulus);\r\n            }\r\n            context.currentLinePos += context.pos - savedPos;// keep track of current line position\r\n    \r\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\r\n            if ((lineLength > 0) && (context.currentLinePos > 0)) {\r\n                // add chunk separator if required\r\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n                context.pos += lineSeparator.length;\r\n            }\r\n        } else {\r\n            for (int i = 0; i < inAvail; i++) {\r\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\r\n                context.modulus = (context.modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\r\n                int b = input[inPos++];\r\n                if (b < 0) {\r\n                    b += 256;\r\n                }\r\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b;// BITS_PER_BYTE\r\n    \r\n                if (0 == context.modulus) {\r\n                    // we have enough bytes to create our output\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 35)) & MASK_5BITS];\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 30)) & MASK_5BITS];\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 25)) & MASK_5BITS];\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 20)) & MASK_5BITS];\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 15)) & MASK_5BITS];\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 10)) & MASK_5BITS];\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea >> 5)) & MASK_5BITS];\r\n                    buffer[context.pos++] = encodeTable[((int) (context.lbitWorkArea)) & MASK_5BITS];\r\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\r\n                    if ((lineLength > 0) && (lineLength <= context.currentLinePos)) {\r\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\r\n                        context.pos += lineSeparator.length;\r\n                        context.currentLinePos = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\npublic static Builder builder();\n    @Override\r\nvoid decode(final byte[] input, int inPos, final int inAvail, final Context context);\n    byte[] getLineSeparator();\n    @Override\r\npublic boolean isInAlphabet(final byte octet);\n}"
      },
      {
        "id": "Rule_pattern",
        "package": "org.apache.commons.codec.language.bm",
        "class": "org.apache.commons.codec.language.bm.Rule",
        "test-class": "org.apache.commons.codec.language.bm.Rule_pattern_Test",
        "method-name": "pattern(String)",
        "source-path": "src/main/java/org/apache/commons/codec/language/bm/Rule.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/bm/Rule_pattern_Test.java",
        "focal-method": "private static RPattern pattern(final String regex) {\r\n    final boolean startsWith = regex.startsWith(\"^\");\r\n    final boolean endsWith = regex.endsWith(\"$\");\r\n    final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\r\n    final boolean boxes = content.contains(\"[\");\r\n    if (!boxes) {\r\n        if (startsWith && endsWith) {\r\n            // exact match\r\n            if (content.isEmpty()) {\r\n                // empty\r\n                return input -> input.length() == 0;\r\n            }\r\n            return input -> input.equals(content);\r\n        }\r\n        if ((startsWith || endsWith) && content.isEmpty()) {\r\n            // matches every string\r\n            return ALL_STRINGS_RMATCHER;\r\n        }\r\n        if (startsWith) {\r\n            // matches from start\r\n            return input -> startsWith(input, content);\r\n        }\r\n        if (endsWith) {\r\n            // matches from start\r\n            return input -> endsWith(input, content);\r\n        }\r\n    } else {\r\n        final boolean startsWithBox = content.startsWith(\"[\");\r\n        final boolean endsWithBox = content.endsWith(\"]\");\r\n        if (startsWithBox && endsWithBox) {\r\n            String boxContent = content.substring(1, content.length() - 1);\r\n            if (!boxContent.contains(\"[\")) {\r\n                // box containing alternatives\r\n                final boolean negate = boxContent.startsWith(\"^\");\r\n                if (negate) {\r\n                    boxContent = boxContent.substring(1);\r\n                }\r\n                final String bContent = boxContent;\r\n                final boolean shouldMatch = !negate;\r\n                if (startsWith && endsWith) {\r\n                    // exact match\r\n                    return input -> (input.length() == 1) && (contains(bContent, input.charAt(0)) == shouldMatch);\r\n                }\r\n                if (startsWith) {\r\n                    // first char\r\n                    return input -> (input.length() > 0) && (contains(bContent, input.charAt(0)) == shouldMatch);\r\n                }\r\n                if (endsWith) {\r\n                    // last char\r\n                    return input -> (input.length() > 0) && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new RPattern() {\r\n        final Pattern pattern = Pattern.compile(regex);\r\n\r\n        @Override\r\n        public boolean isMatch(final CharSequence input) {\r\n            final Matcher matcher = pattern.matcher(input);\r\n            return matcher.find();\r\n        }\r\n    };\r\n}",
        "class-code": "package org.apache.commons.codec.language.bm;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.regex.Matcher;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport org.apache.commons.codec.Resources;\nimport org.apache.commons.codec.language.bm.Languages.LanguageSet;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Collections;\npublic class Rule {\n    public static final RPattern ALL_STRINGS_RMATCHER = input -> true;\n    public static final String ALL = \"ALL\";\n    private static RPattern pattern(final String regex) {\r\n        final boolean startsWith = regex.startsWith(\"^\");\r\n        final boolean endsWith = regex.endsWith(\"$\");\r\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\r\n        final boolean boxes = content.contains(\"[\");\r\n        if (!boxes) {\r\n            if (startsWith && endsWith) {\r\n                // exact match\r\n                if (content.isEmpty()) {\r\n                    // empty\r\n                    return input -> input.length() == 0;\r\n                }\r\n                return input -> input.equals(content);\r\n            }\r\n            if ((startsWith || endsWith) && content.isEmpty()) {\r\n                // matches every string\r\n                return ALL_STRINGS_RMATCHER;\r\n            }\r\n            if (startsWith) {\r\n                // matches from start\r\n                return input -> startsWith(input, content);\r\n            }\r\n            if (endsWith) {\r\n                // matches from start\r\n                return input -> endsWith(input, content);\r\n            }\r\n        } else {\r\n            final boolean startsWithBox = content.startsWith(\"[\");\r\n            final boolean endsWithBox = content.endsWith(\"]\");\r\n            if (startsWithBox && endsWithBox) {\r\n                String boxContent = content.substring(1, content.length() - 1);\r\n                if (!boxContent.contains(\"[\")) {\r\n                    // box containing alternatives\r\n                    final boolean negate = boxContent.startsWith(\"^\");\r\n                    if (negate) {\r\n                        boxContent = boxContent.substring(1);\r\n                    }\r\n                    final String bContent = boxContent;\r\n                    final boolean shouldMatch = !negate;\r\n                    if (startsWith && endsWith) {\r\n                        // exact match\r\n                        return input -> (input.length() == 1) && (contains(bContent, input.charAt(0)) == shouldMatch);\r\n                    }\r\n                    if (startsWith) {\r\n                        // first char\r\n                        return input -> (input.length() > 0) && (contains(bContent, input.charAt(0)) == shouldMatch);\r\n                    }\r\n                    if (endsWith) {\r\n                        // last char\r\n                        return input -> (input.length() > 0) && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new RPattern() {\r\n            final Pattern pattern = Pattern.compile(regex);\r\n    \r\n            @Override\r\n            public boolean isMatch(final CharSequence input) {\r\n                final Matcher matcher = pattern.matcher(input);\r\n                return matcher.find();\r\n            }\r\n        };\r\n    }\nprivate static boolean contains(final CharSequence chars, final char input);\n    private static boolean endsWith(final CharSequence input, final CharSequence suffix);\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang);\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs);\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final String lang);\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt, final Languages.LanguageSet langs);\n    public RPattern getLContext();\n    public String getPattern();\n    public PhonemeExpr getPhoneme();\n    public RPattern getRContext();\n    public boolean patternAndContextMatches(final CharSequence input, final int i);\n    private static boolean startsWith(final CharSequence input, final CharSequence prefix);\n}"
      },
      {
        "id": "DoubleMetaphone_handleS",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.DoubleMetaphone",
        "test-class": "org.apache.commons.codec.language.DoubleMetaphone_handleS_Test",
        "method-name": "handleS(String, DoubleMetaphoneResult, int, boolean)",
        "source-path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/DoubleMetaphone_handleS_Test.java",
        "focal-method": "private int handleS(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\r\n    if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\r\n        // -- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\r\n        index++;\r\n    } else if ((index == 0) && contains(value, index, 5, \"SUGAR\")) {\r\n        // -- special case \"sugar-\" --//\r\n        result.append('X', 'S');\r\n        index++;\r\n    } else if (contains(value, index, 2, \"SH\")) {\r\n        if (contains(value, index + 1, 4, \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\r\n            // -- germanic --//\r\n            result.append('S');\r\n        } else {\r\n            result.append('X');\r\n        }\r\n        index += 2;\r\n    } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\r\n        // -- Italian and Armenian --//\r\n        if (slavoGermanic) {\r\n            result.append('S');\r\n        } else {\r\n            result.append('S', 'X');\r\n        }\r\n        index += 3;\r\n    } else if (((index == 0) && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\r\n        // -- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\r\n        // \"snider\" match \"schneider\" --//\r\n        // -- also, -sz- in slavic language although in hungarian it //\r\n        // is pronounced \"s\" --//\r\n        result.append('S', 'X');\r\n        index = (contains(value, index + 1, 1, \"Z\")) ? index + 2 : index + 1;\r\n    } else if (contains(value, index, 2, \"SC\")) {\r\n        index = handleSC(value, result, index);\r\n    } else {\r\n        if ((index == (value.length() - 1)) && contains(value, index - 2, 2, \"AI\", \"OI\")) {\r\n            // -- french e.g. \"resnais\", \"artois\" --//\r\n            result.appendAlternate('S');\r\n        } else {\r\n            result.append('S');\r\n        }\r\n        index = (contains(value, index + 1, 1, \"S\", \"Z\")) ? index + 2 : index + 1;\r\n    }\r\n    return index;\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\npublic class DoubleMetaphone implements StringEncoder {\n    \n        /**\r\n     * Inner class for storing results, since there is the optional alternate encoding.\r\n     */\r\n    public class DoubleMetaphoneResult {\r\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final int maxLength;\r\n    \r\n        public DoubleMetaphoneResult(final int maxLength) {\r\n            this.maxLength = maxLength;\r\n        }\r\n    \r\n        public void append(final char value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final char primary, final char alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void append(final String value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final String primary, final String alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void appendAlternate(final char value) {\r\n            if (this.alternate.length() < this.maxLength) {\r\n                this.alternate.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendAlternate(final String value) {\r\n            final int addChars = this.maxLength - this.alternate.length();\r\n            if (value.length() <= addChars) {\r\n                this.alternate.append(value);\r\n            } else {\r\n                this.alternate.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final char value) {\r\n            if (this.primary.length() < this.maxLength) {\r\n                this.primary.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final String value) {\r\n            final int addChars = this.maxLength - this.primary.length();\r\n            if (value.length() <= addChars) {\r\n                this.primary.append(value);\r\n            } else {\r\n                this.primary.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public String getAlternate() {\r\n            return this.alternate.toString();\r\n        }\r\n    \r\n        public String getPrimary() {\r\n            return this.primary.toString();\r\n        }\r\n    \r\n        public boolean isComplete() {\r\n            return (this.primary.length() >= this.maxLength) && (this.alternate.length() >= this.maxLength);\r\n        }\r\n    }\nprivate int handleS(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic) {\r\n        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\r\n            // -- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\r\n            index++;\r\n        } else if ((index == 0) && contains(value, index, 5, \"SUGAR\")) {\r\n            // -- special case \"sugar-\" --//\r\n            result.append('X', 'S');\r\n            index++;\r\n        } else if (contains(value, index, 2, \"SH\")) {\r\n            if (contains(value, index + 1, 4, \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\r\n                // -- germanic --//\r\n                result.append('S');\r\n            } else {\r\n                result.append('X');\r\n            }\r\n            index += 2;\r\n        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, index, 4, \"SIAN\")) {\r\n            // -- Italian and Armenian --//\r\n            if (slavoGermanic) {\r\n                result.append('S');\r\n            } else {\r\n                result.append('S', 'X');\r\n            }\r\n            index += 3;\r\n        } else if (((index == 0) && contains(value, index + 1, 1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\r\n            // -- german & anglicisations, e.g. \"smith\" match \"schmidt\" //\r\n            // \"snider\" match \"schneider\" --//\r\n            // -- also, -sz- in slavic language although in hungarian it //\r\n            // is pronounced \"s\" --//\r\n            result.append('S', 'X');\r\n            index = (contains(value, index + 1, 1, \"Z\")) ? index + 2 : index + 1;\r\n        } else if (contains(value, index, 2, \"SC\")) {\r\n            index = handleSC(value, result, index);\r\n        } else {\r\n            if ((index == (value.length() - 1)) && contains(value, index - 2, 2, \"AI\", \"OI\")) {\r\n                // -- french e.g. \"resnais\", \"artois\" --//\r\n                result.appendAlternate('S');\r\n            } else {\r\n                result.append('S');\r\n            }\r\n            index = (contains(value, index + 1, 1, \"S\", \"Z\")) ? index + 2 : index + 1;\r\n        }\r\n        return index;\r\n    }\nprotected char charAt(final String value, final int index);\n    protected static boolean contains(final String value, final int start, final int length, final String... criteria);\n    public String doubleMetaphone(final String value);\n    public String doubleMetaphone(String value, final boolean alternate);\n    @Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String value);\n    public int getMaxCodeLen();\n    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate);\n    public void setMaxCodeLen(final int maxCodeLen);\n}"
      },
      {
        "id": "DaitchMokotoffSoundex_soundex",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.DaitchMokotoffSoundex",
        "test-class": "org.apache.commons.codec.language.DaitchMokotoffSoundex_soundex_Test",
        "method-name": "soundex(String, boolean)",
        "source-path": "src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/DaitchMokotoffSoundex_soundex_Test.java",
        "focal-method": "private String[] soundex(final String source, final boolean branching) {\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    final String input = cleanup(source);\r\n    final Set<Branch> currentBranches = new LinkedHashSet<>();\r\n    currentBranches.add(new Branch());\r\n    char lastChar = '\\u0000';\r\n    for (int index = 0; index < input.length(); index++) {\r\n        final char ch = input.charAt(index);\r\n        // ignore whitespace inside a name\r\n        if (Character.isWhitespace(ch)) {\r\n            continue;\r\n        }\r\n        final String inputContext = input.substring(index);\r\n        final List<Rule> rules = RULES.get(ch);\r\n        if (rules == null) {\r\n            continue;\r\n        }\r\n        // use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access\r\n        final List<Branch> nextBranches = (branching) ? new ArrayList<>() : Collections.emptyList();\r\n        for (final Rule rule : rules) {\r\n            if (rule.matches(inputContext)) {\r\n                if (branching) {\r\n                    nextBranches.clear();\r\n                }\r\n                final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\u0000');\r\n                final boolean branchingRequired = (replacements.length > 1) && branching;\r\n                for (final Branch branch : currentBranches) {\r\n                    for (final String nextReplacement : replacements) {\r\n                        // if we have multiple replacements, always create a new branch\r\n                        final Branch nextBranch = (branchingRequired) ? branch.createBranch() : branch;\r\n                        // special rule: occurrences of mn or nm are treated differently\r\n                        final boolean force = ((lastChar == 'm') && (ch == 'n')) || ((lastChar == 'n') && (ch == 'm'));\r\n                        nextBranch.processNextReplacement(nextReplacement, force);\r\n                        if (!branching) {\r\n                            break;\r\n                        }\r\n                        nextBranches.add(nextBranch);\r\n                    }\r\n                }\r\n                if (branching) {\r\n                    currentBranches.clear();\r\n                    currentBranches.addAll(nextBranches);\r\n                }\r\n                index += rule.getPatternLength() - 1;\r\n                break;\r\n            }\r\n        }\r\n        lastChar = ch;\r\n    }\r\n    final String[] result = new String[currentBranches.size()];\r\n    int index = 0;\r\n    for (final Branch branch : currentBranches) {\r\n        branch.finish();\r\n        result[index++] = branch.toString();\r\n    }\r\n    return result;\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\nimport org.apache.commons.codec.CharEncoding;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.Resources;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.Collections;\npublic class DaitchMokotoffSoundex implements StringEncoder {\n    private static final Map<Character, List<Rule>> RULES = new HashMap<>();\n        /**\r\n     * Inner class representing a branch during DM soundex encoding.\r\n     */\r\n    private static final class Branch {\r\n        private final StringBuilder builder;\r\n    \r\n        private String cachedString;\r\n    \r\n        private String lastReplacement;\r\n    \r\n        private Branch() {\r\n            builder = new StringBuilder();\r\n            lastReplacement = null;\r\n            cachedString = null;\r\n        }\r\n    \r\n        /**\r\n         * Creates a new branch, identical to this branch.\r\n         *\r\n         * @return a new, identical branch\r\n         */\r\n        public Branch createBranch() {\r\n            final Branch branch = new Branch();\r\n            branch.builder.append(toString());\r\n            branch.lastReplacement = this.lastReplacement;\r\n            return branch;\r\n        }\r\n    \r\n        @Override\r\n        public boolean equals(final Object other) {\r\n            if (this == other) {\r\n                return true;\r\n            }\r\n            if (!(other instanceof Branch)) {\r\n                return false;\r\n            }\r\n            return toString().equals(((Branch) (other)).toString());\r\n        }\r\n    \r\n        /**\r\n         * Finish this branch by appending '0's until the maximum code length has been reached.\r\n         */\r\n        public void finish() {\r\n            while (builder.length() < MAX_LENGTH) {\r\n                builder.append('0');\r\n                cachedString = null;\r\n            } \r\n        }\r\n    \r\n        @Override\r\n        public int hashCode() {\r\n            return toString().hashCode();\r\n        }\r\n    \r\n        /**\r\n         * Process the next replacement to be added to this branch.\r\n         *\r\n         * @param replacement\r\n         * \t\tthe next replacement to append\r\n         * @param forceAppend\r\n         * \t\tindicates if the default processing shall be overridden\r\n         */\r\n        public void processNextReplacement(final String replacement, final boolean forceAppend) {\r\n            final boolean append = ((lastReplacement == null) || (!lastReplacement.endsWith(replacement))) || forceAppend;\r\n            if (append && (builder.length() < MAX_LENGTH)) {\r\n                builder.append(replacement);\r\n                // remove all characters after the maximum length\r\n                if (builder.length() > MAX_LENGTH) {\r\n                    builder.delete(MAX_LENGTH, builder.length());\r\n                }\r\n                cachedString = null;\r\n            }\r\n            lastReplacement = replacement;\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            if (cachedString == null) {\r\n                cachedString = builder.toString();\r\n            }\r\n            return cachedString;\r\n        }\r\n    }\n    /**\r\n     * Inner class for storing rules.\r\n     */\r\n    private static final class Rule {\r\n        private final String pattern;\r\n    \r\n        private final String[] replacementAtStart;\r\n    \r\n        private final String[] replacementBeforeVowel;\r\n    \r\n        private final String[] replacementDefault;\r\n    \r\n        protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel, final String replacementDefault) {\r\n            this.pattern = pattern;\r\n            this.replacementAtStart = replacementAtStart.split(\"\\\\|\");\r\n            this.replacementBeforeVowel = replacementBeforeVowel.split(\"\\\\|\");\r\n            this.replacementDefault = replacementDefault.split(\"\\\\|\");\r\n        }\r\n    \r\n        public int getPatternLength() {\r\n            return pattern.length();\r\n        }\r\n    \r\n        public String[] getReplacements(final String context, final boolean atStart) {\r\n            if (atStart) {\r\n                return replacementAtStart;\r\n            }\r\n            final int nextIndex = getPatternLength();\r\n            final boolean nextCharIsVowel = (nextIndex < context.length()) && isVowel(context.charAt(nextIndex));\r\n            if (nextCharIsVowel) {\r\n                return replacementBeforeVowel;\r\n            }\r\n            return replacementDefault;\r\n        }\r\n    \r\n        private boolean isVowel(final char ch) {\r\n            return ((((ch == 'a') || (ch == 'e')) || (ch == 'i')) || (ch == 'o')) || (ch == 'u');\r\n        }\r\n    \r\n        public boolean matches(final String context) {\r\n            return context.startsWith(pattern);\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"%s=(%s,%s,%s)\", pattern, Arrays.asList(replacementAtStart), Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));\r\n        }\r\n    }\nprivate String[] soundex(final String source, final boolean branching) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        final String input = cleanup(source);\r\n        final Set<Branch> currentBranches = new LinkedHashSet<>();\r\n        currentBranches.add(new Branch());\r\n        char lastChar = '\\u0000';\r\n        for (int index = 0; index < input.length(); index++) {\r\n            final char ch = input.charAt(index);\r\n            // ignore whitespace inside a name\r\n            if (Character.isWhitespace(ch)) {\r\n                continue;\r\n            }\r\n            final String inputContext = input.substring(index);\r\n            final List<Rule> rules = RULES.get(ch);\r\n            if (rules == null) {\r\n                continue;\r\n            }\r\n            // use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access\r\n            final List<Branch> nextBranches = (branching) ? new ArrayList<>() : Collections.emptyList();\r\n            for (final Rule rule : rules) {\r\n                if (rule.matches(inputContext)) {\r\n                    if (branching) {\r\n                        nextBranches.clear();\r\n                    }\r\n                    final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\u0000');\r\n                    final boolean branchingRequired = (replacements.length > 1) && branching;\r\n                    for (final Branch branch : currentBranches) {\r\n                        for (final String nextReplacement : replacements) {\r\n                            // if we have multiple replacements, always create a new branch\r\n                            final Branch nextBranch = (branchingRequired) ? branch.createBranch() : branch;\r\n                            // special rule: occurrences of mn or nm are treated differently\r\n                            final boolean force = ((lastChar == 'm') && (ch == 'n')) || ((lastChar == 'n') && (ch == 'm'));\r\n                            nextBranch.processNextReplacement(nextReplacement, force);\r\n                            if (!branching) {\r\n                                break;\r\n                            }\r\n                            nextBranches.add(nextBranch);\r\n                        }\r\n                    }\r\n                    if (branching) {\r\n                        currentBranches.clear();\r\n                        currentBranches.addAll(nextBranches);\r\n                    }\r\n                    index += rule.getPatternLength() - 1;\r\n                    break;\r\n                }\r\n            }\r\n            lastChar = ch;\r\n        }\r\n        final String[] result = new String[currentBranches.size()];\r\n        int index = 0;\r\n        for (final Branch branch : currentBranches) {\r\n            branch.finish();\r\n            result[index++] = branch.toString();\r\n        }\r\n        return result;\r\n    }\nprivate String cleanup(final String input);\n    @Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String source);\n    public String soundex(final String source);\n}"
      },
      {
        "id": "Nysiis_transcodeRemaining",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.Nysiis",
        "test-class": "org.apache.commons.codec.language.Nysiis_transcodeRemaining_Test",
        "method-name": "transcodeRemaining(char, char, char, char)",
        "source-path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/Nysiis_transcodeRemaining_Test.java",
        "focal-method": "private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\r\n    // 1. EV -> AF\r\n    if ((curr == 'E') && (next == 'V')) {\r\n        return CHARS_AF;\r\n    }\r\n    // A, E, I, O, U -> A\r\n    if (isVowel(curr)) {\r\n        return CHARS_A;\r\n    }\r\n    // 2. Q -> G, Z -> S, M -> N\r\n    // 3. KN -> NN else K -> C\r\n    switch (curr) {\r\n        case 'Q' :\r\n            return CHARS_G;\r\n        case 'Z' :\r\n            return CHARS_S;\r\n        case 'M' :\r\n            return CHARS_N;\r\n        case 'K' :\r\n            if (next == 'N') {\r\n                return CHARS_NN;\r\n            }\r\n            return CHARS_C;\r\n        default :\r\n            break;\r\n    }\r\n    // 4. SCH -> SSS\r\n    if (((curr == 'S') && (next == 'C')) && (aNext == 'H')) {\r\n        return CHARS_SSS;\r\n    }\r\n    // PH -> FF\r\n    if ((curr == 'P') && (next == 'H')) {\r\n        return CHARS_FF;\r\n    }\r\n    // 5. H -> If previous or next is a non vowel, previous.\r\n    if ((curr == 'H') && ((!isVowel(prev)) || (!isVowel(next)))) {\r\n        return new char[]{ prev };\r\n    }\r\n    // 6. W -> If previous is vowel, previous.\r\n    if ((curr == 'W') && isVowel(prev)) {\r\n        return new char[]{ prev };\r\n    }\r\n    return new char[]{ curr };\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport java.util.regex.Pattern;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\npublic class Nysiis implements StringEncoder {\n    private static final char[] CHARS_A = new char[]{ 'A' };\n    private static final char[] CHARS_AF = new char[]{ 'A', 'F' };\n    private static final char[] CHARS_C = new char[]{ 'C' };\n    private static final char[] CHARS_FF = new char[]{ 'F', 'F' };\n    private static final char[] CHARS_G = new char[]{ 'G' };\n    private static final char[] CHARS_N = new char[]{ 'N' };\n    private static final char[] CHARS_NN = new char[]{ 'N', 'N' };\n    private static final char[] CHARS_S = new char[]{ 'S' };\n    private static final char[] CHARS_SSS = new char[]{ 'S', 'S', 'S' };\n    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\r\n        // 1. EV -> AF\r\n        if ((curr == 'E') && (next == 'V')) {\r\n            return CHARS_AF;\r\n        }\r\n        // A, E, I, O, U -> A\r\n        if (isVowel(curr)) {\r\n            return CHARS_A;\r\n        }\r\n        // 2. Q -> G, Z -> S, M -> N\r\n        // 3. KN -> NN else K -> C\r\n        switch (curr) {\r\n            case 'Q' :\r\n                return CHARS_G;\r\n            case 'Z' :\r\n                return CHARS_S;\r\n            case 'M' :\r\n                return CHARS_N;\r\n            case 'K' :\r\n                if (next == 'N') {\r\n                    return CHARS_NN;\r\n                }\r\n                return CHARS_C;\r\n            default :\r\n                break;\r\n        }\r\n        // 4. SCH -> SSS\r\n        if (((curr == 'S') && (next == 'C')) && (aNext == 'H')) {\r\n            return CHARS_SSS;\r\n        }\r\n        // PH -> FF\r\n        if ((curr == 'P') && (next == 'H')) {\r\n            return CHARS_FF;\r\n        }\r\n        // 5. H -> If previous or next is a non vowel, previous.\r\n        if ((curr == 'H') && ((!isVowel(prev)) || (!isVowel(next)))) {\r\n            return new char[]{ prev };\r\n        }\r\n        // 6. W -> If previous is vowel, previous.\r\n        if ((curr == 'W') && isVowel(prev)) {\r\n            return new char[]{ prev };\r\n        }\r\n        return new char[]{ curr };\r\n    }\n@Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String str);\n    public boolean isStrict();\n    private static boolean isVowel(final char c);\n    public String nysiis(String str);\n}"
      },
      {
        "id": "MurmurHash3_hash128x64Internal",
        "package": "org.apache.commons.codec.digest",
        "class": "org.apache.commons.codec.digest.MurmurHash3",
        "test-class": "org.apache.commons.codec.digest.MurmurHash3_hash128x64Internal_Test",
        "method-name": "hash128x64Internal(byte[], int, int, long)",
        "source-path": "src/main/java/org/apache/commons/codec/digest/MurmurHash3.java",
        "test-path": "src/test/java/org/apache/commons/codec/digest/MurmurHash3_hash128x64Internal_Test.java",
        "focal-method": "private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {\r\n    long h1 = seed;\r\n    long h2 = seed;\r\n    final int nblocks = length >> 4;\r\n    // body\r\n    for (int i = 0; i < nblocks; i++) {\r\n        final int index = offset + (i << 4);\r\n        long k1 = getLittleEndianLong(data, index);\r\n        long k2 = getLittleEndianLong(data, index + 8);\r\n        // mix functions for k1\r\n        k1 *= C1;\r\n        k1 = Long.rotateLeft(k1, R1);\r\n        k1 *= C2;\r\n        h1 ^= k1;\r\n        h1 = Long.rotateLeft(h1, R2);\r\n        h1 += h2;\r\n        h1 = (h1 * M) + N1;\r\n        // mix functions for k2\r\n        k2 *= C2;\r\n        k2 = Long.rotateLeft(k2, R3);\r\n        k2 *= C1;\r\n        h2 ^= k2;\r\n        h2 = Long.rotateLeft(h2, R1);\r\n        h2 += h1;\r\n        h2 = (h2 * M) + N2;\r\n    }\r\n    // tail\r\n    long k1 = 0;\r\n    long k2 = 0;\r\n    final int index = offset + (nblocks << 4);\r\n    switch ((offset + length) - index) {\r\n        case 15 :\r\n            k2 ^= (((long) (data[index + 14])) & 0xff) << 48;\r\n        case 14 :\r\n            k2 ^= (((long) (data[index + 13])) & 0xff) << 40;\r\n        case 13 :\r\n            k2 ^= (((long) (data[index + 12])) & 0xff) << 32;\r\n        case 12 :\r\n            k2 ^= (((long) (data[index + 11])) & 0xff) << 24;\r\n        case 11 :\r\n            k2 ^= (((long) (data[index + 10])) & 0xff) << 16;\r\n        case 10 :\r\n            k2 ^= (((long) (data[index + 9])) & 0xff) << 8;\r\n        case 9 :\r\n            k2 ^= data[index + 8] & 0xff;\r\n            k2 *= C2;\r\n            k2 = Long.rotateLeft(k2, R3);\r\n            k2 *= C1;\r\n            h2 ^= k2;\r\n        case 8 :\r\n            k1 ^= (((long) (data[index + 7])) & 0xff) << 56;\r\n        case 7 :\r\n            k1 ^= (((long) (data[index + 6])) & 0xff) << 48;\r\n        case 6 :\r\n            k1 ^= (((long) (data[index + 5])) & 0xff) << 40;\r\n        case 5 :\r\n            k1 ^= (((long) (data[index + 4])) & 0xff) << 32;\r\n        case 4 :\r\n            k1 ^= (((long) (data[index + 3])) & 0xff) << 24;\r\n        case 3 :\r\n            k1 ^= (((long) (data[index + 2])) & 0xff) << 16;\r\n        case 2 :\r\n            k1 ^= (((long) (data[index + 1])) & 0xff) << 8;\r\n        case 1 :\r\n            k1 ^= data[index] & 0xff;\r\n            k1 *= C1;\r\n            k1 = Long.rotateLeft(k1, R1);\r\n            k1 *= C2;\r\n            h1 ^= k1;\r\n    }\r\n    // finalization\r\n    h1 ^= length;\r\n    h2 ^= length;\r\n    h1 += h2;\r\n    h2 += h1;\r\n    h1 = fmix64(h1);\r\n    h2 = fmix64(h2);\r\n    h1 += h2;\r\n    h2 += h1;\r\n    return new long[]{ h1, h2 };\r\n}",
        "class-code": "package org.apache.commons.codec.digest;\nimport org.apache.commons.codec.binary.StringUtils;\npublic final class MurmurHash3 {\n    public static final int DEFAULT_SEED = 104729;\n    private static final long C1 = 0x87c37b91114253d5L;\n    private static final long C2 = 0x4cf5ad432745937fL;\n    private static final int R1 = 31;\n    private static final int R2 = 27;\n    private static final int R3 = 33;\n    private static final int M = 5;\n    private static final int N1 = 0x52dce729;\n    private static final int N2 = 0x38495ab5;\n    private static long[] hash128x64Internal(final byte[] data, final int offset, final int length, final long seed) {\r\n        long h1 = seed;\r\n        long h2 = seed;\r\n        final int nblocks = length >> 4;\r\n        // body\r\n        for (int i = 0; i < nblocks; i++) {\r\n            final int index = offset + (i << 4);\r\n            long k1 = getLittleEndianLong(data, index);\r\n            long k2 = getLittleEndianLong(data, index + 8);\r\n            // mix functions for k1\r\n            k1 *= C1;\r\n            k1 = Long.rotateLeft(k1, R1);\r\n            k1 *= C2;\r\n            h1 ^= k1;\r\n            h1 = Long.rotateLeft(h1, R2);\r\n            h1 += h2;\r\n            h1 = (h1 * M) + N1;\r\n            // mix functions for k2\r\n            k2 *= C2;\r\n            k2 = Long.rotateLeft(k2, R3);\r\n            k2 *= C1;\r\n            h2 ^= k2;\r\n            h2 = Long.rotateLeft(h2, R1);\r\n            h2 += h1;\r\n            h2 = (h2 * M) + N2;\r\n        }\r\n        // tail\r\n        long k1 = 0;\r\n        long k2 = 0;\r\n        final int index = offset + (nblocks << 4);\r\n        switch ((offset + length) - index) {\r\n            case 15 :\r\n                k2 ^= (((long) (data[index + 14])) & 0xff) << 48;\r\n            case 14 :\r\n                k2 ^= (((long) (data[index + 13])) & 0xff) << 40;\r\n            case 13 :\r\n                k2 ^= (((long) (data[index + 12])) & 0xff) << 32;\r\n            case 12 :\r\n                k2 ^= (((long) (data[index + 11])) & 0xff) << 24;\r\n            case 11 :\r\n                k2 ^= (((long) (data[index + 10])) & 0xff) << 16;\r\n            case 10 :\r\n                k2 ^= (((long) (data[index + 9])) & 0xff) << 8;\r\n            case 9 :\r\n                k2 ^= data[index + 8] & 0xff;\r\n                k2 *= C2;\r\n                k2 = Long.rotateLeft(k2, R3);\r\n                k2 *= C1;\r\n                h2 ^= k2;\r\n            case 8 :\r\n                k1 ^= (((long) (data[index + 7])) & 0xff) << 56;\r\n            case 7 :\r\n                k1 ^= (((long) (data[index + 6])) & 0xff) << 48;\r\n            case 6 :\r\n                k1 ^= (((long) (data[index + 5])) & 0xff) << 40;\r\n            case 5 :\r\n                k1 ^= (((long) (data[index + 4])) & 0xff) << 32;\r\n            case 4 :\r\n                k1 ^= (((long) (data[index + 3])) & 0xff) << 24;\r\n            case 3 :\r\n                k1 ^= (((long) (data[index + 2])) & 0xff) << 16;\r\n            case 2 :\r\n                k1 ^= (((long) (data[index + 1])) & 0xff) << 8;\r\n            case 1 :\r\n                k1 ^= data[index] & 0xff;\r\n                k1 *= C1;\r\n                k1 = Long.rotateLeft(k1, R1);\r\n                k1 *= C2;\r\n                h1 ^= k1;\r\n        }\r\n        // finalization\r\n        h1 ^= length;\r\n        h2 ^= length;\r\n        h1 += h2;\r\n        h2 += h1;\r\n        h1 = fmix64(h1);\r\n        h2 = fmix64(h2);\r\n        h1 += h2;\r\n        h2 += h1;\r\n        return new long[]{ h1, h2 };\r\n    }\nprivate static long fmix64(long hash);\n    private static long getLittleEndianLong(final byte[] data, final int index);\n    public static long[] hash128(final byte[] data);\n    public static long[] hash128x64(final byte[] data);\n    public static long[] hash128x64(final byte[] data, final int offset, final int length, final int seed);\n    public static int hash32(final long data);\n    public static int hash32(final long data, final int seed);\n    public static int hash32(final long data1, final long data2);\n    public static int hash32(final long data1, final long data2, final int seed);\n    public static int hash32x86(final byte[] data);\n    public static int hash32x86(final byte[] data, final int offset, final int length, final int seed);\n}"
      },
      {
        "id": "Nysiis_nysiis",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.Nysiis",
        "test-class": "org.apache.commons.codec.language.Nysiis_nysiis_Test",
        "method-name": "nysiis(String)",
        "source-path": "src/main/java/org/apache/commons/codec/language/Nysiis.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/Nysiis_nysiis_Test.java",
        "focal-method": "public String nysiis(String str) {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    // Use the same clean rules as Soundex\r\n    str = SoundexUtils.clean(str);\r\n    if (str.isEmpty()) {\r\n        return str;\r\n    }\r\n    // Translate first characters of name:\r\n    // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\r\n    str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\r\n    str = PAT_KN.matcher(str).replaceFirst(\"NN\");\r\n    str = PAT_K.matcher(str).replaceFirst(\"C\");\r\n    str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\r\n    str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\r\n    // Translate last characters of name:\r\n    // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\r\n    str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\r\n    str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\r\n    // First character of key = first character of name.\r\n    final StringBuilder key = new StringBuilder(str.length());\r\n    key.append(str.charAt(0));\r\n    // Transcode remaining characters, incrementing by one character each time\r\n    final char[] chars = str.toCharArray();\r\n    final int len = chars.length;\r\n    for (int i = 1; i < len; i++) {\r\n        final char next = (i < (len - 1)) ? chars[i + 1] : SPACE;\r\n        final char aNext = (i < (len - 2)) ? chars[i + 2] : SPACE;\r\n        final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\r\n        System.arraycopy(transcoded, 0, chars, i, transcoded.length);\r\n        // only append the current char to the key if it is different from the last one\r\n        if (chars[i] != chars[i - 1]) {\r\n            key.append(chars[i]);\r\n        }\r\n    }\r\n    if (key.length() > 1) {\r\n        char lastChar = key.charAt(key.length() - 1);\r\n        // If last character is S, remove it.\r\n        if (lastChar == 'S') {\r\n            key.deleteCharAt(key.length() - 1);\r\n            lastChar = key.charAt(key.length() - 1);\r\n        }\r\n        if (key.length() > 2) {\r\n            final char last2Char = key.charAt(key.length() - 2);\r\n            // If last characters are AY, replace with Y.\r\n            if ((last2Char == 'A') && (lastChar == 'Y')) {\r\n                key.deleteCharAt(key.length() - 2);\r\n            }\r\n        }\r\n        // If last character is A, remove it.\r\n        if (lastChar == 'A') {\r\n            key.deleteCharAt(key.length() - 1);\r\n        }\r\n    }\r\n    final String string = key.toString();\r\n    return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport java.util.regex.Pattern;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\npublic class Nysiis implements StringEncoder {\n    private static final Pattern PAT_MAC = Pattern.compile(\"^MAC\");\n    private static final Pattern PAT_KN = Pattern.compile(\"^KN\");\n    private static final Pattern PAT_K = Pattern.compile(\"^K\");\n    private static final Pattern PAT_PH_PF = Pattern.compile(\"^(PH|PF)\");\n    private static final Pattern PAT_SCH = Pattern.compile(\"^SCH\");\n    private static final Pattern PAT_EE_IE = Pattern.compile(\"(EE|IE)$\");\n    private static final Pattern PAT_DT_ETC = Pattern.compile(\"(DT|RT|RD|NT|ND)$\");\n    private static final char SPACE = ' ';\n    private static final int TRUE_LENGTH = 6;\n    public String nysiis(String str) {\r\n        if (str == null) {\r\n            return null;\r\n        }\r\n        // Use the same clean rules as Soundex\r\n        str = SoundexUtils.clean(str);\r\n        if (str.isEmpty()) {\r\n            return str;\r\n        }\r\n        // Translate first characters of name:\r\n        // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\r\n        str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\r\n        str = PAT_KN.matcher(str).replaceFirst(\"NN\");\r\n        str = PAT_K.matcher(str).replaceFirst(\"C\");\r\n        str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\r\n        str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\r\n        // Translate last characters of name:\r\n        // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\r\n        str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\r\n        str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\r\n        // First character of key = first character of name.\r\n        final StringBuilder key = new StringBuilder(str.length());\r\n        key.append(str.charAt(0));\r\n        // Transcode remaining characters, incrementing by one character each time\r\n        final char[] chars = str.toCharArray();\r\n        final int len = chars.length;\r\n        for (int i = 1; i < len; i++) {\r\n            final char next = (i < (len - 1)) ? chars[i + 1] : SPACE;\r\n            final char aNext = (i < (len - 2)) ? chars[i + 2] : SPACE;\r\n            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\r\n            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\r\n            // only append the current char to the key if it is different from the last one\r\n            if (chars[i] != chars[i - 1]) {\r\n                key.append(chars[i]);\r\n            }\r\n        }\r\n        if (key.length() > 1) {\r\n            char lastChar = key.charAt(key.length() - 1);\r\n            // If last character is S, remove it.\r\n            if (lastChar == 'S') {\r\n                key.deleteCharAt(key.length() - 1);\r\n                lastChar = key.charAt(key.length() - 1);\r\n            }\r\n            if (key.length() > 2) {\r\n                final char last2Char = key.charAt(key.length() - 2);\r\n                // If last characters are AY, replace with Y.\r\n                if ((last2Char == 'A') && (lastChar == 'Y')) {\r\n                    key.deleteCharAt(key.length() - 2);\r\n                }\r\n            }\r\n            // If last character is A, remove it.\r\n            if (lastChar == 'A') {\r\n                key.deleteCharAt(key.length() - 1);\r\n            }\r\n        }\r\n        final String string = key.toString();\r\n        return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\r\n    }\n@Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String str);\n    public boolean isStrict();\n    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext);\n}"
      },
      {
        "id": "ColognePhonetic_colognePhonetic",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.ColognePhonetic",
        "test-class": "org.apache.commons.codec.language.ColognePhonetic_colognePhonetic_Test",
        "method-name": "colognePhonetic(String)",
        "source-path": "src/main/java/org/apache/commons/codec/language/ColognePhonetic.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/ColognePhonetic_colognePhonetic_Test.java",
        "focal-method": "public String colognePhonetic(final String text) {\r\n    if (text == null) {\r\n        return null;\r\n    }\r\n    final CologneInputBuffer input = new CologneInputBuffer(preprocess(text));\r\n    final CologneOutputBuffer output = new CologneOutputBuffer(input.length() * 2);\r\n    char nextChar;\r\n    char lastChar = CHAR_IGNORE;\r\n    char chr;\r\n    while (!input.isEmpty()) {\r\n        chr = input.removeNext();\r\n        if (!input.isEmpty()) {\r\n            nextChar = input.getNextChar();\r\n        } else {\r\n            nextChar = CHAR_IGNORE;\r\n        }\r\n        if ((chr < 'A') || (chr > 'Z')) {\r\n            continue;// ignore unwanted characters\r\n\r\n        }\r\n        if (arrayContains(AEIJOUY, chr)) {\r\n            output.put('0');\r\n        } else if ((chr == 'B') || ((chr == 'P') && (nextChar != 'H'))) {\r\n            output.put('1');\r\n        } else if (((chr == 'D') || (chr == 'T')) && (!arrayContains(CSZ, nextChar))) {\r\n            output.put('2');\r\n        } else if (arrayContains(FPVW, chr)) {\r\n            output.put('3');\r\n        } else if (arrayContains(GKQ, chr)) {\r\n            output.put('4');\r\n        } else if ((chr == 'X') && (!arrayContains(CKQ, lastChar))) {\r\n            output.put('4');\r\n            output.put('8');\r\n        } else if ((chr == 'S') || (chr == 'Z')) {\r\n            output.put('8');\r\n        } else if (chr == 'C') {\r\n            if (output.isEmpty()) {\r\n                if (arrayContains(AHKLOQRUX, nextChar)) {\r\n                    output.put('4');\r\n                } else {\r\n                    output.put('8');\r\n                }\r\n            } else if (arrayContains(SZ, lastChar) || (!arrayContains(AHKOQUX, nextChar))) {\r\n                output.put('8');\r\n            } else {\r\n                output.put('4');\r\n            }\r\n        } else if (arrayContains(DTX, chr)) {\r\n            output.put('8');\r\n        } else {\r\n            switch (chr) {\r\n                case 'R' :\r\n                    output.put('7');\r\n                    break;\r\n                case 'L' :\r\n                    output.put('5');\r\n                    break;\r\n                case 'M' :\r\n                case 'N' :\r\n                    output.put('6');\r\n                    break;\r\n                case 'H' :\r\n                    output.put(CHAR_IGNORE);// needed by put\r\n\r\n                    break;\r\n                default :\r\n                    break;\r\n            }\r\n        }\r\n        lastChar = chr;\r\n    } \r\n    return output.toString();\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport java.util.Locale;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\nimport java.util.Arrays;\npublic class ColognePhonetic implements StringEncoder {\n    private static final char[] AEIJOUY = new char[]{ 'A', 'E', 'I', 'J', 'O', 'U', 'Y' };\n    private static final char[] CSZ = new char[]{ 'C', 'S', 'Z' };\n    private static final char[] FPVW = new char[]{ 'F', 'P', 'V', 'W' };\n    private static final char[] GKQ = new char[]{ 'G', 'K', 'Q' };\n    private static final char[] CKQ = new char[]{ 'C', 'K', 'Q' };\n    private static final char[] AHKLOQRUX = new char[]{ 'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X' };\n    private static final char[] SZ = new char[]{ 'S', 'Z' };\n    private static final char[] AHKOQUX = new char[]{ 'A', 'H', 'K', 'O', 'Q', 'U', 'X' };\n    private static final char[] DTX = new char[]{ 'D', 'T', 'X' };\n    private static final char CHAR_IGNORE = '-';\n        /**\r\n     * This class is not thread-safe; the field {@link #length} is mutable.\r\n     * However, it is not shared between threads, as it is constructed on demand\r\n     * by the method {@link ColognePhonetic#colognePhonetic(String)}\r\n     */\r\n    static abstract class CologneBuffer {\r\n        protected final char[] data;\r\n    \r\n        protected int length;\r\n    \r\n        public CologneBuffer(final char[] data) {\r\n            this.data = data;\r\n            this.length = data.length;\r\n        }\r\n    \r\n        public CologneBuffer(final int buffSize) {\r\n            this.data = new char[buffSize];\r\n            this.length = 0;\r\n        }\r\n    \r\n        protected abstract char[] copyData(int start, int length);\r\n    \r\n        public boolean isEmpty() {\r\n            return length() == 0;\r\n        }\r\n    \r\n        public int length() {\r\n            return length;\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            return new String(copyData(0, length));\r\n        }\r\n    }\n    private final class CologneOutputBuffer extends CologneBuffer {\r\n        private char lastCode;\r\n    \r\n        public CologneOutputBuffer(final int buffSize) {\r\n            super(buffSize);\r\n            lastCode = '/';// impossible value\r\n    \r\n        }\r\n    \r\n        @Override\r\n        protected char[] copyData(final int start, final int length) {\r\n            return Arrays.copyOfRange(data, start, length);\r\n        }\r\n    \r\n        /**\r\n         * Stores the next code in the output buffer, keeping track of the previous code.\r\n         * '0' is only stored if it is the first entry.\r\n         * Ignored chars are never stored.\r\n         * If the code is the same as the last code (whether stored or not) it is not stored.\r\n         *\r\n         * @param code\r\n         * \t\tthe code to store.\r\n         */\r\n        public void put(final char code) {\r\n            if (((code != CHAR_IGNORE) && (lastCode != code)) && ((code != '0') || (length == 0))) {\r\n                data[length] = code;\r\n                length++;\r\n            }\r\n            lastCode = code;\r\n        }\r\n    }\n    private final class CologneInputBuffer extends CologneBuffer {\r\n        public CologneInputBuffer(final char[] data) {\r\n            super(data);\r\n        }\r\n    \r\n        @Override\r\n        protected char[] copyData(final int start, final int length) {\r\n            final char[] newData = new char[length];\r\n            System.arraycopy(data, (data.length - this.length) + start, newData, 0, length);\r\n            return newData;\r\n        }\r\n    \r\n        public char getNextChar() {\r\n            return data[getNextPos()];\r\n        }\r\n    \r\n        protected int getNextPos() {\r\n            return data.length - length;\r\n        }\r\n    \r\n        public char removeNext() {\r\n            final char ch = getNextChar();\r\n            length--;\r\n            return ch;\r\n        }\r\n    }\npublic String colognePhonetic(final String text) {\r\n        if (text == null) {\r\n            return null;\r\n        }\r\n        final CologneInputBuffer input = new CologneInputBuffer(preprocess(text));\r\n        final CologneOutputBuffer output = new CologneOutputBuffer(input.length() * 2);\r\n        char nextChar;\r\n        char lastChar = CHAR_IGNORE;\r\n        char chr;\r\n        while (!input.isEmpty()) {\r\n            chr = input.removeNext();\r\n            if (!input.isEmpty()) {\r\n                nextChar = input.getNextChar();\r\n            } else {\r\n                nextChar = CHAR_IGNORE;\r\n            }\r\n            if ((chr < 'A') || (chr > 'Z')) {\r\n                continue;// ignore unwanted characters\r\n    \r\n            }\r\n            if (arrayContains(AEIJOUY, chr)) {\r\n                output.put('0');\r\n            } else if ((chr == 'B') || ((chr == 'P') && (nextChar != 'H'))) {\r\n                output.put('1');\r\n            } else if (((chr == 'D') || (chr == 'T')) && (!arrayContains(CSZ, nextChar))) {\r\n                output.put('2');\r\n            } else if (arrayContains(FPVW, chr)) {\r\n                output.put('3');\r\n            } else if (arrayContains(GKQ, chr)) {\r\n                output.put('4');\r\n            } else if ((chr == 'X') && (!arrayContains(CKQ, lastChar))) {\r\n                output.put('4');\r\n                output.put('8');\r\n            } else if ((chr == 'S') || (chr == 'Z')) {\r\n                output.put('8');\r\n            } else if (chr == 'C') {\r\n                if (output.isEmpty()) {\r\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\r\n                        output.put('4');\r\n                    } else {\r\n                        output.put('8');\r\n                    }\r\n                } else if (arrayContains(SZ, lastChar) || (!arrayContains(AHKOQUX, nextChar))) {\r\n                    output.put('8');\r\n                } else {\r\n                    output.put('4');\r\n                }\r\n            } else if (arrayContains(DTX, chr)) {\r\n                output.put('8');\r\n            } else {\r\n                switch (chr) {\r\n                    case 'R' :\r\n                        output.put('7');\r\n                        break;\r\n                    case 'L' :\r\n                        output.put('5');\r\n                        break;\r\n                    case 'M' :\r\n                    case 'N' :\r\n                        output.put('6');\r\n                        break;\r\n                    case 'H' :\r\n                        output.put(CHAR_IGNORE);// needed by put\r\n    \r\n                        break;\r\n                    default :\r\n                        break;\r\n                }\r\n            }\r\n            lastChar = chr;\r\n        } \r\n        return output.toString();\r\n    }\nprivate static boolean arrayContains(final char[] arr, final char key);\n    @Override\r\npublic Object encode(final Object object) throws EncoderException;\n    @Override\r\npublic String encode(final String text);\n    public boolean isEncodeEqual(final String text1, final String text2);\n    private char[] preprocess(final String text);\n}"
      },
      {
        "id": "Md5Crypt_md5Crypt",
        "package": "org.apache.commons.codec.digest",
        "class": "org.apache.commons.codec.digest.Md5Crypt",
        "test-class": "org.apache.commons.codec.digest.Md5Crypt_md5Crypt_Test",
        "method-name": "md5Crypt(byte[], String, String, Random)",
        "source-path": "src/main/java/org/apache/commons/codec/digest/Md5Crypt.java",
        "test-path": "src/test/java/org/apache/commons/codec/digest/Md5Crypt_md5Crypt_Test.java",
        "focal-method": "public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix, final Random random) {\r\n    final int keyLen = keyBytes.length;\r\n    // Extract the real salt from the given string which can be a complete hash string.\r\n    final String saltString;\r\n    if (salt == null) {\r\n        saltString = B64.getRandomSalt(8, random);\r\n    } else {\r\n        final Pattern p = Pattern.compile((\"^\" + prefix.replace(\"$\", \"\\\\$\")) + \"([\\\\.\\\\/a-zA-Z0-9]{1,8}).*\");\r\n        final Matcher m = p.matcher(salt);\r\n        if (!m.find()) {\r\n            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\r\n        }\r\n        saltString = m.group(1);\r\n    }\r\n    final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8);\r\n    final MessageDigest ctx = DigestUtils.getMd5Digest();\r\n    /* The password first, since that is what is most unknown */\r\n    ctx.update(keyBytes);\r\n    /* Then our magic string */\r\n    ctx.update(prefix.getBytes(StandardCharsets.UTF_8));\r\n    /* Then the raw salt */\r\n    ctx.update(saltBytes);\r\n    /* Then just as many characters of the MD5(pw,salt,pw) */\r\n    MessageDigest ctx1 = DigestUtils.getMd5Digest();\r\n    ctx1.update(keyBytes);\r\n    ctx1.update(saltBytes);\r\n    ctx1.update(keyBytes);\r\n    byte[] finalb = ctx1.digest();\r\n    int ii = keyLen;\r\n    while (ii > 0) {\r\n        ctx.update(finalb, 0, Math.min(ii, 16));\r\n        ii -= 16;\r\n    } \r\n    /* Don't leave anything around in JVM they could use. */\r\n    Arrays.fill(finalb, ((byte) (0)));\r\n    /* Then something really weird... */\r\n    ii = keyLen;\r\n    final int j = 0;\r\n    while (ii > 0) {\r\n        if ((ii & 1) == 1) {\r\n            ctx.update(finalb[j]);\r\n        } else {\r\n            ctx.update(keyBytes[j]);\r\n        }\r\n        ii >>= 1;\r\n    } \r\n    /* Now make the output string */\r\n    final StringBuilder passwd = new StringBuilder((prefix + saltString) + \"$\");\r\n    finalb = ctx.digest();\r\n    /* and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 milliseconds, so you\r\n    would need 30 seconds to build a 1000 entry dictionary...\r\n     */\r\n    for (int i = 0; i < ROUNDS; i++) {\r\n        ctx1 = DigestUtils.getMd5Digest();\r\n        if ((i & 1) != 0) {\r\n            ctx1.update(keyBytes);\r\n        } else {\r\n            ctx1.update(finalb, 0, BLOCKSIZE);\r\n        }\r\n        if ((i % 3) != 0) {\r\n            ctx1.update(saltBytes);\r\n        }\r\n        if ((i % 7) != 0) {\r\n            ctx1.update(keyBytes);\r\n        }\r\n        if ((i & 1) != 0) {\r\n            ctx1.update(finalb, 0, BLOCKSIZE);\r\n        } else {\r\n            ctx1.update(keyBytes);\r\n        }\r\n        finalb = ctx1.digest();\r\n    }\r\n    // The following was nearly identical to the Sha2Crypt code.\r\n    // Again, the buflen is not really needed.\r\n    // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;\r\n    B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\r\n    B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\r\n    B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\r\n    B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\r\n    B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\r\n    B64.b64from24bit(((byte) (0)), ((byte) (0)), finalb[11], 2, passwd);\r\n    /* Don't leave anything around in JVM they could use. */\r\n    // Is there a better way to do this with the JVM?\r\n    ctx.reset();\r\n    ctx1.reset();\r\n    Arrays.fill(keyBytes, ((byte) (0)));\r\n    Arrays.fill(saltBytes, ((byte) (0)));\r\n    Arrays.fill(finalb, ((byte) (0)));\r\n    return passwd.toString();\r\n}",
        "class-code": "package org.apache.commons.codec.digest;\nimport java.util.regex.Pattern;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;\nimport java.security.MessageDigest;\nimport java.util.Arrays;\npublic class Md5Crypt {\n    static final String APR1_PREFIX = \"$apr1$\";\n    private static final int BLOCKSIZE = 16;\n    static final String MD5_PREFIX = \"$1$\";\n    private static final int ROUNDS = 1000;\n    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix, final Random random) {\r\n        final int keyLen = keyBytes.length;\r\n        // Extract the real salt from the given string which can be a complete hash string.\r\n        final String saltString;\r\n        if (salt == null) {\r\n            saltString = B64.getRandomSalt(8, random);\r\n        } else {\r\n            final Pattern p = Pattern.compile((\"^\" + prefix.replace(\"$\", \"\\\\$\")) + \"([\\\\.\\\\/a-zA-Z0-9]{1,8}).*\");\r\n            final Matcher m = p.matcher(salt);\r\n            if (!m.find()) {\r\n                throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\r\n            }\r\n            saltString = m.group(1);\r\n        }\r\n        final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8);\r\n        final MessageDigest ctx = DigestUtils.getMd5Digest();\r\n        /* The password first, since that is what is most unknown */\r\n        ctx.update(keyBytes);\r\n        /* Then our magic string */\r\n        ctx.update(prefix.getBytes(StandardCharsets.UTF_8));\r\n        /* Then the raw salt */\r\n        ctx.update(saltBytes);\r\n        /* Then just as many characters of the MD5(pw,salt,pw) */\r\n        MessageDigest ctx1 = DigestUtils.getMd5Digest();\r\n        ctx1.update(keyBytes);\r\n        ctx1.update(saltBytes);\r\n        ctx1.update(keyBytes);\r\n        byte[] finalb = ctx1.digest();\r\n        int ii = keyLen;\r\n        while (ii > 0) {\r\n            ctx.update(finalb, 0, Math.min(ii, 16));\r\n            ii -= 16;\r\n        } \r\n        /* Don't leave anything around in JVM they could use. */\r\n        Arrays.fill(finalb, ((byte) (0)));\r\n        /* Then something really weird... */\r\n        ii = keyLen;\r\n        final int j = 0;\r\n        while (ii > 0) {\r\n            if ((ii & 1) == 1) {\r\n                ctx.update(finalb[j]);\r\n            } else {\r\n                ctx.update(keyBytes[j]);\r\n            }\r\n            ii >>= 1;\r\n        } \r\n        /* Now make the output string */\r\n        final StringBuilder passwd = new StringBuilder((prefix + saltString) + \"$\");\r\n        finalb = ctx.digest();\r\n        /* and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 milliseconds, so you\r\n        would need 30 seconds to build a 1000 entry dictionary...\r\n         */\r\n        for (int i = 0; i < ROUNDS; i++) {\r\n            ctx1 = DigestUtils.getMd5Digest();\r\n            if ((i & 1) != 0) {\r\n                ctx1.update(keyBytes);\r\n            } else {\r\n                ctx1.update(finalb, 0, BLOCKSIZE);\r\n            }\r\n            if ((i % 3) != 0) {\r\n                ctx1.update(saltBytes);\r\n            }\r\n            if ((i % 7) != 0) {\r\n                ctx1.update(keyBytes);\r\n            }\r\n            if ((i & 1) != 0) {\r\n                ctx1.update(finalb, 0, BLOCKSIZE);\r\n            } else {\r\n                ctx1.update(keyBytes);\r\n            }\r\n            finalb = ctx1.digest();\r\n        }\r\n        // The following was nearly identical to the Sha2Crypt code.\r\n        // Again, the buflen is not really needed.\r\n        // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;\r\n        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\r\n        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\r\n        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\r\n        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\r\n        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\r\n        B64.b64from24bit(((byte) (0)), ((byte) (0)), finalb[11], 2, passwd);\r\n        /* Don't leave anything around in JVM they could use. */\r\n        // Is there a better way to do this with the JVM?\r\n        ctx.reset();\r\n        ctx1.reset();\r\n        Arrays.fill(keyBytes, ((byte) (0)));\r\n        Arrays.fill(saltBytes, ((byte) (0)));\r\n        Arrays.fill(finalb, ((byte) (0)));\r\n        return passwd.toString();\r\n    }\npublic static String apr1Crypt(final byte[] keyBytes);\n    public static String apr1Crypt(final byte[] keyBytes, String salt);\n    public static String apr1Crypt(final byte[] keyBytes, final Random random);\n    public static String apr1Crypt(final String keyBytes);\n    public static String apr1Crypt(final String keyBytes, final String salt);\n    public static String md5Crypt(final byte[] keyBytes);\n    public static String md5Crypt(final byte[] keyBytes, final String salt);\n    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix);\n    public static String md5Crypt(final byte[] keyBytes, final Random random);\n}"
      },
      {
        "id": "DoubleMetaphone_doubleMetaphone",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.DoubleMetaphone",
        "test-class": "org.apache.commons.codec.language.DoubleMetaphone_doubleMetaphone_Test",
        "method-name": "doubleMetaphone(String, boolean)",
        "source-path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/DoubleMetaphone_doubleMetaphone_Test.java",
        "focal-method": "public String doubleMetaphone(String value, final boolean alternate) {\r\n    value = cleanInput(value);\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    final boolean slavoGermanic = isSlavoGermanic(value);\r\n    int index = (isSilentStart(value)) ? 1 : 0;\r\n    final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\r\n    while ((!result.isComplete()) && (index <= (value.length() - 1))) {\r\n        switch (value.charAt(index)) {\r\n            case 'A' :\r\n            case 'E' :\r\n            case 'I' :\r\n            case 'O' :\r\n            case 'U' :\r\n            case 'Y' :\r\n                index = handleAEIOUY(result, index);\r\n                break;\r\n            case 'B' :\r\n                result.append('P');\r\n                index = (charAt(value, index + 1) == 'B') ? index + 2 : index + 1;\r\n                break;\r\n            case '?' :\r\n                // A C with a Cedilla\r\n                result.append('S');\r\n                index++;\r\n                break;\r\n            case 'C' :\r\n                index = handleC(value, result, index);\r\n                break;\r\n            case 'D' :\r\n                index = handleD(value, result, index);\r\n                break;\r\n            case 'F' :\r\n                result.append('F');\r\n                index = (charAt(value, index + 1) == 'F') ? index + 2 : index + 1;\r\n                break;\r\n            case 'G' :\r\n                index = handleG(value, result, index, slavoGermanic);\r\n                break;\r\n            case 'H' :\r\n                index = handleH(value, result, index);\r\n                break;\r\n            case 'J' :\r\n                index = handleJ(value, result, index, slavoGermanic);\r\n                break;\r\n            case 'K' :\r\n                result.append('K');\r\n                index = (charAt(value, index + 1) == 'K') ? index + 2 : index + 1;\r\n                break;\r\n            case 'L' :\r\n                index = handleL(value, result, index);\r\n                break;\r\n            case 'M' :\r\n                result.append('M');\r\n                index = (conditionM0(value, index)) ? index + 2 : index + 1;\r\n                break;\r\n            case 'N' :\r\n                result.append('N');\r\n                index = (charAt(value, index + 1) == 'N') ? index + 2 : index + 1;\r\n                break;\r\n            case '?' :\r\n                // N with a tilde (spanish ene)\r\n                result.append('N');\r\n                index++;\r\n                break;\r\n            case 'P' :\r\n                index = handleP(value, result, index);\r\n                break;\r\n            case 'Q' :\r\n                result.append('K');\r\n                index = (charAt(value, index + 1) == 'Q') ? index + 2 : index + 1;\r\n                break;\r\n            case 'R' :\r\n                index = handleR(value, result, index, slavoGermanic);\r\n                break;\r\n            case 'S' :\r\n                index = handleS(value, result, index, slavoGermanic);\r\n                break;\r\n            case 'T' :\r\n                index = handleT(value, result, index);\r\n                break;\r\n            case 'V' :\r\n                result.append('F');\r\n                index = (charAt(value, index + 1) == 'V') ? index + 2 : index + 1;\r\n                break;\r\n            case 'W' :\r\n                index = handleW(value, result, index);\r\n                break;\r\n            case 'X' :\r\n                index = handleX(value, result, index);\r\n                break;\r\n            case 'Z' :\r\n                index = handleZ(value, result, index, slavoGermanic);\r\n                break;\r\n            default :\r\n                index++;\r\n                break;\r\n        }\r\n    } \r\n    return alternate ? result.getAlternate() : result.getPrimary();\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\npublic class DoubleMetaphone implements StringEncoder {\n    \n        /**\r\n     * Inner class for storing results, since there is the optional alternate encoding.\r\n     */\r\n    public class DoubleMetaphoneResult {\r\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final int maxLength;\r\n    \r\n        public DoubleMetaphoneResult(final int maxLength) {\r\n            this.maxLength = maxLength;\r\n        }\r\n    \r\n        public void append(final char value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final char primary, final char alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void append(final String value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final String primary, final String alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void appendAlternate(final char value) {\r\n            if (this.alternate.length() < this.maxLength) {\r\n                this.alternate.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendAlternate(final String value) {\r\n            final int addChars = this.maxLength - this.alternate.length();\r\n            if (value.length() <= addChars) {\r\n                this.alternate.append(value);\r\n            } else {\r\n                this.alternate.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final char value) {\r\n            if (this.primary.length() < this.maxLength) {\r\n                this.primary.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final String value) {\r\n            final int addChars = this.maxLength - this.primary.length();\r\n            if (value.length() <= addChars) {\r\n                this.primary.append(value);\r\n            } else {\r\n                this.primary.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public String getAlternate() {\r\n            return this.alternate.toString();\r\n        }\r\n    \r\n        public String getPrimary() {\r\n            return this.primary.toString();\r\n        }\r\n    \r\n        public boolean isComplete() {\r\n            return (this.primary.length() >= this.maxLength) && (this.alternate.length() >= this.maxLength);\r\n        }\r\n    }\npublic String doubleMetaphone(String value, final boolean alternate) {\r\n        value = cleanInput(value);\r\n        if (value == null) {\r\n            return null;\r\n        }\r\n        final boolean slavoGermanic = isSlavoGermanic(value);\r\n        int index = (isSilentStart(value)) ? 1 : 0;\r\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\r\n        while ((!result.isComplete()) && (index <= (value.length() - 1))) {\r\n            switch (value.charAt(index)) {\r\n                case 'A' :\r\n                case 'E' :\r\n                case 'I' :\r\n                case 'O' :\r\n                case 'U' :\r\n                case 'Y' :\r\n                    index = handleAEIOUY(result, index);\r\n                    break;\r\n                case 'B' :\r\n                    result.append('P');\r\n                    index = (charAt(value, index + 1) == 'B') ? index + 2 : index + 1;\r\n                    break;\r\n                case '?' :\r\n                    // A C with a Cedilla\r\n                    result.append('S');\r\n                    index++;\r\n                    break;\r\n                case 'C' :\r\n                    index = handleC(value, result, index);\r\n                    break;\r\n                case 'D' :\r\n                    index = handleD(value, result, index);\r\n                    break;\r\n                case 'F' :\r\n                    result.append('F');\r\n                    index = (charAt(value, index + 1) == 'F') ? index + 2 : index + 1;\r\n                    break;\r\n                case 'G' :\r\n                    index = handleG(value, result, index, slavoGermanic);\r\n                    break;\r\n                case 'H' :\r\n                    index = handleH(value, result, index);\r\n                    break;\r\n                case 'J' :\r\n                    index = handleJ(value, result, index, slavoGermanic);\r\n                    break;\r\n                case 'K' :\r\n                    result.append('K');\r\n                    index = (charAt(value, index + 1) == 'K') ? index + 2 : index + 1;\r\n                    break;\r\n                case 'L' :\r\n                    index = handleL(value, result, index);\r\n                    break;\r\n                case 'M' :\r\n                    result.append('M');\r\n                    index = (conditionM0(value, index)) ? index + 2 : index + 1;\r\n                    break;\r\n                case 'N' :\r\n                    result.append('N');\r\n                    index = (charAt(value, index + 1) == 'N') ? index + 2 : index + 1;\r\n                    break;\r\n                case '?' :\r\n                    // N with a tilde (spanish ene)\r\n                    result.append('N');\r\n                    index++;\r\n                    break;\r\n                case 'P' :\r\n                    index = handleP(value, result, index);\r\n                    break;\r\n                case 'Q' :\r\n                    result.append('K');\r\n                    index = (charAt(value, index + 1) == 'Q') ? index + 2 : index + 1;\r\n                    break;\r\n                case 'R' :\r\n                    index = handleR(value, result, index, slavoGermanic);\r\n                    break;\r\n                case 'S' :\r\n                    index = handleS(value, result, index, slavoGermanic);\r\n                    break;\r\n                case 'T' :\r\n                    index = handleT(value, result, index);\r\n                    break;\r\n                case 'V' :\r\n                    result.append('F');\r\n                    index = (charAt(value, index + 1) == 'V') ? index + 2 : index + 1;\r\n                    break;\r\n                case 'W' :\r\n                    index = handleW(value, result, index);\r\n                    break;\r\n                case 'X' :\r\n                    index = handleX(value, result, index);\r\n                    break;\r\n                case 'Z' :\r\n                    index = handleZ(value, result, index, slavoGermanic);\r\n                    break;\r\n                default :\r\n                    index++;\r\n                    break;\r\n            }\r\n        } \r\n        return alternate ? result.getAlternate() : result.getPrimary();\r\n    }\nprotected char charAt(final String value, final int index);\n    private String cleanInput(String input);\n    private boolean conditionM0(final String value, final int index);\n    protected static boolean contains(final String value, final int start, final int length, final String... criteria);\n    public String doubleMetaphone(final String value);\n    @Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String value);\n    public int getMaxCodeLen();\n    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index);\n    private int handleC(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleD(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleG(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic);\n    private int handleH(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleJ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic);\n    private int handleL(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleP(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleR(final String value, final DoubleMetaphoneResult result, final int index, final boolean slavoGermanic);\n    private int handleS(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic);\n    private int handleT(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleW(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleX(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleZ(final String value, final DoubleMetaphoneResult result, int index, final boolean slavoGermanic);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate);\n    private boolean isSilentStart(final String value);\n    private boolean isSlavoGermanic(final String value);\n    public void setMaxCodeLen(final int maxCodeLen);\n}"
      },
      {
        "id": "Metaphone_metaphone",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.Metaphone",
        "test-class": "org.apache.commons.codec.language.Metaphone_metaphone_Test",
        "method-name": "metaphone(String)",
        "source-path": "src/main/java/org/apache/commons/codec/language/Metaphone.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/Metaphone_metaphone_Test.java",
        "focal-method": "public String metaphone(final String txt) {\r\n    boolean hard = false;\r\n    final int txtLength;\r\n    if ((txt == null) || ((txtLength = txt.length()) == 0)) {\r\n        return \"\";\r\n    }\r\n    // single character is itself\r\n    if (txtLength == 1) {\r\n        return txt.toUpperCase(Locale.ENGLISH);\r\n    }\r\n    final char[] inwd = txt.toUpperCase(Locale.ENGLISH).toCharArray();\r\n    final StringBuilder local = new StringBuilder(40);// manipulate\r\n\r\n    final StringBuilder code = new StringBuilder(10);// output\r\n\r\n    // handle initial 2 characters exceptions\r\n    switch (inwd[0]) {\r\n        case 'K' :\r\n        case 'G' :\r\n        case 'P' :\r\n            /* looking for KN, etc */\r\n            if (inwd[1] == 'N') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'A' :\r\n            /* looking for AE */\r\n            if (inwd[1] == 'E') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'W' :\r\n            /* looking for WR or WH */\r\n            if (inwd[1] == 'R') {\r\n                // WR -> R\r\n                local.append(inwd, 1, inwd.length - 1);\r\n                break;\r\n            }\r\n            if (inwd[1] == 'H') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n                local.setCharAt(0, 'W');// WH -> W\r\n\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'X' :\r\n            /* initial X becomes S */\r\n            inwd[0] = 'S';\r\n            local.append(inwd);\r\n            break;\r\n        default :\r\n            local.append(inwd);\r\n    }// now local has working string with initials fixed\r\n\r\n    final int wdsz = local.length();\r\n    int n = 0;\r\n    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {\r\n        // max code size of 4 works well\r\n        final char symb = local.charAt(n);\r\n        // remove duplicate letters except C\r\n        if ((symb != 'C') && isPreviousChar(local, n, symb)) {\r\n            n++;\r\n        }// end else from symb != 'C'\r\n         else {\r\n            // not dup\r\n            switch (symb) {\r\n                case 'A' :\r\n                case 'E' :\r\n                case 'I' :\r\n                case 'O' :\r\n                case 'U' :\r\n                    if (n == 0) {\r\n                        code.append(symb);\r\n                    }\r\n                    break;// only use vowel if leading char\r\n\r\n                case 'B' :\r\n                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {\r\n                        // B is silent if word ends in MB\r\n                        break;\r\n                    }\r\n                    code.append(symb);\r\n                    break;\r\n                case 'C' :\r\n                    // lots of C special cases\r\n                    /* discard if SCI, SCE or SCY */\r\n                    if ((isPreviousChar(local, n, 'S') && (!isLastChar(wdsz, n))) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                        break;\r\n                    }\r\n                    if (regionMatch(local, n, \"CIA\")) {\r\n                        // \"CIA\" -> X\r\n                        code.append('X');\r\n                        break;\r\n                    }\r\n                    if ((!isLastChar(wdsz, n)) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                        code.append('S');\r\n                        break;// CI,CE,CY -> S\r\n\r\n                    }\r\n                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {\r\n                        // SCH->sk\r\n                        code.append('K');\r\n                        break;\r\n                    }\r\n                    if (isNextChar(local, n, 'H')) {\r\n                        // detect CH\r\n                        if (((n == 0) && (wdsz >= 3)) && isVowel(local, 2)) {\r\n                            // CH consonant -> K consonant\r\n                            code.append('K');\r\n                        } else {\r\n                            code.append('X');// CHvowel -> X\r\n\r\n                        }\r\n                    } else {\r\n                        code.append('K');\r\n                    }\r\n                    break;\r\n                case 'D' :\r\n                    if (((!isLastChar(wdsz, n + 1)) && isNextChar(local, n, 'G')) && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {\r\n                        // DGE DGI DGY -> J\r\n                        code.append('J');\r\n                        n += 2;\r\n                    } else {\r\n                        code.append('T');\r\n                    }\r\n                    break;\r\n                case 'G' :\r\n                    // GH silent at end or before consonant\r\n                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {\r\n                        break;\r\n                    }\r\n                    if (((!isLastChar(wdsz, n + 1)) && isNextChar(local, n, 'H')) && (!isVowel(local, n + 2))) {\r\n                        break;\r\n                    }\r\n                    if ((n > 0) && (regionMatch(local, n, \"GN\") || regionMatch(local, n, \"GNED\"))) {\r\n                        break;// silent G\r\n\r\n                    }\r\n                    // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\r\n                    hard = isPreviousChar(local, n, 'G');\r\n                    if (((!isLastChar(wdsz, n)) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) && (!hard)) {\r\n                        code.append('J');\r\n                    } else {\r\n                        code.append('K');\r\n                    }\r\n                    break;\r\n                case 'H' :\r\n                    if (isLastChar(wdsz, n)) {\r\n                        break;// terminal H\r\n\r\n                    }\r\n                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\r\n                        break;\r\n                    }\r\n                    if (isVowel(local, n + 1)) {\r\n                        code.append('H');// Hvowel\r\n\r\n                    }\r\n                    break;\r\n                case 'F' :\r\n                case 'J' :\r\n                case 'L' :\r\n                case 'M' :\r\n                case 'N' :\r\n                case 'R' :\r\n                    code.append(symb);\r\n                    break;\r\n                case 'K' :\r\n                    if (n > 0) {\r\n                        // not initial\r\n                        if (!isPreviousChar(local, n, 'C')) {\r\n                            code.append(symb);\r\n                        }\r\n                    } else {\r\n                        code.append(symb);// initial K\r\n\r\n                    }\r\n                    break;\r\n                case 'P' :\r\n                    if (isNextChar(local, n, 'H')) {\r\n                        // PH -> F\r\n                        code.append('F');\r\n                    } else {\r\n                        code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'Q' :\r\n                    code.append('K');\r\n                    break;\r\n                case 'S' :\r\n                    if ((regionMatch(local, n, \"SH\") || regionMatch(local, n, \"SIO\")) || regionMatch(local, n, \"SIA\")) {\r\n                        code.append('X');\r\n                    } else {\r\n                        code.append('S');\r\n                    }\r\n                    break;\r\n                case 'T' :\r\n                    if (regionMatch(local, n, \"TIA\") || regionMatch(local, n, \"TIO\")) {\r\n                        code.append('X');\r\n                        break;\r\n                    }\r\n                    if (regionMatch(local, n, \"TCH\")) {\r\n                        // Silent if in \"TCH\"\r\n                        break;\r\n                    }\r\n                    // substitute numeral 0 for TH (resembles theta after all)\r\n                    if (regionMatch(local, n, \"TH\")) {\r\n                        code.append('0');\r\n                    } else {\r\n                        code.append('T');\r\n                    }\r\n                    break;\r\n                case 'V' :\r\n                    code.append('F');\r\n                    break;\r\n                case 'W' :\r\n                case 'Y' :\r\n                    // silent if not followed by vowel\r\n                    if ((!isLastChar(wdsz, n)) && isVowel(local, n + 1)) {\r\n                        code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'X' :\r\n                    code.append('K');\r\n                    code.append('S');\r\n                    break;\r\n                case 'Z' :\r\n                    code.append('S');\r\n                    break;\r\n                default :\r\n                    // do nothing\r\n                    break;\r\n            }// end switch\r\n\r\n            n++;\r\n        }// end else from symb != 'C'\r\n\r\n        if (code.length() > this.getMaxCodeLen()) {\r\n            code.setLength(this.getMaxCodeLen());\r\n        }\r\n    } \r\n    return code.toString();\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\npublic class Metaphone implements StringEncoder {\n    private static final String FRONTV = \"EIY\";\n    private static final String VARSON = \"CSPTG\";\n    public String metaphone(final String txt) {\r\n        boolean hard = false;\r\n        final int txtLength;\r\n        if ((txt == null) || ((txtLength = txt.length()) == 0)) {\r\n            return \"\";\r\n        }\r\n        // single character is itself\r\n        if (txtLength == 1) {\r\n            return txt.toUpperCase(Locale.ENGLISH);\r\n        }\r\n        final char[] inwd = txt.toUpperCase(Locale.ENGLISH).toCharArray();\r\n        final StringBuilder local = new StringBuilder(40);// manipulate\r\n    \r\n        final StringBuilder code = new StringBuilder(10);// output\r\n    \r\n        // handle initial 2 characters exceptions\r\n        switch (inwd[0]) {\r\n            case 'K' :\r\n            case 'G' :\r\n            case 'P' :\r\n                /* looking for KN, etc */\r\n                if (inwd[1] == 'N') {\r\n                    local.append(inwd, 1, inwd.length - 1);\r\n                } else {\r\n                    local.append(inwd);\r\n                }\r\n                break;\r\n            case 'A' :\r\n                /* looking for AE */\r\n                if (inwd[1] == 'E') {\r\n                    local.append(inwd, 1, inwd.length - 1);\r\n                } else {\r\n                    local.append(inwd);\r\n                }\r\n                break;\r\n            case 'W' :\r\n                /* looking for WR or WH */\r\n                if (inwd[1] == 'R') {\r\n                    // WR -> R\r\n                    local.append(inwd, 1, inwd.length - 1);\r\n                    break;\r\n                }\r\n                if (inwd[1] == 'H') {\r\n                    local.append(inwd, 1, inwd.length - 1);\r\n                    local.setCharAt(0, 'W');// WH -> W\r\n    \r\n                } else {\r\n                    local.append(inwd);\r\n                }\r\n                break;\r\n            case 'X' :\r\n                /* initial X becomes S */\r\n                inwd[0] = 'S';\r\n                local.append(inwd);\r\n                break;\r\n            default :\r\n                local.append(inwd);\r\n        }// now local has working string with initials fixed\r\n    \r\n        final int wdsz = local.length();\r\n        int n = 0;\r\n        while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {\r\n            // max code size of 4 works well\r\n            final char symb = local.charAt(n);\r\n            // remove duplicate letters except C\r\n            if ((symb != 'C') && isPreviousChar(local, n, symb)) {\r\n                n++;\r\n            }// end else from symb != 'C'\r\n             else {\r\n                // not dup\r\n                switch (symb) {\r\n                    case 'A' :\r\n                    case 'E' :\r\n                    case 'I' :\r\n                    case 'O' :\r\n                    case 'U' :\r\n                        if (n == 0) {\r\n                            code.append(symb);\r\n                        }\r\n                        break;// only use vowel if leading char\r\n    \r\n                    case 'B' :\r\n                        if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {\r\n                            // B is silent if word ends in MB\r\n                            break;\r\n                        }\r\n                        code.append(symb);\r\n                        break;\r\n                    case 'C' :\r\n                        // lots of C special cases\r\n                        /* discard if SCI, SCE or SCY */\r\n                        if ((isPreviousChar(local, n, 'S') && (!isLastChar(wdsz, n))) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                            break;\r\n                        }\r\n                        if (regionMatch(local, n, \"CIA\")) {\r\n                            // \"CIA\" -> X\r\n                            code.append('X');\r\n                            break;\r\n                        }\r\n                        if ((!isLastChar(wdsz, n)) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                            code.append('S');\r\n                            break;// CI,CE,CY -> S\r\n    \r\n                        }\r\n                        if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {\r\n                            // SCH->sk\r\n                            code.append('K');\r\n                            break;\r\n                        }\r\n                        if (isNextChar(local, n, 'H')) {\r\n                            // detect CH\r\n                            if (((n == 0) && (wdsz >= 3)) && isVowel(local, 2)) {\r\n                                // CH consonant -> K consonant\r\n                                code.append('K');\r\n                            } else {\r\n                                code.append('X');// CHvowel -> X\r\n    \r\n                            }\r\n                        } else {\r\n                            code.append('K');\r\n                        }\r\n                        break;\r\n                    case 'D' :\r\n                        if (((!isLastChar(wdsz, n + 1)) && isNextChar(local, n, 'G')) && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {\r\n                            // DGE DGI DGY -> J\r\n                            code.append('J');\r\n                            n += 2;\r\n                        } else {\r\n                            code.append('T');\r\n                        }\r\n                        break;\r\n                    case 'G' :\r\n                        // GH silent at end or before consonant\r\n                        if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {\r\n                            break;\r\n                        }\r\n                        if (((!isLastChar(wdsz, n + 1)) && isNextChar(local, n, 'H')) && (!isVowel(local, n + 2))) {\r\n                            break;\r\n                        }\r\n                        if ((n > 0) && (regionMatch(local, n, \"GN\") || regionMatch(local, n, \"GNED\"))) {\r\n                            break;// silent G\r\n    \r\n                        }\r\n                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\r\n                        hard = isPreviousChar(local, n, 'G');\r\n                        if (((!isLastChar(wdsz, n)) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) && (!hard)) {\r\n                            code.append('J');\r\n                        } else {\r\n                            code.append('K');\r\n                        }\r\n                        break;\r\n                    case 'H' :\r\n                        if (isLastChar(wdsz, n)) {\r\n                            break;// terminal H\r\n    \r\n                        }\r\n                        if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\r\n                            break;\r\n                        }\r\n                        if (isVowel(local, n + 1)) {\r\n                            code.append('H');// Hvowel\r\n    \r\n                        }\r\n                        break;\r\n                    case 'F' :\r\n                    case 'J' :\r\n                    case 'L' :\r\n                    case 'M' :\r\n                    case 'N' :\r\n                    case 'R' :\r\n                        code.append(symb);\r\n                        break;\r\n                    case 'K' :\r\n                        if (n > 0) {\r\n                            // not initial\r\n                            if (!isPreviousChar(local, n, 'C')) {\r\n                                code.append(symb);\r\n                            }\r\n                        } else {\r\n                            code.append(symb);// initial K\r\n    \r\n                        }\r\n                        break;\r\n                    case 'P' :\r\n                        if (isNextChar(local, n, 'H')) {\r\n                            // PH -> F\r\n                            code.append('F');\r\n                        } else {\r\n                            code.append(symb);\r\n                        }\r\n                        break;\r\n                    case 'Q' :\r\n                        code.append('K');\r\n                        break;\r\n                    case 'S' :\r\n                        if ((regionMatch(local, n, \"SH\") || regionMatch(local, n, \"SIO\")) || regionMatch(local, n, \"SIA\")) {\r\n                            code.append('X');\r\n                        } else {\r\n                            code.append('S');\r\n                        }\r\n                        break;\r\n                    case 'T' :\r\n                        if (regionMatch(local, n, \"TIA\") || regionMatch(local, n, \"TIO\")) {\r\n                            code.append('X');\r\n                            break;\r\n                        }\r\n                        if (regionMatch(local, n, \"TCH\")) {\r\n                            // Silent if in \"TCH\"\r\n                            break;\r\n                        }\r\n                        // substitute numeral 0 for TH (resembles theta after all)\r\n                        if (regionMatch(local, n, \"TH\")) {\r\n                            code.append('0');\r\n                        } else {\r\n                            code.append('T');\r\n                        }\r\n                        break;\r\n                    case 'V' :\r\n                        code.append('F');\r\n                        break;\r\n                    case 'W' :\r\n                    case 'Y' :\r\n                        // silent if not followed by vowel\r\n                        if ((!isLastChar(wdsz, n)) && isVowel(local, n + 1)) {\r\n                            code.append(symb);\r\n                        }\r\n                        break;\r\n                    case 'X' :\r\n                        code.append('K');\r\n                        code.append('S');\r\n                        break;\r\n                    case 'Z' :\r\n                        code.append('S');\r\n                        break;\r\n                    default :\r\n                        // do nothing\r\n                        break;\r\n                }// end switch\r\n    \r\n                n++;\r\n            }// end else from symb != 'C'\r\n    \r\n            if (code.length() > this.getMaxCodeLen()) {\r\n                code.setLength(this.getMaxCodeLen());\r\n            }\r\n        } \r\n        return code.toString();\r\n    }\n@Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String str);\n    public int getMaxCodeLen();\n    private boolean isLastChar(final int wdsz, final int n);\n    public boolean isMetaphoneEqual(final String str1, final String str2);\n    private boolean isNextChar(final StringBuilder string, final int index, final char c);\n    private boolean isPreviousChar(final StringBuilder string, final int index, final char c);\n    private boolean isVowel(final StringBuilder string, final int index);\n    private boolean regionMatch(final StringBuilder string, final int index, final String test);\n    public void setMaxCodeLen(final int maxCodeLen);\n}"
      },
      {
        "id": "DoubleMetaphone_handleC",
        "package": "org.apache.commons.codec.language",
        "class": "org.apache.commons.codec.language.DoubleMetaphone",
        "test-class": "org.apache.commons.codec.language.DoubleMetaphone_handleC_Test",
        "method-name": "handleC(String, DoubleMetaphoneResult, int)",
        "source-path": "src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java",
        "test-path": "src/test/java/org/apache/commons/codec/language/DoubleMetaphone_handleC_Test.java",
        "focal-method": "private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\r\n    if (conditionC0(value, index)) {\r\n        // very confusing, moved out\r\n        result.append('K');\r\n        index += 2;\r\n    } else if ((index == 0) && contains(value, index, 6, \"CAESAR\")) {\r\n        result.append('S');\r\n        index += 2;\r\n    } else if (contains(value, index, 2, \"CH\")) {\r\n        index = handleCH(value, result, index);\r\n    } else if (contains(value, index, 2, \"CZ\") && (!contains(value, index - 2, 4, \"WICZ\"))) {\r\n        // -- \"Czerny\" --//\r\n        result.append('S', 'X');\r\n        index += 2;\r\n    } else if (contains(value, index + 1, 3, \"CIA\")) {\r\n        // -- \"focaccia\" --//\r\n        result.append('X');\r\n        index += 3;\r\n    } else if (contains(value, index, 2, \"CC\") && (!((index == 1) && (charAt(value, 0) == 'M')))) {\r\n        // -- double \"cc\" but not \"McClelland\" --//\r\n        return handleCC(value, result, index);\r\n    } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\r\n        result.append('K');\r\n        index += 2;\r\n    } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\r\n        // -- Italian vs. English --//\r\n        if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\r\n            result.append('S', 'X');\r\n        } else {\r\n            result.append('S');\r\n        }\r\n        index += 2;\r\n    } else {\r\n        result.append('K');\r\n        if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) {\r\n            // -- Mac Caffrey, Mac Gregor --//\r\n            index += 3;\r\n        } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") && (!contains(value, index + 1, 2, \"CE\", \"CI\"))) {\r\n            index += 2;\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    return index;\r\n}",
        "class-code": "package org.apache.commons.codec.language;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.StringEncoder;\nimport org.apache.commons.codec.binary.StringUtils;\npublic class DoubleMetaphone implements StringEncoder {\n    \n        /**\r\n     * Inner class for storing results, since there is the optional alternate encoding.\r\n     */\r\n    public class DoubleMetaphoneResult {\r\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\r\n    \r\n        private final int maxLength;\r\n    \r\n        public DoubleMetaphoneResult(final int maxLength) {\r\n            this.maxLength = maxLength;\r\n        }\r\n    \r\n        public void append(final char value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final char primary, final char alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void append(final String value) {\r\n            appendPrimary(value);\r\n            appendAlternate(value);\r\n        }\r\n    \r\n        public void append(final String primary, final String alternate) {\r\n            appendPrimary(primary);\r\n            appendAlternate(alternate);\r\n        }\r\n    \r\n        public void appendAlternate(final char value) {\r\n            if (this.alternate.length() < this.maxLength) {\r\n                this.alternate.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendAlternate(final String value) {\r\n            final int addChars = this.maxLength - this.alternate.length();\r\n            if (value.length() <= addChars) {\r\n                this.alternate.append(value);\r\n            } else {\r\n                this.alternate.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final char value) {\r\n            if (this.primary.length() < this.maxLength) {\r\n                this.primary.append(value);\r\n            }\r\n        }\r\n    \r\n        public void appendPrimary(final String value) {\r\n            final int addChars = this.maxLength - this.primary.length();\r\n            if (value.length() <= addChars) {\r\n                this.primary.append(value);\r\n            } else {\r\n                this.primary.append(value, 0, addChars);\r\n            }\r\n        }\r\n    \r\n        public String getAlternate() {\r\n            return this.alternate.toString();\r\n        }\r\n    \r\n        public String getPrimary() {\r\n            return this.primary.toString();\r\n        }\r\n    \r\n        public boolean isComplete() {\r\n            return (this.primary.length() >= this.maxLength) && (this.alternate.length() >= this.maxLength);\r\n        }\r\n    }\nprivate int handleC(final String value, final DoubleMetaphoneResult result, int index) {\r\n        if (conditionC0(value, index)) {\r\n            // very confusing, moved out\r\n            result.append('K');\r\n            index += 2;\r\n        } else if ((index == 0) && contains(value, index, 6, \"CAESAR\")) {\r\n            result.append('S');\r\n            index += 2;\r\n        } else if (contains(value, index, 2, \"CH\")) {\r\n            index = handleCH(value, result, index);\r\n        } else if (contains(value, index, 2, \"CZ\") && (!contains(value, index - 2, 4, \"WICZ\"))) {\r\n            // -- \"Czerny\" --//\r\n            result.append('S', 'X');\r\n            index += 2;\r\n        } else if (contains(value, index + 1, 3, \"CIA\")) {\r\n            // -- \"focaccia\" --//\r\n            result.append('X');\r\n            index += 3;\r\n        } else if (contains(value, index, 2, \"CC\") && (!((index == 1) && (charAt(value, 0) == 'M')))) {\r\n            // -- double \"cc\" but not \"McClelland\" --//\r\n            return handleCC(value, result, index);\r\n        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\r\n            result.append('K');\r\n            index += 2;\r\n        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\r\n            // -- Italian vs. English --//\r\n            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\r\n                result.append('S', 'X');\r\n            } else {\r\n                result.append('S');\r\n            }\r\n            index += 2;\r\n        } else {\r\n            result.append('K');\r\n            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) {\r\n                // -- Mac Caffrey, Mac Gregor --//\r\n                index += 3;\r\n            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") && (!contains(value, index + 1, 2, \"CE\", \"CI\"))) {\r\n                index += 2;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        return index;\r\n    }\nprotected char charAt(final String value, final int index);\n    private boolean conditionC0(final String value, final int index);\n    protected static boolean contains(final String value, final int start, final int length, final String... criteria);\n    public String doubleMetaphone(final String value);\n    public String doubleMetaphone(String value, final boolean alternate);\n    @Override\r\npublic Object encode(final Object obj) throws EncoderException;\n    @Override\r\npublic String encode(final String value);\n    public int getMaxCodeLen();\n    private int handleCC(final String value, final DoubleMetaphoneResult result, int index);\n    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2);\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate);\n    public void setMaxCodeLen(final int maxCodeLen);\n}"
      },
      {
        "id": "Sha2Crypt_sha2Crypt",
        "package": "org.apache.commons.codec.digest",
        "class": "org.apache.commons.codec.digest.Sha2Crypt",
        "test-class": "org.apache.commons.codec.digest.Sha2Crypt_sha2Crypt_Test",
        "method-name": "sha2Crypt(byte[], String, String, int, String)",
        "source-path": "src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java",
        "test-path": "src/test/java/org/apache/commons/codec/digest/Sha2Crypt_sha2Crypt_Test.java",
        "focal-method": "private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {\r\n    final int keyLen = keyBytes.length;\r\n    // Extracts effective salt and the number of rounds from the given salt.\r\n    int rounds = ROUNDS_DEFAULT;\r\n    boolean roundsCustom = false;\r\n    if (salt == null) {\r\n        throw new IllegalArgumentException(\"Salt must not be null\");\r\n    }\r\n    final Matcher m = SALT_PATTERN.matcher(salt);\r\n    if (!m.find()) {\r\n        throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\r\n    }\r\n    if (m.group(3) != null) {\r\n        rounds = Integer.parseInt(m.group(3));\r\n        rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\r\n        roundsCustom = true;\r\n    }\r\n    final String saltString = m.group(4);\r\n    final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8);\r\n    final int saltLen = saltBytes.length;\r\n    // 1. start digest A\r\n    // Prepare for the real work.\r\n    MessageDigest ctx = DigestUtils.getDigest(algorithm);\r\n    // 2. the password string is added to digest A\r\n    /* Add the key string. */\r\n    ctx.update(keyBytes);\r\n    // 3. the salt string is added to digest A. This is just the salt string\r\n    // itself without the enclosing '$', without the magic salt_prefix $5$ and\r\n    // $6$ respectively and without the rounds=<N> specification.\r\n    // \r\n    // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\r\n    // necessary since it is a constant string and does not add security\r\n    // and /possibly/ allows a plain text attack. Since the rounds=<N>\r\n    // specification should never be added this would also create an\r\n    // inconsistency.\r\n    /* The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character\r\n    (for compatibility with existing implementations).\r\n     */\r\n    ctx.update(saltBytes);\r\n    // 4. start digest B\r\n    /* Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first\r\n    context.\r\n     */\r\n    MessageDigest altCtx = DigestUtils.getDigest(algorithm);\r\n    // 5. add the password to digest B\r\n    /* Add key. */\r\n    altCtx.update(keyBytes);\r\n    // 6. add the salt string to digest B\r\n    /* Add salt. */\r\n    altCtx.update(saltBytes);\r\n    // 7. add the password again to digest B\r\n    /* Add key again. */\r\n    altCtx.update(keyBytes);\r\n    // 8. finish digest B\r\n    /* Now get result of this (32 bytes) and add it to the other context. */\r\n    byte[] altResult = altCtx.digest();\r\n    // 9. For each block of 32 or 64 bytes in the password string (excluding\r\n    // the terminating NUL in the C representation), add digest B to digest A\r\n    /* Add for any character in the key one byte of the alternate sum. */\r\n    /* (Remark: the C code comment seems wrong for key length > 32!) */\r\n    int cnt = keyBytes.length;\r\n    while (cnt > blocksize) {\r\n        ctx.update(altResult, 0, blocksize);\r\n        cnt -= blocksize;\r\n    } \r\n    // 10. For the remaining N bytes of the password string add the first\r\n    // N bytes of digest B to digest A\r\n    ctx.update(altResult, 0, cnt);\r\n    // 11. For each bit of the binary representation of the length of the\r\n    // password string up to and including the highest 1-digit, starting\r\n    // from to the lowest bit position (numeric value 1):\r\n    // \r\n    // a) for a 1-digit add digest B to digest A\r\n    // \r\n    // b) for a 0-digit add the password string\r\n    // \r\n    // NB: this step differs significantly from the MD5 algorithm. It\r\n    // adds more randomness.\r\n    /* Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0\r\n    the key.\r\n     */\r\n    cnt = keyBytes.length;\r\n    while (cnt > 0) {\r\n        if ((cnt & 1) != 0) {\r\n            ctx.update(altResult, 0, blocksize);\r\n        } else {\r\n            ctx.update(keyBytes);\r\n        }\r\n        cnt >>= 1;\r\n    } \r\n    // 12. finish digest A\r\n    /* Create intermediate result. */\r\n    altResult = ctx.digest();\r\n    // 13. start digest DP\r\n    /* Start computation of P byte sequence. */\r\n    altCtx = DigestUtils.getDigest(algorithm);\r\n    // 14. for every byte in the password (excluding the terminating NUL byte\r\n    // in the C representation of the string)\r\n    // \r\n    // add the password to digest DP\r\n    /* For every character in the password add the entire password. */\r\n    for (int i = 1; i <= keyLen; i++) {\r\n        altCtx.update(keyBytes);\r\n    }\r\n    // 15. finish digest DP\r\n    /* Finish the digest. */\r\n    byte[] tempResult = altCtx.digest();\r\n    // 16. produce byte sequence P of the same length as the password where\r\n    // \r\n    // a) for each block of 32 or 64 bytes of length of the password string\r\n    // the entire digest DP is used\r\n    // \r\n    // b) for the remaining N (up to 31 or 63) bytes use the first N\r\n    // bytes of digest DP\r\n    /* Create byte sequence P. */\r\n    final byte[] pBytes = new byte[keyLen];\r\n    int cp = 0;\r\n    while (cp < (keyLen - blocksize)) {\r\n        System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\r\n        cp += blocksize;\r\n    } \r\n    System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\r\n    // 17. start digest DS\r\n    /* Start computation of S byte sequence. */\r\n    altCtx = DigestUtils.getDigest(algorithm);\r\n    // 18. repeat the following 16+A[0] times, where A[0] represents the first\r\n    // byte in digest A interpreted as an 8-bit unsigned value\r\n    // \r\n    // add the salt to digest DS\r\n    /* For every character in the password add the entire password. */\r\n    for (int i = 1; i <= (16 + (altResult[0] & 0xff)); i++) {\r\n        altCtx.update(saltBytes);\r\n    }\r\n    // 19. finish digest DS\r\n    /* Finish the digest. */\r\n    tempResult = altCtx.digest();\r\n    // 20. produce byte sequence S of the same length as the salt string where\r\n    // \r\n    // a) for each block of 32 or 64 bytes of length of the salt string\r\n    // the entire digest DS is used\r\n    // \r\n    // b) for the remaining N (up to 31 or 63) bytes use the first N\r\n    // bytes of digest DS\r\n    /* Create byte sequence S. */\r\n    // Remark: The salt is limited to 16 chars, how does this make sense?\r\n    final byte[] sBytes = new byte[saltLen];\r\n    cp = 0;\r\n    while (cp < (saltLen - blocksize)) {\r\n        System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\r\n        cp += blocksize;\r\n    } \r\n    System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\r\n    // 21. repeat a loop according to the number specified in the rounds=<N>\r\n    // specification in the salt (or the default value if none is\r\n    // present). Each round is numbered, starting with 0 and up to N-1.\r\n    // \r\n    // The loop uses a digest as input. In the first round it is the\r\n    // digest produced in step 12. In the latter steps it is the digest\r\n    // produced in step 21.h. The following text uses the notation\r\n    // \"digest A/C\" to describe this behavior.\r\n    /* Repeatedly run the collected hash value through sha512 to burn CPU cycles. */\r\n    for (int i = 0; i <= (rounds - 1); i++) {\r\n        // a) start digest C\r\n        /* New context. */\r\n        ctx = DigestUtils.getDigest(algorithm);\r\n        // b) for odd round numbers add the byte sequence P to digest C\r\n        // c) for even round numbers add digest A/C\r\n        /* Add key or last result. */\r\n        if ((i & 1) != 0) {\r\n            ctx.update(pBytes, 0, keyLen);\r\n        } else {\r\n            ctx.update(altResult, 0, blocksize);\r\n        }\r\n        // d) for all round numbers not divisible by 3 add the byte sequence S\r\n        /* Add salt for numbers not divisible by 3. */\r\n        if ((i % 3) != 0) {\r\n            ctx.update(sBytes, 0, saltLen);\r\n        }\r\n        // e) for all round numbers not divisible by 7 add the byte sequence P\r\n        /* Add key for numbers not divisible by 7. */\r\n        if ((i % 7) != 0) {\r\n            ctx.update(pBytes, 0, keyLen);\r\n        }\r\n        // f) for odd round numbers add digest A/C\r\n        // g) for even round numbers add the byte sequence P\r\n        /* Add key or last result. */\r\n        if ((i & 1) != 0) {\r\n            ctx.update(altResult, 0, blocksize);\r\n        } else {\r\n            ctx.update(pBytes, 0, keyLen);\r\n        }\r\n        // h) finish digest C.\r\n        /* Create intermediate result. */\r\n        altResult = ctx.digest();\r\n    }\r\n    // 22. Produce the output string. This is an ASCII string of the maximum\r\n    // size specified above, consisting of multiple pieces:\r\n    // \r\n    // a) the salt salt_prefix, $5$ or $6$ respectively\r\n    // \r\n    // b) the rounds=<N> specification, if one was present in the input\r\n    // salt string. A trailing '$' is added in this case to separate\r\n    // the rounds specification from the following text.\r\n    // \r\n    // c) the salt string truncated to 16 characters\r\n    // \r\n    // d) a '$' character\r\n    /* Now we can construct the result string. It consists of three parts. */\r\n    final StringBuilder buffer = new StringBuilder(saltPrefix);\r\n    if (roundsCustom) {\r\n        buffer.append(ROUNDS_PREFIX);\r\n        buffer.append(rounds);\r\n        buffer.append(\"$\");\r\n    }\r\n    buffer.append(saltString);\r\n    buffer.append(\"$\");\r\n    // e) the base-64 encoded final C digest. The encoding used is as\r\n    // follows:\r\n    // [...]\r\n    // \r\n    // Each group of three bytes from the digest produces four\r\n    // characters as output:\r\n    // \r\n    // 1. character: the six low bits of the first byte\r\n    // 2. character: the two high bits of the first byte and the\r\n    // four low bytes from the second byte\r\n    // 3. character: the four high bytes from the second byte and\r\n    // the two low bits from the third byte\r\n    // 4. character: the six high bits from the third byte\r\n    // \r\n    // The groups of three bytes are as follows (in this sequence).\r\n    // These are the indices into the byte array containing the\r\n    // digest, starting with index 0. For the last group there are\r\n    // not enough bytes left in the digest and the value zero is used\r\n    // in its place. This group also produces only three or two\r\n    // characters as output for SHA-512 and SHA-512 respectively.\r\n    // This was just a safeguard in the C implementation:\r\n    // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;\r\n    if (blocksize == 32) {\r\n        B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\r\n        B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\r\n        B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\r\n        B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\r\n        B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\r\n        B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\r\n        B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\r\n        B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\r\n        B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\r\n        B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\r\n        B64.b64from24bit(((byte) (0)), altResult[31], altResult[30], 3, buffer);\r\n    } else {\r\n        B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\r\n        B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\r\n        B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\r\n        B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\r\n        B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\r\n        B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\r\n        B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\r\n        B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\r\n        B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\r\n        B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\r\n        B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\r\n        B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\r\n        B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\r\n        B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\r\n        B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\r\n        B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\r\n        B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\r\n        B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\r\n        B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\r\n        B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\r\n        B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\r\n        B64.b64from24bit(((byte) (0)), ((byte) (0)), altResult[63], 2, buffer);\r\n    }\r\n    /* Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps\r\n    cannot get any information.\r\n     */\r\n    // Is there a better way to do this with the JVM?\r\n    Arrays.fill(tempResult, ((byte) (0)));\r\n    Arrays.fill(pBytes, ((byte) (0)));\r\n    Arrays.fill(sBytes, ((byte) (0)));\r\n    ctx.reset();\r\n    altCtx.reset();\r\n    Arrays.fill(keyBytes, ((byte) (0)));\r\n    Arrays.fill(saltBytes, ((byte) (0)));\r\n    return buffer.toString();\r\n}",
        "class-code": "package org.apache.commons.codec.digest;\nimport java.util.regex.Pattern;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.MessageDigest;\nimport java.util.Arrays;\npublic class Sha2Crypt {\n    private static final int ROUNDS_DEFAULT = 5000;\n    private static final int ROUNDS_MAX = 999999999;\n    private static final int ROUNDS_MIN = 1000;\n    private static final String ROUNDS_PREFIX = \"rounds=\";\n    static final String SHA256_PREFIX = \"$5$\";\n    static final String SHA512_PREFIX = \"$6$\";\n    private static final Pattern SALT_PATTERN = Pattern.compile(\"^\\\\$([56])\\\\$(rounds=(\\\\d+)\\\\$)?([\\\\.\\\\/a-zA-Z0-9]{1,16}).*\");\n    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix, final int blocksize, final String algorithm) {\r\n        final int keyLen = keyBytes.length;\r\n        // Extracts effective salt and the number of rounds from the given salt.\r\n        int rounds = ROUNDS_DEFAULT;\r\n        boolean roundsCustom = false;\r\n        if (salt == null) {\r\n            throw new IllegalArgumentException(\"Salt must not be null\");\r\n        }\r\n        final Matcher m = SALT_PATTERN.matcher(salt);\r\n        if (!m.find()) {\r\n            throw new IllegalArgumentException(\"Invalid salt value: \" + salt);\r\n        }\r\n        if (m.group(3) != null) {\r\n            rounds = Integer.parseInt(m.group(3));\r\n            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\r\n            roundsCustom = true;\r\n        }\r\n        final String saltString = m.group(4);\r\n        final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8);\r\n        final int saltLen = saltBytes.length;\r\n        // 1. start digest A\r\n        // Prepare for the real work.\r\n        MessageDigest ctx = DigestUtils.getDigest(algorithm);\r\n        // 2. the password string is added to digest A\r\n        /* Add the key string. */\r\n        ctx.update(keyBytes);\r\n        // 3. the salt string is added to digest A. This is just the salt string\r\n        // itself without the enclosing '$', without the magic salt_prefix $5$ and\r\n        // $6$ respectively and without the rounds=<N> specification.\r\n        // \r\n        // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\r\n        // necessary since it is a constant string and does not add security\r\n        // and /possibly/ allows a plain text attack. Since the rounds=<N>\r\n        // specification should never be added this would also create an\r\n        // inconsistency.\r\n        /* The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character\r\n        (for compatibility with existing implementations).\r\n         */\r\n        ctx.update(saltBytes);\r\n        // 4. start digest B\r\n        /* Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first\r\n        context.\r\n         */\r\n        MessageDigest altCtx = DigestUtils.getDigest(algorithm);\r\n        // 5. add the password to digest B\r\n        /* Add key. */\r\n        altCtx.update(keyBytes);\r\n        // 6. add the salt string to digest B\r\n        /* Add salt. */\r\n        altCtx.update(saltBytes);\r\n        // 7. add the password again to digest B\r\n        /* Add key again. */\r\n        altCtx.update(keyBytes);\r\n        // 8. finish digest B\r\n        /* Now get result of this (32 bytes) and add it to the other context. */\r\n        byte[] altResult = altCtx.digest();\r\n        // 9. For each block of 32 or 64 bytes in the password string (excluding\r\n        // the terminating NUL in the C representation), add digest B to digest A\r\n        /* Add for any character in the key one byte of the alternate sum. */\r\n        /* (Remark: the C code comment seems wrong for key length > 32!) */\r\n        int cnt = keyBytes.length;\r\n        while (cnt > blocksize) {\r\n            ctx.update(altResult, 0, blocksize);\r\n            cnt -= blocksize;\r\n        } \r\n        // 10. For the remaining N bytes of the password string add the first\r\n        // N bytes of digest B to digest A\r\n        ctx.update(altResult, 0, cnt);\r\n        // 11. For each bit of the binary representation of the length of the\r\n        // password string up to and including the highest 1-digit, starting\r\n        // from to the lowest bit position (numeric value 1):\r\n        // \r\n        // a) for a 1-digit add digest B to digest A\r\n        // \r\n        // b) for a 0-digit add the password string\r\n        // \r\n        // NB: this step differs significantly from the MD5 algorithm. It\r\n        // adds more randomness.\r\n        /* Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0\r\n        the key.\r\n         */\r\n        cnt = keyBytes.length;\r\n        while (cnt > 0) {\r\n            if ((cnt & 1) != 0) {\r\n                ctx.update(altResult, 0, blocksize);\r\n            } else {\r\n                ctx.update(keyBytes);\r\n            }\r\n            cnt >>= 1;\r\n        } \r\n        // 12. finish digest A\r\n        /* Create intermediate result. */\r\n        altResult = ctx.digest();\r\n        // 13. start digest DP\r\n        /* Start computation of P byte sequence. */\r\n        altCtx = DigestUtils.getDigest(algorithm);\r\n        // 14. for every byte in the password (excluding the terminating NUL byte\r\n        // in the C representation of the string)\r\n        // \r\n        // add the password to digest DP\r\n        /* For every character in the password add the entire password. */\r\n        for (int i = 1; i <= keyLen; i++) {\r\n            altCtx.update(keyBytes);\r\n        }\r\n        // 15. finish digest DP\r\n        /* Finish the digest. */\r\n        byte[] tempResult = altCtx.digest();\r\n        // 16. produce byte sequence P of the same length as the password where\r\n        // \r\n        // a) for each block of 32 or 64 bytes of length of the password string\r\n        // the entire digest DP is used\r\n        // \r\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\r\n        // bytes of digest DP\r\n        /* Create byte sequence P. */\r\n        final byte[] pBytes = new byte[keyLen];\r\n        int cp = 0;\r\n        while (cp < (keyLen - blocksize)) {\r\n            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\r\n            cp += blocksize;\r\n        } \r\n        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\r\n        // 17. start digest DS\r\n        /* Start computation of S byte sequence. */\r\n        altCtx = DigestUtils.getDigest(algorithm);\r\n        // 18. repeat the following 16+A[0] times, where A[0] represents the first\r\n        // byte in digest A interpreted as an 8-bit unsigned value\r\n        // \r\n        // add the salt to digest DS\r\n        /* For every character in the password add the entire password. */\r\n        for (int i = 1; i <= (16 + (altResult[0] & 0xff)); i++) {\r\n            altCtx.update(saltBytes);\r\n        }\r\n        // 19. finish digest DS\r\n        /* Finish the digest. */\r\n        tempResult = altCtx.digest();\r\n        // 20. produce byte sequence S of the same length as the salt string where\r\n        // \r\n        // a) for each block of 32 or 64 bytes of length of the salt string\r\n        // the entire digest DS is used\r\n        // \r\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\r\n        // bytes of digest DS\r\n        /* Create byte sequence S. */\r\n        // Remark: The salt is limited to 16 chars, how does this make sense?\r\n        final byte[] sBytes = new byte[saltLen];\r\n        cp = 0;\r\n        while (cp < (saltLen - blocksize)) {\r\n            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\r\n            cp += blocksize;\r\n        } \r\n        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\r\n        // 21. repeat a loop according to the number specified in the rounds=<N>\r\n        // specification in the salt (or the default value if none is\r\n        // present). Each round is numbered, starting with 0 and up to N-1.\r\n        // \r\n        // The loop uses a digest as input. In the first round it is the\r\n        // digest produced in step 12. In the latter steps it is the digest\r\n        // produced in step 21.h. The following text uses the notation\r\n        // \"digest A/C\" to describe this behavior.\r\n        /* Repeatedly run the collected hash value through sha512 to burn CPU cycles. */\r\n        for (int i = 0; i <= (rounds - 1); i++) {\r\n            // a) start digest C\r\n            /* New context. */\r\n            ctx = DigestUtils.getDigest(algorithm);\r\n            // b) for odd round numbers add the byte sequence P to digest C\r\n            // c) for even round numbers add digest A/C\r\n            /* Add key or last result. */\r\n            if ((i & 1) != 0) {\r\n                ctx.update(pBytes, 0, keyLen);\r\n            } else {\r\n                ctx.update(altResult, 0, blocksize);\r\n            }\r\n            // d) for all round numbers not divisible by 3 add the byte sequence S\r\n            /* Add salt for numbers not divisible by 3. */\r\n            if ((i % 3) != 0) {\r\n                ctx.update(sBytes, 0, saltLen);\r\n            }\r\n            // e) for all round numbers not divisible by 7 add the byte sequence P\r\n            /* Add key for numbers not divisible by 7. */\r\n            if ((i % 7) != 0) {\r\n                ctx.update(pBytes, 0, keyLen);\r\n            }\r\n            // f) for odd round numbers add digest A/C\r\n            // g) for even round numbers add the byte sequence P\r\n            /* Add key or last result. */\r\n            if ((i & 1) != 0) {\r\n                ctx.update(altResult, 0, blocksize);\r\n            } else {\r\n                ctx.update(pBytes, 0, keyLen);\r\n            }\r\n            // h) finish digest C.\r\n            /* Create intermediate result. */\r\n            altResult = ctx.digest();\r\n        }\r\n        // 22. Produce the output string. This is an ASCII string of the maximum\r\n        // size specified above, consisting of multiple pieces:\r\n        // \r\n        // a) the salt salt_prefix, $5$ or $6$ respectively\r\n        // \r\n        // b) the rounds=<N> specification, if one was present in the input\r\n        // salt string. A trailing '$' is added in this case to separate\r\n        // the rounds specification from the following text.\r\n        // \r\n        // c) the salt string truncated to 16 characters\r\n        // \r\n        // d) a '$' character\r\n        /* Now we can construct the result string. It consists of three parts. */\r\n        final StringBuilder buffer = new StringBuilder(saltPrefix);\r\n        if (roundsCustom) {\r\n            buffer.append(ROUNDS_PREFIX);\r\n            buffer.append(rounds);\r\n            buffer.append(\"$\");\r\n        }\r\n        buffer.append(saltString);\r\n        buffer.append(\"$\");\r\n        // e) the base-64 encoded final C digest. The encoding used is as\r\n        // follows:\r\n        // [...]\r\n        // \r\n        // Each group of three bytes from the digest produces four\r\n        // characters as output:\r\n        // \r\n        // 1. character: the six low bits of the first byte\r\n        // 2. character: the two high bits of the first byte and the\r\n        // four low bytes from the second byte\r\n        // 3. character: the four high bytes from the second byte and\r\n        // the two low bits from the third byte\r\n        // 4. character: the six high bits from the third byte\r\n        // \r\n        // The groups of three bytes are as follows (in this sequence).\r\n        // These are the indices into the byte array containing the\r\n        // digest, starting with index 0. For the last group there are\r\n        // not enough bytes left in the digest and the value zero is used\r\n        // in its place. This group also produces only three or two\r\n        // characters as output for SHA-512 and SHA-512 respectively.\r\n        // This was just a safeguard in the C implementation:\r\n        // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;\r\n        if (blocksize == 32) {\r\n            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\r\n            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\r\n            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\r\n            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\r\n            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\r\n            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\r\n            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\r\n            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\r\n            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\r\n            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\r\n            B64.b64from24bit(((byte) (0)), altResult[31], altResult[30], 3, buffer);\r\n        } else {\r\n            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\r\n            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\r\n            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\r\n            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\r\n            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\r\n            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\r\n            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\r\n            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\r\n            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\r\n            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\r\n            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\r\n            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\r\n            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\r\n            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\r\n            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\r\n            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\r\n            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\r\n            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\r\n            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\r\n            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\r\n            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\r\n            B64.b64from24bit(((byte) (0)), ((byte) (0)), altResult[63], 2, buffer);\r\n        }\r\n        /* Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps\r\n        cannot get any information.\r\n         */\r\n        // Is there a better way to do this with the JVM?\r\n        Arrays.fill(tempResult, ((byte) (0)));\r\n        Arrays.fill(pBytes, ((byte) (0)));\r\n        Arrays.fill(sBytes, ((byte) (0)));\r\n        ctx.reset();\r\n        altCtx.reset();\r\n        Arrays.fill(keyBytes, ((byte) (0)));\r\n        Arrays.fill(saltBytes, ((byte) (0)));\r\n        return buffer.toString();\r\n    }\npublic static String sha256Crypt(final byte[] keyBytes);\n    public static String sha256Crypt(final byte[] keyBytes, String salt);\n    public static String sha256Crypt(final byte[] keyBytes, String salt, final Random random);\n    public static String sha512Crypt(final byte[] keyBytes);\n    public static String sha512Crypt(final byte[] keyBytes, String salt);\n    public static String sha512Crypt(final byte[] keyBytes, String salt, final Random random);\n}"
      }
    ]
  },
  "commons-collections": {
    "project-name": "commons-collections",
    "project-url": "commons-collections",
    "focal-methods": [
      {
        "id": "Flat3Map_get",
        "package": "org.apache.commons.collections4.map",
        "class": "org.apache.commons.collections4.map.Flat3Map",
        "test-class": "org.apache.commons.collections4.map.Flat3Map_get_Test",
        "method-name": "get(Object)",
        "source-path": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java",
        "test-path": "src/test/java/org/apache/commons/collections4/map/Flat3Map_get_Test.java",
        "focal-method": "@Override\r\npublic V get(final Object key) {\r\n    if (delegateMap != null) {\r\n        return delegateMap.get(key);\r\n    }\r\n    if (key == null) {\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if (key3 == null) {\r\n                    return value3;\r\n                }\r\n            case 2 :\r\n                if (key2 == null) {\r\n                    return value2;\r\n                }\r\n            case 1 :\r\n                if (key1 == null) {\r\n                    return value1;\r\n                }\r\n        }\r\n    } else if (size > 0) {\r\n        final int hashCode = key.hashCode();\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if ((hash3 == hashCode) && key.equals(key3)) {\r\n                    return value3;\r\n                }\r\n            case 2 :\r\n                if ((hash2 == hashCode) && key.equals(key2)) {\r\n                    return value2;\r\n                }\r\n            case 1 :\r\n                if ((hash1 == hashCode) && key.equals(key1)) {\r\n                    return value1;\r\n                }\r\n        }\r\n    }\r\n    return null;\r\n}",
        "class-code": "package org.apache.commons.collections4.map;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport java.util.Set;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport org.apache.commons.collections4.ResettableIterator;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapIterator;\nimport org.apache.commons.collections4.IterableMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\npublic class Flat3Map<K, V> implements IterableMap<K, V> , Serializable , Cloneable {\n    private transient int size;\n    private transient int hash1;\n    private transient int hash2;\n    private transient int hash3;\n    private transient K key1;\n    private transient K key2;\n    private transient K key3;\n    private transient V value1;\n    private transient V value2;\n    private transient V value3;\n    private transient AbstractHashedMap<K, V> delegateMap;\n    @Override\r\n    public V get(final Object key) {\r\n        if (delegateMap != null) {\r\n            return delegateMap.get(key);\r\n        }\r\n        if (key == null) {\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if (key3 == null) {\r\n                        return value3;\r\n                    }\r\n                case 2 :\r\n                    if (key2 == null) {\r\n                        return value2;\r\n                    }\r\n                case 1 :\r\n                    if (key1 == null) {\r\n                        return value1;\r\n                    }\r\n            }\r\n        } else if (size > 0) {\r\n            final int hashCode = key.hashCode();\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if ((hash3 == hashCode) && key.equals(key3)) {\r\n                        return value3;\r\n                    }\r\n                case 2 :\r\n                    if ((hash2 == hashCode) && key.equals(key2)) {\r\n                        return value2;\r\n                    }\r\n                case 1 :\r\n                    if ((hash1 == hashCode) && key.equals(key1)) {\r\n                        return value1;\r\n                    }\r\n            }\r\n        }\r\n        return null;\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Flat3Map<K, V> clone();\n    @Override\r\npublic boolean containsKey(final Object key);\n    @Override\r\npublic boolean containsValue(final Object value);\n    protected AbstractHashedMap<K, V> createDelegateMap();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic boolean equals(final Object obj);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic MapIterator<K, V> mapIterator();\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic V remove(final Object key);\n    @Override\r\npublic int size();\n    @Override\r\npublic String toString();\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "IteratorUtils_getIterator",
        "package": "org.apache.commons.collections4",
        "class": "org.apache.commons.collections4.IteratorUtils",
        "test-class": "org.apache.commons.collections4.IteratorUtils_getIterator_Test",
        "method-name": "getIterator(Object)",
        "source-path": "src/main/java/org/apache/commons/collections4/IteratorUtils.java",
        "test-path": "src/test/java/org/apache/commons/collections4/IteratorUtils_getIterator_Test.java",
        "focal-method": "public static Iterator<?> getIterator(final Object obj) {\r\n    if (obj == null) {\r\n        return emptyIterator();\r\n    }\r\n    if (obj instanceof Iterator) {\r\n        return ((Iterator<?>) (obj));\r\n    }\r\n    if (obj instanceof Iterable) {\r\n        return ((Iterable<?>) (obj)).iterator();\r\n    }\r\n    if (obj instanceof Object[]) {\r\n        return new ObjectArrayIterator<>(((Object[]) (obj)));\r\n    }\r\n    if (obj instanceof Enumeration) {\r\n        return new EnumerationIterator<>(((Enumeration<?>) (obj)));\r\n    }\r\n    if (obj instanceof Map) {\r\n        return ((Map<?, ?>) (obj)).values().iterator();\r\n    }\r\n    if (obj instanceof NodeList) {\r\n        return new NodeListIterator(((NodeList) (obj)));\r\n    }\r\n    if (obj instanceof Node) {\r\n        return new NodeListIterator(((Node) (obj)));\r\n    }\r\n    if (obj instanceof Dictionary) {\r\n        return new EnumerationIterator<>(((Dictionary<?, ?>) (obj)).elements());\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        return new ArrayIterator<>(obj);\r\n    }\r\n    try {\r\n        final Method method = obj.getClass().getMethod(\"iterator\", ((Class[]) (null)));\r\n        if (Iterator.class.isAssignableFrom(method.getReturnType())) {\r\n            final Iterator<?> it = ((Iterator<?>) (method.invoke(obj, ((Object[]) (null)))));\r\n            if (it != null) {\r\n                return it;\r\n            }\r\n        }\r\n    } catch (RuntimeException | ReflectiveOperationException ignore) {\r\n        // NOPMD\r\n        // ignore\r\n    }\r\n    return singletonIterator(obj);\r\n}",
        "class-code": "package org.apache.commons.collections4;\nimport java.util.Dictionary;\nimport org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\nimport org.apache.commons.collections4.iterators.EnumerationIterator;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport org.apache.commons.collections4.iterators.SingletonIterator;\nimport org.apache.commons.collections4.iterators.EmptyOrderedIterator;\nimport org.w3c.dom.Node;\nimport java.util.ArrayList;\nimport org.apache.commons.collections4.iterators.TransformIterator;\nimport org.apache.commons.collections4.iterators.PushbackIterator;\nimport org.apache.commons.collections4.iterators.EmptyListIterator;\nimport org.apache.commons.collections4.iterators.ListIteratorWrapper;\nimport java.util.Comparator;\nimport org.apache.commons.collections4.functors.EqualPredicate;\nimport org.apache.commons.collections4.iterators.ObjectArrayListIterator;\nimport org.apache.commons.collections4.iterators.IteratorIterable;\nimport org.apache.commons.collections4.iterators.BoundedIterator;\nimport org.apache.commons.collections4.iterators.FilterIterator;\nimport java.util.Iterator;\nimport org.apache.commons.collections4.iterators.LoopingListIterator;\nimport java.util.List;\nimport org.apache.commons.collections4.iterators.SkippingIterator;\nimport org.apache.commons.collections4.iterators.SingletonListIterator;\nimport org.apache.commons.collections4.iterators.ZippingIterator;\nimport org.apache.commons.collections4.iterators.ArrayListIterator;\nimport org.apache.commons.collections4.iterators.FilterListIterator;\nimport org.apache.commons.collections4.iterators.IteratorEnumeration;\nimport org.apache.commons.collections4.iterators.NodeListIterator;\nimport org.w3c.dom.NodeList;\nimport org.apache.commons.collections4.iterators.CollatingIterator;\nimport java.lang.reflect.Method;\nimport org.apache.commons.collections4.iterators.PeekingIterator;\nimport org.apache.commons.collections4.iterators.IteratorChain;\nimport org.apache.commons.collections4.iterators.ObjectArrayIterator;\nimport java.util.Enumeration;\nimport java.util.ListIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableListIterator;\nimport org.apache.commons.collections4.iterators.ArrayIterator;\nimport java.lang.reflect.Array;\nimport org.apache.commons.collections4.iterators.UnmodifiableIterator;\nimport java.util.Collection;\nimport java.util.Objects;\nimport org.apache.commons.collections4.iterators.ObjectGraphIterator;\nimport java.util.Map;\nimport org.apache.commons.collections4.iterators.LoopingIterator;\npublic class IteratorUtils {\n    @SuppressWarnings(\"rawtypes\")\r\npublic static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n    @SuppressWarnings(\"rawtypes\")\r\npublic static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n    @SuppressWarnings(\"rawtypes\")\r\npublic static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n    @SuppressWarnings(\"rawtypes\")\r\npublic static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n    @SuppressWarnings(\"rawtypes\")\r\npublic static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n    public static Iterator<?> getIterator(final Object obj) {\r\n        if (obj == null) {\r\n            return emptyIterator();\r\n        }\r\n        if (obj instanceof Iterator) {\r\n            return ((Iterator<?>) (obj));\r\n        }\r\n        if (obj instanceof Iterable) {\r\n            return ((Iterable<?>) (obj)).iterator();\r\n        }\r\n        if (obj instanceof Object[]) {\r\n            return new ObjectArrayIterator<>(((Object[]) (obj)));\r\n        }\r\n        if (obj instanceof Enumeration) {\r\n            return new EnumerationIterator<>(((Enumeration<?>) (obj)));\r\n        }\r\n        if (obj instanceof Map) {\r\n            return ((Map<?, ?>) (obj)).values().iterator();\r\n        }\r\n        if (obj instanceof NodeList) {\r\n            return new NodeListIterator(((NodeList) (obj)));\r\n        }\r\n        if (obj instanceof Node) {\r\n            return new NodeListIterator(((Node) (obj)));\r\n        }\r\n        if (obj instanceof Dictionary) {\r\n            return new EnumerationIterator<>(((Dictionary<?, ?>) (obj)).elements());\r\n        }\r\n        if (obj.getClass().isArray()) {\r\n            return new ArrayIterator<>(obj);\r\n        }\r\n        try {\r\n            final Method method = obj.getClass().getMethod(\"iterator\", ((Class[]) (null)));\r\n            if (Iterator.class.isAssignableFrom(method.getReturnType())) {\r\n                final Iterator<?> it = ((Iterator<?>) (method.invoke(obj, ((Object[]) (null)))));\r\n                if (it != null) {\r\n                    return it;\r\n                }\r\n            }\r\n        } catch (RuntimeException | ReflectiveOperationException ignore) {\r\n            // NOPMD\r\n            // ignore\r\n        }\r\n        return singletonIterator(obj);\r\n    }\npublic static <E> ResettableIterator<E> arrayIterator(final Object array);\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start);\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end);\n    public static <E> ResettableIterator<E> arrayIterator(final E... array);\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start);\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end);\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array);\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start);\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end);\n    public static <E> ResettableListIterator<E> arrayListIterator(final E... array);\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start);\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end);\n    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator);\n    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator);\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration);\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection);\n    public static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator);\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, final long max);\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, final long offset, final long max);\n    public static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators);\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2);\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators);\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators);\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2);\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators);\n    public static <E> boolean contains(final Iterator<E> iterator, final Object object);\n    public static <E> ResettableIterator<E> emptyIterator();\n    public static <E> ResettableListIterator<E> emptyListIterator();\n    public static <K, V> MapIterator<K, V> emptyMapIterator();\n    public static <E> OrderedIterator<E> emptyOrderedIterator();\n    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator();\n    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate);\n    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate);\n    public static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate);\n    public static <E> E first(final Iterator<E> iterator);\n    public static <E> void forEach(final Iterator<E> iterator, final Closure<? super E> closure);\n    public static <E> E forEachButLast(final Iterator<E> iterator, final Closure<? super E> closure);\n    public static <E> E get(final Iterator<E> iterator, final int index);\n    public static <E> int indexOf(final Iterator<E> iterator, final Predicate<? super E> predicate);\n    public static boolean isEmpty(final Iterator<?> iterator);\n    public static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> collection);\n    public static <E> ResettableListIterator<E> loopingListIterator(final List<E> list);\n    public static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate);\n    public static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate);\n    public static NodeListIterator nodeListIterator(final Node node);\n    public static NodeListIterator nodeListIterator(final NodeList nodeList);\n    public static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer);\n    public static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator);\n    public static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator);\n    public static <E> ResettableIterator<E> singletonIterator(final E object);\n    public static <E> ListIterator<E> singletonListIterator(final E object);\n    public static int size(final Iterator<?> iterator);\n    public static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, final long offset);\n    public static Object[] toArray(final Iterator<?> iterator);\n    public static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass);\n    public static <E> List<E> toList(final Iterator<? extends E> iterator);\n    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize);\n    public static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator);\n    public static <E> String toString(final Iterator<E> iterator);\n    public static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer);\n    public static <E> String toString(final Iterator<E> iterator, final Transformer<? super E, String> transformer, final String delimiter, final String prefix, final String suffix);\n    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transformer);\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator);\n    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator);\n    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator);\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b);\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b, final Iterator<? extends E> c);\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators);\n}"
      },
      {
        "id": "SequencesComparator_getMiddleSnake",
        "package": "org.apache.commons.collections4.sequence",
        "class": "org.apache.commons.collections4.sequence.SequencesComparator",
        "test-class": "org.apache.commons.collections4.sequence.SequencesComparator_getMiddleSnake_Test",
        "method-name": "getMiddleSnake(int, int, int, int)",
        "source-path": "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java",
        "test-path": "src/test/java/org/apache/commons/collections4/sequence/SequencesComparator_getMiddleSnake_Test.java",
        "focal-method": "private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\r\n    // Myers Algorithm\r\n    // Initialisations\r\n    final int m = end1 - start1;\r\n    final int n = end2 - start2;\r\n    if ((m == 0) || (n == 0)) {\r\n        return null;\r\n    }\r\n    final int delta = m - n;\r\n    final int sum = n + m;\r\n    final int offset = ((sum % 2) == 0 ? sum : sum + 1) / 2;\r\n    vDown[1 + offset] = start1;\r\n    vUp[1 + offset] = end1 + 1;\r\n    for (int d = 0; d <= offset; ++d) {\r\n        // Down\r\n        for (int k = -d; k <= d; k += 2) {\r\n            // First step\r\n            final int i = k + offset;\r\n            if ((k == (-d)) || ((k != d) && (vDown[i - 1] < vDown[i + 1]))) {\r\n                vDown[i] = vDown[i + 1];\r\n            } else {\r\n                vDown[i] = vDown[i - 1] + 1;\r\n            }\r\n            int x = vDown[i];\r\n            int y = ((x - start1) + start2) - k;\r\n            while (((x < end1) && (y < end2)) && equator.equate(sequence1.get(x), sequence2.get(y))) {\r\n                vDown[i] = ++x;\r\n                ++y;\r\n            } \r\n            // Second step\r\n            if (((((delta % 2) != 0) && ((delta - d) <= k)) && (k <= (delta + d))) && (vUp[i - delta] <= vDown[i])) {\r\n                // NOPMD\r\n                return buildSnake(vUp[i - delta], (k + start1) - start2, end1, end2);\r\n            }\r\n        }\r\n        // Up\r\n        for (int k = delta - d; k <= (delta + d); k += 2) {\r\n            // First step\r\n            final int i = (k + offset) - delta;\r\n            if ((k == (delta - d)) || ((k != (delta + d)) && (vUp[i + 1] <= vUp[i - 1]))) {\r\n                vUp[i] = vUp[i + 1] - 1;\r\n            } else {\r\n                vUp[i] = vUp[i - 1];\r\n            }\r\n            int x = vUp[i] - 1;\r\n            int y = ((x - start1) + start2) - k;\r\n            while (((x >= start1) && (y >= start2)) && equator.equate(sequence1.get(x), sequence2.get(y))) {\r\n                vUp[i] = x--;\r\n                y--;\r\n            } \r\n            // Second step\r\n            if (((((delta % 2) == 0) && ((-d) <= k)) && (k <= d)) && (vUp[i] <= vDown[i + delta])) {\r\n                // NOPMD\r\n                return buildSnake(vUp[i], (k + start1) - start2, end1, end2);\r\n            }\r\n        }\r\n    }\r\n    // this should not happen\r\n    throw new IllegalStateException(\"Internal Error\");\r\n}",
        "class-code": "package org.apache.commons.collections4.sequence;\nimport org.apache.commons.collections4.Equator;\nimport java.util.List;\nimport org.apache.commons.collections4.functors.DefaultEquator;\npublic class SequencesComparator<T> {\n    private final List<T> sequence1;\n    private final List<T> sequence2;\n    private final Equator<? super T> equator;\n    private final int[] vDown;\n    private final int[] vUp;\n    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\r\n        // Myers Algorithm\r\n        // Initialisations\r\n        final int m = end1 - start1;\r\n        final int n = end2 - start2;\r\n        if ((m == 0) || (n == 0)) {\r\n            return null;\r\n        }\r\n        final int delta = m - n;\r\n        final int sum = n + m;\r\n        final int offset = ((sum % 2) == 0 ? sum : sum + 1) / 2;\r\n        vDown[1 + offset] = start1;\r\n        vUp[1 + offset] = end1 + 1;\r\n        for (int d = 0; d <= offset; ++d) {\r\n            // Down\r\n            for (int k = -d; k <= d; k += 2) {\r\n                // First step\r\n                final int i = k + offset;\r\n                if ((k == (-d)) || ((k != d) && (vDown[i - 1] < vDown[i + 1]))) {\r\n                    vDown[i] = vDown[i + 1];\r\n                } else {\r\n                    vDown[i] = vDown[i - 1] + 1;\r\n                }\r\n                int x = vDown[i];\r\n                int y = ((x - start1) + start2) - k;\r\n                while (((x < end1) && (y < end2)) && equator.equate(sequence1.get(x), sequence2.get(y))) {\r\n                    vDown[i] = ++x;\r\n                    ++y;\r\n                } \r\n                // Second step\r\n                if (((((delta % 2) != 0) && ((delta - d) <= k)) && (k <= (delta + d))) && (vUp[i - delta] <= vDown[i])) {\r\n                    // NOPMD\r\n                    return buildSnake(vUp[i - delta], (k + start1) - start2, end1, end2);\r\n                }\r\n            }\r\n            // Up\r\n            for (int k = delta - d; k <= (delta + d); k += 2) {\r\n                // First step\r\n                final int i = (k + offset) - delta;\r\n                if ((k == (delta - d)) || ((k != (delta + d)) && (vUp[i + 1] <= vUp[i - 1]))) {\r\n                    vUp[i] = vUp[i + 1] - 1;\r\n                } else {\r\n                    vUp[i] = vUp[i - 1];\r\n                }\r\n                int x = vUp[i] - 1;\r\n                int y = ((x - start1) + start2) - k;\r\n                while (((x >= start1) && (y >= start2)) && equator.equate(sequence1.get(x), sequence2.get(y))) {\r\n                    vUp[i] = x--;\r\n                    y--;\r\n                } \r\n                // Second step\r\n                if (((((delta % 2) == 0) && ((-d) <= k)) && (k <= d)) && (vUp[i] <= vDown[i + delta])) {\r\n                    // NOPMD\r\n                    return buildSnake(vUp[i], (k + start1) - start2, end1, end2);\r\n                }\r\n            }\r\n        }\r\n        // this should not happen\r\n        throw new IllegalStateException(\"Internal Error\");\r\n    }\nprivate Snake buildSnake(final int start, final int diag, final int end1, final int end2);\n    public EditScript<T> getScript();\n}"
      },
      {
        "id": "Flat3Map_containsKey",
        "package": "org.apache.commons.collections4.map",
        "class": "org.apache.commons.collections4.map.Flat3Map",
        "test-class": "org.apache.commons.collections4.map.Flat3Map_containsKey_Test",
        "method-name": "containsKey(Object)",
        "source-path": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java",
        "test-path": "src/test/java/org/apache/commons/collections4/map/Flat3Map_containsKey_Test.java",
        "focal-method": "@Override\r\npublic boolean containsKey(final Object key) {\r\n    if (delegateMap != null) {\r\n        return delegateMap.containsKey(key);\r\n    }\r\n    if (key == null) {\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if (key3 == null) {\r\n                    return true;\r\n                }\r\n            case 2 :\r\n                if (key2 == null) {\r\n                    return true;\r\n                }\r\n            case 1 :\r\n                if (key1 == null) {\r\n                    return true;\r\n                }\r\n        }\r\n    } else if (size > 0) {\r\n        final int hashCode = key.hashCode();\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if ((hash3 == hashCode) && key.equals(key3)) {\r\n                    return true;\r\n                }\r\n            case 2 :\r\n                if ((hash2 == hashCode) && key.equals(key2)) {\r\n                    return true;\r\n                }\r\n            case 1 :\r\n                if ((hash1 == hashCode) && key.equals(key1)) {\r\n                    return true;\r\n                }\r\n        }\r\n    }\r\n    return false;\r\n}",
        "class-code": "package org.apache.commons.collections4.map;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport java.util.Set;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport org.apache.commons.collections4.ResettableIterator;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapIterator;\nimport org.apache.commons.collections4.IterableMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\npublic class Flat3Map<K, V> implements IterableMap<K, V> , Serializable , Cloneable {\n    private transient int size;\n    private transient int hash1;\n    private transient int hash2;\n    private transient int hash3;\n    private transient K key1;\n    private transient K key2;\n    private transient K key3;\n    private transient AbstractHashedMap<K, V> delegateMap;\n    @Override\r\n    public boolean containsKey(final Object key) {\r\n        if (delegateMap != null) {\r\n            return delegateMap.containsKey(key);\r\n        }\r\n        if (key == null) {\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if (key3 == null) {\r\n                        return true;\r\n                    }\r\n                case 2 :\r\n                    if (key2 == null) {\r\n                        return true;\r\n                    }\r\n                case 1 :\r\n                    if (key1 == null) {\r\n                        return true;\r\n                    }\r\n            }\r\n        } else if (size > 0) {\r\n            final int hashCode = key.hashCode();\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if ((hash3 == hashCode) && key.equals(key3)) {\r\n                        return true;\r\n                    }\r\n                case 2 :\r\n                    if ((hash2 == hashCode) && key.equals(key2)) {\r\n                        return true;\r\n                    }\r\n                case 1 :\r\n                    if ((hash1 == hashCode) && key.equals(key1)) {\r\n                        return true;\r\n                    }\r\n            }\r\n        }\r\n        return false;\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Flat3Map<K, V> clone();\n    @Override\r\npublic boolean containsValue(final Object value);\n    protected AbstractHashedMap<K, V> createDelegateMap();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic boolean equals(final Object obj);\n    @Override\r\npublic V get(final Object key);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic MapIterator<K, V> mapIterator();\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic V remove(final Object key);\n    @Override\r\npublic int size();\n    @Override\r\npublic String toString();\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "Flat3Map_equals",
        "package": "org.apache.commons.collections4.map",
        "class": "org.apache.commons.collections4.map.Flat3Map",
        "test-class": "org.apache.commons.collections4.map.Flat3Map_equals_Test",
        "method-name": "equals(Object)",
        "source-path": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java",
        "test-path": "src/test/java/org/apache/commons/collections4/map/Flat3Map_equals_Test.java",
        "focal-method": "@Override\r\npublic boolean equals(final Object obj) {\r\n    if (obj == this) {\r\n        return true;\r\n    }\r\n    if (delegateMap != null) {\r\n        return delegateMap.equals(obj);\r\n    }\r\n    if (!(obj instanceof Map)) {\r\n        return false;\r\n    }\r\n    final Map<?, ?> other = ((Map<?, ?>) (obj));\r\n    if (size != other.size()) {\r\n        return false;\r\n    }\r\n    if (size > 0) {\r\n        Object otherValue = null;\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if (!other.containsKey(key3)) {\r\n                    return false;\r\n                }\r\n                otherValue = other.get(key3);\r\n                if (!Objects.equals(value3, otherValue)) {\r\n                    return false;\r\n                }\r\n            case 2 :\r\n                if (!other.containsKey(key2)) {\r\n                    return false;\r\n                }\r\n                otherValue = other.get(key2);\r\n                if (!Objects.equals(value2, otherValue)) {\r\n                    return false;\r\n                }\r\n            case 1 :\r\n                if (!other.containsKey(key1)) {\r\n                    return false;\r\n                }\r\n                otherValue = other.get(key1);\r\n                if (!Objects.equals(value1, otherValue)) {\r\n                    return false;\r\n                }\r\n        }\r\n    }\r\n    return true;\r\n}",
        "class-code": "package org.apache.commons.collections4.map;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport java.util.Set;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport org.apache.commons.collections4.ResettableIterator;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapIterator;\nimport org.apache.commons.collections4.IterableMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\npublic class Flat3Map<K, V> implements IterableMap<K, V> , Serializable , Cloneable {\n    private transient int size;\n    private transient K key1;\n    private transient K key2;\n    private transient K key3;\n    private transient V value1;\n    private transient V value2;\n    private transient V value3;\n    private transient AbstractHashedMap<K, V> delegateMap;\n    @Override\r\n    public boolean equals(final Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (delegateMap != null) {\r\n            return delegateMap.equals(obj);\r\n        }\r\n        if (!(obj instanceof Map)) {\r\n            return false;\r\n        }\r\n        final Map<?, ?> other = ((Map<?, ?>) (obj));\r\n        if (size != other.size()) {\r\n            return false;\r\n        }\r\n        if (size > 0) {\r\n            Object otherValue = null;\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if (!other.containsKey(key3)) {\r\n                        return false;\r\n                    }\r\n                    otherValue = other.get(key3);\r\n                    if (!Objects.equals(value3, otherValue)) {\r\n                        return false;\r\n                    }\r\n                case 2 :\r\n                    if (!other.containsKey(key2)) {\r\n                        return false;\r\n                    }\r\n                    otherValue = other.get(key2);\r\n                    if (!Objects.equals(value2, otherValue)) {\r\n                        return false;\r\n                    }\r\n                case 1 :\r\n                    if (!other.containsKey(key1)) {\r\n                        return false;\r\n                    }\r\n                    otherValue = other.get(key1);\r\n                    if (!Objects.equals(value1, otherValue)) {\r\n                        return false;\r\n                    }\r\n            }\r\n        }\r\n        return true;\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Flat3Map<K, V> clone();\n    @Override\r\npublic boolean containsKey(final Object key);\n    @Override\r\npublic boolean containsValue(final Object value);\n    protected AbstractHashedMap<K, V> createDelegateMap();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic V get(final Object key);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic MapIterator<K, V> mapIterator();\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic V remove(final Object key);\n    @Override\r\npublic int size();\n    @Override\r\npublic String toString();\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "AbstractPatriciaTrie_put",
        "package": "org.apache.commons.collections4.trie",
        "class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie",
        "test-class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie_put_Test",
        "method-name": "put(K, V)",
        "source-path": "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java",
        "test-path": "src/test/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie_put_Test.java",
        "focal-method": "@Override\r\npublic V put(final K key, final V value) {\r\n    Objects.requireNonNull(key, \"key\");\r\n    final int lengthInBits = lengthInBits(key);\r\n    // The only place to store a key with a length\r\n    // of zero bits is the root node\r\n    if (lengthInBits == 0) {\r\n        if (root.isEmpty()) {\r\n            incrementSize();\r\n        } else {\r\n            incrementModCount();\r\n        }\r\n        return root.setKeyValue(key, value);\r\n    }\r\n    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\r\n    if (compareKeys(key, found.key)) {\r\n        if (found.isEmpty()) {\r\n            // <- must be the root\r\n            incrementSize();\r\n        } else {\r\n            incrementModCount();\r\n        }\r\n        return found.setKeyValue(key, value);\r\n    }\r\n    final int bitIndex = bitIndex(key, found.key);\r\n    if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\r\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\r\n            // in 99.999...9% the case\r\n            /* NEW KEY+VALUE TUPLE */\r\n            final TrieEntry<K, V> t = new TrieEntry<>(key, value, bitIndex);\r\n            addEntry(t, lengthInBits);\r\n            incrementSize();\r\n            return null;\r\n        }\r\n        if (KeyAnalyzer.isNullBitKey(bitIndex)) {\r\n            // A bits of the Key are zero. The only place to\r\n            // store such a Key is the root Node!\r\n            /* NULL BIT KEY */\r\n            if (root.isEmpty()) {\r\n                incrementSize();\r\n            } else {\r\n                incrementModCount();\r\n            }\r\n            return root.setKeyValue(key, value);\r\n        }\r\n        if (KeyAnalyzer.isEqualBitKey(bitIndex) && (found != root)) {\r\n            // NOPMD\r\n            incrementModCount();\r\n            return found.setKeyValue(key, value);\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(((((\"Failed to put: \" + key) + \" -> \") + value) + \", \") + bitIndex);\r\n}",
        "class-code": "package org.apache.commons.collections4.trie;\nimport java.util.Set;\nimport java.util.ConcurrentModificationException;\nimport java.io.IOException;\nimport java.util.SortedMap;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport java.util.Comparator;\nimport java.util.AbstractMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport org.apache.commons.collections4.Trie;\nimport java.util.Collections;\npublic abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n    private transient TrieEntry<K, V> root = new TrieEntry<>(null, null, -1);\n    protected transient int modCount;\n        /**\r\n     * A {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.\r\n     */\r\n    protected static class TrieEntry<K, V> extends BasicEntry<K, V> {\r\n        private static final long serialVersionUID = 4596023148184140013L;\r\n    \r\n        /**\r\n         * The index this entry is comparing.\r\n         */\r\n        protected int bitIndex;\r\n    \r\n        /**\r\n         * The parent of this entry.\r\n         */\r\n        protected TrieEntry<K, V> parent;\r\n    \r\n        /**\r\n         * The left child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> left;\r\n    \r\n        /**\r\n         * The right child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> right;\r\n    \r\n        /**\r\n         * The entry who uplinks to this entry.\r\n         */\r\n        protected TrieEntry<K, V> predecessor;\r\n    \r\n        public TrieEntry(final K key, final V value, final int bitIndex) {\r\n            super(key, value);\r\n            this.bitIndex = bitIndex;\r\n            this.parent = null;\r\n            this.left = this;\r\n            this.right = null;\r\n            this.predecessor = this;\r\n        }\r\n    \r\n        /**\r\n         * Whether or not the entry is storing a key.\r\n         * Only the root can potentially be empty, all other\r\n         * nodes must have a key.\r\n         */\r\n        public boolean isEmpty() {\r\n            return key == null;\r\n        }\r\n    \r\n        /**\r\n         * Either the left or right child is a loopback.\r\n         */\r\n        public boolean isExternalNode() {\r\n            return !isInternalNode();\r\n        }\r\n    \r\n        /**\r\n         * Neither the left nor right child is a loopback.\r\n         */\r\n        public boolean isInternalNode() {\r\n            return (left != this) && (right != this);\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            final StringBuilder buffer = new StringBuilder();\r\n            if (bitIndex == (-1)) {\r\n                buffer.append(\"RootEntry(\");\r\n            } else {\r\n                buffer.append(\"Entry(\");\r\n            }\r\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\r\n            buffer.append(\"value=\").append(getValue()).append(\", \");\r\n            // buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\r\n            if (parent != null) {\r\n                if (parent.bitIndex == (-1)) {\r\n                    buffer.append(\"parent=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"parent=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (left != null) {\r\n                if (left.bitIndex == (-1)) {\r\n                    buffer.append(\"left=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"left=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (right != null) {\r\n                if (right.bitIndex == (-1)) {\r\n                    buffer.append(\"right=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"right=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (predecessor != null) {\r\n                if (predecessor.bitIndex == (-1)) {\r\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").append(predecessor.bitIndex).append(\"]\");\r\n                }\r\n            }\r\n            buffer.append(\")\");\r\n            return buffer.toString();\r\n        }\r\n    }\n@Override\r\n    public V put(final K key, final V value) {\r\n        Objects.requireNonNull(key, \"key\");\r\n        final int lengthInBits = lengthInBits(key);\r\n        // The only place to store a key with a length\r\n        // of zero bits is the root node\r\n        if (lengthInBits == 0) {\r\n            if (root.isEmpty()) {\r\n                incrementSize();\r\n            } else {\r\n                incrementModCount();\r\n            }\r\n            return root.setKeyValue(key, value);\r\n        }\r\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\r\n        if (compareKeys(key, found.key)) {\r\n            if (found.isEmpty()) {\r\n                // <- must be the root\r\n                incrementSize();\r\n            } else {\r\n                incrementModCount();\r\n            }\r\n            return found.setKeyValue(key, value);\r\n        }\r\n        final int bitIndex = bitIndex(key, found.key);\r\n        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\r\n            if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\r\n                // in 99.999...9% the case\r\n                /* NEW KEY+VALUE TUPLE */\r\n                final TrieEntry<K, V> t = new TrieEntry<>(key, value, bitIndex);\r\n                addEntry(t, lengthInBits);\r\n                incrementSize();\r\n                return null;\r\n            }\r\n            if (KeyAnalyzer.isNullBitKey(bitIndex)) {\r\n                // A bits of the Key are zero. The only place to\r\n                // store such a Key is the root Node!\r\n                /* NULL BIT KEY */\r\n                if (root.isEmpty()) {\r\n                    incrementSize();\r\n                } else {\r\n                    incrementModCount();\r\n                }\r\n                return root.setKeyValue(key, value);\r\n            }\r\n            if (KeyAnalyzer.isEqualBitKey(bitIndex) && (found != root)) {\r\n                // NOPMD\r\n                incrementModCount();\r\n                return found.setKeyValue(key, value);\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(((((\"Failed to put: \" + key) + \" -> \") + value) + \", \") + bitIndex);\r\n    }\nTrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits);\n    TrieEntry<K, V> ceilingEntry(final K key);\n    @Override\r\npublic void clear();\n    @Override\r\npublic Comparator<? super K> comparator();\n    @Override\r\npublic boolean containsKey(final Object k);\n    void decrementSize();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    TrieEntry<K, V> firstEntry();\n    @Override\r\npublic K firstKey();\n    TrieEntry<K, V> floorEntry(final K key);\n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node);\n    TrieEntry<K, V> followRight(TrieEntry<K, V> node);\n    @Override\r\npublic V get(final Object k);\n    TrieEntry<K, V> getEntry(final Object k);\n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> headMap(final K toKey);\n    TrieEntry<K, V> higherEntry(final K key);\n    private void incrementModCount();\n    void incrementSize();\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from);\n    @Override\r\npublic Set<K> keySet();\n    TrieEntry<K, V> lastEntry();\n    @Override\r\npublic K lastKey();\n    TrieEntry<K, V> lowerEntry(final K key);\n    @Override\r\npublic OrderedMapIterator<K, V> mapIterator();\n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node);\n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree);\n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, final TrieEntry<K, V> parentOfSubtree);\n    @Override\r\npublic K nextKey(final K key);\n    @Override\r\npublic SortedMap<K, V> prefixMap(final K key);\n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start);\n    @Override\r\npublic K previousKey(final K key);\n    @Override\r\npublic V remove(final Object k);\n    V removeEntry(final TrieEntry<K, V> h);\n    public Map.Entry<K, V> select(final K key);\n    public K selectKey(final K key);\n    public V selectValue(final K key);\n    @Override\r\npublic int size();\n    @Override\r\npublic SortedMap<K, V> subMap(final K fromKey, final K toKey);\n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> tailMap(final K fromKey);\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "AbstractPatriciaTrie_nextEntryImpl",
        "package": "org.apache.commons.collections4.trie",
        "class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie",
        "test-class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie_nextEntryImpl_Test",
        "method-name": "nextEntryImpl(TrieEntry<K, V>, TrieEntry<K, V>, TrieEntry<K, V>)",
        "source-path": "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java",
        "test-path": "src/test/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie_nextEntryImpl_Test.java",
        "focal-method": "TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\r\n    TrieEntry<K, V> current = start;\r\n    // Only look at the left if this was a recursive or\r\n    // the first check, otherwise we know we've already looked\r\n    // at the left.\r\n    if ((previous == null) || (start != previous.predecessor)) {\r\n        while (!current.left.isEmpty()) {\r\n            // stop traversing if we've already\r\n            // returned the left of this node.\r\n            if (previous == current.left) {\r\n                break;\r\n            }\r\n            if (isValidUplink(current.left, current)) {\r\n                return current.left;\r\n            }\r\n            current = current.left;\r\n        } \r\n    }\r\n    // If there's no data at all, exit.\r\n    if (current.isEmpty()) {\r\n        return null;\r\n    }\r\n    // If we've already returned the left,\r\n    // and the immediate right is null,\r\n    // there's only one entry in the Trie\r\n    // which is stored at the root.\r\n    // \r\n    // / (\"\")   <-- root\r\n    // \\_/  \\\r\n    // null <-- 'current'\r\n    // \r\n    if (current.right == null) {\r\n        return null;\r\n    }\r\n    // If nothing valid on the left, try the right.\r\n    if (previous != current.right) {\r\n        // See if it immediately is valid.\r\n        if (isValidUplink(current.right, current)) {\r\n            return current.right;\r\n        }\r\n        // Must search on the right's side if it wasn't initially valid.\r\n        return nextEntryImpl(current.right, previous, tree);\r\n    }\r\n    // Neither left nor right are valid, find the first parent\r\n    // whose child did not come from the right & traverse it.\r\n    while (current == current.parent.right) {\r\n        // If we're going to traverse to above the subtree, stop.\r\n        if (current == tree) {\r\n            return null;\r\n        }\r\n        current = current.parent;\r\n    } \r\n    // If we're on the top of the subtree, we can't go any higher.\r\n    if (current == tree) {\r\n        return null;\r\n    }\r\n    // If there's no right, the parent must be root, so we're done.\r\n    if (current.parent.right == null) {\r\n        return null;\r\n    }\r\n    // If the parent's right points to itself, we've found one.\r\n    if ((previous != current.parent.right) && isValidUplink(current.parent.right, current.parent)) {\r\n        return current.parent.right;\r\n    }\r\n    // If the parent's right is itself, there can't be any more nodes.\r\n    if (current.parent.right == current.parent) {\r\n        return null;\r\n    }\r\n    // We need to traverse down the parent's right's path.\r\n    return nextEntryImpl(current.parent.right, previous, tree);\r\n}",
        "class-code": "package org.apache.commons.collections4.trie;\nimport java.util.Set;\nimport java.util.ConcurrentModificationException;\nimport java.io.IOException;\nimport java.util.SortedMap;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport java.util.Comparator;\nimport java.util.AbstractMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport org.apache.commons.collections4.Trie;\nimport java.util.Collections;\npublic abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n    protected transient int modCount;\n        /**\r\n     * A {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.\r\n     */\r\n    protected static class TrieEntry<K, V> extends BasicEntry<K, V> {\r\n        private static final long serialVersionUID = 4596023148184140013L;\r\n    \r\n        /**\r\n         * The index this entry is comparing.\r\n         */\r\n        protected int bitIndex;\r\n    \r\n        /**\r\n         * The parent of this entry.\r\n         */\r\n        protected TrieEntry<K, V> parent;\r\n    \r\n        /**\r\n         * The left child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> left;\r\n    \r\n        /**\r\n         * The right child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> right;\r\n    \r\n        /**\r\n         * The entry who uplinks to this entry.\r\n         */\r\n        protected TrieEntry<K, V> predecessor;\r\n    \r\n        public TrieEntry(final K key, final V value, final int bitIndex) {\r\n            super(key, value);\r\n            this.bitIndex = bitIndex;\r\n            this.parent = null;\r\n            this.left = this;\r\n            this.right = null;\r\n            this.predecessor = this;\r\n        }\r\n    \r\n        /**\r\n         * Whether or not the entry is storing a key.\r\n         * Only the root can potentially be empty, all other\r\n         * nodes must have a key.\r\n         */\r\n        public boolean isEmpty() {\r\n            return key == null;\r\n        }\r\n    \r\n        /**\r\n         * Either the left or right child is a loopback.\r\n         */\r\n        public boolean isExternalNode() {\r\n            return !isInternalNode();\r\n        }\r\n    \r\n        /**\r\n         * Neither the left nor right child is a loopback.\r\n         */\r\n        public boolean isInternalNode() {\r\n            return (left != this) && (right != this);\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            final StringBuilder buffer = new StringBuilder();\r\n            if (bitIndex == (-1)) {\r\n                buffer.append(\"RootEntry(\");\r\n            } else {\r\n                buffer.append(\"Entry(\");\r\n            }\r\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\r\n            buffer.append(\"value=\").append(getValue()).append(\", \");\r\n            // buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\r\n            if (parent != null) {\r\n                if (parent.bitIndex == (-1)) {\r\n                    buffer.append(\"parent=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"parent=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (left != null) {\r\n                if (left.bitIndex == (-1)) {\r\n                    buffer.append(\"left=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"left=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (right != null) {\r\n                if (right.bitIndex == (-1)) {\r\n                    buffer.append(\"right=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"right=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (predecessor != null) {\r\n                if (predecessor.bitIndex == (-1)) {\r\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").append(predecessor.bitIndex).append(\"]\");\r\n                }\r\n            }\r\n            buffer.append(\")\");\r\n            return buffer.toString();\r\n        }\r\n    }\nTrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\r\n        TrieEntry<K, V> current = start;\r\n        // Only look at the left if this was a recursive or\r\n        // the first check, otherwise we know we've already looked\r\n        // at the left.\r\n        if ((previous == null) || (start != previous.predecessor)) {\r\n            while (!current.left.isEmpty()) {\r\n                // stop traversing if we've already\r\n                // returned the left of this node.\r\n                if (previous == current.left) {\r\n                    break;\r\n                }\r\n                if (isValidUplink(current.left, current)) {\r\n                    return current.left;\r\n                }\r\n                current = current.left;\r\n            } \r\n        }\r\n        // If there's no data at all, exit.\r\n        if (current.isEmpty()) {\r\n            return null;\r\n        }\r\n        // If we've already returned the left,\r\n        // and the immediate right is null,\r\n        // there's only one entry in the Trie\r\n        // which is stored at the root.\r\n        // \r\n        // / (\"\")   <-- root\r\n        // \\_/  \\\r\n        // null <-- 'current'\r\n        // \r\n        if (current.right == null) {\r\n            return null;\r\n        }\r\n        // If nothing valid on the left, try the right.\r\n        if (previous != current.right) {\r\n            // See if it immediately is valid.\r\n            if (isValidUplink(current.right, current)) {\r\n                return current.right;\r\n            }\r\n            // Must search on the right's side if it wasn't initially valid.\r\n            return nextEntryImpl(current.right, previous, tree);\r\n        }\r\n        // Neither left nor right are valid, find the first parent\r\n        // whose child did not come from the right & traverse it.\r\n        while (current == current.parent.right) {\r\n            // If we're going to traverse to above the subtree, stop.\r\n            if (current == tree) {\r\n                return null;\r\n            }\r\n            current = current.parent;\r\n        } \r\n        // If we're on the top of the subtree, we can't go any higher.\r\n        if (current == tree) {\r\n            return null;\r\n        }\r\n        // If there's no right, the parent must be root, so we're done.\r\n        if (current.parent.right == null) {\r\n            return null;\r\n        }\r\n        // If the parent's right points to itself, we've found one.\r\n        if ((previous != current.parent.right) && isValidUplink(current.parent.right, current.parent)) {\r\n            return current.parent.right;\r\n        }\r\n        // If the parent's right is itself, there can't be any more nodes.\r\n        if (current.parent.right == current.parent) {\r\n            return null;\r\n        }\r\n        // We need to traverse down the parent's right's path.\r\n        return nextEntryImpl(current.parent.right, previous, tree);\r\n    }\nTrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits);\n    TrieEntry<K, V> ceilingEntry(final K key);\n    @Override\r\npublic void clear();\n    @Override\r\npublic Comparator<? super K> comparator();\n    @Override\r\npublic boolean containsKey(final Object k);\n    void decrementSize();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    TrieEntry<K, V> firstEntry();\n    @Override\r\npublic K firstKey();\n    TrieEntry<K, V> floorEntry(final K key);\n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node);\n    TrieEntry<K, V> followRight(TrieEntry<K, V> node);\n    @Override\r\npublic V get(final Object k);\n    TrieEntry<K, V> getEntry(final Object k);\n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> headMap(final K toKey);\n    TrieEntry<K, V> higherEntry(final K key);\n    void incrementSize();\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from);\n    @Override\r\npublic Set<K> keySet();\n    TrieEntry<K, V> lastEntry();\n    @Override\r\npublic K lastKey();\n    TrieEntry<K, V> lowerEntry(final K key);\n    @Override\r\npublic OrderedMapIterator<K, V> mapIterator();\n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node);\n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, final TrieEntry<K, V> parentOfSubtree);\n    @Override\r\npublic K nextKey(final K key);\n    @Override\r\npublic SortedMap<K, V> prefixMap(final K key);\n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start);\n    @Override\r\npublic K previousKey(final K key);\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic V remove(final Object k);\n    V removeEntry(final TrieEntry<K, V> h);\n    public Map.Entry<K, V> select(final K key);\n    public K selectKey(final K key);\n    public V selectValue(final K key);\n    @Override\r\npublic int size();\n    @Override\r\npublic SortedMap<K, V> subMap(final K fromKey, final K toKey);\n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> tailMap(final K fromKey);\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "Flat3Map_remove",
        "package": "org.apache.commons.collections4.map",
        "class": "org.apache.commons.collections4.map.Flat3Map",
        "test-class": "org.apache.commons.collections4.map.Flat3Map_remove_Test",
        "method-name": "remove(Object)",
        "source-path": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java",
        "test-path": "src/test/java/org/apache/commons/collections4/map/Flat3Map_remove_Test.java",
        "focal-method": "@Override\r\npublic V remove(final Object key) {\r\n    if (delegateMap != null) {\r\n        return delegateMap.remove(key);\r\n    }\r\n    if (size == 0) {\r\n        return null;\r\n    }\r\n    if (key == null) {\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if (key3 == null) {\r\n                    final V old = value3;\r\n                    hash3 = 0;\r\n                    key3 = null;\r\n                    value3 = null;\r\n                    size = 2;\r\n                    return old;\r\n                }\r\n                if (key2 == null) {\r\n                    final V old = value2;\r\n                    hash2 = hash3;\r\n                    key2 = key3;\r\n                    value2 = value3;\r\n                    hash3 = 0;\r\n                    key3 = null;\r\n                    value3 = null;\r\n                    size = 2;\r\n                    return old;\r\n                }\r\n                if (key1 == null) {\r\n                    final V old = value1;\r\n                    hash1 = hash3;\r\n                    key1 = key3;\r\n                    value1 = value3;\r\n                    hash3 = 0;\r\n                    key3 = null;\r\n                    value3 = null;\r\n                    size = 2;\r\n                    return old;\r\n                }\r\n                return null;\r\n            case 2 :\r\n                if (key2 == null) {\r\n                    final V old = value2;\r\n                    hash2 = 0;\r\n                    key2 = null;\r\n                    value2 = null;\r\n                    size = 1;\r\n                    return old;\r\n                }\r\n                if (key1 == null) {\r\n                    final V old = value1;\r\n                    hash1 = hash2;\r\n                    key1 = key2;\r\n                    value1 = value2;\r\n                    hash2 = 0;\r\n                    key2 = null;\r\n                    value2 = null;\r\n                    size = 1;\r\n                    return old;\r\n                }\r\n                return null;\r\n            case 1 :\r\n                if (key1 == null) {\r\n                    final V old = value1;\r\n                    hash1 = 0;\r\n                    key1 = null;\r\n                    value1 = null;\r\n                    size = 0;\r\n                    return old;\r\n                }\r\n        }\r\n    } else if (size > 0) {\r\n        final int hashCode = key.hashCode();\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if ((hash3 == hashCode) && key.equals(key3)) {\r\n                    final V old = value3;\r\n                    hash3 = 0;\r\n                    key3 = null;\r\n                    value3 = null;\r\n                    size = 2;\r\n                    return old;\r\n                }\r\n                if ((hash2 == hashCode) && key.equals(key2)) {\r\n                    final V old = value2;\r\n                    hash2 = hash3;\r\n                    key2 = key3;\r\n                    value2 = value3;\r\n                    hash3 = 0;\r\n                    key3 = null;\r\n                    value3 = null;\r\n                    size = 2;\r\n                    return old;\r\n                }\r\n                if ((hash1 == hashCode) && key.equals(key1)) {\r\n                    final V old = value1;\r\n                    hash1 = hash3;\r\n                    key1 = key3;\r\n                    value1 = value3;\r\n                    hash3 = 0;\r\n                    key3 = null;\r\n                    value3 = null;\r\n                    size = 2;\r\n                    return old;\r\n                }\r\n                return null;\r\n            case 2 :\r\n                if ((hash2 == hashCode) && key.equals(key2)) {\r\n                    final V old = value2;\r\n                    hash2 = 0;\r\n                    key2 = null;\r\n                    value2 = null;\r\n                    size = 1;\r\n                    return old;\r\n                }\r\n                if ((hash1 == hashCode) && key.equals(key1)) {\r\n                    final V old = value1;\r\n                    hash1 = hash2;\r\n                    key1 = key2;\r\n                    value1 = value2;\r\n                    hash2 = 0;\r\n                    key2 = null;\r\n                    value2 = null;\r\n                    size = 1;\r\n                    return old;\r\n                }\r\n                return null;\r\n            case 1 :\r\n                if ((hash1 == hashCode) && key.equals(key1)) {\r\n                    final V old = value1;\r\n                    hash1 = 0;\r\n                    key1 = null;\r\n                    value1 = null;\r\n                    size = 0;\r\n                    return old;\r\n                }\r\n        }\r\n    }\r\n    return null;\r\n}",
        "class-code": "package org.apache.commons.collections4.map;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport java.util.Set;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport org.apache.commons.collections4.ResettableIterator;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapIterator;\nimport org.apache.commons.collections4.IterableMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\npublic class Flat3Map<K, V> implements IterableMap<K, V> , Serializable , Cloneable {\n    private transient int size;\n    private transient int hash1;\n    private transient int hash2;\n    private transient int hash3;\n    private transient K key1;\n    private transient K key2;\n    private transient K key3;\n    private transient V value1;\n    private transient V value2;\n    private transient V value3;\n    private transient AbstractHashedMap<K, V> delegateMap;\n    @Override\r\n    public V remove(final Object key) {\r\n        if (delegateMap != null) {\r\n            return delegateMap.remove(key);\r\n        }\r\n        if (size == 0) {\r\n            return null;\r\n        }\r\n        if (key == null) {\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if (key3 == null) {\r\n                        final V old = value3;\r\n                        hash3 = 0;\r\n                        key3 = null;\r\n                        value3 = null;\r\n                        size = 2;\r\n                        return old;\r\n                    }\r\n                    if (key2 == null) {\r\n                        final V old = value2;\r\n                        hash2 = hash3;\r\n                        key2 = key3;\r\n                        value2 = value3;\r\n                        hash3 = 0;\r\n                        key3 = null;\r\n                        value3 = null;\r\n                        size = 2;\r\n                        return old;\r\n                    }\r\n                    if (key1 == null) {\r\n                        final V old = value1;\r\n                        hash1 = hash3;\r\n                        key1 = key3;\r\n                        value1 = value3;\r\n                        hash3 = 0;\r\n                        key3 = null;\r\n                        value3 = null;\r\n                        size = 2;\r\n                        return old;\r\n                    }\r\n                    return null;\r\n                case 2 :\r\n                    if (key2 == null) {\r\n                        final V old = value2;\r\n                        hash2 = 0;\r\n                        key2 = null;\r\n                        value2 = null;\r\n                        size = 1;\r\n                        return old;\r\n                    }\r\n                    if (key1 == null) {\r\n                        final V old = value1;\r\n                        hash1 = hash2;\r\n                        key1 = key2;\r\n                        value1 = value2;\r\n                        hash2 = 0;\r\n                        key2 = null;\r\n                        value2 = null;\r\n                        size = 1;\r\n                        return old;\r\n                    }\r\n                    return null;\r\n                case 1 :\r\n                    if (key1 == null) {\r\n                        final V old = value1;\r\n                        hash1 = 0;\r\n                        key1 = null;\r\n                        value1 = null;\r\n                        size = 0;\r\n                        return old;\r\n                    }\r\n            }\r\n        } else if (size > 0) {\r\n            final int hashCode = key.hashCode();\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if ((hash3 == hashCode) && key.equals(key3)) {\r\n                        final V old = value3;\r\n                        hash3 = 0;\r\n                        key3 = null;\r\n                        value3 = null;\r\n                        size = 2;\r\n                        return old;\r\n                    }\r\n                    if ((hash2 == hashCode) && key.equals(key2)) {\r\n                        final V old = value2;\r\n                        hash2 = hash3;\r\n                        key2 = key3;\r\n                        value2 = value3;\r\n                        hash3 = 0;\r\n                        key3 = null;\r\n                        value3 = null;\r\n                        size = 2;\r\n                        return old;\r\n                    }\r\n                    if ((hash1 == hashCode) && key.equals(key1)) {\r\n                        final V old = value1;\r\n                        hash1 = hash3;\r\n                        key1 = key3;\r\n                        value1 = value3;\r\n                        hash3 = 0;\r\n                        key3 = null;\r\n                        value3 = null;\r\n                        size = 2;\r\n                        return old;\r\n                    }\r\n                    return null;\r\n                case 2 :\r\n                    if ((hash2 == hashCode) && key.equals(key2)) {\r\n                        final V old = value2;\r\n                        hash2 = 0;\r\n                        key2 = null;\r\n                        value2 = null;\r\n                        size = 1;\r\n                        return old;\r\n                    }\r\n                    if ((hash1 == hashCode) && key.equals(key1)) {\r\n                        final V old = value1;\r\n                        hash1 = hash2;\r\n                        key1 = key2;\r\n                        value1 = value2;\r\n                        hash2 = 0;\r\n                        key2 = null;\r\n                        value2 = null;\r\n                        size = 1;\r\n                        return old;\r\n                    }\r\n                    return null;\r\n                case 1 :\r\n                    if ((hash1 == hashCode) && key.equals(key1)) {\r\n                        final V old = value1;\r\n                        hash1 = 0;\r\n                        key1 = null;\r\n                        value1 = null;\r\n                        size = 0;\r\n                        return old;\r\n                    }\r\n            }\r\n        }\r\n        return null;\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Flat3Map<K, V> clone();\n    @Override\r\npublic boolean containsKey(final Object key);\n    @Override\r\npublic boolean containsValue(final Object value);\n    protected AbstractHashedMap<K, V> createDelegateMap();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic boolean equals(final Object obj);\n    @Override\r\npublic V get(final Object key);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic MapIterator<K, V> mapIterator();\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic int size();\n    @Override\r\npublic String toString();\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "AbstractPatriciaTrie_removeInternalEntry",
        "package": "org.apache.commons.collections4.trie",
        "class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie",
        "test-class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie_removeInternalEntry_Test",
        "method-name": "removeInternalEntry(TrieEntry<K, V>)",
        "source-path": "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java",
        "test-path": "src/test/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie_removeInternalEntry_Test.java",
        "focal-method": "private void removeInternalEntry(final TrieEntry<K, V> h) {\r\n    if (h == root) {\r\n        throw new IllegalArgumentException(\"Cannot delete root Entry!\");\r\n    }\r\n    if (!h.isInternalNode()) {\r\n        throw new IllegalArgumentException(h + \" is not an internal Entry!\");\r\n    }\r\n    final TrieEntry<K, V> p = h.predecessor;\r\n    // Set P's bitIndex\r\n    p.bitIndex = h.bitIndex;\r\n    // Fix P's parent, predecessor and child Nodes\r\n    {\r\n        final TrieEntry<K, V> parent = p.parent;\r\n        final TrieEntry<K, V> child = (p.left == h) ? p.right : p.left;\r\n        // if it was looping to itself previously,\r\n        // it will now be pointed from its parent\r\n        // (if we aren't removing its parent --\r\n        // in that case, it remains looping to itself).\r\n        // otherwise, it will continue to have the same\r\n        // predecessor.\r\n        if ((p.predecessor == p) && (p.parent != h)) {\r\n            p.predecessor = p.parent;\r\n        }\r\n        if (parent.left == p) {\r\n            parent.left = child;\r\n        } else {\r\n            parent.right = child;\r\n        }\r\n        if (child.bitIndex > parent.bitIndex) {\r\n            child.parent = parent;\r\n        }\r\n    }\r\n    // Fix H's parent and child Nodes\r\n    {\r\n        // If H is a parent of its left and right child\r\n        // then change them to P\r\n        if (h.left.parent == h) {\r\n            h.left.parent = p;\r\n        }\r\n        if (h.right.parent == h) {\r\n            h.right.parent = p;\r\n        }\r\n        // Change H's parent\r\n        if (h.parent.left == h) {\r\n            h.parent.left = p;\r\n        } else {\r\n            h.parent.right = p;\r\n        }\r\n    }\r\n    // Copy the remaining fields from H to P\r\n    // p.bitIndex = h.bitIndex;\r\n    p.parent = h.parent;\r\n    p.left = h.left;\r\n    p.right = h.right;\r\n    // Make sure that if h was pointing to any uplinks,\r\n    // p now points to them.\r\n    if (isValidUplink(p.left, p)) {\r\n        p.left.predecessor = p;\r\n    }\r\n    if (isValidUplink(p.right, p)) {\r\n        p.right.predecessor = p;\r\n    }\r\n}",
        "class-code": "package org.apache.commons.collections4.trie;\nimport java.util.Set;\nimport java.util.ConcurrentModificationException;\nimport java.io.IOException;\nimport java.util.SortedMap;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport java.util.Comparator;\nimport java.util.AbstractMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport org.apache.commons.collections4.Trie;\nimport java.util.Collections;\npublic abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n    private transient TrieEntry<K, V> root = new TrieEntry<>(null, null, -1);\n    protected transient int modCount;\n        /**\r\n     * A {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.\r\n     */\r\n    protected static class TrieEntry<K, V> extends BasicEntry<K, V> {\r\n        private static final long serialVersionUID = 4596023148184140013L;\r\n    \r\n        /**\r\n         * The index this entry is comparing.\r\n         */\r\n        protected int bitIndex;\r\n    \r\n        /**\r\n         * The parent of this entry.\r\n         */\r\n        protected TrieEntry<K, V> parent;\r\n    \r\n        /**\r\n         * The left child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> left;\r\n    \r\n        /**\r\n         * The right child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> right;\r\n    \r\n        /**\r\n         * The entry who uplinks to this entry.\r\n         */\r\n        protected TrieEntry<K, V> predecessor;\r\n    \r\n        public TrieEntry(final K key, final V value, final int bitIndex) {\r\n            super(key, value);\r\n            this.bitIndex = bitIndex;\r\n            this.parent = null;\r\n            this.left = this;\r\n            this.right = null;\r\n            this.predecessor = this;\r\n        }\r\n    \r\n        /**\r\n         * Whether or not the entry is storing a key.\r\n         * Only the root can potentially be empty, all other\r\n         * nodes must have a key.\r\n         */\r\n        public boolean isEmpty() {\r\n            return key == null;\r\n        }\r\n    \r\n        /**\r\n         * Either the left or right child is a loopback.\r\n         */\r\n        public boolean isExternalNode() {\r\n            return !isInternalNode();\r\n        }\r\n    \r\n        /**\r\n         * Neither the left nor right child is a loopback.\r\n         */\r\n        public boolean isInternalNode() {\r\n            return (left != this) && (right != this);\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            final StringBuilder buffer = new StringBuilder();\r\n            if (bitIndex == (-1)) {\r\n                buffer.append(\"RootEntry(\");\r\n            } else {\r\n                buffer.append(\"Entry(\");\r\n            }\r\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\r\n            buffer.append(\"value=\").append(getValue()).append(\", \");\r\n            // buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\r\n            if (parent != null) {\r\n                if (parent.bitIndex == (-1)) {\r\n                    buffer.append(\"parent=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"parent=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (left != null) {\r\n                if (left.bitIndex == (-1)) {\r\n                    buffer.append(\"left=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"left=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (right != null) {\r\n                if (right.bitIndex == (-1)) {\r\n                    buffer.append(\"right=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"right=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (predecessor != null) {\r\n                if (predecessor.bitIndex == (-1)) {\r\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").append(predecessor.bitIndex).append(\"]\");\r\n                }\r\n            }\r\n            buffer.append(\")\");\r\n            return buffer.toString();\r\n        }\r\n    }\nprivate void removeInternalEntry(final TrieEntry<K, V> h) {\r\n        if (h == root) {\r\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\r\n        }\r\n        if (!h.isInternalNode()) {\r\n            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\r\n        }\r\n        final TrieEntry<K, V> p = h.predecessor;\r\n        // Set P's bitIndex\r\n        p.bitIndex = h.bitIndex;\r\n        // Fix P's parent, predecessor and child Nodes\r\n        {\r\n            final TrieEntry<K, V> parent = p.parent;\r\n            final TrieEntry<K, V> child = (p.left == h) ? p.right : p.left;\r\n            // if it was looping to itself previously,\r\n            // it will now be pointed from its parent\r\n            // (if we aren't removing its parent --\r\n            // in that case, it remains looping to itself).\r\n            // otherwise, it will continue to have the same\r\n            // predecessor.\r\n            if ((p.predecessor == p) && (p.parent != h)) {\r\n                p.predecessor = p.parent;\r\n            }\r\n            if (parent.left == p) {\r\n                parent.left = child;\r\n            } else {\r\n                parent.right = child;\r\n            }\r\n            if (child.bitIndex > parent.bitIndex) {\r\n                child.parent = parent;\r\n            }\r\n        }\r\n        // Fix H's parent and child Nodes\r\n        {\r\n            // If H is a parent of its left and right child\r\n            // then change them to P\r\n            if (h.left.parent == h) {\r\n                h.left.parent = p;\r\n            }\r\n            if (h.right.parent == h) {\r\n                h.right.parent = p;\r\n            }\r\n            // Change H's parent\r\n            if (h.parent.left == h) {\r\n                h.parent.left = p;\r\n            } else {\r\n                h.parent.right = p;\r\n            }\r\n        }\r\n        // Copy the remaining fields from H to P\r\n        // p.bitIndex = h.bitIndex;\r\n        p.parent = h.parent;\r\n        p.left = h.left;\r\n        p.right = h.right;\r\n        // Make sure that if h was pointing to any uplinks,\r\n        // p now points to them.\r\n        if (isValidUplink(p.left, p)) {\r\n            p.left.predecessor = p;\r\n        }\r\n        if (isValidUplink(p.right, p)) {\r\n            p.right.predecessor = p;\r\n        }\r\n    }\nTrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits);\n    TrieEntry<K, V> ceilingEntry(final K key);\n    @Override\r\npublic void clear();\n    @Override\r\npublic Comparator<? super K> comparator();\n    @Override\r\npublic boolean containsKey(final Object k);\n    void decrementSize();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    TrieEntry<K, V> firstEntry();\n    @Override\r\npublic K firstKey();\n    TrieEntry<K, V> floorEntry(final K key);\n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node);\n    TrieEntry<K, V> followRight(TrieEntry<K, V> node);\n    @Override\r\npublic V get(final Object k);\n    TrieEntry<K, V> getEntry(final Object k);\n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> headMap(final K toKey);\n    TrieEntry<K, V> higherEntry(final K key);\n    void incrementSize();\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from);\n    @Override\r\npublic Set<K> keySet();\n    TrieEntry<K, V> lastEntry();\n    @Override\r\npublic K lastKey();\n    TrieEntry<K, V> lowerEntry(final K key);\n    @Override\r\npublic OrderedMapIterator<K, V> mapIterator();\n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node);\n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree);\n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, final TrieEntry<K, V> parentOfSubtree);\n    @Override\r\npublic K nextKey(final K key);\n    @Override\r\npublic SortedMap<K, V> prefixMap(final K key);\n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start);\n    @Override\r\npublic K previousKey(final K key);\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic V remove(final Object k);\n    V removeEntry(final TrieEntry<K, V> h);\n    public Map.Entry<K, V> select(final K key);\n    public K selectKey(final K key);\n    public V selectValue(final K key);\n    @Override\r\npublic int size();\n    @Override\r\npublic SortedMap<K, V> subMap(final K fromKey, final K toKey);\n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> tailMap(final K fromKey);\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "TreeBidiMap_doRedBlackDelete",
        "package": "org.apache.commons.collections4.bidimap",
        "class": "org.apache.commons.collections4.bidimap.TreeBidiMap",
        "test-class": "org.apache.commons.collections4.bidimap.TreeBidiMap_doRedBlackDelete_Test",
        "method-name": "doRedBlackDelete(Node<K, V>)",
        "source-path": "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java",
        "test-path": "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMap_doRedBlackDelete_Test.java",
        "focal-method": "private void doRedBlackDelete(final Node<K, V> deletedNode) {\r\n    for (final DataElement dataElement : DataElement.values()) {\r\n        // if deleted node has both left and children, swap with\r\n        // the next greater node\r\n        if ((deletedNode.getLeft(dataElement) != null) && (deletedNode.getRight(dataElement) != null)) {\r\n            swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);\r\n        }\r\n        final Node<K, V> replacement = (deletedNode.getLeft(dataElement) != null) ? deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);\r\n        if (replacement != null) {\r\n            replacement.setParent(deletedNode.getParent(dataElement), dataElement);\r\n            if (deletedNode.getParent(dataElement) == null) {\r\n                rootNode[dataElement.ordinal()] = replacement;\r\n            } else if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\r\n                deletedNode.getParent(dataElement).setLeft(replacement, dataElement);\r\n            } else {\r\n                deletedNode.getParent(dataElement).setRight(replacement, dataElement);\r\n            }\r\n            deletedNode.setLeft(null, dataElement);\r\n            deletedNode.setRight(null, dataElement);\r\n            deletedNode.setParent(null, dataElement);\r\n            if (isBlack(deletedNode, dataElement)) {\r\n                doRedBlackDeleteFixup(replacement, dataElement);\r\n            }\r\n        } else // replacement is null\r\n        if (deletedNode.getParent(dataElement) == null) {\r\n            // empty tree\r\n            rootNode[dataElement.ordinal()] = null;\r\n        } else {\r\n            // deleted node had no children\r\n            if (isBlack(deletedNode, dataElement)) {\r\n                doRedBlackDeleteFixup(deletedNode, dataElement);\r\n            }\r\n            if (deletedNode.getParent(dataElement) != null) {\r\n                if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\r\n                    deletedNode.getParent(dataElement).setLeft(null, dataElement);\r\n                } else {\r\n                    deletedNode.getParent(dataElement).setRight(null, dataElement);\r\n                }\r\n                deletedNode.setParent(null, dataElement);\r\n            }\r\n        }\r\n    }\r\n    shrink();\r\n}",
        "class-code": "package org.apache.commons.collections4.bidimap;\nimport org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\nimport static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.KEY;\nimport java.util.Set;\nimport org.apache.commons.collections4.KeyValue;\nimport java.util.ConcurrentModificationException;\nimport static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.VALUE;\nimport java.io.IOException;\nimport org.apache.commons.collections4.OrderedBidiMap;\nimport java.util.AbstractSet;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.keyvalue.UnmodifiableMapEntry;\nimport org.apache.commons.collections4.MapIterator;\nimport java.io.ObjectInputStream;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\nimport org.apache.commons.collections4.OrderedIterator;\npublic class TreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> implements OrderedBidiMap<K, V> , Serializable {\n    private transient Node<K, V>[] rootNode;\n        enum DataElement {\r\n    \r\n        KEY(\"key\"),\r\n        VALUE(\"value\");\r\n    \r\n        private final String description;\r\n    \r\n        /**\r\n         * Creates a new TreeBidiMap.DataElement.\r\n         *\r\n         * @param description\r\n         * \t\tthe description for the element\r\n         */\r\n        DataElement(final String description) {\r\n            this.description = description;\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            return description;\r\n        }\r\n    }\n    /**\r\n     * A node used to store the data.\r\n     */\r\n    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V> , KeyValue<K, V> {\r\n        private final K key;\r\n    \r\n        private final V value;\r\n    \r\n        private final Node<K, V>[] leftNode;\r\n    \r\n        private final Node<K, V>[] rightNode;\r\n    \r\n        private final Node<K, V>[] parentNode;\r\n    \r\n        private final boolean[] blackColor;\r\n    \r\n        private int hashCodeValue;\r\n    \r\n        private boolean calculatedHashCode;\r\n    \r\n        /**\r\n         * Makes a new cell with given key and value, and with null\r\n         * links, and black (true) colors.\r\n         *\r\n         * @param key\r\n         * \t\tthe key of this node\r\n         * @param value\r\n         * \t\tthe value of this node\r\n         */\r\n        @SuppressWarnings(\"unchecked\")\r\n        Node(final K key, final V value) {\r\n            this.key = key;\r\n            this.value = value;\r\n            leftNode = new Node[2];\r\n            rightNode = new Node[2];\r\n            parentNode = new Node[2];\r\n            blackColor = new boolean[]{ true, true };\r\n            calculatedHashCode = false;\r\n        }\r\n    \r\n        /**\r\n         * Makes this node the same color as another.\r\n         *\r\n         * @param node\r\n         * \t\tthe node whose color we're adopting\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\r\n            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\r\n        }\r\n    \r\n        /**\r\n         * Compares the specified object with this entry for equality.\r\n         * Returns true if the given object is also a map entry and\r\n         * the two entries represent the same mapping.\r\n         *\r\n         * @param obj\r\n         * \t\tthe object to be compared for equality with this entry.\r\n         * @return true if the specified object is equal to this entry.\r\n         */\r\n        @Override\r\n        public boolean equals(final Object obj) {\r\n            if (obj == this) {\r\n                return true;\r\n            }\r\n            if (!(obj instanceof Map.Entry)) {\r\n                return false;\r\n            }\r\n            final Map.Entry<?, ?> e = ((Map.Entry<?, ?>) (obj));\r\n            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\r\n        }\r\n    \r\n        private Object getData(final DataElement dataElement) {\r\n            switch (dataElement) {\r\n                case KEY :\r\n                    return getKey();\r\n                case VALUE :\r\n                    return getValue();\r\n                default :\r\n                    throw new IllegalArgumentException();\r\n            }\r\n        }\r\n    \r\n        /**\r\n         * Gets the key.\r\n         *\r\n         * @return the key corresponding to this entry.\r\n         */\r\n        @Override\r\n        public K getKey() {\r\n            return key;\r\n        }\r\n    \r\n        private Node<K, V> getLeft(final DataElement dataElement) {\r\n            return leftNode[dataElement.ordinal()];\r\n        }\r\n    \r\n        /**\r\n         * Gets the parent node.\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         * @return the parent node, may be null\r\n         */\r\n        private Node<K, V> getParent(final DataElement dataElement) {\r\n            return parentNode[dataElement.ordinal()];\r\n        }\r\n    \r\n        private Node<K, V> getRight(final DataElement dataElement) {\r\n            return rightNode[dataElement.ordinal()];\r\n        }\r\n    \r\n        /**\r\n         * Gets the value.\r\n         *\r\n         * @return the value corresponding to this entry.\r\n         */\r\n        @Override\r\n        public V getValue() {\r\n            return value;\r\n        }\r\n    \r\n        /**\r\n         *\r\n         * @return the hash code value for this map entry.\r\n         */\r\n        @Override\r\n        public int hashCode() {\r\n            if (!calculatedHashCode) {\r\n                hashCodeValue = getKey().hashCode() ^ getValue().hashCode();\r\n                calculatedHashCode = true;\r\n            }\r\n            return hashCodeValue;\r\n        }\r\n    \r\n        /**\r\n         * Is this node black?\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         * @return true if black (which is represented as a true boolean)\r\n         */\r\n        private boolean isBlack(final DataElement dataElement) {\r\n            return blackColor[dataElement.ordinal()];\r\n        }\r\n    \r\n        private boolean isLeftChild(final DataElement dataElement) {\r\n            return (parentNode[dataElement.ordinal()] != null) && (parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this);\r\n        }\r\n    \r\n        /**\r\n         * Is this node red?\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         * @return true if non-black\r\n         */\r\n        private boolean isRed(final DataElement dataElement) {\r\n            return !blackColor[dataElement.ordinal()];\r\n        }\r\n    \r\n        private boolean isRightChild(final DataElement dataElement) {\r\n            return (parentNode[dataElement.ordinal()] != null) && (parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this);\r\n        }\r\n    \r\n        /**\r\n         * Makes this node black.\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void setBlack(final DataElement dataElement) {\r\n            blackColor[dataElement.ordinal()] = true;\r\n        }\r\n    \r\n        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\r\n            leftNode[dataElement.ordinal()] = node;\r\n        }\r\n    \r\n        /**\r\n         * Sets this node's parent node.\r\n         *\r\n         * @param node\r\n         * \t\tthe new parent node\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void setParent(final Node<K, V> node, final DataElement dataElement) {\r\n            parentNode[dataElement.ordinal()] = node;\r\n        }\r\n    \r\n        /**\r\n         * Makes this node red.\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void setRed(final DataElement dataElement) {\r\n            blackColor[dataElement.ordinal()] = false;\r\n        }\r\n    \r\n        private void setRight(final Node<K, V> node, final DataElement dataElement) {\r\n            rightNode[dataElement.ordinal()] = node;\r\n        }\r\n    \r\n        /**\r\n         * Optional operation that is not permitted in this implementation.\r\n         *\r\n         * @param ignored\r\n         * \t\tthis parameter is ignored.\r\n         * @return does not return\r\n         * @throws UnsupportedOperationException\r\n         * \t\talways\r\n         */\r\n        @Override\r\n        public V setValue(final V ignored) throws UnsupportedOperationException {\r\n            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\r\n        }\r\n    \r\n        /**\r\n         * Exchanges colors with another node.\r\n         *\r\n         * @param node\r\n         * \t\tthe node to swap with\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\r\n            // Swap colors -- old hacker's trick\r\n            blackColor[dataElement.ordinal()] ^= node.blackColor[dataElement.ordinal()];\r\n            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\r\n            blackColor[dataElement.ordinal()] ^= node.blackColor[dataElement.ordinal()];\r\n        }\r\n    }\nprivate void doRedBlackDelete(final Node<K, V> deletedNode) {\r\n        for (final DataElement dataElement : DataElement.values()) {\r\n            // if deleted node has both left and children, swap with\r\n            // the next greater node\r\n            if ((deletedNode.getLeft(dataElement) != null) && (deletedNode.getRight(dataElement) != null)) {\r\n                swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);\r\n            }\r\n            final Node<K, V> replacement = (deletedNode.getLeft(dataElement) != null) ? deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);\r\n            if (replacement != null) {\r\n                replacement.setParent(deletedNode.getParent(dataElement), dataElement);\r\n                if (deletedNode.getParent(dataElement) == null) {\r\n                    rootNode[dataElement.ordinal()] = replacement;\r\n                } else if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\r\n                    deletedNode.getParent(dataElement).setLeft(replacement, dataElement);\r\n                } else {\r\n                    deletedNode.getParent(dataElement).setRight(replacement, dataElement);\r\n                }\r\n                deletedNode.setLeft(null, dataElement);\r\n                deletedNode.setRight(null, dataElement);\r\n                deletedNode.setParent(null, dataElement);\r\n                if (isBlack(deletedNode, dataElement)) {\r\n                    doRedBlackDeleteFixup(replacement, dataElement);\r\n                }\r\n            } else // replacement is null\r\n            if (deletedNode.getParent(dataElement) == null) {\r\n                // empty tree\r\n                rootNode[dataElement.ordinal()] = null;\r\n            } else {\r\n                // deleted node had no children\r\n                if (isBlack(deletedNode, dataElement)) {\r\n                    doRedBlackDeleteFixup(deletedNode, dataElement);\r\n                }\r\n                if (deletedNode.getParent(dataElement) != null) {\r\n                    if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\r\n                        deletedNode.getParent(dataElement).setLeft(null, dataElement);\r\n                    } else {\r\n                        deletedNode.getParent(dataElement).setRight(null, dataElement);\r\n                    }\r\n                    deletedNode.setParent(null, dataElement);\r\n                }\r\n            }\r\n        }\r\n        shrink();\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\npublic boolean containsKey(final Object key);\n    @Override\r\npublic boolean containsValue(final Object value);\n    private void doRedBlackDeleteFixup(final Node<K, V> replacementNode, final DataElement dataElement);\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic boolean equals(final Object obj);\n    @Override\r\npublic K firstKey();\n    @Override\r\npublic V get(final Object key);\n    @Override\r\npublic K getKey(final Object value);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic OrderedBidiMap<V, K> inverseBidiMap();\n    private static boolean isBlack(final Node<?, ?> node, final DataElement dataElement);\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic K lastKey();\n    @Override\r\npublic OrderedMapIterator<K, V> mapIterator();\n    private Node<K, V> nextGreater(final Node<K, V> node, final DataElement dataElement);\n    @Override\r\npublic K nextKey(final K key);\n    @Override\r\npublic K previousKey(final K key);\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic V remove(final Object key);\n    @Override\r\npublic K removeValue(final Object value);\n    private void shrink();\n    @Override\r\npublic int size();\n    private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement);\n    @Override\r\npublic String toString();\n    @Override\r\npublic Set<V> values();\n}"
      },
      {
        "id": "TreeBidiMap_swapPosition",
        "package": "org.apache.commons.collections4.bidimap",
        "class": "org.apache.commons.collections4.bidimap.TreeBidiMap",
        "test-class": "org.apache.commons.collections4.bidimap.TreeBidiMap_swapPosition_Test",
        "method-name": "swapPosition(Node<K, V>, Node<K, V>, DataElement)",
        "source-path": "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java",
        "test-path": "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMap_swapPosition_Test.java",
        "focal-method": "private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement) {\r\n    // Save initial values.\r\n    final Node<K, V> xFormerParent = x.getParent(dataElement);\r\n    final Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\r\n    final Node<K, V> xFormerRightChild = x.getRight(dataElement);\r\n    final Node<K, V> yFormerParent = y.getParent(dataElement);\r\n    final Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\r\n    final Node<K, V> yFormerRightChild = y.getRight(dataElement);\r\n    final boolean xWasLeftChild = (x.getParent(dataElement) != null) && (x == x.getParent(dataElement).getLeft(dataElement));\r\n    final boolean yWasLeftChild = (y.getParent(dataElement) != null) && (y == y.getParent(dataElement).getLeft(dataElement));\r\n    // Swap, handling special cases of one being the other's parent.\r\n    if (x == yFormerParent) {\r\n        // x was y's parent\r\n        x.setParent(y, dataElement);\r\n        if (yWasLeftChild) {\r\n            y.setLeft(x, dataElement);\r\n            y.setRight(xFormerRightChild, dataElement);\r\n        } else {\r\n            y.setRight(x, dataElement);\r\n            y.setLeft(xFormerLeftChild, dataElement);\r\n        }\r\n    } else {\r\n        x.setParent(yFormerParent, dataElement);\r\n        if (yFormerParent != null) {\r\n            if (yWasLeftChild) {\r\n                yFormerParent.setLeft(x, dataElement);\r\n            } else {\r\n                yFormerParent.setRight(x, dataElement);\r\n            }\r\n        }\r\n        y.setLeft(xFormerLeftChild, dataElement);\r\n        y.setRight(xFormerRightChild, dataElement);\r\n    }\r\n    if (y == xFormerParent) {\r\n        // y was x's parent\r\n        y.setParent(x, dataElement);\r\n        if (xWasLeftChild) {\r\n            x.setLeft(y, dataElement);\r\n            x.setRight(yFormerRightChild, dataElement);\r\n        } else {\r\n            x.setRight(y, dataElement);\r\n            x.setLeft(yFormerLeftChild, dataElement);\r\n        }\r\n    } else {\r\n        y.setParent(xFormerParent, dataElement);\r\n        if (xFormerParent != null) {\r\n            if (xWasLeftChild) {\r\n                xFormerParent.setLeft(y, dataElement);\r\n            } else {\r\n                xFormerParent.setRight(y, dataElement);\r\n            }\r\n        }\r\n        x.setLeft(yFormerLeftChild, dataElement);\r\n        x.setRight(yFormerRightChild, dataElement);\r\n    }\r\n    // Fix children's parent pointers\r\n    if (x.getLeft(dataElement) != null) {\r\n        x.getLeft(dataElement).setParent(x, dataElement);\r\n    }\r\n    if (x.getRight(dataElement) != null) {\r\n        x.getRight(dataElement).setParent(x, dataElement);\r\n    }\r\n    if (y.getLeft(dataElement) != null) {\r\n        y.getLeft(dataElement).setParent(y, dataElement);\r\n    }\r\n    if (y.getRight(dataElement) != null) {\r\n        y.getRight(dataElement).setParent(y, dataElement);\r\n    }\r\n    x.swapColors(y, dataElement);\r\n    // Check if root changed\r\n    if (rootNode[dataElement.ordinal()] == x) {\r\n        rootNode[dataElement.ordinal()] = y;\r\n    } else if (rootNode[dataElement.ordinal()] == y) {\r\n        rootNode[dataElement.ordinal()] = x;\r\n    }\r\n}",
        "class-code": "package org.apache.commons.collections4.bidimap;\nimport org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\nimport static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.KEY;\nimport java.util.Set;\nimport org.apache.commons.collections4.KeyValue;\nimport java.util.ConcurrentModificationException;\nimport static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.VALUE;\nimport java.io.IOException;\nimport org.apache.commons.collections4.OrderedBidiMap;\nimport java.util.AbstractSet;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.keyvalue.UnmodifiableMapEntry;\nimport org.apache.commons.collections4.MapIterator;\nimport java.io.ObjectInputStream;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\nimport org.apache.commons.collections4.OrderedIterator;\npublic class TreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> implements OrderedBidiMap<K, V> , Serializable {\n    private transient Node<K, V>[] rootNode;\n        /**\r\n     * A node used to store the data.\r\n     */\r\n    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V> , KeyValue<K, V> {\r\n        private final K key;\r\n    \r\n        private final V value;\r\n    \r\n        private final Node<K, V>[] leftNode;\r\n    \r\n        private final Node<K, V>[] rightNode;\r\n    \r\n        private final Node<K, V>[] parentNode;\r\n    \r\n        private final boolean[] blackColor;\r\n    \r\n        private int hashCodeValue;\r\n    \r\n        private boolean calculatedHashCode;\r\n    \r\n        /**\r\n         * Makes a new cell with given key and value, and with null\r\n         * links, and black (true) colors.\r\n         *\r\n         * @param key\r\n         * \t\tthe key of this node\r\n         * @param value\r\n         * \t\tthe value of this node\r\n         */\r\n        @SuppressWarnings(\"unchecked\")\r\n        Node(final K key, final V value) {\r\n            this.key = key;\r\n            this.value = value;\r\n            leftNode = new Node[2];\r\n            rightNode = new Node[2];\r\n            parentNode = new Node[2];\r\n            blackColor = new boolean[]{ true, true };\r\n            calculatedHashCode = false;\r\n        }\r\n    \r\n        /**\r\n         * Makes this node the same color as another.\r\n         *\r\n         * @param node\r\n         * \t\tthe node whose color we're adopting\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\r\n            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\r\n        }\r\n    \r\n        /**\r\n         * Compares the specified object with this entry for equality.\r\n         * Returns true if the given object is also a map entry and\r\n         * the two entries represent the same mapping.\r\n         *\r\n         * @param obj\r\n         * \t\tthe object to be compared for equality with this entry.\r\n         * @return true if the specified object is equal to this entry.\r\n         */\r\n        @Override\r\n        public boolean equals(final Object obj) {\r\n            if (obj == this) {\r\n                return true;\r\n            }\r\n            if (!(obj instanceof Map.Entry)) {\r\n                return false;\r\n            }\r\n            final Map.Entry<?, ?> e = ((Map.Entry<?, ?>) (obj));\r\n            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\r\n        }\r\n    \r\n        private Object getData(final DataElement dataElement) {\r\n            switch (dataElement) {\r\n                case KEY :\r\n                    return getKey();\r\n                case VALUE :\r\n                    return getValue();\r\n                default :\r\n                    throw new IllegalArgumentException();\r\n            }\r\n        }\r\n    \r\n        /**\r\n         * Gets the key.\r\n         *\r\n         * @return the key corresponding to this entry.\r\n         */\r\n        @Override\r\n        public K getKey() {\r\n            return key;\r\n        }\r\n    \r\n        private Node<K, V> getLeft(final DataElement dataElement) {\r\n            return leftNode[dataElement.ordinal()];\r\n        }\r\n    \r\n        /**\r\n         * Gets the parent node.\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         * @return the parent node, may be null\r\n         */\r\n        private Node<K, V> getParent(final DataElement dataElement) {\r\n            return parentNode[dataElement.ordinal()];\r\n        }\r\n    \r\n        private Node<K, V> getRight(final DataElement dataElement) {\r\n            return rightNode[dataElement.ordinal()];\r\n        }\r\n    \r\n        /**\r\n         * Gets the value.\r\n         *\r\n         * @return the value corresponding to this entry.\r\n         */\r\n        @Override\r\n        public V getValue() {\r\n            return value;\r\n        }\r\n    \r\n        /**\r\n         *\r\n         * @return the hash code value for this map entry.\r\n         */\r\n        @Override\r\n        public int hashCode() {\r\n            if (!calculatedHashCode) {\r\n                hashCodeValue = getKey().hashCode() ^ getValue().hashCode();\r\n                calculatedHashCode = true;\r\n            }\r\n            return hashCodeValue;\r\n        }\r\n    \r\n        /**\r\n         * Is this node black?\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         * @return true if black (which is represented as a true boolean)\r\n         */\r\n        private boolean isBlack(final DataElement dataElement) {\r\n            return blackColor[dataElement.ordinal()];\r\n        }\r\n    \r\n        private boolean isLeftChild(final DataElement dataElement) {\r\n            return (parentNode[dataElement.ordinal()] != null) && (parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this);\r\n        }\r\n    \r\n        /**\r\n         * Is this node red?\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         * @return true if non-black\r\n         */\r\n        private boolean isRed(final DataElement dataElement) {\r\n            return !blackColor[dataElement.ordinal()];\r\n        }\r\n    \r\n        private boolean isRightChild(final DataElement dataElement) {\r\n            return (parentNode[dataElement.ordinal()] != null) && (parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this);\r\n        }\r\n    \r\n        /**\r\n         * Makes this node black.\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void setBlack(final DataElement dataElement) {\r\n            blackColor[dataElement.ordinal()] = true;\r\n        }\r\n    \r\n        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\r\n            leftNode[dataElement.ordinal()] = node;\r\n        }\r\n    \r\n        /**\r\n         * Sets this node's parent node.\r\n         *\r\n         * @param node\r\n         * \t\tthe new parent node\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void setParent(final Node<K, V> node, final DataElement dataElement) {\r\n            parentNode[dataElement.ordinal()] = node;\r\n        }\r\n    \r\n        /**\r\n         * Makes this node red.\r\n         *\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void setRed(final DataElement dataElement) {\r\n            blackColor[dataElement.ordinal()] = false;\r\n        }\r\n    \r\n        private void setRight(final Node<K, V> node, final DataElement dataElement) {\r\n            rightNode[dataElement.ordinal()] = node;\r\n        }\r\n    \r\n        /**\r\n         * Optional operation that is not permitted in this implementation.\r\n         *\r\n         * @param ignored\r\n         * \t\tthis parameter is ignored.\r\n         * @return does not return\r\n         * @throws UnsupportedOperationException\r\n         * \t\talways\r\n         */\r\n        @Override\r\n        public V setValue(final V ignored) throws UnsupportedOperationException {\r\n            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\r\n        }\r\n    \r\n        /**\r\n         * Exchanges colors with another node.\r\n         *\r\n         * @param node\r\n         * \t\tthe node to swap with\r\n         * @param dataElement\r\n         * \t\teither the {@link DataElement#KEY key}\r\n         * \t\tor the {@link DataElement#VALUE value}.\r\n         */\r\n        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\r\n            // Swap colors -- old hacker's trick\r\n            blackColor[dataElement.ordinal()] ^= node.blackColor[dataElement.ordinal()];\r\n            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\r\n            blackColor[dataElement.ordinal()] ^= node.blackColor[dataElement.ordinal()];\r\n        }\r\n    }\nprivate void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement) {\r\n        // Save initial values.\r\n        final Node<K, V> xFormerParent = x.getParent(dataElement);\r\n        final Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\r\n        final Node<K, V> xFormerRightChild = x.getRight(dataElement);\r\n        final Node<K, V> yFormerParent = y.getParent(dataElement);\r\n        final Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\r\n        final Node<K, V> yFormerRightChild = y.getRight(dataElement);\r\n        final boolean xWasLeftChild = (x.getParent(dataElement) != null) && (x == x.getParent(dataElement).getLeft(dataElement));\r\n        final boolean yWasLeftChild = (y.getParent(dataElement) != null) && (y == y.getParent(dataElement).getLeft(dataElement));\r\n        // Swap, handling special cases of one being the other's parent.\r\n        if (x == yFormerParent) {\r\n            // x was y's parent\r\n            x.setParent(y, dataElement);\r\n            if (yWasLeftChild) {\r\n                y.setLeft(x, dataElement);\r\n                y.setRight(xFormerRightChild, dataElement);\r\n            } else {\r\n                y.setRight(x, dataElement);\r\n                y.setLeft(xFormerLeftChild, dataElement);\r\n            }\r\n        } else {\r\n            x.setParent(yFormerParent, dataElement);\r\n            if (yFormerParent != null) {\r\n                if (yWasLeftChild) {\r\n                    yFormerParent.setLeft(x, dataElement);\r\n                } else {\r\n                    yFormerParent.setRight(x, dataElement);\r\n                }\r\n            }\r\n            y.setLeft(xFormerLeftChild, dataElement);\r\n            y.setRight(xFormerRightChild, dataElement);\r\n        }\r\n        if (y == xFormerParent) {\r\n            // y was x's parent\r\n            y.setParent(x, dataElement);\r\n            if (xWasLeftChild) {\r\n                x.setLeft(y, dataElement);\r\n                x.setRight(yFormerRightChild, dataElement);\r\n            } else {\r\n                x.setRight(y, dataElement);\r\n                x.setLeft(yFormerLeftChild, dataElement);\r\n            }\r\n        } else {\r\n            y.setParent(xFormerParent, dataElement);\r\n            if (xFormerParent != null) {\r\n                if (xWasLeftChild) {\r\n                    xFormerParent.setLeft(y, dataElement);\r\n                } else {\r\n                    xFormerParent.setRight(y, dataElement);\r\n                }\r\n            }\r\n            x.setLeft(yFormerLeftChild, dataElement);\r\n            x.setRight(yFormerRightChild, dataElement);\r\n        }\r\n        // Fix children's parent pointers\r\n        if (x.getLeft(dataElement) != null) {\r\n            x.getLeft(dataElement).setParent(x, dataElement);\r\n        }\r\n        if (x.getRight(dataElement) != null) {\r\n            x.getRight(dataElement).setParent(x, dataElement);\r\n        }\r\n        if (y.getLeft(dataElement) != null) {\r\n            y.getLeft(dataElement).setParent(y, dataElement);\r\n        }\r\n        if (y.getRight(dataElement) != null) {\r\n            y.getRight(dataElement).setParent(y, dataElement);\r\n        }\r\n        x.swapColors(y, dataElement);\r\n        // Check if root changed\r\n        if (rootNode[dataElement.ordinal()] == x) {\r\n            rootNode[dataElement.ordinal()] = y;\r\n        } else if (rootNode[dataElement.ordinal()] == y) {\r\n            rootNode[dataElement.ordinal()] = x;\r\n        }\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\npublic boolean containsKey(final Object key);\n    @Override\r\npublic boolean containsValue(final Object value);\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic boolean equals(final Object obj);\n    @Override\r\npublic K firstKey();\n    @Override\r\npublic V get(final Object key);\n    @Override\r\npublic K getKey(final Object value);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic OrderedBidiMap<V, K> inverseBidiMap();\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic K lastKey();\n    @Override\r\npublic OrderedMapIterator<K, V> mapIterator();\n    @Override\r\npublic K nextKey(final K key);\n    @Override\r\npublic K previousKey(final K key);\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic V remove(final Object key);\n    @Override\r\npublic K removeValue(final Object value);\n    @Override\r\npublic int size();\n    @Override\r\npublic String toString();\n    @Override\r\npublic Set<V> values();\n}"
      },
      {
        "id": "Flat3Map_put",
        "package": "org.apache.commons.collections4.map",
        "class": "org.apache.commons.collections4.map.Flat3Map",
        "test-class": "org.apache.commons.collections4.map.Flat3Map_put_Test",
        "method-name": "put(K, V)",
        "source-path": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java",
        "test-path": "src/test/java/org/apache/commons/collections4/map/Flat3Map_put_Test.java",
        "focal-method": "@Override\r\npublic V put(final K key, final V value) {\r\n    if (delegateMap != null) {\r\n        return delegateMap.put(key, value);\r\n    }\r\n    // change existing mapping\r\n    if (key == null) {\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if (key3 == null) {\r\n                    final V old = value3;\r\n                    value3 = value;\r\n                    return old;\r\n                }\r\n            case 2 :\r\n                if (key2 == null) {\r\n                    final V old = value2;\r\n                    value2 = value;\r\n                    return old;\r\n                }\r\n            case 1 :\r\n                if (key1 == null) {\r\n                    final V old = value1;\r\n                    value1 = value;\r\n                    return old;\r\n                }\r\n        }\r\n    } else if (size > 0) {\r\n        final int hashCode = key.hashCode();\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if ((hash3 == hashCode) && key.equals(key3)) {\r\n                    final V old = value3;\r\n                    value3 = value;\r\n                    return old;\r\n                }\r\n            case 2 :\r\n                if ((hash2 == hashCode) && key.equals(key2)) {\r\n                    final V old = value2;\r\n                    value2 = value;\r\n                    return old;\r\n                }\r\n            case 1 :\r\n                if ((hash1 == hashCode) && key.equals(key1)) {\r\n                    final V old = value1;\r\n                    value1 = value;\r\n                    return old;\r\n                }\r\n        }\r\n    }\r\n    // add new mapping\r\n    switch (size) {\r\n        default :\r\n            convertToMap();\r\n            delegateMap.put(key, value);\r\n            return null;\r\n        case 2 :\r\n            hash3 = (key == null) ? 0 : key.hashCode();\r\n            key3 = key;\r\n            value3 = value;\r\n            break;\r\n        case 1 :\r\n            hash2 = (key == null) ? 0 : key.hashCode();\r\n            key2 = key;\r\n            value2 = value;\r\n            break;\r\n        case 0 :\r\n            hash1 = (key == null) ? 0 : key.hashCode();\r\n            key1 = key;\r\n            value1 = value;\r\n            break;\r\n    }\r\n    size++;\r\n    return null;\r\n}",
        "class-code": "package org.apache.commons.collections4.map;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport java.util.Set;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport org.apache.commons.collections4.ResettableIterator;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapIterator;\nimport org.apache.commons.collections4.IterableMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\npublic class Flat3Map<K, V> implements IterableMap<K, V> , Serializable , Cloneable {\n    private transient int size;\n    private transient int hash1;\n    private transient int hash2;\n    private transient int hash3;\n    private transient K key1;\n    private transient K key2;\n    private transient K key3;\n    private transient V value1;\n    private transient V value2;\n    private transient V value3;\n    private transient AbstractHashedMap<K, V> delegateMap;\n    @Override\r\n    public V put(final K key, final V value) {\r\n        if (delegateMap != null) {\r\n            return delegateMap.put(key, value);\r\n        }\r\n        // change existing mapping\r\n        if (key == null) {\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if (key3 == null) {\r\n                        final V old = value3;\r\n                        value3 = value;\r\n                        return old;\r\n                    }\r\n                case 2 :\r\n                    if (key2 == null) {\r\n                        final V old = value2;\r\n                        value2 = value;\r\n                        return old;\r\n                    }\r\n                case 1 :\r\n                    if (key1 == null) {\r\n                        final V old = value1;\r\n                        value1 = value;\r\n                        return old;\r\n                    }\r\n            }\r\n        } else if (size > 0) {\r\n            final int hashCode = key.hashCode();\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if ((hash3 == hashCode) && key.equals(key3)) {\r\n                        final V old = value3;\r\n                        value3 = value;\r\n                        return old;\r\n                    }\r\n                case 2 :\r\n                    if ((hash2 == hashCode) && key.equals(key2)) {\r\n                        final V old = value2;\r\n                        value2 = value;\r\n                        return old;\r\n                    }\r\n                case 1 :\r\n                    if ((hash1 == hashCode) && key.equals(key1)) {\r\n                        final V old = value1;\r\n                        value1 = value;\r\n                        return old;\r\n                    }\r\n            }\r\n        }\r\n        // add new mapping\r\n        switch (size) {\r\n            default :\r\n                convertToMap();\r\n                delegateMap.put(key, value);\r\n                return null;\r\n            case 2 :\r\n                hash3 = (key == null) ? 0 : key.hashCode();\r\n                key3 = key;\r\n                value3 = value;\r\n                break;\r\n            case 1 :\r\n                hash2 = (key == null) ? 0 : key.hashCode();\r\n                key2 = key;\r\n                value2 = value;\r\n                break;\r\n            case 0 :\r\n                hash1 = (key == null) ? 0 : key.hashCode();\r\n                key1 = key;\r\n                value1 = value;\r\n                break;\r\n        }\r\n        size++;\r\n        return null;\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Flat3Map<K, V> clone();\n    @Override\r\npublic boolean containsKey(final Object key);\n    @Override\r\npublic boolean containsValue(final Object value);\n    private void convertToMap();\n    protected AbstractHashedMap<K, V> createDelegateMap();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic boolean equals(final Object obj);\n    @Override\r\npublic V get(final Object key);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic MapIterator<K, V> mapIterator();\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic V remove(final Object key);\n    @Override\r\npublic int size();\n    @Override\r\npublic String toString();\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "AbstractPatriciaTrie_higherEntry",
        "package": "org.apache.commons.collections4.trie",
        "class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie",
        "test-class": "org.apache.commons.collections4.trie.AbstractPatriciaTrie_higherEntry_Test",
        "method-name": "higherEntry(K)",
        "source-path": "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java",
        "test-path": "src/test/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie_higherEntry_Test.java",
        "focal-method": "TrieEntry<K, V> higherEntry(final K key) {\r\n    // TODO: Cleanup so that we don't actually have to add/remove from the\r\n    // tree.  (We do it here because there are other well-defined\r\n    // functions to perform the search.)\r\n    final int lengthInBits = lengthInBits(key);\r\n    if (lengthInBits == 0) {\r\n        if (!root.isEmpty()) {\r\n            // If data in root, and more after -- return it.\r\n            if (size() > 1) {\r\n                return nextEntry(root);\r\n            }\r\n            // If no more after, no higher entry.\r\n            return null;\r\n        }\r\n        // Root is empty & we want something after empty, return first.\r\n        return firstEntry();\r\n    }\r\n    final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\r\n    if (compareKeys(key, found.key)) {\r\n        return nextEntry(found);\r\n    }\r\n    final int bitIndex = bitIndex(key, found.key);\r\n    if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\r\n        final TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);\r\n        addEntry(added, lengthInBits);\r\n        incrementSize();// must increment because remove will decrement\r\n\r\n        final TrieEntry<K, V> ceil = nextEntry(added);\r\n        removeEntry(added);\r\n        modCount -= 2;// we didn't really modify it.\r\n\r\n        return ceil;\r\n    }\r\n    if (KeyAnalyzer.isNullBitKey(bitIndex)) {\r\n        if (!root.isEmpty()) {\r\n            return firstEntry();\r\n        }\r\n        if (size() > 1) {\r\n            return nextEntry(firstEntry());\r\n        }\r\n        return null;\r\n    }\r\n    if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\r\n        return nextEntry(found);\r\n    }\r\n    // we should have exited above.\r\n    throw new IllegalStateException(\"invalid lookup: \" + key);\r\n}",
        "class-code": "package org.apache.commons.collections4.trie;\nimport java.util.Set;\nimport java.util.ConcurrentModificationException;\nimport java.io.IOException;\nimport java.util.SortedMap;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport java.util.Comparator;\nimport java.util.AbstractMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport org.apache.commons.collections4.Trie;\nimport java.util.Collections;\npublic abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n    private transient TrieEntry<K, V> root = new TrieEntry<>(null, null, -1);\n    protected transient int modCount;\n        /**\r\n     * A {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.\r\n     */\r\n    protected static class TrieEntry<K, V> extends BasicEntry<K, V> {\r\n        private static final long serialVersionUID = 4596023148184140013L;\r\n    \r\n        /**\r\n         * The index this entry is comparing.\r\n         */\r\n        protected int bitIndex;\r\n    \r\n        /**\r\n         * The parent of this entry.\r\n         */\r\n        protected TrieEntry<K, V> parent;\r\n    \r\n        /**\r\n         * The left child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> left;\r\n    \r\n        /**\r\n         * The right child of this entry.\r\n         */\r\n        protected TrieEntry<K, V> right;\r\n    \r\n        /**\r\n         * The entry who uplinks to this entry.\r\n         */\r\n        protected TrieEntry<K, V> predecessor;\r\n    \r\n        public TrieEntry(final K key, final V value, final int bitIndex) {\r\n            super(key, value);\r\n            this.bitIndex = bitIndex;\r\n            this.parent = null;\r\n            this.left = this;\r\n            this.right = null;\r\n            this.predecessor = this;\r\n        }\r\n    \r\n        /**\r\n         * Whether or not the entry is storing a key.\r\n         * Only the root can potentially be empty, all other\r\n         * nodes must have a key.\r\n         */\r\n        public boolean isEmpty() {\r\n            return key == null;\r\n        }\r\n    \r\n        /**\r\n         * Either the left or right child is a loopback.\r\n         */\r\n        public boolean isExternalNode() {\r\n            return !isInternalNode();\r\n        }\r\n    \r\n        /**\r\n         * Neither the left nor right child is a loopback.\r\n         */\r\n        public boolean isInternalNode() {\r\n            return (left != this) && (right != this);\r\n        }\r\n    \r\n        @Override\r\n        public String toString() {\r\n            final StringBuilder buffer = new StringBuilder();\r\n            if (bitIndex == (-1)) {\r\n                buffer.append(\"RootEntry(\");\r\n            } else {\r\n                buffer.append(\"Entry(\");\r\n            }\r\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\r\n            buffer.append(\"value=\").append(getValue()).append(\", \");\r\n            // buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\r\n            if (parent != null) {\r\n                if (parent.bitIndex == (-1)) {\r\n                    buffer.append(\"parent=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"parent=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (left != null) {\r\n                if (left.bitIndex == (-1)) {\r\n                    buffer.append(\"left=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"left=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (right != null) {\r\n                if (right.bitIndex == (-1)) {\r\n                    buffer.append(\"right=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\r\n                }\r\n            } else {\r\n                buffer.append(\"right=\").append(\"null\");\r\n            }\r\n            buffer.append(\", \");\r\n            if (predecessor != null) {\r\n                if (predecessor.bitIndex == (-1)) {\r\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\r\n                } else {\r\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").append(predecessor.bitIndex).append(\"]\");\r\n                }\r\n            }\r\n            buffer.append(\")\");\r\n            return buffer.toString();\r\n        }\r\n    }\nTrieEntry<K, V> higherEntry(final K key) {\r\n        // TODO: Cleanup so that we don't actually have to add/remove from the\r\n        // tree.  (We do it here because there are other well-defined\r\n        // functions to perform the search.)\r\n        final int lengthInBits = lengthInBits(key);\r\n        if (lengthInBits == 0) {\r\n            if (!root.isEmpty()) {\r\n                // If data in root, and more after -- return it.\r\n                if (size() > 1) {\r\n                    return nextEntry(root);\r\n                }\r\n                // If no more after, no higher entry.\r\n                return null;\r\n            }\r\n            // Root is empty & we want something after empty, return first.\r\n            return firstEntry();\r\n        }\r\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\r\n        if (compareKeys(key, found.key)) {\r\n            return nextEntry(found);\r\n        }\r\n        final int bitIndex = bitIndex(key, found.key);\r\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\r\n            final TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);\r\n            addEntry(added, lengthInBits);\r\n            incrementSize();// must increment because remove will decrement\r\n    \r\n            final TrieEntry<K, V> ceil = nextEntry(added);\r\n            removeEntry(added);\r\n            modCount -= 2;// we didn't really modify it.\r\n    \r\n            return ceil;\r\n        }\r\n        if (KeyAnalyzer.isNullBitKey(bitIndex)) {\r\n            if (!root.isEmpty()) {\r\n                return firstEntry();\r\n            }\r\n            if (size() > 1) {\r\n                return nextEntry(firstEntry());\r\n            }\r\n            return null;\r\n        }\r\n        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\r\n            return nextEntry(found);\r\n        }\r\n        // we should have exited above.\r\n        throw new IllegalStateException(\"invalid lookup: \" + key);\r\n    }\nTrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits);\n    TrieEntry<K, V> ceilingEntry(final K key);\n    @Override\r\npublic void clear();\n    @Override\r\npublic Comparator<? super K> comparator();\n    @Override\r\npublic boolean containsKey(final Object k);\n    void decrementSize();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    TrieEntry<K, V> firstEntry();\n    @Override\r\npublic K firstKey();\n    TrieEntry<K, V> floorEntry(final K key);\n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node);\n    TrieEntry<K, V> followRight(TrieEntry<K, V> node);\n    @Override\r\npublic V get(final Object k);\n    TrieEntry<K, V> getEntry(final Object k);\n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> headMap(final K toKey);\n    void incrementSize();\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from);\n    @Override\r\npublic Set<K> keySet();\n    TrieEntry<K, V> lastEntry();\n    @Override\r\npublic K lastKey();\n    TrieEntry<K, V> lowerEntry(final K key);\n    @Override\r\npublic OrderedMapIterator<K, V> mapIterator();\n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node);\n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, final TrieEntry<K, V> previous, final TrieEntry<K, V> tree);\n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, final TrieEntry<K, V> parentOfSubtree);\n    @Override\r\npublic K nextKey(final K key);\n    @Override\r\npublic SortedMap<K, V> prefixMap(final K key);\n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start);\n    @Override\r\npublic K previousKey(final K key);\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic V remove(final Object k);\n    V removeEntry(final TrieEntry<K, V> h);\n    public Map.Entry<K, V> select(final K key);\n    public K selectKey(final K key);\n    public V selectValue(final K key);\n    @Override\r\npublic int size();\n    @Override\r\npublic SortedMap<K, V> subMap(final K fromKey, final K toKey);\n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits);\n    @Override\r\npublic SortedMap<K, V> tailMap(final K fromKey);\n    @Override\r\npublic Collection<V> values();\n}"
      },
      {
        "id": "Flat3Map_containsValue",
        "package": "org.apache.commons.collections4.map",
        "class": "org.apache.commons.collections4.map.Flat3Map",
        "test-class": "org.apache.commons.collections4.map.Flat3Map_containsValue_Test",
        "method-name": "containsValue(Object)",
        "source-path": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java",
        "test-path": "src/test/java/org/apache/commons/collections4/map/Flat3Map_containsValue_Test.java",
        "focal-method": "@Override\r\npublic boolean containsValue(final Object value) {\r\n    if (delegateMap != null) {\r\n        return delegateMap.containsValue(value);\r\n    }\r\n    if (value == null) {\r\n        // drop through\r\n        switch (size) {\r\n            case 3 :\r\n                if (value3 == null) {\r\n                    return true;\r\n                }\r\n            case 2 :\r\n                if (value2 == null) {\r\n                    return true;\r\n                }\r\n            case 1 :\r\n                if (value1 == null) {\r\n                    return true;\r\n                }\r\n        }\r\n    } else {\r\n        switch (size) {\r\n            // drop through\r\n            case 3 :\r\n                if (value.equals(value3)) {\r\n                    return true;\r\n                }\r\n            case 2 :\r\n                if (value.equals(value2)) {\r\n                    return true;\r\n                }\r\n            case 1 :\r\n                if (value.equals(value1)) {\r\n                    return true;\r\n                }\r\n        }\r\n    }\r\n    return false;\r\n}",
        "class-code": "package org.apache.commons.collections4.map;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport java.util.Set;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport org.apache.commons.collections4.ResettableIterator;\nimport java.io.ObjectOutputStream;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.MapIterator;\nimport org.apache.commons.collections4.IterableMap;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\npublic class Flat3Map<K, V> implements IterableMap<K, V> , Serializable , Cloneable {\n    private transient int size;\n    private transient V value1;\n    private transient V value2;\n    private transient V value3;\n    private transient AbstractHashedMap<K, V> delegateMap;\n    @Override\r\n    public boolean containsValue(final Object value) {\r\n        if (delegateMap != null) {\r\n            return delegateMap.containsValue(value);\r\n        }\r\n        if (value == null) {\r\n            // drop through\r\n            switch (size) {\r\n                case 3 :\r\n                    if (value3 == null) {\r\n                        return true;\r\n                    }\r\n                case 2 :\r\n                    if (value2 == null) {\r\n                        return true;\r\n                    }\r\n                case 1 :\r\n                    if (value1 == null) {\r\n                        return true;\r\n                    }\r\n            }\r\n        } else {\r\n            switch (size) {\r\n                // drop through\r\n                case 3 :\r\n                    if (value.equals(value3)) {\r\n                        return true;\r\n                    }\r\n                case 2 :\r\n                    if (value.equals(value2)) {\r\n                        return true;\r\n                    }\r\n                case 1 :\r\n                    if (value.equals(value1)) {\r\n                        return true;\r\n                    }\r\n            }\r\n        }\r\n        return false;\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Flat3Map<K, V> clone();\n    @Override\r\npublic boolean containsKey(final Object key);\n    protected AbstractHashedMap<K, V> createDelegateMap();\n    @Override\r\npublic Set<Map.Entry<K, V>> entrySet();\n    @Override\r\npublic boolean equals(final Object obj);\n    @Override\r\npublic V get(final Object key);\n    @Override\r\npublic int hashCode();\n    @Override\r\npublic boolean isEmpty();\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic MapIterator<K, V> mapIterator();\n    @Override\r\npublic V put(final K key, final V value);\n    @Override\r\npublic void putAll(final Map<? extends K, ? extends V> map);\n    @Override\r\npublic V remove(final Object key);\n    @Override\r\npublic int size();\n    @Override\r\npublic String toString();\n    @Override\r\npublic Collection<V> values();\n}"
      }
    ]
  },
  "commons-csv": {
    "project-name": "commons-csv",
    "project-url": "commons-csv",
    "focal-methods": [
      {
        "id": "Lexer_parseEncapsulatedToken",
        "package": "org.apache.commons.csv",
        "class": "org.apache.commons.csv.Lexer",
        "test-class": "org.apache.commons.csv.Lexer_parseEncapsulatedToken_Test",
        "method-name": "parseEncapsulatedToken(Token)",
        "source-path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "test-path": "src/test/java/org/apache/commons/csv/Lexer_parseEncapsulatedToken_Test.java",
        "focal-method": "private Token parseEncapsulatedToken(final Token token) throws IOException {\r\n    token.isQuoted = true;\r\n    // save current line number in case needed for IOE\r\n    final long startLineNumber = getCurrentLineNumber();\r\n    int c;\r\n    while (true) {\r\n        c = reader.read();\r\n        if (isEscape(c)) {\r\n            if (isEscapeDelimiter()) {\r\n                token.content.append(delimiter);\r\n            } else {\r\n                final int unescaped = readEscape();\r\n                if (unescaped == END_OF_STREAM) {\r\n                    // unexpected char after escape\r\n                    token.content.append(((char) (c))).append(((char) (reader.getLastChar())));\r\n                } else {\r\n                    token.content.append(((char) (unescaped)));\r\n                }\r\n            }\r\n        } else if (isQuoteChar(c)) {\r\n            if (isQuoteChar(reader.lookAhead())) {\r\n                // double or escaped encapsulator -> add single encapsulator to token\r\n                c = reader.read();\r\n                token.content.append(((char) (c)));\r\n            } else {\r\n                // token finish mark (encapsulator) reached: ignore whitespace till delimiter\r\n                while (true) {\r\n                    c = reader.read();\r\n                    if (isDelimiter(c)) {\r\n                        token.type = TOKEN;\r\n                        return token;\r\n                    }\r\n                    if (isEndOfFile(c)) {\r\n                        token.type = EOF;\r\n                        token.isReady = true;// There is data at EOF\r\n\r\n                        return token;\r\n                    }\r\n                    if (readEndOfLine(c)) {\r\n                        token.type = EORECORD;\r\n                        return token;\r\n                    }\r\n                    if (!Character.isWhitespace(((char) (c)))) {\r\n                        // error invalid char between token and next delimiter\r\n                        throw new IOException((\"(line \" + getCurrentLineNumber()) + \") invalid char between encapsulated token and delimiter\");\r\n                    }\r\n                } \r\n            }\r\n        } else if (isEndOfFile(c)) {\r\n            // error condition (end of file before end of token)\r\n            throw new IOException((\"(startline \" + startLineNumber) + \") EOF reached before encapsulated token finished\");\r\n        } else {\r\n            // consume character\r\n            token.content.append(((char) (c)));\r\n        }\r\n    } \r\n}",
        "class-code": "package org.apache.commons.csv;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nfinal class Lexer implements Closeable {\n    private final char[] delimiter;\n    private final ExtendedBufferedReader reader;\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\r\n        token.isQuoted = true;\r\n        // save current line number in case needed for IOE\r\n        final long startLineNumber = getCurrentLineNumber();\r\n        int c;\r\n        while (true) {\r\n            c = reader.read();\r\n            if (isEscape(c)) {\r\n                if (isEscapeDelimiter()) {\r\n                    token.content.append(delimiter);\r\n                } else {\r\n                    final int unescaped = readEscape();\r\n                    if (unescaped == END_OF_STREAM) {\r\n                        // unexpected char after escape\r\n                        token.content.append(((char) (c))).append(((char) (reader.getLastChar())));\r\n                    } else {\r\n                        token.content.append(((char) (unescaped)));\r\n                    }\r\n                }\r\n            } else if (isQuoteChar(c)) {\r\n                if (isQuoteChar(reader.lookAhead())) {\r\n                    // double or escaped encapsulator -> add single encapsulator to token\r\n                    c = reader.read();\r\n                    token.content.append(((char) (c)));\r\n                } else {\r\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\r\n                    while (true) {\r\n                        c = reader.read();\r\n                        if (isDelimiter(c)) {\r\n                            token.type = TOKEN;\r\n                            return token;\r\n                        }\r\n                        if (isEndOfFile(c)) {\r\n                            token.type = EOF;\r\n                            token.isReady = true;// There is data at EOF\r\n    \r\n                            return token;\r\n                        }\r\n                        if (readEndOfLine(c)) {\r\n                            token.type = EORECORD;\r\n                            return token;\r\n                        }\r\n                        if (!Character.isWhitespace(((char) (c)))) {\r\n                            // error invalid char between token and next delimiter\r\n                            throw new IOException((\"(line \" + getCurrentLineNumber()) + \") invalid char between encapsulated token and delimiter\");\r\n                        }\r\n                    } \r\n                }\r\n            } else if (isEndOfFile(c)) {\r\n                // error condition (end of file before end of token)\r\n                throw new IOException((\"(startline \" + startLineNumber) + \") EOF reached before encapsulated token finished\");\r\n            } else {\r\n                // consume character\r\n                token.content.append(((char) (c)));\r\n            }\r\n        } \r\n    }\n@Override\r\npublic void close() throws IOException;\n    long getCharacterPosition();\n    long getCurrentLineNumber();\n    String getFirstEol();\n    boolean isClosed();\n    boolean isCommentStart(final int ch);\n    boolean isDelimiter(final int ch) throws IOException;\n    boolean isEndOfFile(final int ch);\n    boolean isEscape(final int ch);\n    boolean isEscapeDelimiter() throws IOException;\n    boolean isQuoteChar(final int ch);\n    boolean isStartOfLine(final int ch);\n    Token nextToken(final Token token) throws IOException;\n    boolean readEndOfLine(int ch) throws IOException;\n    int readEscape() throws IOException;\n    void trimTrailingSpaces(final StringBuilder buffer);\n}"
      },
      {
        "id": "Lexer_nextToken",
        "package": "org.apache.commons.csv",
        "class": "org.apache.commons.csv.Lexer",
        "test-class": "org.apache.commons.csv.Lexer_nextToken_Test",
        "method-name": "nextToken(Token)",
        "source-path": "src/main/java/org/apache/commons/csv/Lexer.java",
        "test-path": "src/test/java/org/apache/commons/csv/Lexer_nextToken_Test.java",
        "focal-method": "Token nextToken(final Token token) throws IOException {\r\n    // get the last read char (required for empty line detection)\r\n    int lastChar = reader.getLastChar();\r\n    // read the next char and set eol\r\n    int c = reader.read();\r\n    /* Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\r\n    - they are equivalent here.\r\n     */\r\n    boolean eol = readEndOfLine(c);\r\n    // empty line detection: eol AND (last char was EOL or beginning)\r\n    if (ignoreEmptyLines) {\r\n        while (eol && isStartOfLine(lastChar)) {\r\n            // go on char ahead ...\r\n            lastChar = c;\r\n            c = reader.read();\r\n            eol = readEndOfLine(c);\r\n            // reached end of file without any content (empty line at the end)\r\n            if (isEndOfFile(c)) {\r\n                token.type = EOF;\r\n                // don't set token.isReady here because no content\r\n                return token;\r\n            }\r\n        } \r\n    }\r\n    // did we reach eof during the last iteration already ? EOF\r\n    if (isEndOfFile(lastChar) || ((!isLastTokenDelimiter) && isEndOfFile(c))) {\r\n        token.type = EOF;\r\n        // don't set token.isReady here because no content\r\n        return token;\r\n    }\r\n    if (isStartOfLine(lastChar) && isCommentStart(c)) {\r\n        final String line = reader.readLine();\r\n        if (line == null) {\r\n            token.type = EOF;\r\n            // don't set token.isReady here because no content\r\n            return token;\r\n        }\r\n        final String comment = line.trim();\r\n        token.content.append(comment);\r\n        token.type = COMMENT;\r\n        return token;\r\n    }\r\n    // important: make sure a new char gets consumed in each iteration\r\n    while (token.type == INVALID) {\r\n        // ignore whitespaces at beginning of a token\r\n        if (ignoreSurroundingSpaces) {\r\n            while ((Character.isWhitespace(((char) (c))) && (!isDelimiter(c))) && (!eol)) {\r\n                c = reader.read();\r\n                eol = readEndOfLine(c);\r\n            } \r\n        }\r\n        // ok, start of token reached: encapsulated, or token\r\n        if (isDelimiter(c)) {\r\n            // empty token return TOKEN(\"\")\r\n            token.type = TOKEN;\r\n        } else if (eol) {\r\n            // empty token return EORECORD(\"\")\r\n            // noop: token.content.append(\"\");\r\n            token.type = EORECORD;\r\n        } else if (isQuoteChar(c)) {\r\n            // consume encapsulated token\r\n            parseEncapsulatedToken(token);\r\n        } else if (isEndOfFile(c)) {\r\n            // end of file return EOF()\r\n            // noop: token.content.append(\"\");\r\n            token.type = EOF;\r\n            token.isReady = true;// there is data at EOF\r\n\r\n        } else {\r\n            // next token must be a simple token\r\n            // add removed blanks when not ignoring whitespace chars...\r\n            parseSimpleToken(token, c);\r\n        }\r\n    } \r\n    return token;\r\n}",
        "class-code": "package org.apache.commons.csv;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Token.Type.INVALID;\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport static org.apache.commons.csv.Token.Type.EORECORD;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Token.Type.COMMENT;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Token.Type.EOF;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nfinal class Lexer implements Closeable {\n    private final boolean ignoreSurroundingSpaces;\n    private final boolean ignoreEmptyLines;\n    private final ExtendedBufferedReader reader;\n    private boolean isLastTokenDelimiter;\n    Token nextToken(final Token token) throws IOException {\r\n        // get the last read char (required for empty line detection)\r\n        int lastChar = reader.getLastChar();\r\n        // read the next char and set eol\r\n        int c = reader.read();\r\n        /* Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\r\n        - they are equivalent here.\r\n         */\r\n        boolean eol = readEndOfLine(c);\r\n        // empty line detection: eol AND (last char was EOL or beginning)\r\n        if (ignoreEmptyLines) {\r\n            while (eol && isStartOfLine(lastChar)) {\r\n                // go on char ahead ...\r\n                lastChar = c;\r\n                c = reader.read();\r\n                eol = readEndOfLine(c);\r\n                // reached end of file without any content (empty line at the end)\r\n                if (isEndOfFile(c)) {\r\n                    token.type = EOF;\r\n                    // don't set token.isReady here because no content\r\n                    return token;\r\n                }\r\n            } \r\n        }\r\n        // did we reach eof during the last iteration already ? EOF\r\n        if (isEndOfFile(lastChar) || ((!isLastTokenDelimiter) && isEndOfFile(c))) {\r\n            token.type = EOF;\r\n            // don't set token.isReady here because no content\r\n            return token;\r\n        }\r\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\r\n            final String line = reader.readLine();\r\n            if (line == null) {\r\n                token.type = EOF;\r\n                // don't set token.isReady here because no content\r\n                return token;\r\n            }\r\n            final String comment = line.trim();\r\n            token.content.append(comment);\r\n            token.type = COMMENT;\r\n            return token;\r\n        }\r\n        // important: make sure a new char gets consumed in each iteration\r\n        while (token.type == INVALID) {\r\n            // ignore whitespaces at beginning of a token\r\n            if (ignoreSurroundingSpaces) {\r\n                while ((Character.isWhitespace(((char) (c))) && (!isDelimiter(c))) && (!eol)) {\r\n                    c = reader.read();\r\n                    eol = readEndOfLine(c);\r\n                } \r\n            }\r\n            // ok, start of token reached: encapsulated, or token\r\n            if (isDelimiter(c)) {\r\n                // empty token return TOKEN(\"\")\r\n                token.type = TOKEN;\r\n            } else if (eol) {\r\n                // empty token return EORECORD(\"\")\r\n                // noop: token.content.append(\"\");\r\n                token.type = EORECORD;\r\n            } else if (isQuoteChar(c)) {\r\n                // consume encapsulated token\r\n                parseEncapsulatedToken(token);\r\n            } else if (isEndOfFile(c)) {\r\n                // end of file return EOF()\r\n                // noop: token.content.append(\"\");\r\n                token.type = EOF;\r\n                token.isReady = true;// there is data at EOF\r\n    \r\n            } else {\r\n                // next token must be a simple token\r\n                // add removed blanks when not ignoring whitespace chars...\r\n                parseSimpleToken(token, c);\r\n            }\r\n        } \r\n        return token;\r\n    }\n@Override\r\npublic void close() throws IOException;\n    long getCharacterPosition();\n    long getCurrentLineNumber();\n    String getFirstEol();\n    boolean isClosed();\n    boolean isCommentStart(final int ch);\n    boolean isDelimiter(final int ch) throws IOException;\n    boolean isEndOfFile(final int ch);\n    boolean isEscape(final int ch);\n    boolean isEscapeDelimiter() throws IOException;\n    boolean isQuoteChar(final int ch);\n    boolean isStartOfLine(final int ch);\n    private Token parseEncapsulatedToken(final Token token) throws IOException;\n    private Token parseSimpleToken(final Token token, int ch) throws IOException;\n    boolean readEndOfLine(int ch) throws IOException;\n    int readEscape() throws IOException;\n    void trimTrailingSpaces(final StringBuilder buffer);\n}"
      },
      {
        "id": "CSVParser_createHeaders",
        "package": "org.apache.commons.csv",
        "class": "org.apache.commons.csv.CSVParser",
        "test-class": "org.apache.commons.csv.CSVParser_createHeaders_Test",
        "method-name": "createHeaders()",
        "source-path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "test-path": "src/test/java/org/apache/commons/csv/CSVParser_createHeaders_Test.java",
        "focal-method": "private Headers createHeaders() throws IOException {\r\n    Map<String, Integer> hdrMap = null;\r\n    List<String> headerNames = null;\r\n    final String[] formatHeader = this.format.getHeader();\r\n    if (formatHeader != null) {\r\n        hdrMap = createEmptyHeaderMap();\r\n        String[] headerRecord = null;\r\n        if (formatHeader.length == 0) {\r\n            // read the header from the first line of the file\r\n            final CSVRecord nextRecord = this.nextRecord();\r\n            if (nextRecord != null) {\r\n                headerRecord = nextRecord.values();\r\n                headerComment = nextRecord.getComment();\r\n            }\r\n        } else {\r\n            if (this.format.getSkipHeaderRecord()) {\r\n                final CSVRecord nextRecord = this.nextRecord();\r\n                if (nextRecord != null) {\r\n                    headerComment = nextRecord.getComment();\r\n                }\r\n            }\r\n            headerRecord = formatHeader;\r\n        }\r\n        // build the name to index mappings\r\n        if (headerRecord != null) {\r\n            // Track an occurrence of a null, empty or blank header.\r\n            boolean observedMissing = false;\r\n            for (int i = 0; i < headerRecord.length; i++) {\r\n                final String header = headerRecord[i];\r\n                final boolean blankHeader = CSVFormat.isBlank(header);\r\n                if (blankHeader && (!this.format.getAllowMissingColumnNames())) {\r\n                    throw new IllegalArgumentException(\"A header name is missing in \" + Arrays.toString(headerRecord));\r\n                }\r\n                final boolean containsHeader = (blankHeader) ? observedMissing : hdrMap.containsKey(header);\r\n                final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\r\n                final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\r\n                final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\r\n                if ((containsHeader && (!duplicatesAllowed)) && (!(blankHeader && emptyDuplicatesAllowed))) {\r\n                    throw new IllegalArgumentException(String.format(\"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\", header, Arrays.toString(headerRecord)));\r\n                }\r\n                observedMissing |= blankHeader;\r\n                if (header != null) {\r\n                    hdrMap.put(header, Integer.valueOf(i));\r\n                    if (headerNames == null) {\r\n                        headerNames = new ArrayList<>(headerRecord.length);\r\n                    }\r\n                    headerNames.add(header);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (headerNames == null) {\r\n        headerNames = Collections.emptyList();// immutable\r\n\r\n    } else {\r\n        headerNames = Collections.unmodifiableList(headerNames);\r\n    }\r\n    return new Headers(hdrMap, headerNames);\r\n}",
        "class-code": "package org.apache.commons.csv;\nimport java.io.Closeable;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.io.UncheckedIOException;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.util.stream.StreamSupport;\nimport java.io.StringReader;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.Spliterator;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.nio.file.Path;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.TreeMap;\nimport java.util.Spliterators;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.io.File;\nimport java.util.Map;\nimport java.util.Arrays;\npublic final class CSVParser implements Iterable<CSVRecord> , Closeable {\n    private String headerComment;\n    private final CSVFormat format;\n    private Headers createHeaders() throws IOException {\r\n        Map<String, Integer> hdrMap = null;\r\n        List<String> headerNames = null;\r\n        final String[] formatHeader = this.format.getHeader();\r\n        if (formatHeader != null) {\r\n            hdrMap = createEmptyHeaderMap();\r\n            String[] headerRecord = null;\r\n            if (formatHeader.length == 0) {\r\n                // read the header from the first line of the file\r\n                final CSVRecord nextRecord = this.nextRecord();\r\n                if (nextRecord != null) {\r\n                    headerRecord = nextRecord.values();\r\n                    headerComment = nextRecord.getComment();\r\n                }\r\n            } else {\r\n                if (this.format.getSkipHeaderRecord()) {\r\n                    final CSVRecord nextRecord = this.nextRecord();\r\n                    if (nextRecord != null) {\r\n                        headerComment = nextRecord.getComment();\r\n                    }\r\n                }\r\n                headerRecord = formatHeader;\r\n            }\r\n            // build the name to index mappings\r\n            if (headerRecord != null) {\r\n                // Track an occurrence of a null, empty or blank header.\r\n                boolean observedMissing = false;\r\n                for (int i = 0; i < headerRecord.length; i++) {\r\n                    final String header = headerRecord[i];\r\n                    final boolean blankHeader = CSVFormat.isBlank(header);\r\n                    if (blankHeader && (!this.format.getAllowMissingColumnNames())) {\r\n                        throw new IllegalArgumentException(\"A header name is missing in \" + Arrays.toString(headerRecord));\r\n                    }\r\n                    final boolean containsHeader = (blankHeader) ? observedMissing : hdrMap.containsKey(header);\r\n                    final DuplicateHeaderMode headerMode = this.format.getDuplicateHeaderMode();\r\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\r\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\r\n                    if ((containsHeader && (!duplicatesAllowed)) && (!(blankHeader && emptyDuplicatesAllowed))) {\r\n                        throw new IllegalArgumentException(String.format(\"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\", header, Arrays.toString(headerRecord)));\r\n                    }\r\n                    observedMissing |= blankHeader;\r\n                    if (header != null) {\r\n                        hdrMap.put(header, Integer.valueOf(i));\r\n                        if (headerNames == null) {\r\n                            headerNames = new ArrayList<>(headerRecord.length);\r\n                        }\r\n                        headerNames.add(header);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (headerNames == null) {\r\n            headerNames = Collections.emptyList();// immutable\r\n    \r\n        } else {\r\n            headerNames = Collections.unmodifiableList(headerNames);\r\n        }\r\n        return new Headers(hdrMap, headerNames);\r\n    }\n@Override\r\npublic void close() throws IOException;\n    private Map<String, Integer> createEmptyHeaderMap();\n    public long getCurrentLineNumber();\n    public String getFirstEndOfLine();\n    public String getHeaderComment();\n    public Map<String, Integer> getHeaderMap();\n    Map<String, Integer> getHeaderMapRaw();\n    public List<String> getHeaderNames();\n    public long getRecordNumber();\n    public List<CSVRecord> getRecords();\n    public String getTrailerComment();\n    public boolean hasHeaderComment();\n    public boolean hasTrailerComment();\n    public boolean isClosed();\n    @Override\r\npublic Iterator<CSVRecord> iterator();\n    CSVRecord nextRecord() throws IOException;\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException;\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException;\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException;\n    public Stream<CSVRecord> stream();\n}"
      },
      {
        "id": "CSVFormat_printWithQuotes",
        "package": "org.apache.commons.csv",
        "class": "org.apache.commons.csv.CSVFormat",
        "test-class": "org.apache.commons.csv.CSVFormat_printWithQuotes_Test",
        "method-name": "printWithQuotes(Object, CharSequence, Appendable, boolean)",
        "source-path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "test-path": "src/test/java/org/apache/commons/csv/CSVFormat_printWithQuotes_Test.java",
        "focal-method": "private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n    boolean quote = false;\r\n    int start = 0;\r\n    int pos = 0;\r\n    final int len = charSeq.length();\r\n    final char[] delim = getDelimiterString().toCharArray();\r\n    final int delimLength = delim.length;\r\n    final char quoteChar = getQuoteCharacter().charValue();\r\n    // If escape char not specified, default to the quote char\r\n    // This avoids having to keep checking whether there is an escape character\r\n    // at the cost of checking against quote twice\r\n    final char escapeChar = (isEscapeCharacterSet()) ? getEscapeCharacter().charValue() : quoteChar;\r\n    QuoteMode quoteModePolicy = getQuoteMode();\r\n    if (quoteModePolicy == null) {\r\n        quoteModePolicy = QuoteMode.MINIMAL;\r\n    }\r\n    switch (quoteModePolicy) {\r\n        case ALL :\r\n        case ALL_NON_NULL :\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC :\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE :\r\n            // Use the existing escaping code\r\n            printWithEscapes(charSeq, out);\r\n            return;\r\n        case MINIMAL :\r\n            if (len <= 0) {\r\n                // always quote an empty token that is the first\r\n                // on the line, as it may be the only thing on the\r\n                // line. If it were not quoted in that case,\r\n                // an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = charSeq.charAt(pos);\r\n                if (c <= COMMENT) {\r\n                    // Some other chars at the start of a value caused the parser to fail, so for now\r\n                    // encapsulate if we start in anything less than '#'. We are being conservative\r\n                    // by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < len) {\r\n                        c = charSeq.charAt(pos);\r\n                        if (((((c == LF) || (c == CR)) || (c == quoteChar)) || (c == escapeChar)) || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    } \r\n                    if (!quote) {\r\n                        pos = len - 1;\r\n                        c = charSeq.charAt(pos);\r\n                        // Some other chars at the end caused the parser to fail, so for now\r\n                        // encapsulate if we end in anything less than ' '\r\n                        if (isTrimChar(c)) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!quote) {\r\n                // no encapsulation needed - write out the original value\r\n                out.append(charSeq, start, len);\r\n                return;\r\n            }\r\n            break;\r\n        default :\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n    }\r\n    if (!quote) {\r\n        // no encapsulation needed - write out the original value\r\n        out.append(charSeq, start, len);\r\n        return;\r\n    }\r\n    // we hit something that needed encapsulation\r\n    out.append(quoteChar);\r\n    // Pick up where we left off: pos should be positioned on the first character that caused\r\n    // the need for encapsulation.\r\n    while (pos < len) {\r\n        final char c = charSeq.charAt(pos);\r\n        if ((c == quoteChar) || (c == escapeChar)) {\r\n            // write out the chunk up until this point\r\n            out.append(charSeq, start, pos);\r\n            out.append(escapeChar);// now output the escape\r\n\r\n            start = pos;// and restart with the matched char\r\n\r\n        }\r\n        pos++;\r\n    } \r\n    // write the last segment\r\n    out.append(charSeq, start, pos);\r\n    out.append(quoteChar);\r\n}",
        "class-code": "package org.apache.commons.csv;\nimport java.util.Set;\nimport java.sql.SQLException;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport java.io.Reader;\nimport java.sql.ResultSetMetaData;\nimport java.nio.file.Files;\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport java.io.StringWriter;\nimport java.sql.ResultSet;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.SP;\nimport java.util.HashSet;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport java.nio.file.Path;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport java.io.FileOutputStream;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport java.io.Writer;\nimport java.util.Objects;\nimport static org.apache.commons.csv.Constants.LF;\nimport java.io.OutputStreamWriter;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Arrays;\npublic final class CSVFormat implements Serializable {\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false, DuplicateHeaderMode.ALLOW_ALL);\n    public static final CSVFormat EXCEL = DEFAULT.builder().setIgnoreEmptyLines(false).setAllowMissingColumnNames(true).build();\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder().setDelimiter(PIPE).setEscape(BACKSLASH).setQuote(DOUBLE_QUOTE_CHAR).setRecordSeparator(LF).build();\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder().setDelimiter(COMMA).setQuote(DOUBLE_QUOTE_CHAR).setRecordSeparator(LF).build();\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder().setDelimiter(COMMA).setEscape(DOUBLE_QUOTE_CHAR).setQuote(DOUBLE_QUOTE_CHAR).setQuoteMode(QuoteMode.MINIMAL).setSkipHeaderRecord(false).build();\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder().setDelimiter(TAB).setEscape(DOUBLE_QUOTE_CHAR).setQuote(DOUBLE_QUOTE_CHAR).setQuoteMode(QuoteMode.MINIMAL).setSkipHeaderRecord(false).build();\n    public static final CSVFormat MYSQL = DEFAULT.builder().setDelimiter(TAB).setEscape(BACKSLASH).setIgnoreEmptyLines(false).setQuote(null).setRecordSeparator(LF).setNullString(Constants.SQL_NULL_STRING).setQuoteMode(QuoteMode.ALL_NON_NULL).build();\n    public static final CSVFormat ORACLE = DEFAULT.builder().setDelimiter(COMMA).setEscape(BACKSLASH).setIgnoreEmptyLines(false).setQuote(DOUBLE_QUOTE_CHAR).setNullString(Constants.SQL_NULL_STRING).setTrim(true).setRecordSeparator(System.lineSeparator()).setQuoteMode(QuoteMode.MINIMAL).build();\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder().setDelimiter(COMMA).setEscape(null).setIgnoreEmptyLines(false).setQuote(DOUBLE_QUOTE_CHAR).setRecordSeparator(LF).setNullString(EMPTY).setQuoteMode(QuoteMode.ALL_NON_NULL).build();\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder().setDelimiter(TAB).setEscape(BACKSLASH).setIgnoreEmptyLines(false).setQuote(null).setRecordSeparator(LF).setNullString(Constants.SQL_NULL_STRING).setQuoteMode(QuoteMode.ALL_NON_NULL).build();\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\n    public static final CSVFormat TDF = DEFAULT.builder().setDelimiter(TAB).setIgnoreSurroundingSpaces(true).build();\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\r\n        boolean quote = false;\r\n        int start = 0;\r\n        int pos = 0;\r\n        final int len = charSeq.length();\r\n        final char[] delim = getDelimiterString().toCharArray();\r\n        final int delimLength = delim.length;\r\n        final char quoteChar = getQuoteCharacter().charValue();\r\n        // If escape char not specified, default to the quote char\r\n        // This avoids having to keep checking whether there is an escape character\r\n        // at the cost of checking against quote twice\r\n        final char escapeChar = (isEscapeCharacterSet()) ? getEscapeCharacter().charValue() : quoteChar;\r\n        QuoteMode quoteModePolicy = getQuoteMode();\r\n        if (quoteModePolicy == null) {\r\n            quoteModePolicy = QuoteMode.MINIMAL;\r\n        }\r\n        switch (quoteModePolicy) {\r\n            case ALL :\r\n            case ALL_NON_NULL :\r\n                quote = true;\r\n                break;\r\n            case NON_NUMERIC :\r\n                quote = !(object instanceof Number);\r\n                break;\r\n            case NONE :\r\n                // Use the existing escaping code\r\n                printWithEscapes(charSeq, out);\r\n                return;\r\n            case MINIMAL :\r\n                if (len <= 0) {\r\n                    // always quote an empty token that is the first\r\n                    // on the line, as it may be the only thing on the\r\n                    // line. If it were not quoted in that case,\r\n                    // an empty line has no tokens.\r\n                    if (newRecord) {\r\n                        quote = true;\r\n                    }\r\n                } else {\r\n                    char c = charSeq.charAt(pos);\r\n                    if (c <= COMMENT) {\r\n                        // Some other chars at the start of a value caused the parser to fail, so for now\r\n                        // encapsulate if we start in anything less than '#'. We are being conservative\r\n                        // by including the default comment char too.\r\n                        quote = true;\r\n                    } else {\r\n                        while (pos < len) {\r\n                            c = charSeq.charAt(pos);\r\n                            if (((((c == LF) || (c == CR)) || (c == quoteChar)) || (c == escapeChar)) || isDelimiter(c, charSeq, pos, delim, delimLength)) {\r\n                                quote = true;\r\n                                break;\r\n                            }\r\n                            pos++;\r\n                        } \r\n                        if (!quote) {\r\n                            pos = len - 1;\r\n                            c = charSeq.charAt(pos);\r\n                            // Some other chars at the end caused the parser to fail, so for now\r\n                            // encapsulate if we end in anything less than ' '\r\n                            if (isTrimChar(c)) {\r\n                                quote = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!quote) {\r\n                    // no encapsulation needed - write out the original value\r\n                    out.append(charSeq, start, len);\r\n                    return;\r\n                }\r\n                break;\r\n            default :\r\n                throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n        }\r\n        if (!quote) {\r\n            // no encapsulation needed - write out the original value\r\n            out.append(charSeq, start, len);\r\n            return;\r\n        }\r\n        // we hit something that needed encapsulation\r\n        out.append(quoteChar);\r\n        // Pick up where we left off: pos should be positioned on the first character that caused\r\n        // the need for encapsulation.\r\n        while (pos < len) {\r\n            final char c = charSeq.charAt(pos);\r\n            if ((c == quoteChar) || (c == escapeChar)) {\r\n                // write out the chunk up until this point\r\n                out.append(charSeq, start, pos);\r\n                out.append(escapeChar);// now output the escape\r\n    \r\n                start = pos;// and restart with the matched char\r\n    \r\n            }\r\n            pos++;\r\n        } \r\n        // write the last segment\r\n        out.append(charSeq, start, pos);\r\n        out.append(quoteChar);\r\n    }\npublic Builder builder();\n    @SafeVarargs\r\nstatic <T> T[] clone(final T... values);\n    CSVFormat copy();\n    @Override\r\npublic boolean equals(final Object obj);\n    public String format(final Object... values);\n    public boolean getAllowMissingColumnNames();\n    public boolean getAutoFlush();\n    public Character getCommentMarker();\n    public String getDelimiterString();\n    public DuplicateHeaderMode getDuplicateHeaderMode();\n    public Character getEscapeCharacter();\n    public String[] getHeader();\n    public String[] getHeaderComments();\n    public boolean getIgnoreEmptyLines();\n    public boolean getIgnoreHeaderCase();\n    public boolean getIgnoreSurroundingSpaces();\n    public String getNullString();\n    public Character getQuoteCharacter();\n    public QuoteMode getQuoteMode();\n    public String getRecordSeparator();\n    public boolean getSkipHeaderRecord();\n    public boolean getTrailingDelimiter();\n    public boolean getTrim();\n    @Override\r\npublic int hashCode();\n    static boolean isBlank(final String value);\n    public boolean isCommentMarkerSet();\n    private boolean isDelimiter(final char ch, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength);\n    public boolean isEscapeCharacterSet();\n    public boolean isNullStringSet();\n    public boolean isQuoteCharacterSet();\n    private static boolean isTrimChar(final char ch);\n    private static boolean isTrimChar(final CharSequence charSequence, final int pos);\n    public static CSVFormat newFormat(final char delimiter);\n    public CSVParser parse(final Reader reader) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic CSVPrinter print(final File out, final Charset charset) throws IOException;\n    public CSVPrinter print(final Appendable out) throws IOException;\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic CSVPrinter print(final Path out, final Charset charset) throws IOException;\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException;\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException;\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException;\n    public CSVPrinter printer() throws IOException;\n    public synchronized void println(final Appendable appendable) throws IOException;\n    @Override\r\npublic String toString();\n    static String[] toStringArray(final Object[] values);\n    static CharSequence trim(final CharSequence charSequence);\n    String trim(final String value);\n    public static CSVFormat valueOf(final String format);\n}"
      },
      {
        "id": "CSVParser_nextRecord",
        "package": "org.apache.commons.csv",
        "class": "org.apache.commons.csv.CSVParser",
        "test-class": "org.apache.commons.csv.CSVParser_nextRecord_Test",
        "method-name": "nextRecord()",
        "source-path": "src/main/java/org/apache/commons/csv/CSVParser.java",
        "test-path": "src/test/java/org/apache/commons/csv/CSVParser_nextRecord_Test.java",
        "focal-method": "CSVRecord nextRecord() throws IOException {\r\n    CSVRecord result = null;\r\n    this.recordList.clear();\r\n    StringBuilder sb = null;\r\n    final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\r\n    do {\r\n        this.reusableToken.reset();\r\n        this.lexer.nextToken(this.reusableToken);\r\n        switch (this.reusableToken.type) {\r\n            case TOKEN :\r\n                this.addRecordValue(false);\r\n                break;\r\n            case EORECORD :\r\n                this.addRecordValue(true);\r\n                break;\r\n            case EOF :\r\n                if (this.reusableToken.isReady) {\r\n                    this.addRecordValue(true);\r\n                } else if (sb != null) {\r\n                    trailerComment = sb.toString();\r\n                }\r\n                break;\r\n            case INVALID :\r\n                throw new IOException((\"(line \" + this.getCurrentLineNumber()) + \") invalid parse sequence\");\r\n            case COMMENT :\r\n                // Ignored currently\r\n                if (sb == null) {\r\n                    // first comment for this record\r\n                    sb = new StringBuilder();\r\n                } else {\r\n                    sb.append(Constants.LF);\r\n                }\r\n                sb.append(this.reusableToken.content);\r\n                this.reusableToken.type = TOKEN;// Read another token\r\n\r\n                break;\r\n            default :\r\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\r\n        }\r\n    } while (this.reusableToken.type == TOKEN );\r\n    if (!this.recordList.isEmpty()) {\r\n        this.recordNumber++;\r\n        final String comment = (sb == null) ? null : sb.toString();\r\n        result = new CSVRecord(this, this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment, this.recordNumber, startCharPosition);\r\n    }\r\n    return result;\r\n}",
        "class-code": "package org.apache.commons.csv;\nimport java.io.Closeable;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.io.UncheckedIOException;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.util.stream.StreamSupport;\nimport java.io.StringReader;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.Spliterator;\nimport static org.apache.commons.csv.Token.Type.TOKEN;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.nio.file.Path;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.TreeMap;\nimport java.util.Spliterators;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.io.File;\nimport java.util.Map;\nimport java.util.Arrays;\npublic final class CSVParser implements Iterable<CSVRecord> , Closeable {\n    private String trailerComment;\n    private final Lexer lexer;\n    private final List<String> recordList = new ArrayList<>();\n    private long recordNumber;\n    private final long characterOffset;\n    private final Token reusableToken = new Token();\n    CSVRecord nextRecord() throws IOException {\r\n        CSVRecord result = null;\r\n        this.recordList.clear();\r\n        StringBuilder sb = null;\r\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\r\n        do {\r\n            this.reusableToken.reset();\r\n            this.lexer.nextToken(this.reusableToken);\r\n            switch (this.reusableToken.type) {\r\n                case TOKEN :\r\n                    this.addRecordValue(false);\r\n                    break;\r\n                case EORECORD :\r\n                    this.addRecordValue(true);\r\n                    break;\r\n                case EOF :\r\n                    if (this.reusableToken.isReady) {\r\n                        this.addRecordValue(true);\r\n                    } else if (sb != null) {\r\n                        trailerComment = sb.toString();\r\n                    }\r\n                    break;\r\n                case INVALID :\r\n                    throw new IOException((\"(line \" + this.getCurrentLineNumber()) + \") invalid parse sequence\");\r\n                case COMMENT :\r\n                    // Ignored currently\r\n                    if (sb == null) {\r\n                        // first comment for this record\r\n                        sb = new StringBuilder();\r\n                    } else {\r\n                        sb.append(Constants.LF);\r\n                    }\r\n                    sb.append(this.reusableToken.content);\r\n                    this.reusableToken.type = TOKEN;// Read another token\r\n    \r\n                    break;\r\n                default :\r\n                    throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\r\n            }\r\n        } while (this.reusableToken.type == TOKEN );\r\n        if (!this.recordList.isEmpty()) {\r\n            this.recordNumber++;\r\n            final String comment = (sb == null) ? null : sb.toString();\r\n            result = new CSVRecord(this, this.recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment, this.recordNumber, startCharPosition);\r\n        }\r\n        return result;\r\n    }\nprivate void addRecordValue(final boolean lastRecord);\n    @Override\r\npublic void close() throws IOException;\n    public long getCurrentLineNumber();\n    public String getFirstEndOfLine();\n    public String getHeaderComment();\n    public Map<String, Integer> getHeaderMap();\n    Map<String, Integer> getHeaderMapRaw();\n    public List<String> getHeaderNames();\n    public long getRecordNumber();\n    public List<CSVRecord> getRecords();\n    public String getTrailerComment();\n    public boolean hasHeaderComment();\n    public boolean hasTrailerComment();\n    public boolean isClosed();\n    @Override\r\npublic Iterator<CSVRecord> iterator();\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException;\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException;\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException;\n    public Stream<CSVRecord> stream();\n}"
      },
      {
        "id": "CSVFormat_toString",
        "package": "org.apache.commons.csv",
        "class": "org.apache.commons.csv.CSVFormat",
        "test-class": "org.apache.commons.csv.CSVFormat_toString_Test",
        "method-name": "toString()",
        "source-path": "src/main/java/org/apache/commons/csv/CSVFormat.java",
        "test-path": "src/test/java/org/apache/commons/csv/CSVFormat_toString_Test.java",
        "focal-method": "@Override\r\npublic String toString() {\r\n    final StringBuilder sb = new StringBuilder();\r\n    sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n    if (isEscapeCharacterSet()) {\r\n        sb.append(' ');\r\n        sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n    }\r\n    if (isQuoteCharacterSet()) {\r\n        sb.append(' ');\r\n        sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n    }\r\n    if (quoteMode != null) {\r\n        sb.append(' ');\r\n        sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n    }\r\n    if (isCommentMarkerSet()) {\r\n        sb.append(' ');\r\n        sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n    }\r\n    if (isNullStringSet()) {\r\n        sb.append(' ');\r\n        sb.append(\"NullString=<\").append(nullString).append('>');\r\n    }\r\n    if (recordSeparator != null) {\r\n        sb.append(' ');\r\n        sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n    }\r\n    if (getIgnoreEmptyLines()) {\r\n        sb.append(\" EmptyLines:ignored\");\r\n    }\r\n    if (getIgnoreSurroundingSpaces()) {\r\n        sb.append(\" SurroundingSpaces:ignored\");\r\n    }\r\n    if (getIgnoreHeaderCase()) {\r\n        sb.append(\" IgnoreHeaderCase:ignored\");\r\n    }\r\n    sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n    if (headerComments != null) {\r\n        sb.append(' ');\r\n        sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n    }\r\n    if (headers != null) {\r\n        sb.append(' ');\r\n        sb.append(\"Header:\").append(Arrays.toString(headers));\r\n    }\r\n    return sb.toString();\r\n}",
        "class-code": "package org.apache.commons.csv;\nimport java.util.Set;\nimport java.sql.SQLException;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport java.io.Reader;\nimport java.sql.ResultSetMetaData;\nimport java.nio.file.Files;\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport java.io.StringWriter;\nimport java.sql.ResultSet;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.SP;\nimport java.util.HashSet;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport java.nio.file.Path;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport java.io.FileOutputStream;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport java.io.Writer;\nimport java.util.Objects;\nimport static org.apache.commons.csv.Constants.LF;\nimport java.io.OutputStreamWriter;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Arrays;\npublic final class CSVFormat implements Serializable {\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, null, false, false, false, false, false, false, DuplicateHeaderMode.ALLOW_ALL);\n    public static final CSVFormat EXCEL = DEFAULT.builder().setIgnoreEmptyLines(false).setAllowMissingColumnNames(true).build();\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.builder().setDelimiter(PIPE).setEscape(BACKSLASH).setQuote(DOUBLE_QUOTE_CHAR).setRecordSeparator(LF).build();\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.builder().setDelimiter(COMMA).setQuote(DOUBLE_QUOTE_CHAR).setRecordSeparator(LF).build();\n    public static final CSVFormat MONGODB_CSV = DEFAULT.builder().setDelimiter(COMMA).setEscape(DOUBLE_QUOTE_CHAR).setQuote(DOUBLE_QUOTE_CHAR).setQuoteMode(QuoteMode.MINIMAL).setSkipHeaderRecord(false).build();\n    public static final CSVFormat MONGODB_TSV = DEFAULT.builder().setDelimiter(TAB).setEscape(DOUBLE_QUOTE_CHAR).setQuote(DOUBLE_QUOTE_CHAR).setQuoteMode(QuoteMode.MINIMAL).setSkipHeaderRecord(false).build();\n    public static final CSVFormat MYSQL = DEFAULT.builder().setDelimiter(TAB).setEscape(BACKSLASH).setIgnoreEmptyLines(false).setQuote(null).setRecordSeparator(LF).setNullString(Constants.SQL_NULL_STRING).setQuoteMode(QuoteMode.ALL_NON_NULL).build();\n    public static final CSVFormat ORACLE = DEFAULT.builder().setDelimiter(COMMA).setEscape(BACKSLASH).setIgnoreEmptyLines(false).setQuote(DOUBLE_QUOTE_CHAR).setNullString(Constants.SQL_NULL_STRING).setTrim(true).setRecordSeparator(System.lineSeparator()).setQuoteMode(QuoteMode.MINIMAL).build();\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT.builder().setDelimiter(COMMA).setEscape(null).setIgnoreEmptyLines(false).setQuote(DOUBLE_QUOTE_CHAR).setRecordSeparator(LF).setNullString(EMPTY).setQuoteMode(QuoteMode.ALL_NON_NULL).build();\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT.builder().setDelimiter(TAB).setEscape(BACKSLASH).setIgnoreEmptyLines(false).setQuote(null).setRecordSeparator(LF).setNullString(Constants.SQL_NULL_STRING).setQuoteMode(QuoteMode.ALL_NON_NULL).build();\n    public static final CSVFormat RFC4180 = DEFAULT.builder().setIgnoreEmptyLines(false).build();\n    public static final CSVFormat TDF = DEFAULT.builder().setDelimiter(TAB).setIgnoreSurroundingSpaces(true).build();\n    private final Character commentMarker;\n    private final String delimiter;\n    private final Character escapeCharacter;\n    private final String[] headers;\n    private final String[] headerComments;\n    private final String nullString;\n    private final Character quoteCharacter;\n    private final QuoteMode quoteMode;\n    private final String recordSeparator;\n    private final boolean skipHeaderRecord;\n    @Override\r\n    public String toString() {\r\n        final StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\r\n        if (isEscapeCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\r\n        }\r\n        if (isQuoteCharacterSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\r\n        }\r\n        if (quoteMode != null) {\r\n            sb.append(' ');\r\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\r\n        }\r\n        if (isCommentMarkerSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\r\n        }\r\n        if (isNullStringSet()) {\r\n            sb.append(' ');\r\n            sb.append(\"NullString=<\").append(nullString).append('>');\r\n        }\r\n        if (recordSeparator != null) {\r\n            sb.append(' ');\r\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\r\n        }\r\n        if (getIgnoreEmptyLines()) {\r\n            sb.append(\" EmptyLines:ignored\");\r\n        }\r\n        if (getIgnoreSurroundingSpaces()) {\r\n            sb.append(\" SurroundingSpaces:ignored\");\r\n        }\r\n        if (getIgnoreHeaderCase()) {\r\n            sb.append(\" IgnoreHeaderCase:ignored\");\r\n        }\r\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\r\n        if (headerComments != null) {\r\n            sb.append(' ');\r\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\r\n        }\r\n        if (headers != null) {\r\n            sb.append(' ');\r\n            sb.append(\"Header:\").append(Arrays.toString(headers));\r\n        }\r\n        return sb.toString();\r\n    }\npublic Builder builder();\n    @SafeVarargs\r\nstatic <T> T[] clone(final T... values);\n    CSVFormat copy();\n    @Override\r\npublic boolean equals(final Object obj);\n    public String format(final Object... values);\n    public boolean getAllowMissingColumnNames();\n    public boolean getAutoFlush();\n    public Character getCommentMarker();\n    public String getDelimiterString();\n    public DuplicateHeaderMode getDuplicateHeaderMode();\n    public Character getEscapeCharacter();\n    public String[] getHeader();\n    public String[] getHeaderComments();\n    public boolean getIgnoreEmptyLines();\n    public boolean getIgnoreHeaderCase();\n    public boolean getIgnoreSurroundingSpaces();\n    public String getNullString();\n    public Character getQuoteCharacter();\n    public QuoteMode getQuoteMode();\n    public String getRecordSeparator();\n    public boolean getSkipHeaderRecord();\n    public boolean getTrailingDelimiter();\n    public boolean getTrim();\n    @Override\r\npublic int hashCode();\n    static boolean isBlank(final String value);\n    public boolean isCommentMarkerSet();\n    public boolean isEscapeCharacterSet();\n    public boolean isNullStringSet();\n    public boolean isQuoteCharacterSet();\n    public static CSVFormat newFormat(final char delimiter);\n    public CSVParser parse(final Reader reader) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic CSVPrinter print(final File out, final Charset charset) throws IOException;\n    public CSVPrinter print(final Appendable out) throws IOException;\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException;\n    @SuppressWarnings(\"resource\")\r\npublic CSVPrinter print(final Path out, final Charset charset) throws IOException;\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException;\n    public CSVPrinter printer() throws IOException;\n    public synchronized void println(final Appendable appendable) throws IOException;\n    static String[] toStringArray(final Object[] values);\n    static CharSequence trim(final CharSequence charSequence);\n    String trim(final String value);\n    public static CSVFormat valueOf(final String format);\n}"
      }
    ]
  },
  "datafaker": {
    "project-name": "datafaker",
    "project-url": "datafaker",
    "focal-methods": [
      {
        "id": "SqlTransformer_handlePrimitivesInArray",
        "package": "net.datafaker.transformations.sql",
        "class": "net.datafaker.transformations.sql.SqlTransformer",
        "test-class": "net.datafaker.transformations.sql.SqlTransformer_handlePrimitivesInArray_Test",
        "method-name": "handlePrimitivesInArray(Class<?>, Object)",
        "source-path": "src/main/java/net/datafaker/transformations/sql/SqlTransformer.java",
        "test-path": "src/test/java/net/datafaker/transformations/sql/SqlTransformer_handlePrimitivesInArray_Test.java",
        "focal-method": "private String handlePrimitivesInArray(Class<?> componentType, Object value) {\r\n    StringJoiner joiner = new StringJoiner(\", \");\r\n    if (componentType == byte.class) {\r\n        byte[] array = ((byte[]) (value));\r\n        for (int j = 0; j < array.length; j++) {\r\n            joiner.add(String.valueOf(array[j]));\r\n        }\r\n    }\r\n    if (componentType == short.class) {\r\n        short[] array = ((short[]) (value));\r\n        for (int j = 0; j < array.length; j++) {\r\n            joiner.add(String.valueOf(array[j]));\r\n        }\r\n    }\r\n    if (componentType == boolean.class) {\r\n        boolean[] array = ((boolean[]) (value));\r\n        for (int j = 0; j < array.length; j++) {\r\n            joiner.add(String.valueOf(array[j]));\r\n        }\r\n    } else if (componentType == int.class) {\r\n        int[] array = ((int[]) (value));\r\n        for (int j = 0; j < array.length; j++) {\r\n            joiner.add(String.valueOf(array[j]));\r\n        }\r\n    } else if (componentType == long.class) {\r\n        long[] array = ((long[]) (value));\r\n        for (int j = 0; j < array.length; j++) {\r\n            joiner.add(String.valueOf(array[j]));\r\n        }\r\n    } else if (componentType == float.class) {\r\n        float[] array = ((float[]) (value));\r\n        for (int j = 0; j < array.length; j++) {\r\n            joiner.add(String.valueOf(array[j]));\r\n        }\r\n    } else if (componentType == double.class) {\r\n        double[] array = ((double[]) (value));\r\n        for (int j = 0; j < array.length; j++) {\r\n            joiner.add(String.valueOf(array[j]));\r\n        }\r\n    }\r\n    return joiner.toString();\r\n}",
        "class-code": "package net.datafaker.transformations.sql;\nimport net.datafaker.sequence.FakeSequence;\nimport net.datafaker.transformations.Transformer;\nimport java.util.stream.Collectors;\nimport static net.datafaker.transformations.sql.SqlTransformer.SQLKeyWords.ARRAY;\nimport net.datafaker.transformations.CompositeField;\nimport net.datafaker.transformations.Schema;\nimport net.datafaker.sequence.FakeStream;\nimport java.util.ArrayList;\nimport static net.datafaker.transformations.sql.SqlTransformer.SQLKeyWords.INSERT_INTO;\nimport static net.datafaker.transformations.sql.SqlTransformer.SQLKeyWords.NULL;\nimport net.datafaker.transformations.Field;\nimport static net.datafaker.transformations.sql.SqlTransformer.SQLKeyWords.MULTISET;\nimport java.util.Collection;\nimport static net.datafaker.transformations.sql.SqlTransformer.SQLKeyWords.ROW;\nimport net.datafaker.transformations.SimpleField;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport static net.datafaker.transformations.sql.SqlTransformer.SQLKeyWords.VALUES;\nimport java.util.StringJoiner;\npublic class SqlTransformer<IN> implements Transformer<IN, CharSequence> {\n    \n    private String handlePrimitivesInArray(Class<?> componentType, Object value) {\r\n        StringJoiner joiner = new StringJoiner(\", \");\r\n        if (componentType == byte.class) {\r\n            byte[] array = ((byte[]) (value));\r\n            for (int j = 0; j < array.length; j++) {\r\n                joiner.add(String.valueOf(array[j]));\r\n            }\r\n        }\r\n        if (componentType == short.class) {\r\n            short[] array = ((short[]) (value));\r\n            for (int j = 0; j < array.length; j++) {\r\n                joiner.add(String.valueOf(array[j]));\r\n            }\r\n        }\r\n        if (componentType == boolean.class) {\r\n            boolean[] array = ((boolean[]) (value));\r\n            for (int j = 0; j < array.length; j++) {\r\n                joiner.add(String.valueOf(array[j]));\r\n            }\r\n        } else if (componentType == int.class) {\r\n            int[] array = ((int[]) (value));\r\n            for (int j = 0; j < array.length; j++) {\r\n                joiner.add(String.valueOf(array[j]));\r\n            }\r\n        } else if (componentType == long.class) {\r\n            long[] array = ((long[]) (value));\r\n            for (int j = 0; j < array.length; j++) {\r\n                joiner.add(String.valueOf(array[j]));\r\n            }\r\n        } else if (componentType == float.class) {\r\n            float[] array = ((float[]) (value));\r\n            for (int j = 0; j < array.length; j++) {\r\n                joiner.add(String.valueOf(array[j]));\r\n            }\r\n        } else if (componentType == double.class) {\r\n            double[] array = ((double[]) (value));\r\n            for (int j = 0; j < array.length; j++) {\r\n                joiner.add(String.valueOf(array[j]));\r\n            }\r\n        }\r\n        return joiner.toString();\r\n    }\n@Override\r\npublic CharSequence apply(IN input, Schema<IN, ?> schema);\n    @Override\r\npublic CharSequence apply(IN input, Schema<IN, ?> schema, int rowId);\n    public static <IN> SqlTransformer.SqlTransformerBuilder<IN> builder();\n    @Override\r\npublic String generate(Iterable<IN> input, Schema<IN, ?> schema);\n    @Override\r\npublic String generate(Schema<IN, ?> schema, int limit);\n}"
      },
      {
        "id": "FakeValuesService_javaNameToYamlName",
        "package": "net.datafaker.service",
        "class": "net.datafaker.service.FakeValuesService",
        "test-class": "net.datafaker.service.FakeValuesService_javaNameToYamlName_Test",
        "method-name": "javaNameToYamlName(String)",
        "source-path": "src/main/java/net/datafaker/service/FakeValuesService.java",
        "test-path": "src/test/java/net/datafaker/service/FakeValuesService_javaNameToYamlName_Test.java",
        "focal-method": "private String javaNameToYamlName(String expression) {\r\n    String result = name2yaml.get(expression);\r\n    if (result != null) {\r\n        return result;\r\n    }\r\n    final int length = expression.length();\r\n    final boolean firstLetterUpperCase = (length > 0) && Character.isUpperCase(expression.charAt(0));\r\n    int cnt = (firstLetterUpperCase) ? 1 : 0;\r\n    for (int i = 1; i < length; i++) {\r\n        if (Character.isUpperCase(expression.charAt(i))) {\r\n            cnt++;\r\n        }\r\n    }\r\n    if (cnt == 0) {\r\n        name2yaml.put(expression, expression);\r\n        return expression;\r\n    }\r\n    final char[] res = new char[length + (firstLetterUpperCase ? cnt - 1 : cnt)];\r\n    int pos = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        final char c = expression.charAt(i);\r\n        if (cnt > 0) {\r\n            if (Character.isUpperCase(c)) {\r\n                if (pos > 0) {\r\n                    res[pos++] = '_';\r\n                }\r\n                res[pos++] = Character.toLowerCase(c);\r\n                cnt--;\r\n            } else {\r\n                res[pos++] = c;\r\n            }\r\n        } else {\r\n            res[pos++] = c;\r\n        }\r\n    }\r\n    result = new String(res);\r\n    name2yaml.put(expression, result);\r\n    return result;\r\n}",
        "class-code": "package net.datafaker.service;\nimport java.util.Locale;\nimport net.datafaker.transformations.Schema;\nimport java.util.HashMap;\nimport net.datafaker.internal.helper.SingletonLocale;\nimport net.datafaker.providers.base.Address;\nimport java.net.MalformedURLException;\nimport java.util.IdentityHashMap;\nimport java.util.ArrayList;\nimport net.datafaker.providers.base.Name;\nimport net.datafaker.providers.base.BaseFaker;\nimport java.util.logging.Logger;\nimport net.datafaker.transformations.CsvTransformer;\nimport net.datafaker.transformations.Field;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport net.datafaker.providers.base.ProviderRegistration;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport net.datafaker.transformations.JsonTransformer;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.nio.file.Path;\nimport net.datafaker.providers.base.AbstractProvider;\nimport java.lang.reflect.Constructor;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.lang.reflect.InvocationTargetException;\nimport com.mifmif.common.regex.Generex;\nimport java.lang.reflect.Array;\nimport static net.datafaker.transformations.Field.field;\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.util.Objects;\nimport net.datafaker.transformations.SimpleField;\nimport java.util.logging.Level;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\npublic class FakeValuesService {\n    public static final SingletonLocale DEFAULT_LOCALE = SingletonLocale.get(Locale.ENGLISH);\n    private final Map<String, String> name2yaml = new WeakHashMap<>();\n    private String javaNameToYamlName(String expression) {\r\n        String result = name2yaml.get(expression);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        final int length = expression.length();\r\n        final boolean firstLetterUpperCase = (length > 0) && Character.isUpperCase(expression.charAt(0));\r\n        int cnt = (firstLetterUpperCase) ? 1 : 0;\r\n        for (int i = 1; i < length; i++) {\r\n            if (Character.isUpperCase(expression.charAt(i))) {\r\n                cnt++;\r\n            }\r\n        }\r\n        if (cnt == 0) {\r\n            name2yaml.put(expression, expression);\r\n            return expression;\r\n        }\r\n        final char[] res = new char[length + (firstLetterUpperCase ? cnt - 1 : cnt)];\r\n        int pos = 0;\r\n        for (int i = 0; i < length; i++) {\r\n            final char c = expression.charAt(i);\r\n            if (cnt > 0) {\r\n                if (Character.isUpperCase(c)) {\r\n                    if (pos > 0) {\r\n                        res[pos++] = '_';\r\n                    }\r\n                    res[pos++] = Character.toLowerCase(c);\r\n                    cnt--;\r\n                } else {\r\n                    res[pos++] = c;\r\n                }\r\n            } else {\r\n                res[pos++] = c;\r\n            }\r\n        }\r\n        result = new String(res);\r\n        name2yaml.put(expression, result);\r\n        return result;\r\n    }\npublic void addPath(Locale locale, Path path);\n    public void addUrl(Locale locale, URL url);\n    public String bothify(String string, FakerContext context);\n    public String bothify(String input, FakerContext context, boolean isUpper);\n    public String csv(int limit, String... columnExpressions);\n    public String csv(String delimiter, char quote, boolean withHeader, int limit, String... columnExpressions);\n    public String examplify(String example, FakerContext context);\n    public String expression(String expression, BaseFaker faker, FakerContext context);\n    public Object fetch(String key, FakerContext context);\n    public Object fetchObject(String key, FakerContext context);\n    public String fetchString(String key, FakerContext context);\n    public String fileExpression(Path path, BaseFaker faker, FakerContext context);\n    public String json(String... fieldExpressions);\n    public String jsona(String... fieldExpressions);\n    public String letterify(String letterString, FakerContext context);\n    public String letterify(String letterString, FakerContext context, boolean isUpper);\n    public String numerify(String numberString, FakerContext context);\n    public static Class<?> primitiveToWrapper(final Class<?> cls);\n    public String regexify(String regex, FakerContext context);\n    public String resolve(String key, Object current, BaseFaker root, FakerContext context);\n    public String resolve(String key, Object current, ProviderRegistration root, Supplier<String> exceptionMessage, FakerContext context);\n    public String resolve(String key, AbstractProvider<?> provider, FakerContext context);\n    protected String resolveExpression(String expression, Object current, ProviderRegistration root, FakerContext context);\n    @SuppressWarnings(\"unchecked\")\r\npublic String safeFetch(String key, FakerContext context, String defaultIfNull);\n    public String templatify(String letterString, char char2replace, FakerContext context, String... options);\n    public String templatify(String letterString, Map<Character, String[]> optionsMap, FakerContext context);\n    public void updateFakeValuesInterfaceMap(List<SingletonLocale> locales);\n}"
      },
      {
        "id": "FakeValuesService_resolveExpression",
        "package": "net.datafaker.service",
        "class": "net.datafaker.service.FakeValuesService",
        "test-class": "net.datafaker.service.FakeValuesService_resolveExpression_Test",
        "method-name": "resolveExpression(String, String[], Object, ProviderRegistration, FakerContext)",
        "source-path": "src/main/java/net/datafaker/service/FakeValuesService.java",
        "test-path": "src/test/java/net/datafaker/service/FakeValuesService_resolveExpression_Test.java",
        "focal-method": "private Object resolveExpression(String directive, String[] args, Object current, ProviderRegistration root, FakerContext context) {\r\n    // name.name (resolve locally)\r\n    // Name.first_name (resolve to faker.name().firstName())\r\n    if (directive.isEmpty()) {\r\n        return directive;\r\n    }\r\n    final int dotIndex = getDotIndex(directive);\r\n    Object resolved;\r\n    if (args.length == 0) {\r\n        // resolve method references on CURRENT object like #{number_between '1','10'} on Number or\r\n        // #{ssn_valid} on IdNumber\r\n        if (dotIndex == (-1)) {\r\n            if (current instanceof AbstractProvider) {\r\n                final Method method = BaseFaker.getMethod(((AbstractProvider<?>) (current)), directive);\r\n                if (method != null) {\r\n                    try {\r\n                        return method.invoke(current);\r\n                    } catch (Exception e) {\r\n                        throw new RuntimeException((e + \" \") + Arrays.toString(args));\r\n                    }\r\n                }\r\n            }\r\n            Supplier<Object> supplier = resolveFromMethodOn(current, directive, args);\r\n            if ((supplier != null) && ((resolved = supplier.get()) != null)) {\r\n                // expression2function.put(expression, supplier);\r\n                return resolved;\r\n            }\r\n        }\r\n        if (dotIndex > 0) {\r\n            final AbstractProvider<?> ap = BaseFaker.getProvider(directive.substring(0, dotIndex), context);\r\n            final Method method = BaseFaker.getMethod(ap, directive.substring(dotIndex + 1));\r\n            if (method != null) {\r\n                try {\r\n                    return method.invoke(ap);\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException((e + \" \") + Arrays.toString(args));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    final String simpleDirective = ((dotIndex >= 0) || (current == null)) ? directive : (classNameToYamlName(current) + \".\") + directive;\r\n    // simple fetch of a value from the yaml file. the directive may have been mutated\r\n    // such that if the current yml object is car: and directive is #{wheel} then\r\n    // car.wheel will be looked up in the YAML file.\r\n    Supplier<Object> supplier = () -> safeFetch(simpleDirective, context, null);\r\n    resolved = supplier.get();\r\n    if (resolved != null) {\r\n        // expression2function.put(expression, supplier);\r\n        return resolved;\r\n    }\r\n    // resolve method references on faker object like #{regexify '[a-z]'}\r\n    if (((dotIndex == (-1)) && (root != null)) && ((current == null) || (root.getClass() != current.getClass()))) {\r\n        supplier = resolveFromMethodOn(root, directive, args);\r\n        if ((supplier != null) && ((resolved = supplier.get()) != null)) {\r\n            // expression2function.put(expression, supplier);\r\n            return resolved;\r\n        }\r\n    }\r\n    // Resolve Faker Object method references like #{ClassName.method_name}\r\n    if (dotIndex >= 0) {\r\n        supplier = resolveFakerObjectAndMethod(root, directive, dotIndex, args);\r\n        if ((supplier != null) && ((resolved = supplier.get()) != null)) {\r\n            // expression2function.put(expression, supplier);\r\n            return resolved;\r\n        }\r\n    }\r\n    // last ditch effort.  Due to Ruby's dynamic nature, something like 'Address.street_title' will resolve\r\n    // because 'street_title' is a dynamic method on the Address object.  We can't do this in Java so we go\r\n    // thru the normal resolution above, but if we will can't resolve it, we once again do a 'safeFetch' as we\r\n    // did first but FIRST we change the Object reference Class.method_name with a yml style internal reference ->\r\n    // class.method_name (lowercase)\r\n    if (dotIndex >= 0) {\r\n        supplier = () -> safeFetch(javaNameToYamlName(simpleDirective), context, null);\r\n        resolved = supplier.get();\r\n    }\r\n    return resolved;\r\n}",
        "class-code": "package net.datafaker.service;\nimport java.util.Locale;\nimport net.datafaker.transformations.Schema;\nimport java.util.HashMap;\nimport net.datafaker.internal.helper.SingletonLocale;\nimport net.datafaker.providers.base.Address;\nimport java.net.MalformedURLException;\nimport java.util.IdentityHashMap;\nimport java.util.ArrayList;\nimport net.datafaker.providers.base.Name;\nimport net.datafaker.providers.base.BaseFaker;\nimport java.util.logging.Logger;\nimport net.datafaker.transformations.CsvTransformer;\nimport net.datafaker.transformations.Field;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport net.datafaker.providers.base.ProviderRegistration;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport net.datafaker.transformations.JsonTransformer;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.nio.file.Path;\nimport net.datafaker.providers.base.AbstractProvider;\nimport java.lang.reflect.Constructor;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.lang.reflect.InvocationTargetException;\nimport com.mifmif.common.regex.Generex;\nimport java.lang.reflect.Array;\nimport static net.datafaker.transformations.Field.field;\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.util.Objects;\nimport net.datafaker.transformations.SimpleField;\nimport java.util.logging.Level;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\npublic class FakeValuesService {\n    public static final SingletonLocale DEFAULT_LOCALE = SingletonLocale.get(Locale.ENGLISH);\n    private Object resolveExpression(String directive, String[] args, Object current, ProviderRegistration root, FakerContext context) {\r\n        // name.name (resolve locally)\r\n        // Name.first_name (resolve to faker.name().firstName())\r\n        if (directive.isEmpty()) {\r\n            return directive;\r\n        }\r\n        final int dotIndex = getDotIndex(directive);\r\n        Object resolved;\r\n        if (args.length == 0) {\r\n            // resolve method references on CURRENT object like #{number_between '1','10'} on Number or\r\n            // #{ssn_valid} on IdNumber\r\n            if (dotIndex == (-1)) {\r\n                if (current instanceof AbstractProvider) {\r\n                    final Method method = BaseFaker.getMethod(((AbstractProvider<?>) (current)), directive);\r\n                    if (method != null) {\r\n                        try {\r\n                            return method.invoke(current);\r\n                        } catch (Exception e) {\r\n                            throw new RuntimeException((e + \" \") + Arrays.toString(args));\r\n                        }\r\n                    }\r\n                }\r\n                Supplier<Object> supplier = resolveFromMethodOn(current, directive, args);\r\n                if ((supplier != null) && ((resolved = supplier.get()) != null)) {\r\n                    // expression2function.put(expression, supplier);\r\n                    return resolved;\r\n                }\r\n            }\r\n            if (dotIndex > 0) {\r\n                final AbstractProvider<?> ap = BaseFaker.getProvider(directive.substring(0, dotIndex), context);\r\n                final Method method = BaseFaker.getMethod(ap, directive.substring(dotIndex + 1));\r\n                if (method != null) {\r\n                    try {\r\n                        return method.invoke(ap);\r\n                    } catch (Exception e) {\r\n                        throw new RuntimeException((e + \" \") + Arrays.toString(args));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        final String simpleDirective = ((dotIndex >= 0) || (current == null)) ? directive : (classNameToYamlName(current) + \".\") + directive;\r\n        // simple fetch of a value from the yaml file. the directive may have been mutated\r\n        // such that if the current yml object is car: and directive is #{wheel} then\r\n        // car.wheel will be looked up in the YAML file.\r\n        Supplier<Object> supplier = () -> safeFetch(simpleDirective, context, null);\r\n        resolved = supplier.get();\r\n        if (resolved != null) {\r\n            // expression2function.put(expression, supplier);\r\n            return resolved;\r\n        }\r\n        // resolve method references on faker object like #{regexify '[a-z]'}\r\n        if (((dotIndex == (-1)) && (root != null)) && ((current == null) || (root.getClass() != current.getClass()))) {\r\n            supplier = resolveFromMethodOn(root, directive, args);\r\n            if ((supplier != null) && ((resolved = supplier.get()) != null)) {\r\n                // expression2function.put(expression, supplier);\r\n                return resolved;\r\n            }\r\n        }\r\n        // Resolve Faker Object method references like #{ClassName.method_name}\r\n        if (dotIndex >= 0) {\r\n            supplier = resolveFakerObjectAndMethod(root, directive, dotIndex, args);\r\n            if ((supplier != null) && ((resolved = supplier.get()) != null)) {\r\n                // expression2function.put(expression, supplier);\r\n                return resolved;\r\n            }\r\n        }\r\n        // last ditch effort.  Due to Ruby's dynamic nature, something like 'Address.street_title' will resolve\r\n        // because 'street_title' is a dynamic method on the Address object.  We can't do this in Java so we go\r\n        // thru the normal resolution above, but if we will can't resolve it, we once again do a 'safeFetch' as we\r\n        // did first but FIRST we change the Object reference Class.method_name with a yml style internal reference ->\r\n        // class.method_name (lowercase)\r\n        if (dotIndex >= 0) {\r\n            supplier = () -> safeFetch(javaNameToYamlName(simpleDirective), context, null);\r\n            resolved = supplier.get();\r\n        }\r\n        return resolved;\r\n    }\npublic void addPath(Locale locale, Path path);\n    public void addUrl(Locale locale, URL url);\n    public String bothify(String string, FakerContext context);\n    public String bothify(String input, FakerContext context, boolean isUpper);\n    private String classNameToYamlName(Object current);\n    public String csv(int limit, String... columnExpressions);\n    public String csv(String delimiter, char quote, boolean withHeader, int limit, String... columnExpressions);\n    public String examplify(String example, FakerContext context);\n    public String expression(String expression, BaseFaker faker, FakerContext context);\n    public Object fetch(String key, FakerContext context);\n    public Object fetchObject(String key, FakerContext context);\n    public String fetchString(String key, FakerContext context);\n    public String fileExpression(Path path, BaseFaker faker, FakerContext context);\n    private int getDotIndex(String directive);\n    private String javaNameToYamlName(String expression);\n    public String json(String... fieldExpressions);\n    public String jsona(String... fieldExpressions);\n    public String letterify(String letterString, FakerContext context);\n    public String letterify(String letterString, FakerContext context, boolean isUpper);\n    public String numerify(String numberString, FakerContext context);\n    public static Class<?> primitiveToWrapper(final Class<?> cls);\n    public String regexify(String regex, FakerContext context);\n    public String resolve(String key, Object current, BaseFaker root, FakerContext context);\n    public String resolve(String key, Object current, ProviderRegistration root, Supplier<String> exceptionMessage, FakerContext context);\n    public String resolve(String key, AbstractProvider<?> provider, FakerContext context);\n    protected String resolveExpression(String expression, Object current, ProviderRegistration root, FakerContext context);\n    private Supplier<Object> resolveFakerObjectAndMethod(ProviderRegistration faker, String key, int dotIndex, String[] args);\n    private Supplier<Object> resolveFromMethodOn(Object obj, String directive, String[] args);\n    @SuppressWarnings(\"unchecked\")\r\npublic String safeFetch(String key, FakerContext context, String defaultIfNull);\n    public String templatify(String letterString, char char2replace, FakerContext context, String... options);\n    public String templatify(String letterString, Map<Character, String[]> optionsMap, FakerContext context);\n    public void updateFakeValuesInterfaceMap(List<SingletonLocale> locales);\n}"
      },
      {
        "id": "FakeValues_toJavaNames",
        "package": "net.datafaker.service",
        "class": "net.datafaker.service.FakeValues",
        "test-class": "net.datafaker.service.FakeValues_toJavaNames_Test",
        "method-name": "toJavaNames(String, boolean)",
        "source-path": "src/main/java/net/datafaker/service/FakeValues.java",
        "test-path": "src/test/java/net/datafaker/service/FakeValues_toJavaNames_Test.java",
        "focal-method": "private static String toJavaNames(String string, boolean isMethod) {\r\n    final int length;\r\n    if ((string == null) || ((length = string.length()) == 0)) {\r\n        return string;\r\n    }\r\n    int cnt = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        if (string.charAt(i) == '_') {\r\n            cnt++;\r\n        }\r\n    }\r\n    if ((cnt == 0) && ((Character.isUpperCase(string.charAt(0)) && (!isMethod)) || (isMethod && Character.isLowerCase(string.charAt(0)))))\r\n        return string;\r\n\r\n    final char[] res = new char[length - cnt];\r\n    int pos = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        char c = string.charAt(i);\r\n        if ((i == 0) && Character.isLetter(c)) {\r\n            res[pos++] = (isMethod) ? Character.toLowerCase(c) : Character.toUpperCase(c);\r\n        } else if (c == '_') {\r\n            final char next = string.charAt(i + 1);\r\n            if ((i < (length - 1)) && Character.isLetter(next)) {\r\n                res[pos++] = Character.toUpperCase(next);\r\n                i++;\r\n            }\r\n        } else {\r\n            res[pos++] = c;\r\n        }\r\n    }\r\n    return new String(res);\r\n}",
        "class-code": "package net.datafaker.service;\nimport java.util.Locale;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.HashMap;\nimport net.datafaker.internal.helper.SingletonLocale;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.logging.Logger;\nimport org.yaml.snakeyaml.Yaml;\nimport java.net.URL;\nimport java.util.Objects;\nimport java.util.logging.Level;\nimport java.util.Map;\npublic class FakeValues implements FakeValuesInterface {\n    \n    private static String toJavaNames(String string, boolean isMethod) {\r\n        final int length;\r\n        if ((string == null) || ((length = string.length()) == 0)) {\r\n            return string;\r\n        }\r\n        int cnt = 0;\r\n        for (int i = 0; i < length; i++) {\r\n            if (string.charAt(i) == '_') {\r\n                cnt++;\r\n            }\r\n        }\r\n        if ((cnt == 0) && ((Character.isUpperCase(string.charAt(0)) && (!isMethod)) || (isMethod && Character.isLowerCase(string.charAt(0)))))\r\n            return string;\r\n    \r\n        final char[] res = new char[length - cnt];\r\n        int pos = 0;\r\n        for (int i = 0; i < length; i++) {\r\n            char c = string.charAt(i);\r\n            if ((i == 0) && Character.isLetter(c)) {\r\n                res[pos++] = (isMethod) ? Character.toLowerCase(c) : Character.toUpperCase(c);\r\n            } else if (c == '_') {\r\n                final char next = string.charAt(i + 1);\r\n                if ((i < (length - 1)) && Character.isLetter(next)) {\r\n                    res[pos++] = Character.toUpperCase(next);\r\n                    i++;\r\n                }\r\n            } else {\r\n                res[pos++] = c;\r\n            }\r\n        }\r\n        return new String(res);\r\n    }\n@Override\r\npublic boolean equals(Object o);\n    @Override\r\npublic Map<String, Object> get(String key);\n    Locale getLocale();\n    String getPath();\n    @Override\r\npublic int hashCode();\n    boolean supportsPath(String path);\n}"
      },
      {
        "id": "FakeValuesService_bothify",
        "package": "net.datafaker.service",
        "class": "net.datafaker.service.FakeValuesService",
        "test-class": "net.datafaker.service.FakeValuesService_bothify_Test",
        "method-name": "bothify(String, FakerContext, boolean, boolean, boolean)",
        "source-path": "src/main/java/net/datafaker/service/FakeValuesService.java",
        "test-path": "src/test/java/net/datafaker/service/FakeValuesService_bothify_Test.java",
        "focal-method": "private String bothify(String input, FakerContext context, boolean isUpper, boolean numerify, boolean letterify) {\r\n    final int baseChar = (isUpper) ? 65 : 97;\r\n    final char[] res = input.toCharArray();\r\n    for (int i = 0; i < res.length; i++) {\r\n        switch (res[i]) {\r\n            case '#' :\r\n                if (numerify) {\r\n                    res[i] = DIGITS[context.getRandomService().nextInt(10)];\r\n                }\r\n                break;\r\n            case '?' :\r\n                if (numerify) {\r\n                    res[i] = DIGITS[context.getRandomService().nextInt(1, 9)];\r\n                }\r\n                break;\r\n            case '?' :\r\n                if (letterify) {\r\n                    res[i] = ((char) (baseChar + context.getRandomService().nextInt(26)));// a-z\r\n\r\n                }\r\n                break;\r\n            default :\r\n                break;\r\n        }\r\n    }\r\n    return String.valueOf(res);\r\n}",
        "class-code": "package net.datafaker.service;\nimport java.util.Locale;\nimport net.datafaker.transformations.Schema;\nimport java.util.HashMap;\nimport net.datafaker.internal.helper.SingletonLocale;\nimport net.datafaker.providers.base.Address;\nimport java.net.MalformedURLException;\nimport java.util.IdentityHashMap;\nimport java.util.ArrayList;\nimport net.datafaker.providers.base.Name;\nimport net.datafaker.providers.base.BaseFaker;\nimport java.util.logging.Logger;\nimport net.datafaker.transformations.CsvTransformer;\nimport net.datafaker.transformations.Field;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport net.datafaker.providers.base.ProviderRegistration;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport net.datafaker.transformations.JsonTransformer;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.nio.file.Path;\nimport net.datafaker.providers.base.AbstractProvider;\nimport java.lang.reflect.Constructor;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.lang.reflect.InvocationTargetException;\nimport com.mifmif.common.regex.Generex;\nimport java.lang.reflect.Array;\nimport static net.datafaker.transformations.Field.field;\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.util.Objects;\nimport net.datafaker.transformations.SimpleField;\nimport java.util.logging.Level;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\npublic class FakeValuesService {\n    private static final char[] DIGITS = \"0123456789\".toCharArray();\n    public static final SingletonLocale DEFAULT_LOCALE = SingletonLocale.get(Locale.ENGLISH);\n    private String bothify(String input, FakerContext context, boolean isUpper, boolean numerify, boolean letterify) {\r\n        final int baseChar = (isUpper) ? 65 : 97;\r\n        final char[] res = input.toCharArray();\r\n        for (int i = 0; i < res.length; i++) {\r\n            switch (res[i]) {\r\n                case '#' :\r\n                    if (numerify) {\r\n                        res[i] = DIGITS[context.getRandomService().nextInt(10)];\r\n                    }\r\n                    break;\r\n                case '?' :\r\n                    if (numerify) {\r\n                        res[i] = DIGITS[context.getRandomService().nextInt(1, 9)];\r\n                    }\r\n                    break;\r\n                case '?' :\r\n                    if (letterify) {\r\n                        res[i] = ((char) (baseChar + context.getRandomService().nextInt(26)));// a-z\r\n    \r\n                    }\r\n                    break;\r\n                default :\r\n                    break;\r\n            }\r\n        }\r\n        return String.valueOf(res);\r\n    }\npublic void addPath(Locale locale, Path path);\n    public void addUrl(Locale locale, URL url);\n    public String bothify(String string, FakerContext context);\n    public String bothify(String input, FakerContext context, boolean isUpper);\n    public String csv(int limit, String... columnExpressions);\n    public String csv(String delimiter, char quote, boolean withHeader, int limit, String... columnExpressions);\n    public String examplify(String example, FakerContext context);\n    public String expression(String expression, BaseFaker faker, FakerContext context);\n    public Object fetch(String key, FakerContext context);\n    public Object fetchObject(String key, FakerContext context);\n    public String fetchString(String key, FakerContext context);\n    public String fileExpression(Path path, BaseFaker faker, FakerContext context);\n    public String json(String... fieldExpressions);\n    public String jsona(String... fieldExpressions);\n    public String letterify(String letterString, FakerContext context);\n    public String letterify(String letterString, FakerContext context, boolean isUpper);\n    public String numerify(String numberString, FakerContext context);\n    public static Class<?> primitiveToWrapper(final Class<?> cls);\n    public String regexify(String regex, FakerContext context);\n    public String resolve(String key, Object current, BaseFaker root, FakerContext context);\n    public String resolve(String key, Object current, ProviderRegistration root, Supplier<String> exceptionMessage, FakerContext context);\n    public String resolve(String key, AbstractProvider<?> provider, FakerContext context);\n    protected String resolveExpression(String expression, Object current, ProviderRegistration root, FakerContext context);\n    @SuppressWarnings(\"unchecked\")\r\npublic String safeFetch(String key, FakerContext context, String defaultIfNull);\n    public String templatify(String letterString, char char2replace, FakerContext context, String... options);\n    public String templatify(String letterString, Map<Character, String[]> optionsMap, FakerContext context);\n    public void updateFakeValuesInterfaceMap(List<SingletonLocale> locales);\n}"
      },
      {
        "id": "FakeValuesService_resolveExpression_2",
        "package": "net.datafaker.service",
        "class": "net.datafaker.service.FakeValuesService",
        "test-class": "net.datafaker.service.FakeValuesService_resolveExpression_2_Test",
        "method-name": "resolveExpression(String, Object, ProviderRegistration, FakerContext)",
        "source-path": "src/main/java/net/datafaker/service/FakeValuesService.java",
        "test-path": "src/test/java/net/datafaker/service/FakeValuesService_resolveExpression_2_Test.java",
        "focal-method": "protected String resolveExpression(String expression, Object current, ProviderRegistration root, FakerContext context) {\r\n    int cnt = 0;\r\n    final int expressionLength = expression.length();\r\n    for (int i = 0; i < expressionLength; i++) {\r\n        if (expression.charAt(i) == '}') {\r\n            cnt++;\r\n        }\r\n    }\r\n    if (cnt == 0) {\r\n        return expression;\r\n    }\r\n    final List<String> expressions = splitExpressions(expression, cnt, expressionLength);\r\n    final StringBuilder result = new StringBuilder(expressions.size() * expressionLength);\r\n    for (int i = 0; i < expressions.size(); i++) {\r\n        // odd are expressions, even are not expressions, just strings\r\n        final String expr = expressions.get(i);\r\n        if ((i % 2) == 0) {\r\n            if (!expr.isEmpty()) {\r\n                result.append(expr);\r\n            }\r\n            continue;\r\n        }\r\n        int j = 0;\r\n        final int length = expr.length();\r\n        while ((j < length) && (!Character.isWhitespace(expr.charAt(j))))\r\n            j++;\r\n\r\n        String directive = expr.substring(0, j);\r\n        while ((j < length) && Character.isWhitespace(expr.charAt(j)))\r\n            j++;\r\n\r\n        final String arguments = (j == length) ? \"\" : expr.substring(j);\r\n        final String[] args = splitArguments(arguments);\r\n        final Object resolved = resolveExpression(directive, args, current, root, context);\r\n        if (resolved == null) {\r\n            throw new RuntimeException((((\"Unable to resolve #{\" + expr) + \"} directive for FakerContext \") + context) + \".\");\r\n        }\r\n        result.append(resolveExpression(Objects.toString(resolved), current, root, context));\r\n    }\r\n    return result.toString();\r\n}",
        "class-code": "package net.datafaker.service;\nimport java.util.Locale;\nimport net.datafaker.transformations.Schema;\nimport java.util.HashMap;\nimport net.datafaker.internal.helper.SingletonLocale;\nimport net.datafaker.providers.base.Address;\nimport java.net.MalformedURLException;\nimport java.util.IdentityHashMap;\nimport java.util.ArrayList;\nimport net.datafaker.providers.base.Name;\nimport net.datafaker.providers.base.BaseFaker;\nimport java.util.logging.Logger;\nimport net.datafaker.transformations.CsvTransformer;\nimport net.datafaker.transformations.Field;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport net.datafaker.providers.base.ProviderRegistration;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport net.datafaker.transformations.JsonTransformer;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.nio.file.Path;\nimport net.datafaker.providers.base.AbstractProvider;\nimport java.lang.reflect.Constructor;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.lang.reflect.InvocationTargetException;\nimport com.mifmif.common.regex.Generex;\nimport java.lang.reflect.Array;\nimport static net.datafaker.transformations.Field.field;\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.util.Objects;\nimport net.datafaker.transformations.SimpleField;\nimport java.util.logging.Level;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\npublic class FakeValuesService {\n    public static final SingletonLocale DEFAULT_LOCALE = SingletonLocale.get(Locale.ENGLISH);\n    protected String resolveExpression(String expression, Object current, ProviderRegistration root, FakerContext context) {\r\n        int cnt = 0;\r\n        final int expressionLength = expression.length();\r\n        for (int i = 0; i < expressionLength; i++) {\r\n            if (expression.charAt(i) == '}') {\r\n                cnt++;\r\n            }\r\n        }\r\n        if (cnt == 0) {\r\n            return expression;\r\n        }\r\n        final List<String> expressions = splitExpressions(expression, cnt, expressionLength);\r\n        final StringBuilder result = new StringBuilder(expressions.size() * expressionLength);\r\n        for (int i = 0; i < expressions.size(); i++) {\r\n            // odd are expressions, even are not expressions, just strings\r\n            final String expr = expressions.get(i);\r\n            if ((i % 2) == 0) {\r\n                if (!expr.isEmpty()) {\r\n                    result.append(expr);\r\n                }\r\n                continue;\r\n            }\r\n            int j = 0;\r\n            final int length = expr.length();\r\n            while ((j < length) && (!Character.isWhitespace(expr.charAt(j))))\r\n                j++;\r\n    \r\n            String directive = expr.substring(0, j);\r\n            while ((j < length) && Character.isWhitespace(expr.charAt(j)))\r\n                j++;\r\n    \r\n            final String arguments = (j == length) ? \"\" : expr.substring(j);\r\n            final String[] args = splitArguments(arguments);\r\n            final Object resolved = resolveExpression(directive, args, current, root, context);\r\n            if (resolved == null) {\r\n                throw new RuntimeException((((\"Unable to resolve #{\" + expr) + \"} directive for FakerContext \") + context) + \".\");\r\n            }\r\n            result.append(resolveExpression(Objects.toString(resolved), current, root, context));\r\n        }\r\n        return result.toString();\r\n    }\npublic void addPath(Locale locale, Path path);\n    public void addUrl(Locale locale, URL url);\n    public String bothify(String string, FakerContext context);\n    public String bothify(String input, FakerContext context, boolean isUpper);\n    public String csv(int limit, String... columnExpressions);\n    public String csv(String delimiter, char quote, boolean withHeader, int limit, String... columnExpressions);\n    public String examplify(String example, FakerContext context);\n    public String expression(String expression, BaseFaker faker, FakerContext context);\n    public Object fetch(String key, FakerContext context);\n    public Object fetchObject(String key, FakerContext context);\n    public String fetchString(String key, FakerContext context);\n    public String fileExpression(Path path, BaseFaker faker, FakerContext context);\n    public String json(String... fieldExpressions);\n    public String jsona(String... fieldExpressions);\n    public String letterify(String letterString, FakerContext context);\n    public String letterify(String letterString, FakerContext context, boolean isUpper);\n    public String numerify(String numberString, FakerContext context);\n    public static Class<?> primitiveToWrapper(final Class<?> cls);\n    public String regexify(String regex, FakerContext context);\n    public String resolve(String key, Object current, BaseFaker root, FakerContext context);\n    public String resolve(String key, Object current, ProviderRegistration root, Supplier<String> exceptionMessage, FakerContext context);\n    public String resolve(String key, AbstractProvider<?> provider, FakerContext context);\n    private Object resolveExpression(String directive, String[] args, Object current, ProviderRegistration root, FakerContext context);\n    @SuppressWarnings(\"unchecked\")\r\npublic String safeFetch(String key, FakerContext context, String defaultIfNull);\n    private String[] splitArguments(String arguments);\n    private List<String> splitExpressions(String expression, int cnt, int length);\n    public String templatify(String letterString, char char2replace, FakerContext context, String... options);\n    public String templatify(String letterString, Map<Character, String[]> optionsMap, FakerContext context);\n    public void updateFakeValuesInterfaceMap(List<SingletonLocale> locales);\n}"
      }
    ]
  },
  "gson": {
    "project-name": "gson",
    "project-url": "gson/gson",
    "focal-methods": [
      {
        "id": "ConstructorConstructor_newDefaultImplementationConstructor",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.ConstructorConstructor",
        "test-class": "com.google.gson.internal.ConstructorConstructor_newDefaultImplementationConstructor_Test",
        "method-name": "newDefaultImplementationConstructor(Type, Class<? super T>)",
        "source-path": "src/main/java/com/google/gson/internal/ConstructorConstructor.java",
        "test-path": "src/test/java/com/google/gson/internal/ConstructorConstructor_newDefaultImplementationConstructor_Test.java",
        "focal-method": "@SuppressWarnings(\"unchecked\")\r\nprivate static <T> ObjectConstructor<T> newDefaultImplementationConstructor(final Type type, Class<? super T> rawType) {\r\n    /* IMPORTANT: Must only create instances for classes with public no-args constructor.\r\n    For classes with special constructors / factory methods (e.g. EnumSet)\r\n    `newSpecialCollectionConstructor` defined above must be used, to avoid no-args\r\n    constructor check (which is called before this method) detecting internal no-args\r\n    constructors which might be added in a future JDK version\r\n     */\r\n    if (Collection.class.isAssignableFrom(rawType)) {\r\n        if (SortedSet.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new TreeSet<>()));\r\n                }\r\n            };\r\n        } else if (Set.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new LinkedHashSet<>()));\r\n                }\r\n            };\r\n        } else if (Queue.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new ArrayDeque<>()));\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new ArrayList<>()));\r\n                }\r\n            };\r\n        }\r\n    }\r\n    if (Map.class.isAssignableFrom(rawType)) {\r\n        if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new ConcurrentSkipListMap<>()));\r\n                }\r\n            };\r\n        } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new ConcurrentHashMap<>()));\r\n                }\r\n            };\r\n        } else if (SortedMap.class.isAssignableFrom(rawType)) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new TreeMap<>()));\r\n                }\r\n            };\r\n        } else if ((type instanceof ParameterizedType) && (!String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) (type)).getActualTypeArguments()[0]).getRawType()))) {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new LinkedHashMap<>()));\r\n                }\r\n            };\r\n        } else {\r\n            return new ObjectConstructor<T>() {\r\n                @Override\r\n                public T construct() {\r\n                    return ((T) (new LinkedTreeMap<>()));\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\nimport java.util.SortedMap;\nimport com.google.gson.reflect.TypeToken;\nimport java.util.LinkedHashMap;\nimport java.util.SortedSet;\nimport java.lang.reflect.Modifier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport com.google.gson.JsonIOException;\nimport java.lang.reflect.ParameterizedType;\nimport java.util.TreeSet;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentNavigableMap;\nimport java.util.ArrayDeque;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport com.google.gson.ReflectionAccessFilter;\nimport com.google.gson.internal.reflect.ReflectionHelper;\nimport java.util.EnumSet;\nimport java.lang.reflect.Constructor;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.TreeMap;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Type;\nimport com.google.gson.ReflectionAccessFilter.FilterResult;\nimport java.util.Collection;\nimport com.google.gson.InstanceCreator;\nimport java.util.Map;\npublic final class ConstructorConstructor {\n    \n    @SuppressWarnings(\"unchecked\")\r\n    private static <T> ObjectConstructor<T> newDefaultImplementationConstructor(final Type type, Class<? super T> rawType) {\r\n        /* IMPORTANT: Must only create instances for classes with public no-args constructor.\r\n        For classes with special constructors / factory methods (e.g. EnumSet)\r\n        `newSpecialCollectionConstructor` defined above must be used, to avoid no-args\r\n        constructor check (which is called before this method) detecting internal no-args\r\n        constructors which might be added in a future JDK version\r\n         */\r\n        if (Collection.class.isAssignableFrom(rawType)) {\r\n            if (SortedSet.class.isAssignableFrom(rawType)) {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new TreeSet<>()));\r\n                    }\r\n                };\r\n            } else if (Set.class.isAssignableFrom(rawType)) {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new LinkedHashSet<>()));\r\n                    }\r\n                };\r\n            } else if (Queue.class.isAssignableFrom(rawType)) {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new ArrayDeque<>()));\r\n                    }\r\n                };\r\n            } else {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new ArrayList<>()));\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        if (Map.class.isAssignableFrom(rawType)) {\r\n            if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new ConcurrentSkipListMap<>()));\r\n                    }\r\n                };\r\n            } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new ConcurrentHashMap<>()));\r\n                    }\r\n                };\r\n            } else if (SortedMap.class.isAssignableFrom(rawType)) {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new TreeMap<>()));\r\n                    }\r\n                };\r\n            } else if ((type instanceof ParameterizedType) && (!String.class.isAssignableFrom(TypeToken.get(((ParameterizedType) (type)).getActualTypeArguments()[0]).getRawType()))) {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new LinkedHashMap<>()));\r\n                    }\r\n                };\r\n            } else {\r\n                return new ObjectConstructor<T>() {\r\n                    @Override\r\n                    public T construct() {\r\n                        return ((T) (new LinkedTreeMap<>()));\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    }\nstatic String checkInstantiable(Class<?> c);\n    public <T> ObjectConstructor<T> get(TypeToken<T> typeToken);\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "$Gson$Types_resolve",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.$Gson$Types",
        "test-class": "com.google.gson.internal.$Gson$Types_resolve_Test",
        "method-name": "resolve(Type, Class<?>, Type, Map<TypeVariable<?>, Type>)",
        "source-path": "src/main/java/com/google/gson/internal/$Gson$Types.java",
        "test-path": "src/test/java/com/google/gson/internal/$Gson$Types_resolve_Test.java",
        "focal-method": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve, Map<TypeVariable<?>, Type> visitedTypeVariables) {\r\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\r\n    TypeVariable<?> resolving = null;\r\n    while (true) {\r\n        if (toResolve instanceof TypeVariable) {\r\n            TypeVariable<?> typeVariable = ((TypeVariable<?>) (toResolve));\r\n            Type previouslyResolved = visitedTypeVariables.get(typeVariable);\r\n            if (previouslyResolved != null) {\r\n                // cannot reduce due to infinite recursion\r\n                return previouslyResolved == Void.TYPE ? toResolve : previouslyResolved;\r\n            }\r\n            // Insert a placeholder to mark the fact that we are in the process of resolving this type\r\n            visitedTypeVariables.put(typeVariable, Void.TYPE);\r\n            if (resolving == null) {\r\n                resolving = typeVariable;\r\n            }\r\n            toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\r\n            if (toResolve == typeVariable) {\r\n                break;\r\n            }\r\n        } else if ((toResolve instanceof Class) && ((Class<?>) (toResolve)).isArray()) {\r\n            Class<?> original = ((Class<?>) (toResolve));\r\n            Type componentType = original.getComponentType();\r\n            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve = (equal(componentType, newComponentType)) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof GenericArrayType) {\r\n            GenericArrayType original = ((GenericArrayType) (toResolve));\r\n            Type componentType = original.getGenericComponentType();\r\n            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve = (equal(componentType, newComponentType)) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof ParameterizedType) {\r\n            ParameterizedType original = ((ParameterizedType) (toResolve));\r\n            Type ownerType = original.getOwnerType();\r\n            Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\r\n            boolean changed = !equal(newOwnerType, ownerType);\r\n            Type[] args = original.getActualTypeArguments();\r\n            for (int t = 0, length = args.length; t < length; t++) {\r\n                Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\r\n                if (!equal(resolvedTypeArgument, args[t])) {\r\n                    if (!changed) {\r\n                        args = args.clone();\r\n                        changed = true;\r\n                    }\r\n                    args[t] = resolvedTypeArgument;\r\n                }\r\n            }\r\n            toResolve = (changed) ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original;\r\n            break;\r\n        } else if (toResolve instanceof WildcardType) {\r\n            WildcardType original = ((WildcardType) (toResolve));\r\n            Type[] originalLowerBound = original.getLowerBounds();\r\n            Type[] originalUpperBound = original.getUpperBounds();\r\n            if (originalLowerBound.length == 1) {\r\n                Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\r\n                if (lowerBound != originalLowerBound[0]) {\r\n                    toResolve = supertypeOf(lowerBound);\r\n                    break;\r\n                }\r\n            } else if (originalUpperBound.length == 1) {\r\n                Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\r\n                if (upperBound != originalUpperBound[0]) {\r\n                    toResolve = subtypeOf(upperBound);\r\n                    break;\r\n                }\r\n            }\r\n            toResolve = original;\r\n            break;\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // ensure that any in-process resolution gets updated with the final result\r\n    if (resolving != null) {\r\n        visitedTypeVariables.put(resolving, toResolve);\r\n    }\r\n    return toResolve;\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.util.HashMap;\nimport static java.util.Objects.requireNonNull;\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.util.Properties;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.WildcardType;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.ParameterizedType;\nimport java.util.Collection;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\nimport java.util.Arrays;\npublic final class $Gson$Types {\n    static final Type[] EMPTY_TYPE_ARRAY = new Type[]{  };\n    private static Type resolve(Type context, Class<?> contextRawType, Type toResolve, Map<TypeVariable<?>, Type> visitedTypeVariables) {\r\n        // this implementation is made a little more complicated in an attempt to avoid object-creation\r\n        TypeVariable<?> resolving = null;\r\n        while (true) {\r\n            if (toResolve instanceof TypeVariable) {\r\n                TypeVariable<?> typeVariable = ((TypeVariable<?>) (toResolve));\r\n                Type previouslyResolved = visitedTypeVariables.get(typeVariable);\r\n                if (previouslyResolved != null) {\r\n                    // cannot reduce due to infinite recursion\r\n                    return previouslyResolved == Void.TYPE ? toResolve : previouslyResolved;\r\n                }\r\n                // Insert a placeholder to mark the fact that we are in the process of resolving this type\r\n                visitedTypeVariables.put(typeVariable, Void.TYPE);\r\n                if (resolving == null) {\r\n                    resolving = typeVariable;\r\n                }\r\n                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\r\n                if (toResolve == typeVariable) {\r\n                    break;\r\n                }\r\n            } else if ((toResolve instanceof Class) && ((Class<?>) (toResolve)).isArray()) {\r\n                Class<?> original = ((Class<?>) (toResolve));\r\n                Type componentType = original.getComponentType();\r\n                Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n                toResolve = (equal(componentType, newComponentType)) ? original : arrayOf(newComponentType);\r\n                break;\r\n            } else if (toResolve instanceof GenericArrayType) {\r\n                GenericArrayType original = ((GenericArrayType) (toResolve));\r\n                Type componentType = original.getGenericComponentType();\r\n                Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n                toResolve = (equal(componentType, newComponentType)) ? original : arrayOf(newComponentType);\r\n                break;\r\n            } else if (toResolve instanceof ParameterizedType) {\r\n                ParameterizedType original = ((ParameterizedType) (toResolve));\r\n                Type ownerType = original.getOwnerType();\r\n                Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\r\n                boolean changed = !equal(newOwnerType, ownerType);\r\n                Type[] args = original.getActualTypeArguments();\r\n                for (int t = 0, length = args.length; t < length; t++) {\r\n                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\r\n                    if (!equal(resolvedTypeArgument, args[t])) {\r\n                        if (!changed) {\r\n                            args = args.clone();\r\n                            changed = true;\r\n                        }\r\n                        args[t] = resolvedTypeArgument;\r\n                    }\r\n                }\r\n                toResolve = (changed) ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original;\r\n                break;\r\n            } else if (toResolve instanceof WildcardType) {\r\n                WildcardType original = ((WildcardType) (toResolve));\r\n                Type[] originalLowerBound = original.getLowerBounds();\r\n                Type[] originalUpperBound = original.getUpperBounds();\r\n                if (originalLowerBound.length == 1) {\r\n                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\r\n                    if (lowerBound != originalLowerBound[0]) {\r\n                        toResolve = supertypeOf(lowerBound);\r\n                        break;\r\n                    }\r\n                } else if (originalUpperBound.length == 1) {\r\n                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\r\n                    if (upperBound != originalUpperBound[0]) {\r\n                        toResolve = subtypeOf(upperBound);\r\n                        break;\r\n                    }\r\n                }\r\n                toResolve = original;\r\n                break;\r\n            } else {\r\n                break;\r\n            }\r\n        } \r\n        // ensure that any in-process resolution gets updated with the final result\r\n        if (resolving != null) {\r\n            visitedTypeVariables.put(resolving, toResolve);\r\n        }\r\n        return toResolve;\r\n    }\npublic static GenericArrayType arrayOf(Type componentType);\n    public static Type canonicalize(Type type);\n    static void checkNotPrimitive(Type type);\n    private static boolean equal(Object a, Object b);\n    public static boolean equals(Type a, Type b);\n    public static Type getArrayComponentType(Type array);\n    public static Type getCollectionElementType(Type context, Class<?> contextRawType);\n    public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType);\n    public static Class<?> getRawType(Type type);\n    public static ParameterizedType newParameterizedTypeWithOwner(Type ownerType, Type rawType, Type... typeArguments);\n    public static Type resolve(Type context, Class<?> contextRawType, Type toResolve);\n    private static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown);\n    public static WildcardType subtypeOf(Type bound);\n    public static WildcardType supertypeOf(Type bound);\n    public static String typeToString(Type type);\n}"
      },
      {
        "id": "JsonReader_doPeek",
        "package": "com.google.gson.stream",
        "class": "com.google.gson.stream.JsonReader",
        "test-class": "com.google.gson.stream.JsonReader_doPeek_Test",
        "method-name": "doPeek()",
        "source-path": "src/main/java/com/google/gson/stream/JsonReader.java",
        "test-path": "src/test/java/com/google/gson/stream/JsonReader_doPeek_Test.java",
        "focal-method": "@SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException {\r\n    int peekStack = stack[stackSize - 1];\r\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c = nextNonWhitespace(true);\r\n        switch (c) {\r\n            case ']' :\r\n                return peeked = PEEKED_END_ARRAY;\r\n            case ';' :\r\n                checkLenient();// fall-through\r\n\r\n            case ',' :\r\n                break;\r\n            default :\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if ((peekStack == JsonScope.EMPTY_OBJECT) || (peekStack == JsonScope.NONEMPTY_OBJECT)) {\r\n        stack[stackSize - 1] = JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack == JsonScope.NONEMPTY_OBJECT) {\r\n            int c = nextNonWhitespace(true);\r\n            switch (c) {\r\n                case '}' :\r\n                    return peeked = PEEKED_END_OBJECT;\r\n                case ';' :\r\n                    checkLenient();// fall-through\r\n\r\n                case ',' :\r\n                    break;\r\n                default :\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c = nextNonWhitespace(true);\r\n        switch (c) {\r\n            case '\"' :\r\n                return peeked = PEEKED_DOUBLE_QUOTED_NAME;\r\n            case '\\'' :\r\n                checkLenient();\r\n                return peeked = PEEKED_SINGLE_QUOTED_NAME;\r\n            case '}' :\r\n                if (peekStack != JsonScope.NONEMPTY_OBJECT) {\r\n                    return peeked = PEEKED_END_OBJECT;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default :\r\n                checkLenient();\r\n                pos--;// Don't consume the first character in an unquoted string.\r\n\r\n                if (isLiteral(((char) (c)))) {\r\n                    return peeked = PEEKED_UNQUOTED_NAME;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c = nextNonWhitespace(true);\r\n        switch (c) {\r\n            case ':' :\r\n                break;\r\n            case '=' :\r\n                checkLenient();\r\n                if (((pos < limit) || fillBuffer(1)) && (buffer[pos] == '>')) {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default :\r\n                throw syntaxError(\"Expected ':'\");\r\n        }\r\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\r\n        if (lenient) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c = nextNonWhitespace(false);\r\n        if (c == (-1)) {\r\n            return peeked = PEEKED_EOF;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack == JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c = nextNonWhitespace(true);\r\n    switch (c) {\r\n        case ']' :\r\n            if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n                return peeked = PEEKED_END_ARRAY;\r\n            }\r\n            // fall-through to handle \",]\"\r\n        case ';' :\r\n        case ',' :\r\n            // In lenient mode, a 0-length literal in an array means 'null'.\r\n            if ((peekStack == JsonScope.EMPTY_ARRAY) || (peekStack == JsonScope.NONEMPTY_ARRAY)) {\r\n                checkLenient();\r\n                pos--;\r\n                return peeked = PEEKED_NULL;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case '\\'' :\r\n            checkLenient();\r\n            return peeked = PEEKED_SINGLE_QUOTED;\r\n        case '\"' :\r\n            return peeked = PEEKED_DOUBLE_QUOTED;\r\n        case '[' :\r\n            return peeked = PEEKED_BEGIN_ARRAY;\r\n        case '{' :\r\n            return peeked = PEEKED_BEGIN_OBJECT;\r\n        default :\r\n            pos--;// Don't consume the first character in a literal value.\r\n\r\n    }\r\n    int result = peekKeyword();\r\n    if (result != PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result = peekNumber();\r\n    if (result != PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    return peeked = PEEKED_UNQUOTED;\r\n}",
        "class-code": "package com.google.gson.stream;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport java.io.Reader;\nimport java.io.EOFException;\npublic class JsonReader implements Closeable {\n    private static final int PEEKED_NONE = 0;\n    private static final int PEEKED_BEGIN_OBJECT = 1;\n    private static final int PEEKED_END_OBJECT = 2;\n    private static final int PEEKED_BEGIN_ARRAY = 3;\n    private static final int PEEKED_END_ARRAY = 4;\n    private static final int PEEKED_NULL = 7;\n    private static final int PEEKED_SINGLE_QUOTED = 8;\n    private static final int PEEKED_DOUBLE_QUOTED = 9;\n    private static final int PEEKED_UNQUOTED = 10;\n    private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n    private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n    private static final int PEEKED_UNQUOTED_NAME = 14;\n    private static final int PEEKED_EOF = 17;\n    private boolean lenient = false;\n    static final int BUFFER_SIZE = 1024;\n    private final char[] buffer = new char[BUFFER_SIZE];\n    private int pos = 0;\n    private int limit = 0;\n    int peeked = PEEKED_NONE;\n    private int[] stack = new int[32];\n    private int stackSize = 0;\n    @SuppressWarnings(\"fallthrough\")\r\n    int doPeek() throws IOException {\r\n        int peekStack = stack[stackSize - 1];\r\n        if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n            stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\r\n        } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\r\n            // Look for a comma before the next element.\r\n            int c = nextNonWhitespace(true);\r\n            switch (c) {\r\n                case ']' :\r\n                    return peeked = PEEKED_END_ARRAY;\r\n                case ';' :\r\n                    checkLenient();// fall-through\r\n    \r\n                case ',' :\r\n                    break;\r\n                default :\r\n                    throw syntaxError(\"Unterminated array\");\r\n            }\r\n        } else if ((peekStack == JsonScope.EMPTY_OBJECT) || (peekStack == JsonScope.NONEMPTY_OBJECT)) {\r\n            stack[stackSize - 1] = JsonScope.DANGLING_NAME;\r\n            // Look for a comma before the next element.\r\n            if (peekStack == JsonScope.NONEMPTY_OBJECT) {\r\n                int c = nextNonWhitespace(true);\r\n                switch (c) {\r\n                    case '}' :\r\n                        return peeked = PEEKED_END_OBJECT;\r\n                    case ';' :\r\n                        checkLenient();// fall-through\r\n    \r\n                    case ',' :\r\n                        break;\r\n                    default :\r\n                        throw syntaxError(\"Unterminated object\");\r\n                }\r\n            }\r\n            int c = nextNonWhitespace(true);\r\n            switch (c) {\r\n                case '\"' :\r\n                    return peeked = PEEKED_DOUBLE_QUOTED_NAME;\r\n                case '\\'' :\r\n                    checkLenient();\r\n                    return peeked = PEEKED_SINGLE_QUOTED_NAME;\r\n                case '}' :\r\n                    if (peekStack != JsonScope.NONEMPTY_OBJECT) {\r\n                        return peeked = PEEKED_END_OBJECT;\r\n                    } else {\r\n                        throw syntaxError(\"Expected name\");\r\n                    }\r\n                default :\r\n                    checkLenient();\r\n                    pos--;// Don't consume the first character in an unquoted string.\r\n    \r\n                    if (isLiteral(((char) (c)))) {\r\n                        return peeked = PEEKED_UNQUOTED_NAME;\r\n                    } else {\r\n                        throw syntaxError(\"Expected name\");\r\n                    }\r\n            }\r\n        } else if (peekStack == JsonScope.DANGLING_NAME) {\r\n            stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\r\n            // Look for a colon before the value.\r\n            int c = nextNonWhitespace(true);\r\n            switch (c) {\r\n                case ':' :\r\n                    break;\r\n                case '=' :\r\n                    checkLenient();\r\n                    if (((pos < limit) || fillBuffer(1)) && (buffer[pos] == '>')) {\r\n                        pos++;\r\n                    }\r\n                    break;\r\n                default :\r\n                    throw syntaxError(\"Expected ':'\");\r\n            }\r\n        } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\r\n            if (lenient) {\r\n                consumeNonExecutePrefix();\r\n            }\r\n            stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\r\n        } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\r\n            int c = nextNonWhitespace(false);\r\n            if (c == (-1)) {\r\n                return peeked = PEEKED_EOF;\r\n            } else {\r\n                checkLenient();\r\n                pos--;\r\n            }\r\n        } else if (peekStack == JsonScope.CLOSED) {\r\n            throw new IllegalStateException(\"JsonReader is closed\");\r\n        }\r\n        int c = nextNonWhitespace(true);\r\n        switch (c) {\r\n            case ']' :\r\n                if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n                    return peeked = PEEKED_END_ARRAY;\r\n                }\r\n                // fall-through to handle \",]\"\r\n            case ';' :\r\n            case ',' :\r\n                // In lenient mode, a 0-length literal in an array means 'null'.\r\n                if ((peekStack == JsonScope.EMPTY_ARRAY) || (peekStack == JsonScope.NONEMPTY_ARRAY)) {\r\n                    checkLenient();\r\n                    pos--;\r\n                    return peeked = PEEKED_NULL;\r\n                } else {\r\n                    throw syntaxError(\"Unexpected value\");\r\n                }\r\n            case '\\'' :\r\n                checkLenient();\r\n                return peeked = PEEKED_SINGLE_QUOTED;\r\n            case '\"' :\r\n                return peeked = PEEKED_DOUBLE_QUOTED;\r\n            case '[' :\r\n                return peeked = PEEKED_BEGIN_ARRAY;\r\n            case '{' :\r\n                return peeked = PEEKED_BEGIN_OBJECT;\r\n            default :\r\n                pos--;// Don't consume the first character in a literal value.\r\n    \r\n        }\r\n        int result = peekKeyword();\r\n        if (result != PEEKED_NONE) {\r\n            return result;\r\n        }\r\n        result = peekNumber();\r\n        if (result != PEEKED_NONE) {\r\n            return result;\r\n        }\r\n        if (!isLiteral(buffer[pos])) {\r\n            throw syntaxError(\"Expected value\");\r\n        }\r\n        checkLenient();\r\n        return peeked = PEEKED_UNQUOTED;\r\n    }\npublic void beginArray() throws IOException;\n    public void beginObject() throws IOException;\n    private void checkLenient() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    private void consumeNonExecutePrefix() throws IOException;\n    public void endArray() throws IOException;\n    public void endObject() throws IOException;\n    private boolean fillBuffer(int minimum) throws IOException;\n    public String getPath();\n    public String getPreviousPath();\n    public boolean hasNext() throws IOException;\n    public final boolean isLenient();\n    @SuppressWarnings(\"fallthrough\")\r\nprivate boolean isLiteral(char c) throws IOException;\n    String locationString();\n    public boolean nextBoolean() throws IOException;\n    public double nextDouble() throws IOException;\n    public int nextInt() throws IOException;\n    public long nextLong() throws IOException;\n    public String nextName() throws IOException;\n    private int nextNonWhitespace(boolean throwOnEof) throws IOException;\n    public void nextNull() throws IOException;\n    public String nextString() throws IOException;\n    public JsonToken peek() throws IOException;\n    private int peekKeyword() throws IOException;\n    private int peekNumber() throws IOException;\n    public final void setLenient(boolean lenient);\n    public void skipValue() throws IOException;\n    private IOException syntaxError(String message) throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "JsonReader_skipValue",
        "package": "com.google.gson.stream",
        "class": "com.google.gson.stream.JsonReader",
        "test-class": "com.google.gson.stream.JsonReader_skipValue_Test",
        "method-name": "skipValue()",
        "source-path": "src/main/java/com/google/gson/stream/JsonReader.java",
        "test-path": "src/test/java/com/google/gson/stream/JsonReader_skipValue_Test.java",
        "focal-method": "public void skipValue() throws IOException {\r\n    int count = 0;\r\n    do {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        switch (p) {\r\n            case PEEKED_BEGIN_ARRAY :\r\n                push(JsonScope.EMPTY_ARRAY);\r\n                count++;\r\n                break;\r\n            case PEEKED_BEGIN_OBJECT :\r\n                push(JsonScope.EMPTY_OBJECT);\r\n                count++;\r\n                break;\r\n            case PEEKED_END_ARRAY :\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_END_OBJECT :\r\n                // Only update when object end is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count == 0) {\r\n                    pathNames[stackSize - 1] = null;// Free the last path name so that it can be garbage collected\r\n\r\n                }\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_UNQUOTED :\r\n                skipUnquotedValue();\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED :\r\n                skipQuotedValue('\\'');\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED :\r\n                skipQuotedValue('\"');\r\n                break;\r\n            case PEEKED_UNQUOTED_NAME :\r\n                skipUnquotedValue();\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count == 0) {\r\n                    pathNames[stackSize - 1] = \"<skipped>\";\r\n                }\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED_NAME :\r\n                skipQuotedValue('\\'');\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count == 0) {\r\n                    pathNames[stackSize - 1] = \"<skipped>\";\r\n                }\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED_NAME :\r\n                skipQuotedValue('\"');\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count == 0) {\r\n                    pathNames[stackSize - 1] = \"<skipped>\";\r\n                }\r\n                break;\r\n            case PEEKED_NUMBER :\r\n                pos += peekedNumberLength;\r\n                break;\r\n            case PEEKED_EOF :\r\n                // Do nothing\r\n                return;\r\n                // For all other tokens there is nothing to do; token has already been consumed from underlying reader\r\n        }\r\n        peeked = PEEKED_NONE;\r\n    } while (count > 0 );\r\n    pathIndices[stackSize - 1]++;\r\n}",
        "class-code": "package com.google.gson.stream;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport java.io.Reader;\nimport java.io.EOFException;\npublic class JsonReader implements Closeable {\n    private static final int PEEKED_NONE = 0;\n    private static final int PEEKED_BEGIN_OBJECT = 1;\n    private static final int PEEKED_END_OBJECT = 2;\n    private static final int PEEKED_BEGIN_ARRAY = 3;\n    private static final int PEEKED_END_ARRAY = 4;\n    private static final int PEEKED_SINGLE_QUOTED = 8;\n    private static final int PEEKED_DOUBLE_QUOTED = 9;\n    private static final int PEEKED_UNQUOTED = 10;\n    private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n    private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n    private static final int PEEKED_UNQUOTED_NAME = 14;\n    private static final int PEEKED_NUMBER = 16;\n    private static final int PEEKED_EOF = 17;\n    static final int BUFFER_SIZE = 1024;\n    private int pos = 0;\n    int peeked = PEEKED_NONE;\n    private int peekedNumberLength;\n    private int stackSize = 0;\n    private String[] pathNames = new String[32];\n    private int[] pathIndices = new int[32];\n    public void skipValue() throws IOException {\r\n        int count = 0;\r\n        do {\r\n            int p = peeked;\r\n            if (p == PEEKED_NONE) {\r\n                p = doPeek();\r\n            }\r\n            switch (p) {\r\n                case PEEKED_BEGIN_ARRAY :\r\n                    push(JsonScope.EMPTY_ARRAY);\r\n                    count++;\r\n                    break;\r\n                case PEEKED_BEGIN_OBJECT :\r\n                    push(JsonScope.EMPTY_OBJECT);\r\n                    count++;\r\n                    break;\r\n                case PEEKED_END_ARRAY :\r\n                    stackSize--;\r\n                    count--;\r\n                    break;\r\n                case PEEKED_END_OBJECT :\r\n                    // Only update when object end is explicitly skipped, otherwise stack is not updated anyways\r\n                    if (count == 0) {\r\n                        pathNames[stackSize - 1] = null;// Free the last path name so that it can be garbage collected\r\n    \r\n                    }\r\n                    stackSize--;\r\n                    count--;\r\n                    break;\r\n                case PEEKED_UNQUOTED :\r\n                    skipUnquotedValue();\r\n                    break;\r\n                case PEEKED_SINGLE_QUOTED :\r\n                    skipQuotedValue('\\'');\r\n                    break;\r\n                case PEEKED_DOUBLE_QUOTED :\r\n                    skipQuotedValue('\"');\r\n                    break;\r\n                case PEEKED_UNQUOTED_NAME :\r\n                    skipUnquotedValue();\r\n                    // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                    if (count == 0) {\r\n                        pathNames[stackSize - 1] = \"<skipped>\";\r\n                    }\r\n                    break;\r\n                case PEEKED_SINGLE_QUOTED_NAME :\r\n                    skipQuotedValue('\\'');\r\n                    // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                    if (count == 0) {\r\n                        pathNames[stackSize - 1] = \"<skipped>\";\r\n                    }\r\n                    break;\r\n                case PEEKED_DOUBLE_QUOTED_NAME :\r\n                    skipQuotedValue('\"');\r\n                    // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                    if (count == 0) {\r\n                        pathNames[stackSize - 1] = \"<skipped>\";\r\n                    }\r\n                    break;\r\n                case PEEKED_NUMBER :\r\n                    pos += peekedNumberLength;\r\n                    break;\r\n                case PEEKED_EOF :\r\n                    // Do nothing\r\n                    return;\r\n                    // For all other tokens there is nothing to do; token has already been consumed from underlying reader\r\n            }\r\n            peeked = PEEKED_NONE;\r\n        } while (count > 0 );\r\n        pathIndices[stackSize - 1]++;\r\n    }\npublic void beginArray() throws IOException;\n    public void beginObject() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    @SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException;\n    public void endArray() throws IOException;\n    public void endObject() throws IOException;\n    public String getPath();\n    public String getPreviousPath();\n    public boolean hasNext() throws IOException;\n    public final boolean isLenient();\n    String locationString();\n    public boolean nextBoolean() throws IOException;\n    public double nextDouble() throws IOException;\n    public int nextInt() throws IOException;\n    public long nextLong() throws IOException;\n    public String nextName() throws IOException;\n    public void nextNull() throws IOException;\n    public String nextString() throws IOException;\n    public JsonToken peek() throws IOException;\n    private void push(int newTop);\n    public final void setLenient(boolean lenient);\n    private void skipQuotedValue(char quote) throws IOException;\n    @SuppressWarnings(\"fallthrough\")\r\nprivate void skipUnquotedValue() throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "JsonTreeReader_peek",
        "package": "com.google.gson.internal.bind",
        "class": "com.google.gson.internal.bind.JsonTreeReader",
        "test-class": "com.google.gson.internal.bind.JsonTreeReader_peek_Test",
        "method-name": "peek()",
        "source-path": "src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
        "test-path": "src/test/java/com/google/gson/internal/bind/JsonTreeReader_peek_Test.java",
        "focal-method": "@Override\r\npublic JsonToken peek() throws IOException {\r\n    if (stackSize == 0) {\r\n        return JsonToken.END_DOCUMENT;\r\n    }\r\n    Object o = peekStack();\r\n    if (o instanceof Iterator) {\r\n        boolean isObject = stack[stackSize - 2] instanceof JsonObject;\r\n        Iterator<?> iterator = ((Iterator<?>) (o));\r\n        if (iterator.hasNext()) {\r\n            if (isObject) {\r\n                return JsonToken.NAME;\r\n            } else {\r\n                push(iterator.next());\r\n                return peek();\r\n            }\r\n        } else {\r\n            return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n        }\r\n    } else if (o instanceof JsonObject) {\r\n        return JsonToken.BEGIN_OBJECT;\r\n    } else if (o instanceof JsonArray) {\r\n        return JsonToken.BEGIN_ARRAY;\r\n    } else if (o instanceof JsonPrimitive) {\r\n        JsonPrimitive primitive = ((JsonPrimitive) (o));\r\n        if (primitive.isString()) {\r\n            return JsonToken.STRING;\r\n        } else if (primitive.isBoolean()) {\r\n            return JsonToken.BOOLEAN;\r\n        } else if (primitive.isNumber()) {\r\n            return JsonToken.NUMBER;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else if (o instanceof JsonNull) {\r\n        return JsonToken.NULL;\r\n    } else if (o == SENTINEL_CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    } else {\r\n        throw new MalformedJsonException((\"Custom JsonElement subclass \" + o.getClass().getName()) + \" is not supported\");\r\n    }\r\n}",
        "class-code": "package com.google.gson.internal.bind;\nimport com.google.gson.JsonObject;\nimport java.io.IOException;\nimport java.io.Reader;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.stream.JsonToken;\nimport java.util.Iterator;\nimport com.google.gson.JsonPrimitive;\nimport java.util.Map;\nimport java.util.Arrays;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.MalformedJsonException;\npublic final class JsonTreeReader extends JsonReader {\n    private static final Object SENTINEL_CLOSED = new Object();\n    private Object[] stack = new Object[32];\n    private int stackSize = 0;\n    @Override\r\n    public JsonToken peek() throws IOException {\r\n        if (stackSize == 0) {\r\n            return JsonToken.END_DOCUMENT;\r\n        }\r\n        Object o = peekStack();\r\n        if (o instanceof Iterator) {\r\n            boolean isObject = stack[stackSize - 2] instanceof JsonObject;\r\n            Iterator<?> iterator = ((Iterator<?>) (o));\r\n            if (iterator.hasNext()) {\r\n                if (isObject) {\r\n                    return JsonToken.NAME;\r\n                } else {\r\n                    push(iterator.next());\r\n                    return peek();\r\n                }\r\n            } else {\r\n                return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\r\n            }\r\n        } else if (o instanceof JsonObject) {\r\n            return JsonToken.BEGIN_OBJECT;\r\n        } else if (o instanceof JsonArray) {\r\n            return JsonToken.BEGIN_ARRAY;\r\n        } else if (o instanceof JsonPrimitive) {\r\n            JsonPrimitive primitive = ((JsonPrimitive) (o));\r\n            if (primitive.isString()) {\r\n                return JsonToken.STRING;\r\n            } else if (primitive.isBoolean()) {\r\n                return JsonToken.BOOLEAN;\r\n            } else if (primitive.isNumber()) {\r\n                return JsonToken.NUMBER;\r\n            } else {\r\n                throw new AssertionError();\r\n            }\r\n        } else if (o instanceof JsonNull) {\r\n            return JsonToken.NULL;\r\n        } else if (o == SENTINEL_CLOSED) {\r\n            throw new IllegalStateException(\"JsonReader is closed\");\r\n        } else {\r\n            throw new MalformedJsonException((\"Custom JsonElement subclass \" + o.getClass().getName()) + \" is not supported\");\r\n        }\r\n    }\n@Override\r\npublic void beginArray() throws IOException;\n    @Override\r\npublic void beginObject() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    @Override\r\npublic void endArray() throws IOException;\n    @Override\r\npublic void endObject() throws IOException;\n    @Override\r\npublic String getPath();\n    @Override\r\npublic String getPreviousPath();\n    @Override\r\npublic boolean hasNext() throws IOException;\n    @Override\r\npublic boolean nextBoolean() throws IOException;\n    @Override\r\npublic double nextDouble() throws IOException;\n    @Override\r\npublic int nextInt() throws IOException;\n    JsonElement nextJsonElement() throws IOException;\n    @Override\r\npublic long nextLong() throws IOException;\n    @Override\r\npublic String nextName() throws IOException;\n    @Override\r\npublic void nextNull() throws IOException;\n    @Override\r\npublic String nextString() throws IOException;\n    private Object peekStack();\n    public void promoteNameToValue() throws IOException;\n    private void push(Object newTop);\n    @Override\r\npublic void skipValue() throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "Primitives_unwrap",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.Primitives",
        "test-class": "com.google.gson.internal.Primitives_unwrap_Test",
        "method-name": "unwrap(Class<T>)",
        "source-path": "src/main/java/com/google/gson/internal/Primitives.java",
        "test-path": "src/test/java/com/google/gson/internal/Primitives_unwrap_Test.java",
        "focal-method": "@SuppressWarnings(\"unchecked\")\r\npublic static <T> Class<T> unwrap(Class<T> type) {\r\n    if (type == Integer.class)\r\n        return ((Class<T>) (int.class));\r\n\r\n    if (type == Float.class)\r\n        return ((Class<T>) (float.class));\r\n\r\n    if (type == Byte.class)\r\n        return ((Class<T>) (byte.class));\r\n\r\n    if (type == Double.class)\r\n        return ((Class<T>) (double.class));\r\n\r\n    if (type == Long.class)\r\n        return ((Class<T>) (long.class));\r\n\r\n    if (type == Character.class)\r\n        return ((Class<T>) (char.class));\r\n\r\n    if (type == Boolean.class)\r\n        return ((Class<T>) (boolean.class));\r\n\r\n    if (type == Short.class)\r\n        return ((Class<T>) (short.class));\r\n\r\n    if (type == Void.class)\r\n        return ((Class<T>) (void.class));\r\n\r\n    return type;\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.lang.reflect.Type;\npublic final class Primitives {\n    \n    @SuppressWarnings(\"unchecked\")\r\n    public static <T> Class<T> unwrap(Class<T> type) {\r\n        if (type == Integer.class)\r\n            return ((Class<T>) (int.class));\r\n    \r\n        if (type == Float.class)\r\n            return ((Class<T>) (float.class));\r\n    \r\n        if (type == Byte.class)\r\n            return ((Class<T>) (byte.class));\r\n    \r\n        if (type == Double.class)\r\n            return ((Class<T>) (double.class));\r\n    \r\n        if (type == Long.class)\r\n            return ((Class<T>) (long.class));\r\n    \r\n        if (type == Character.class)\r\n            return ((Class<T>) (char.class));\r\n    \r\n        if (type == Boolean.class)\r\n            return ((Class<T>) (boolean.class));\r\n    \r\n        if (type == Short.class)\r\n            return ((Class<T>) (short.class));\r\n    \r\n        if (type == Void.class)\r\n            return ((Class<T>) (void.class));\r\n    \r\n        return type;\r\n    }\npublic static boolean isPrimitive(Type type);\n    public static boolean isWrapperType(Type type);\n    @SuppressWarnings(\"unchecked\")\r\npublic static <T> Class<T> wrap(Class<T> type);\n}"
      },
      {
        "id": "JsonReader_peek",
        "package": "com.google.gson.stream",
        "class": "com.google.gson.stream.JsonReader",
        "test-class": "com.google.gson.stream.JsonReader_peek_Test",
        "method-name": "peek()",
        "source-path": "src/main/java/com/google/gson/stream/JsonReader.java",
        "test-path": "src/test/java/com/google/gson/stream/JsonReader_peek_Test.java",
        "focal-method": "public JsonToken peek() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    switch (p) {\r\n        case PEEKED_BEGIN_OBJECT :\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT :\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY :\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY :\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME :\r\n        case PEEKED_DOUBLE_QUOTED_NAME :\r\n        case PEEKED_UNQUOTED_NAME :\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE :\r\n        case PEEKED_FALSE :\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL :\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED :\r\n        case PEEKED_DOUBLE_QUOTED :\r\n        case PEEKED_UNQUOTED :\r\n        case PEEKED_BUFFERED :\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG :\r\n        case PEEKED_NUMBER :\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF :\r\n            return JsonToken.END_DOCUMENT;\r\n        default :\r\n            throw new AssertionError();\r\n    }\r\n}",
        "class-code": "package com.google.gson.stream;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport java.io.Reader;\nimport java.io.EOFException;\npublic class JsonReader implements Closeable {\n    private static final int PEEKED_NONE = 0;\n    private static final int PEEKED_BEGIN_OBJECT = 1;\n    private static final int PEEKED_END_OBJECT = 2;\n    private static final int PEEKED_BEGIN_ARRAY = 3;\n    private static final int PEEKED_END_ARRAY = 4;\n    private static final int PEEKED_TRUE = 5;\n    private static final int PEEKED_FALSE = 6;\n    private static final int PEEKED_NULL = 7;\n    private static final int PEEKED_SINGLE_QUOTED = 8;\n    private static final int PEEKED_DOUBLE_QUOTED = 9;\n    private static final int PEEKED_UNQUOTED = 10;\n    private static final int PEEKED_BUFFERED = 11;\n    private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n    private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n    private static final int PEEKED_UNQUOTED_NAME = 14;\n    private static final int PEEKED_LONG = 15;\n    private static final int PEEKED_NUMBER = 16;\n    private static final int PEEKED_EOF = 17;\n    static final int BUFFER_SIZE = 1024;\n    int peeked = PEEKED_NONE;\n    public JsonToken peek() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        switch (p) {\r\n            case PEEKED_BEGIN_OBJECT :\r\n                return JsonToken.BEGIN_OBJECT;\r\n            case PEEKED_END_OBJECT :\r\n                return JsonToken.END_OBJECT;\r\n            case PEEKED_BEGIN_ARRAY :\r\n                return JsonToken.BEGIN_ARRAY;\r\n            case PEEKED_END_ARRAY :\r\n                return JsonToken.END_ARRAY;\r\n            case PEEKED_SINGLE_QUOTED_NAME :\r\n            case PEEKED_DOUBLE_QUOTED_NAME :\r\n            case PEEKED_UNQUOTED_NAME :\r\n                return JsonToken.NAME;\r\n            case PEEKED_TRUE :\r\n            case PEEKED_FALSE :\r\n                return JsonToken.BOOLEAN;\r\n            case PEEKED_NULL :\r\n                return JsonToken.NULL;\r\n            case PEEKED_SINGLE_QUOTED :\r\n            case PEEKED_DOUBLE_QUOTED :\r\n            case PEEKED_UNQUOTED :\r\n            case PEEKED_BUFFERED :\r\n                return JsonToken.STRING;\r\n            case PEEKED_LONG :\r\n            case PEEKED_NUMBER :\r\n                return JsonToken.NUMBER;\r\n            case PEEKED_EOF :\r\n                return JsonToken.END_DOCUMENT;\r\n            default :\r\n                throw new AssertionError();\r\n        }\r\n    }\npublic void beginArray() throws IOException;\n    public void beginObject() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    @SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException;\n    public void endArray() throws IOException;\n    public void endObject() throws IOException;\n    public String getPath();\n    public String getPreviousPath();\n    public boolean hasNext() throws IOException;\n    public final boolean isLenient();\n    String locationString();\n    public boolean nextBoolean() throws IOException;\n    public double nextDouble() throws IOException;\n    public int nextInt() throws IOException;\n    public long nextLong() throws IOException;\n    public String nextName() throws IOException;\n    public void nextNull() throws IOException;\n    public String nextString() throws IOException;\n    public final void setLenient(boolean lenient);\n    public void skipValue() throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "JsonReader_peekNumber",
        "package": "com.google.gson.stream",
        "class": "com.google.gson.stream.JsonReader",
        "test-class": "com.google.gson.stream.JsonReader_peekNumber_Test",
        "method-name": "peekNumber()",
        "source-path": "src/main/java/com/google/gson/stream/JsonReader.java",
        "test-path": "src/test/java/com/google/gson/stream/JsonReader_peekNumber_Test.java",
        "focal-method": "private int peekNumber() throws IOException {\r\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n    char[] buffer = this.buffer;\r\n    int p = pos;\r\n    int l = limit;\r\n    long value = 0;// Negative to accommodate Long.MIN_VALUE more easily.\r\n\r\n    boolean negative = false;\r\n    boolean fitsInLong = true;\r\n    int last = NUMBER_CHAR_NONE;\r\n    int i = 0;\r\n    charactersOfNumber : for (; true; i++) {\r\n        if ((p + i) == l) {\r\n            if (i == buffer.length) {\r\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\r\n                // and let the application handle this as an unquoted literal.\r\n                return PEEKED_NONE;\r\n            }\r\n            if (!fillBuffer(i + 1)) {\r\n                break;\r\n            }\r\n            p = pos;\r\n            l = limit;\r\n        }\r\n        char c = buffer[p + i];\r\n        switch (c) {\r\n            case '-' :\r\n                if (last == NUMBER_CHAR_NONE) {\r\n                    negative = true;\r\n                    last = NUMBER_CHAR_SIGN;\r\n                    continue;\r\n                } else if (last == NUMBER_CHAR_EXP_E) {\r\n                    last = NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case '+' :\r\n                if (last == NUMBER_CHAR_EXP_E) {\r\n                    last = NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case 'e' :\r\n            case 'E' :\r\n                if ((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT)) {\r\n                    last = NUMBER_CHAR_EXP_E;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case '.' :\r\n                if (last == NUMBER_CHAR_DIGIT) {\r\n                    last = NUMBER_CHAR_DECIMAL;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            default :\r\n                if ((c < '0') || (c > '9')) {\r\n                    if (!isLiteral(c)) {\r\n                        break charactersOfNumber;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                }\r\n                if ((last == NUMBER_CHAR_SIGN) || (last == NUMBER_CHAR_NONE)) {\r\n                    value = -(c - '0');\r\n                    last = NUMBER_CHAR_DIGIT;\r\n                } else if (last == NUMBER_CHAR_DIGIT) {\r\n                    if (value == 0) {\r\n                        return PEEKED_NONE;// Leading '0' prefix is not allowed (since it could be octal).\r\n\r\n                    }\r\n                    long newValue = (value * 10) - (c - '0');\r\n                    fitsInLong &= (value > MIN_INCOMPLETE_INTEGER) || ((value == MIN_INCOMPLETE_INTEGER) && (newValue < value));\r\n                    value = newValue;\r\n                } else if (last == NUMBER_CHAR_DECIMAL) {\r\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\r\n                } else if ((last == NUMBER_CHAR_EXP_E) || (last == NUMBER_CHAR_EXP_SIGN)) {\r\n                    last = NUMBER_CHAR_EXP_DIGIT;\r\n                }\r\n        }\r\n    }\r\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\r\n    // Don't store -0 as long; user might want to read it as double -0.0\r\n    // Don't try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE\r\n    if ((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && ((value != 0) || (!negative))) {\r\n        peekedLong = (negative) ? value : -value;\r\n        pos += i;\r\n        return peeked = PEEKED_LONG;\r\n    } else if (((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT)) || (last == NUMBER_CHAR_EXP_DIGIT)) {\r\n        peekedNumberLength = i;\r\n        return peeked = PEEKED_NUMBER;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n}",
        "class-code": "package com.google.gson.stream;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport java.io.Reader;\nimport java.io.EOFException;\npublic class JsonReader implements Closeable {\n    private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n    private static final int PEEKED_NONE = 0;\n    private static final int PEEKED_LONG = 15;\n    private static final int PEEKED_NUMBER = 16;\n    private static final int NUMBER_CHAR_NONE = 0;\n    private static final int NUMBER_CHAR_SIGN = 1;\n    private static final int NUMBER_CHAR_DIGIT = 2;\n    private static final int NUMBER_CHAR_DECIMAL = 3;\n    private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n    private static final int NUMBER_CHAR_EXP_E = 5;\n    private static final int NUMBER_CHAR_EXP_SIGN = 6;\n    private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n    static final int BUFFER_SIZE = 1024;\n    private final char[] buffer = new char[BUFFER_SIZE];\n    private int pos = 0;\n    private int limit = 0;\n    int peeked = PEEKED_NONE;\n    private long peekedLong;\n    private int peekedNumberLength;\n    private int peekNumber() throws IOException {\r\n        // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n        char[] buffer = this.buffer;\r\n        int p = pos;\r\n        int l = limit;\r\n        long value = 0;// Negative to accommodate Long.MIN_VALUE more easily.\r\n    \r\n        boolean negative = false;\r\n        boolean fitsInLong = true;\r\n        int last = NUMBER_CHAR_NONE;\r\n        int i = 0;\r\n        charactersOfNumber : for (; true; i++) {\r\n            if ((p + i) == l) {\r\n                if (i == buffer.length) {\r\n                    // Though this looks like a well-formed number, it's too long to continue reading. Give up\r\n                    // and let the application handle this as an unquoted literal.\r\n                    return PEEKED_NONE;\r\n                }\r\n                if (!fillBuffer(i + 1)) {\r\n                    break;\r\n                }\r\n                p = pos;\r\n                l = limit;\r\n            }\r\n            char c = buffer[p + i];\r\n            switch (c) {\r\n                case '-' :\r\n                    if (last == NUMBER_CHAR_NONE) {\r\n                        negative = true;\r\n                        last = NUMBER_CHAR_SIGN;\r\n                        continue;\r\n                    } else if (last == NUMBER_CHAR_EXP_E) {\r\n                        last = NUMBER_CHAR_EXP_SIGN;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                case '+' :\r\n                    if (last == NUMBER_CHAR_EXP_E) {\r\n                        last = NUMBER_CHAR_EXP_SIGN;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                case 'e' :\r\n                case 'E' :\r\n                    if ((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT)) {\r\n                        last = NUMBER_CHAR_EXP_E;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                case '.' :\r\n                    if (last == NUMBER_CHAR_DIGIT) {\r\n                        last = NUMBER_CHAR_DECIMAL;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                default :\r\n                    if ((c < '0') || (c > '9')) {\r\n                        if (!isLiteral(c)) {\r\n                            break charactersOfNumber;\r\n                        }\r\n                        return PEEKED_NONE;\r\n                    }\r\n                    if ((last == NUMBER_CHAR_SIGN) || (last == NUMBER_CHAR_NONE)) {\r\n                        value = -(c - '0');\r\n                        last = NUMBER_CHAR_DIGIT;\r\n                    } else if (last == NUMBER_CHAR_DIGIT) {\r\n                        if (value == 0) {\r\n                            return PEEKED_NONE;// Leading '0' prefix is not allowed (since it could be octal).\r\n    \r\n                        }\r\n                        long newValue = (value * 10) - (c - '0');\r\n                        fitsInLong &= (value > MIN_INCOMPLETE_INTEGER) || ((value == MIN_INCOMPLETE_INTEGER) && (newValue < value));\r\n                        value = newValue;\r\n                    } else if (last == NUMBER_CHAR_DECIMAL) {\r\n                        last = NUMBER_CHAR_FRACTION_DIGIT;\r\n                    } else if ((last == NUMBER_CHAR_EXP_E) || (last == NUMBER_CHAR_EXP_SIGN)) {\r\n                        last = NUMBER_CHAR_EXP_DIGIT;\r\n                    }\r\n            }\r\n        }\r\n        // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\r\n        // Don't store -0 as long; user might want to read it as double -0.0\r\n        // Don't try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE\r\n        if ((((last == NUMBER_CHAR_DIGIT) && fitsInLong) && ((value != Long.MIN_VALUE) || negative)) && ((value != 0) || (!negative))) {\r\n            peekedLong = (negative) ? value : -value;\r\n            pos += i;\r\n            return peeked = PEEKED_LONG;\r\n        } else if (((last == NUMBER_CHAR_DIGIT) || (last == NUMBER_CHAR_FRACTION_DIGIT)) || (last == NUMBER_CHAR_EXP_DIGIT)) {\r\n            peekedNumberLength = i;\r\n            return peeked = PEEKED_NUMBER;\r\n        } else {\r\n            return PEEKED_NONE;\r\n        }\r\n    }\npublic void beginArray() throws IOException;\n    public void beginObject() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    @SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException;\n    public void endArray() throws IOException;\n    public void endObject() throws IOException;\n    private boolean fillBuffer(int minimum) throws IOException;\n    public String getPath();\n    public String getPreviousPath();\n    public boolean hasNext() throws IOException;\n    public final boolean isLenient();\n    @SuppressWarnings(\"fallthrough\")\r\nprivate boolean isLiteral(char c) throws IOException;\n    String locationString();\n    public boolean nextBoolean() throws IOException;\n    public double nextDouble() throws IOException;\n    public int nextInt() throws IOException;\n    public long nextLong() throws IOException;\n    public String nextName() throws IOException;\n    public void nextNull() throws IOException;\n    public String nextString() throws IOException;\n    public JsonToken peek() throws IOException;\n    public final void setLenient(boolean lenient);\n    public void skipValue() throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "JsonReader_nextUnquotedValue",
        "package": "com.google.gson.stream",
        "class": "com.google.gson.stream.JsonReader",
        "test-class": "com.google.gson.stream.JsonReader_nextUnquotedValue_Test",
        "method-name": "nextUnquotedValue()",
        "source-path": "src/main/java/com/google/gson/stream/JsonReader.java",
        "test-path": "src/test/java/com/google/gson/stream/JsonReader_nextUnquotedValue_Test.java",
        "focal-method": "@SuppressWarnings(\"fallthrough\")\r\nprivate String nextUnquotedValue() throws IOException {\r\n    StringBuilder builder = null;\r\n    int i = 0;\r\n    findNonLiteralCharacter : while (true) {\r\n        for (; (pos + i) < limit; i++) {\r\n            switch (buffer[pos + i]) {\r\n                case '/' :\r\n                case '\\\\' :\r\n                case ';' :\r\n                case '#' :\r\n                case '=' :\r\n                    checkLenient();// fall-through\r\n\r\n                case '{' :\r\n                case '}' :\r\n                case '[' :\r\n                case ']' :\r\n                case ':' :\r\n                case ',' :\r\n                case ' ' :\r\n                case '\\t' :\r\n                case '\\f' :\r\n                case '\\r' :\r\n                case '\\n' :\r\n                    break findNonLiteralCharacter;\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i < buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder == null) {\r\n            builder = new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos += i;\r\n        i = 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    } \r\n    String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos += i;\r\n    return result;\r\n}",
        "class-code": "package com.google.gson.stream;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport java.io.Reader;\nimport java.io.EOFException;\npublic class JsonReader implements Closeable {\n    static final int BUFFER_SIZE = 1024;\n    private final char[] buffer = new char[BUFFER_SIZE];\n    private int pos = 0;\n    private int limit = 0;\n    int peeked = PEEKED_NONE;\n    @SuppressWarnings(\"fallthrough\")\r\n    private String nextUnquotedValue() throws IOException {\r\n        StringBuilder builder = null;\r\n        int i = 0;\r\n        findNonLiteralCharacter : while (true) {\r\n            for (; (pos + i) < limit; i++) {\r\n                switch (buffer[pos + i]) {\r\n                    case '/' :\r\n                    case '\\\\' :\r\n                    case ';' :\r\n                    case '#' :\r\n                    case '=' :\r\n                        checkLenient();// fall-through\r\n    \r\n                    case '{' :\r\n                    case '}' :\r\n                    case '[' :\r\n                    case ']' :\r\n                    case ':' :\r\n                    case ',' :\r\n                    case ' ' :\r\n                    case '\\t' :\r\n                    case '\\f' :\r\n                    case '\\r' :\r\n                    case '\\n' :\r\n                        break findNonLiteralCharacter;\r\n                }\r\n            }\r\n            // Attempt to load the entire literal into the buffer at once.\r\n            if (i < buffer.length) {\r\n                if (fillBuffer(i + 1)) {\r\n                    continue;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            // use a StringBuilder when the value is too long. This is too long to be a number!\r\n            if (builder == null) {\r\n                builder = new StringBuilder(Math.max(i, 16));\r\n            }\r\n            builder.append(buffer, pos, i);\r\n            pos += i;\r\n            i = 0;\r\n            if (!fillBuffer(1)) {\r\n                break;\r\n            }\r\n        } \r\n        String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n        pos += i;\r\n        return result;\r\n    }\npublic void beginArray() throws IOException;\n    public void beginObject() throws IOException;\n    private void checkLenient() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    @SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException;\n    public void endArray() throws IOException;\n    public void endObject() throws IOException;\n    private boolean fillBuffer(int minimum) throws IOException;\n    public String getPath();\n    public String getPreviousPath();\n    public boolean hasNext() throws IOException;\n    public final boolean isLenient();\n    String locationString();\n    public boolean nextBoolean() throws IOException;\n    public double nextDouble() throws IOException;\n    public int nextInt() throws IOException;\n    public long nextLong() throws IOException;\n    public String nextName() throws IOException;\n    public void nextNull() throws IOException;\n    public String nextString() throws IOException;\n    public JsonToken peek() throws IOException;\n    public final void setLenient(boolean lenient);\n    public void skipValue() throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "LinkedTreeMap_find",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.LinkedTreeMap",
        "test-class": "com.google.gson.internal.LinkedTreeMap_find_Test",
        "method-name": "find(K, boolean)",
        "source-path": "src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "test-path": "src/test/java/com/google/gson/internal/LinkedTreeMap_find_Test.java",
        "focal-method": "Node<K, V> find(K key, boolean create) {\r\n    Comparator<? super K> comparator = this.comparator;\r\n    Node<K, V> nearest = root;\r\n    int comparison = 0;\r\n    if (nearest != null) {\r\n        // Micro-optimization: avoid polymorphic calls to Comparator.compare().\r\n        // Throws a ClassCastException below if there's trouble.\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable<Object> comparableKey = (comparator == NATURAL_ORDER) ? ((Comparable<Object>) (key)) : null;\r\n        while (true) {\r\n            comparison = (comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            // We found the requested key.\r\n            if (comparison == 0) {\r\n                return nearest;\r\n            }\r\n            // If it exists, the key is in a subtree. Go deeper.\r\n            Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\r\n            if (child == null) {\r\n                break;\r\n            }\r\n            nearest = child;\r\n        } \r\n    }\r\n    // The key doesn't exist in this tree.\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    // Create the node and add it to the tree or the table.\r\n    Node<K, V> header = this.header;\r\n    Node<K, V> created;\r\n    if (nearest == null) {\r\n        // Check that the value is comparable if we didn't do any comparisons.\r\n        if ((comparator == NATURAL_ORDER) && (!(key instanceof Comparable))) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n        root = created;\r\n    } else {\r\n        created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n        if (comparison < 0) {\r\n            // nearest.key is higher\r\n            nearest.left = created;\r\n        } else {\r\n            // comparison > 0, nearest.key is lower\r\n            nearest.right = created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    size++;\r\n    modCount++;\r\n    return created;\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.util.Set;\nimport java.util.ConcurrentModificationException;\nimport java.io.IOException;\nimport java.util.AbstractSet;\nimport java.util.LinkedHashMap;\nimport java.util.Comparator;\nimport java.util.AbstractMap;\nimport java.io.ObjectInputStream;\nimport java.io.InvalidObjectException;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\n@SuppressWarnings(\"serial\")\r\npublic final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\r\n    @Override\r\n    public int compare(Comparable a, Comparable b) {\r\n        return a.compareTo(b);\r\n    }\r\n};\n    private final boolean allowNullValues;\n    Node<K, V> root;\n    int size = 0;\n    int modCount = 0;\n    final Node<K, V> header;\n    Node<K, V> find(K key, boolean create) {\r\n        Comparator<? super K> comparator = this.comparator;\r\n        Node<K, V> nearest = root;\r\n        int comparison = 0;\r\n        if (nearest != null) {\r\n            // Micro-optimization: avoid polymorphic calls to Comparator.compare().\r\n            // Throws a ClassCastException below if there's trouble.\r\n            @SuppressWarnings(\"unchecked\")\r\n            Comparable<Object> comparableKey = (comparator == NATURAL_ORDER) ? ((Comparable<Object>) (key)) : null;\r\n            while (true) {\r\n                comparison = (comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n                // We found the requested key.\r\n                if (comparison == 0) {\r\n                    return nearest;\r\n                }\r\n                // If it exists, the key is in a subtree. Go deeper.\r\n                Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\r\n                if (child == null) {\r\n                    break;\r\n                }\r\n                nearest = child;\r\n            } \r\n        }\r\n        // The key doesn't exist in this tree.\r\n        if (!create) {\r\n            return null;\r\n        }\r\n        // Create the node and add it to the tree or the table.\r\n        Node<K, V> header = this.header;\r\n        Node<K, V> created;\r\n        if (nearest == null) {\r\n            // Check that the value is comparable if we didn't do any comparisons.\r\n            if ((comparator == NATURAL_ORDER) && (!(key instanceof Comparable))) {\r\n                throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n            }\r\n            created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n            root = created;\r\n        } else {\r\n            created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n            if (comparison < 0) {\r\n                // nearest.key is higher\r\n                nearest.left = created;\r\n            } else {\r\n                // comparison > 0, nearest.key is lower\r\n                nearest.right = created;\r\n            }\r\n            rebalance(nearest, true);\r\n        }\r\n        size++;\r\n        modCount++;\r\n        return created;\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\npublic boolean containsKey(Object key);\n    @Override\r\npublic Set<Entry<K, V>> entrySet();\n    Node<K, V> findByEntry(Entry<?, ?> entry);\n    @SuppressWarnings(\"unchecked\")\r\nNode<K, V> findByObject(Object key);\n    @Override\r\npublic V get(Object key);\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic V put(K key, V value);\n    private void rebalance(Node<K, V> unbalanced, boolean insert);\n    @Override\r\npublic V remove(Object key);\n    void removeInternal(Node<K, V> node, boolean unlink);\n    Node<K, V> removeInternalByKey(Object key);\n    @Override\r\npublic int size();\n}"
      },
      {
        "id": "JsonReader_nextNonWhitespace",
        "package": "com.google.gson.stream",
        "class": "com.google.gson.stream.JsonReader",
        "test-class": "com.google.gson.stream.JsonReader_nextNonWhitespace_Test",
        "method-name": "nextNonWhitespace(boolean)",
        "source-path": "src/main/java/com/google/gson/stream/JsonReader.java",
        "test-path": "src/test/java/com/google/gson/stream/JsonReader_nextNonWhitespace_Test.java",
        "focal-method": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\r\n    /* This code uses ugly local variables 'p' and 'l' representing the 'pos'\r\n    and 'limit' fields respectively. Using locals rather than fields saves\r\n    a few field reads for each whitespace character in a pretty-printed\r\n    document, resulting in a 5% speedup. We need to flush 'p' to its field\r\n    before any (potentially indirect) call to fillBuffer() and reread both\r\n    'p' and 'l' after any (potentially indirect) call to the same method.\r\n     */\r\n    char[] buffer = this.buffer;\r\n    int p = pos;\r\n    int l = limit;\r\n    while (true) {\r\n        if (p == l) {\r\n            pos = p;\r\n            if (!fillBuffer(1)) {\r\n                break;\r\n            }\r\n            p = pos;\r\n            l = limit;\r\n        }\r\n        int c = buffer[p++];\r\n        if (c == '\\n') {\r\n            lineNumber++;\r\n            lineStart = p;\r\n            continue;\r\n        } else if (((c == ' ') || (c == '\\r')) || (c == '\\t')) {\r\n            continue;\r\n        }\r\n        if (c == '/') {\r\n            pos = p;\r\n            if (p == l) {\r\n                pos--;// push back '/' so it's still in the buffer when this method returns\r\n\r\n                boolean charsLoaded = fillBuffer(2);\r\n                pos++;// consume the '/' again\r\n\r\n                if (!charsLoaded) {\r\n                    return c;\r\n                }\r\n            }\r\n            checkLenient();\r\n            char peek = buffer[pos];\r\n            switch (peek) {\r\n                case '*' :\r\n                    // skip a /* c-style comment */\r\n                    pos++;\r\n                    if (!skipTo(\"*/\")) {\r\n                        throw syntaxError(\"Unterminated comment\");\r\n                    }\r\n                    p = pos + 2;\r\n                    l = limit;\r\n                    continue;\r\n                case '/' :\r\n                    // skip a // end-of-line comment\r\n                    pos++;\r\n                    skipToEndOfLine();\r\n                    p = pos;\r\n                    l = limit;\r\n                    continue;\r\n                default :\r\n                    return c;\r\n            }\r\n        } else if (c == '#') {\r\n            pos = p;\r\n            /* Skip a # hash end-of-line comment. The JSON RFC doesn't\r\n            specify this behaviour, but it's required to parse\r\n            existing documents. See http://b/2571423.\r\n             */\r\n            checkLenient();\r\n            skipToEndOfLine();\r\n            p = pos;\r\n            l = limit;\r\n        } else {\r\n            pos = p;\r\n            return c;\r\n        }\r\n    } \r\n    if (throwOnEof) {\r\n        throw new EOFException(\"End of input\" + locationString());\r\n    } else {\r\n        return -1;\r\n    }\r\n}",
        "class-code": "package com.google.gson.stream;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport java.io.Reader;\nimport java.io.EOFException;\npublic class JsonReader implements Closeable {\n    static final int BUFFER_SIZE = 1024;\n    private final char[] buffer = new char[BUFFER_SIZE];\n    private int pos = 0;\n    private int limit = 0;\n    private int lineNumber = 0;\n    private int lineStart = 0;\n    int peeked = PEEKED_NONE;\n    private int nextNonWhitespace(boolean throwOnEof) throws IOException {\r\n        /* This code uses ugly local variables 'p' and 'l' representing the 'pos'\r\n        and 'limit' fields respectively. Using locals rather than fields saves\r\n        a few field reads for each whitespace character in a pretty-printed\r\n        document, resulting in a 5% speedup. We need to flush 'p' to its field\r\n        before any (potentially indirect) call to fillBuffer() and reread both\r\n        'p' and 'l' after any (potentially indirect) call to the same method.\r\n         */\r\n        char[] buffer = this.buffer;\r\n        int p = pos;\r\n        int l = limit;\r\n        while (true) {\r\n            if (p == l) {\r\n                pos = p;\r\n                if (!fillBuffer(1)) {\r\n                    break;\r\n                }\r\n                p = pos;\r\n                l = limit;\r\n            }\r\n            int c = buffer[p++];\r\n            if (c == '\\n') {\r\n                lineNumber++;\r\n                lineStart = p;\r\n                continue;\r\n            } else if (((c == ' ') || (c == '\\r')) || (c == '\\t')) {\r\n                continue;\r\n            }\r\n            if (c == '/') {\r\n                pos = p;\r\n                if (p == l) {\r\n                    pos--;// push back '/' so it's still in the buffer when this method returns\r\n    \r\n                    boolean charsLoaded = fillBuffer(2);\r\n                    pos++;// consume the '/' again\r\n    \r\n                    if (!charsLoaded) {\r\n                        return c;\r\n                    }\r\n                }\r\n                checkLenient();\r\n                char peek = buffer[pos];\r\n                switch (peek) {\r\n                    case '*' :\r\n                        // skip a /* c-style comment */\r\n                        pos++;\r\n                        if (!skipTo(\"*/\")) {\r\n                            throw syntaxError(\"Unterminated comment\");\r\n                        }\r\n                        p = pos + 2;\r\n                        l = limit;\r\n                        continue;\r\n                    case '/' :\r\n                        // skip a // end-of-line comment\r\n                        pos++;\r\n                        skipToEndOfLine();\r\n                        p = pos;\r\n                        l = limit;\r\n                        continue;\r\n                    default :\r\n                        return c;\r\n                }\r\n            } else if (c == '#') {\r\n                pos = p;\r\n                /* Skip a # hash end-of-line comment. The JSON RFC doesn't\r\n                specify this behaviour, but it's required to parse\r\n                existing documents. See http://b/2571423.\r\n                 */\r\n                checkLenient();\r\n                skipToEndOfLine();\r\n                p = pos;\r\n                l = limit;\r\n            } else {\r\n                pos = p;\r\n                return c;\r\n            }\r\n        } \r\n        if (throwOnEof) {\r\n            throw new EOFException(\"End of input\" + locationString());\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\npublic void beginArray() throws IOException;\n    public void beginObject() throws IOException;\n    private void checkLenient() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    @SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException;\n    public void endArray() throws IOException;\n    public void endObject() throws IOException;\n    private boolean fillBuffer(int minimum) throws IOException;\n    public String getPath();\n    public String getPreviousPath();\n    public boolean hasNext() throws IOException;\n    public final boolean isLenient();\n    String locationString();\n    public boolean nextBoolean() throws IOException;\n    public double nextDouble() throws IOException;\n    public int nextInt() throws IOException;\n    public long nextLong() throws IOException;\n    public String nextName() throws IOException;\n    public void nextNull() throws IOException;\n    public String nextString() throws IOException;\n    public JsonToken peek() throws IOException;\n    public final void setLenient(boolean lenient);\n    private boolean skipTo(String toFind) throws IOException;\n    private void skipToEndOfLine() throws IOException;\n    public void skipValue() throws IOException;\n    private IOException syntaxError(String message) throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "Excluder_excludeField",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.Excluder",
        "test-class": "com.google.gson.internal.Excluder_excludeField_Test",
        "method-name": "excludeField(Field, boolean)",
        "source-path": "src/main/java/com/google/gson/internal/Excluder.java",
        "test-path": "src/test/java/com/google/gson/internal/Excluder_excludeField_Test.java",
        "focal-method": "public boolean excludeField(Field field, boolean serialize) {\r\n    if ((modifiers & field.getModifiers()) != 0) {\r\n        return true;\r\n    }\r\n    if ((version != Excluder.IGNORE_VERSIONS) && (!isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class)))) {\r\n        return true;\r\n    }\r\n    if (field.isSynthetic()) {\r\n        return true;\r\n    }\r\n    if (requireExpose) {\r\n        Expose annotation = field.getAnnotation(Expose.class);\r\n        if ((annotation == null) || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\r\n            return true;\r\n        }\r\n    }\r\n    if ((!serializeInnerClasses) && isInnerClass(field.getType())) {\r\n        return true;\r\n    }\r\n    if (isAnonymousOrNonStaticLocal(field.getType())) {\r\n        return true;\r\n    }\r\n    List<ExclusionStrategy> list = (serialize) ? serializationStrategies : deserializationStrategies;\r\n    if (!list.isEmpty()) {\r\n        FieldAttributes fieldAttributes = new FieldAttributes(field);\r\n        for (ExclusionStrategy exclusionStrategy : list) {\r\n            if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
        "class-code": "package com.google.gson.internal;\nimport com.google.gson.TypeAdapterFactory;\nimport java.util.ArrayList;\nimport com.google.gson.annotations.Expose;\nimport java.io.IOException;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonWriter;\nimport com.google.gson.Gson;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport com.google.gson.ExclusionStrategy;\nimport com.google.gson.annotations.Since;\nimport com.google.gson.TypeAdapter;\nimport java.util.List;\nimport com.google.gson.FieldAttributes;\nimport com.google.gson.annotations.Until;\nimport com.google.gson.stream.JsonReader;\nimport java.util.Collections;\npublic final class Excluder implements TypeAdapterFactory , Cloneable {\n    private static final double IGNORE_VERSIONS = -1.0;\n    public static final Excluder DEFAULT = new Excluder();\n    private double version = IGNORE_VERSIONS;\n    private int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\n    private boolean serializeInnerClasses = true;\n    private boolean requireExpose;\n    private List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\n    private List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n    public boolean excludeField(Field field, boolean serialize) {\r\n        if ((modifiers & field.getModifiers()) != 0) {\r\n            return true;\r\n        }\r\n        if ((version != Excluder.IGNORE_VERSIONS) && (!isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class)))) {\r\n            return true;\r\n        }\r\n        if (field.isSynthetic()) {\r\n            return true;\r\n        }\r\n        if (requireExpose) {\r\n            Expose annotation = field.getAnnotation(Expose.class);\r\n            if ((annotation == null) || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\r\n                return true;\r\n            }\r\n        }\r\n        if ((!serializeInnerClasses) && isInnerClass(field.getType())) {\r\n            return true;\r\n        }\r\n        if (isAnonymousOrNonStaticLocal(field.getType())) {\r\n            return true;\r\n        }\r\n        List<ExclusionStrategy> list = (serialize) ? serializationStrategies : deserializationStrategies;\r\n        if (!list.isEmpty()) {\r\n            FieldAttributes fieldAttributes = new FieldAttributes(field);\r\n            for (ExclusionStrategy exclusionStrategy : list) {\r\n                if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\n@Override\r\nprotected Excluder clone();\n    @Override\r\npublic <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type);\n    public Excluder disableInnerClassSerialization();\n    public boolean excludeClass(Class<?> clazz, boolean serialize);\n    public Excluder excludeFieldsWithoutExposeAnnotation();\n    private boolean isAnonymousOrNonStaticLocal(Class<?> clazz);\n    private boolean isInnerClass(Class<?> clazz);\n    private boolean isValidVersion(Since since, Until until);\n    public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy, boolean serialization, boolean deserialization);\n    public Excluder withModifiers(int... modifiers);\n    public Excluder withVersion(double ignoreVersionsAfter);\n}"
      },
      {
        "id": "TypeToken_isAssignableFrom",
        "package": "com.google.gson.reflect",
        "class": "com.google.gson.reflect.TypeToken",
        "test-class": "com.google.gson.reflect.TypeToken_isAssignableFrom_Test",
        "method-name": "isAssignableFrom(Type, ParameterizedType, Map<String, Type>)",
        "source-path": "src/main/java/com/google/gson/reflect/TypeToken.java",
        "test-path": "src/test/java/com/google/gson/reflect/TypeToken_isAssignableFrom_Test.java",
        "focal-method": "private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\r\n    if (from == null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    // First figure out the class and any type information.\r\n    Class<?> clazz = $Gson$Types.getRawType(from);\r\n    ParameterizedType ptype = null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype = ((ParameterizedType) (from));\r\n    }\r\n    // Load up parameterized variable info if it was parameterized.\r\n    if (ptype != null) {\r\n        Type[] tArgs = ptype.getActualTypeArguments();\r\n        TypeVariable<?>[] tParams = clazz.getTypeParameters();\r\n        for (int i = 0; i < tArgs.length; i++) {\r\n            Type arg = tArgs[i];\r\n            TypeVariable<?> var = tParams[i];\r\n            while (arg instanceof TypeVariable<?>) {\r\n                TypeVariable<?> v = ((TypeVariable<?>) (arg));\r\n                arg = typeVarMap.get(v.getName());\r\n            } \r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        // check if they are equivalent under our current mapping.\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap<>(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    // Interfaces didn't work, try the superclass.\r\n    Type sType = clazz.getGenericSuperclass();\r\n    return isAssignableFrom(sType, to, new HashMap<>(typeVarMap));\r\n}",
        "class-code": "package com.google.gson.reflect;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.HashMap;\nimport java.lang.reflect.ParameterizedType;\nimport com.google.gson.internal.$Gson$Types;\nimport java.util.Objects;\nimport java.lang.reflect.GenericArrayType;\nimport java.util.Map;\npublic class TypeToken<T> {\n    \n    private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\r\n        if (from == null) {\r\n            return false;\r\n        }\r\n        if (to.equals(from)) {\r\n            return true;\r\n        }\r\n        // First figure out the class and any type information.\r\n        Class<?> clazz = $Gson$Types.getRawType(from);\r\n        ParameterizedType ptype = null;\r\n        if (from instanceof ParameterizedType) {\r\n            ptype = ((ParameterizedType) (from));\r\n        }\r\n        // Load up parameterized variable info if it was parameterized.\r\n        if (ptype != null) {\r\n            Type[] tArgs = ptype.getActualTypeArguments();\r\n            TypeVariable<?>[] tParams = clazz.getTypeParameters();\r\n            for (int i = 0; i < tArgs.length; i++) {\r\n                Type arg = tArgs[i];\r\n                TypeVariable<?> var = tParams[i];\r\n                while (arg instanceof TypeVariable<?>) {\r\n                    TypeVariable<?> v = ((TypeVariable<?>) (arg));\r\n                    arg = typeVarMap.get(v.getName());\r\n                } \r\n                typeVarMap.put(var.getName(), arg);\r\n            }\r\n            // check if they are equivalent under our current mapping.\r\n            if (typeEquals(ptype, to, typeVarMap)) {\r\n                return true;\r\n            }\r\n        }\r\n        for (Type itype : clazz.getGenericInterfaces()) {\r\n            if (isAssignableFrom(itype, to, new HashMap<>(typeVarMap))) {\r\n                return true;\r\n            }\r\n        }\r\n        // Interfaces didn't work, try the superclass.\r\n        Type sType = clazz.getGenericSuperclass();\r\n        return isAssignableFrom(sType, to, new HashMap<>(typeVarMap));\r\n    }\n@Override\r\npublic final boolean equals(Object o);\n    public static <T> TypeToken<T> get(Class<T> type);\n    public static TypeToken<?> get(Type type);\n    public static TypeToken<?> getArray(Type componentType);\n    public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments);\n    public final Class<? super T> getRawType();\n    public final Type getType();\n    @Override\r\npublic final int hashCode();\n    private static boolean isAssignableFrom(Type from, GenericArrayType to);\n    @Override\r\npublic final String toString();\n    private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap);\n}"
      },
      {
        "id": "Primitives_wrap",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.Primitives",
        "test-class": "com.google.gson.internal.Primitives_wrap_Test",
        "method-name": "wrap(Class<T>)",
        "source-path": "src/main/java/com/google/gson/internal/Primitives.java",
        "test-path": "src/test/java/com/google/gson/internal/Primitives_wrap_Test.java",
        "focal-method": "@SuppressWarnings(\"unchecked\")\r\npublic static <T> Class<T> wrap(Class<T> type) {\r\n    if (type == int.class)\r\n        return ((Class<T>) (Integer.class));\r\n\r\n    if (type == float.class)\r\n        return ((Class<T>) (Float.class));\r\n\r\n    if (type == byte.class)\r\n        return ((Class<T>) (Byte.class));\r\n\r\n    if (type == double.class)\r\n        return ((Class<T>) (Double.class));\r\n\r\n    if (type == long.class)\r\n        return ((Class<T>) (Long.class));\r\n\r\n    if (type == char.class)\r\n        return ((Class<T>) (Character.class));\r\n\r\n    if (type == boolean.class)\r\n        return ((Class<T>) (Boolean.class));\r\n\r\n    if (type == short.class)\r\n        return ((Class<T>) (Short.class));\r\n\r\n    if (type == void.class)\r\n        return ((Class<T>) (Void.class));\r\n\r\n    return type;\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.lang.reflect.Type;\npublic final class Primitives {\n    \n    @SuppressWarnings(\"unchecked\")\r\n    public static <T> Class<T> wrap(Class<T> type) {\r\n        if (type == int.class)\r\n            return ((Class<T>) (Integer.class));\r\n    \r\n        if (type == float.class)\r\n            return ((Class<T>) (Float.class));\r\n    \r\n        if (type == byte.class)\r\n            return ((Class<T>) (Byte.class));\r\n    \r\n        if (type == double.class)\r\n            return ((Class<T>) (Double.class));\r\n    \r\n        if (type == long.class)\r\n            return ((Class<T>) (Long.class));\r\n    \r\n        if (type == char.class)\r\n            return ((Class<T>) (Character.class));\r\n    \r\n        if (type == boolean.class)\r\n            return ((Class<T>) (Boolean.class));\r\n    \r\n        if (type == short.class)\r\n            return ((Class<T>) (Short.class));\r\n    \r\n        if (type == void.class)\r\n            return ((Class<T>) (Void.class));\r\n    \r\n        return type;\r\n    }\npublic static boolean isPrimitive(Type type);\n    public static boolean isWrapperType(Type type);\n    @SuppressWarnings(\"unchecked\")\r\npublic static <T> Class<T> unwrap(Class<T> type);\n}"
      },
      {
        "id": "LinkedTreeMap_rebalance",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.LinkedTreeMap",
        "test-class": "com.google.gson.internal.LinkedTreeMap_rebalance_Test",
        "method-name": "rebalance(Node<K, V>, boolean)",
        "source-path": "src/main/java/com/google/gson/internal/LinkedTreeMap.java",
        "test-path": "src/test/java/com/google/gson/internal/LinkedTreeMap_rebalance_Test.java",
        "focal-method": "private void rebalance(Node<K, V> unbalanced, boolean insert) {\r\n    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\r\n        Node<K, V> left = node.left;\r\n        Node<K, V> right = node.right;\r\n        int leftHeight = (left != null) ? left.height : 0;\r\n        int rightHeight = (right != null) ? right.height : 0;\r\n        int delta = leftHeight - rightHeight;\r\n        if (delta == (-2)) {\r\n            Node<K, V> rightLeft = right.left;\r\n            Node<K, V> rightRight = right.right;\r\n            int rightRightHeight = (rightRight != null) ? rightRight.height : 0;\r\n            int rightLeftHeight = (rightLeft != null) ? rightLeft.height : 0;\r\n            int rightDelta = rightLeftHeight - rightRightHeight;\r\n            if ((rightDelta == (-1)) || ((rightDelta == 0) && (!insert))) {\r\n                rotateLeft(node);// AVL right right\r\n\r\n            } else {\r\n                assert rightDelta == 1;\r\n                rotateRight(right);// AVL right left\r\n\r\n                rotateLeft(node);\r\n            }\r\n            if (insert) {\r\n                break;// no further rotations will be necessary\r\n\r\n            }\r\n        } else if (delta == 2) {\r\n            Node<K, V> leftLeft = left.left;\r\n            Node<K, V> leftRight = left.right;\r\n            int leftRightHeight = (leftRight != null) ? leftRight.height : 0;\r\n            int leftLeftHeight = (leftLeft != null) ? leftLeft.height : 0;\r\n            int leftDelta = leftLeftHeight - leftRightHeight;\r\n            if ((leftDelta == 1) || ((leftDelta == 0) && (!insert))) {\r\n                rotateRight(node);// AVL left left\r\n\r\n            } else {\r\n                assert leftDelta == (-1);\r\n                rotateLeft(left);// AVL left right\r\n\r\n                rotateRight(node);\r\n            }\r\n            if (insert) {\r\n                break;// no further rotations will be necessary\r\n\r\n            }\r\n        } else if (delta == 0) {\r\n            node.height = leftHeight + 1;// leftHeight == rightHeight\r\n\r\n            if (insert) {\r\n                break;// the insert caused balance, so rebalancing is done!\r\n\r\n            }\r\n        } else {\r\n            assert (delta == (-1)) || (delta == 1);\r\n            node.height = Math.max(leftHeight, rightHeight) + 1;\r\n            if (!insert) {\r\n                break;// the height hasn't changed, so rebalancing is done!\r\n\r\n            }\r\n        }\r\n    }\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.util.Set;\nimport java.util.ConcurrentModificationException;\nimport java.io.IOException;\nimport java.util.AbstractSet;\nimport java.util.LinkedHashMap;\nimport java.util.Comparator;\nimport java.util.AbstractMap;\nimport java.io.ObjectInputStream;\nimport java.io.InvalidObjectException;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.io.ObjectStreamException;\nimport java.io.Serializable;\n@SuppressWarnings(\"serial\")\r\npublic final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {\n    Node<K, V> root;\n    int size = 0;\n    int modCount = 0;\n    final Node<K, V> header;\n    private void rebalance(Node<K, V> unbalanced, boolean insert) {\r\n        for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\r\n            Node<K, V> left = node.left;\r\n            Node<K, V> right = node.right;\r\n            int leftHeight = (left != null) ? left.height : 0;\r\n            int rightHeight = (right != null) ? right.height : 0;\r\n            int delta = leftHeight - rightHeight;\r\n            if (delta == (-2)) {\r\n                Node<K, V> rightLeft = right.left;\r\n                Node<K, V> rightRight = right.right;\r\n                int rightRightHeight = (rightRight != null) ? rightRight.height : 0;\r\n                int rightLeftHeight = (rightLeft != null) ? rightLeft.height : 0;\r\n                int rightDelta = rightLeftHeight - rightRightHeight;\r\n                if ((rightDelta == (-1)) || ((rightDelta == 0) && (!insert))) {\r\n                    rotateLeft(node);// AVL right right\r\n    \r\n                } else {\r\n                    assert rightDelta == 1;\r\n                    rotateRight(right);// AVL right left\r\n    \r\n                    rotateLeft(node);\r\n                }\r\n                if (insert) {\r\n                    break;// no further rotations will be necessary\r\n    \r\n                }\r\n            } else if (delta == 2) {\r\n                Node<K, V> leftLeft = left.left;\r\n                Node<K, V> leftRight = left.right;\r\n                int leftRightHeight = (leftRight != null) ? leftRight.height : 0;\r\n                int leftLeftHeight = (leftLeft != null) ? leftLeft.height : 0;\r\n                int leftDelta = leftLeftHeight - leftRightHeight;\r\n                if ((leftDelta == 1) || ((leftDelta == 0) && (!insert))) {\r\n                    rotateRight(node);// AVL left left\r\n    \r\n                } else {\r\n                    assert leftDelta == (-1);\r\n                    rotateLeft(left);// AVL left right\r\n    \r\n                    rotateRight(node);\r\n                }\r\n                if (insert) {\r\n                    break;// no further rotations will be necessary\r\n    \r\n                }\r\n            } else if (delta == 0) {\r\n                node.height = leftHeight + 1;// leftHeight == rightHeight\r\n    \r\n                if (insert) {\r\n                    break;// the insert caused balance, so rebalancing is done!\r\n    \r\n                }\r\n            } else {\r\n                assert (delta == (-1)) || (delta == 1);\r\n                node.height = Math.max(leftHeight, rightHeight) + 1;\r\n                if (!insert) {\r\n                    break;// the height hasn't changed, so rebalancing is done!\r\n    \r\n                }\r\n            }\r\n        }\r\n    }\n@Override\r\npublic void clear();\n    @Override\r\npublic boolean containsKey(Object key);\n    @Override\r\npublic Set<Entry<K, V>> entrySet();\n    Node<K, V> find(K key, boolean create);\n    Node<K, V> findByEntry(Entry<?, ?> entry);\n    @SuppressWarnings(\"unchecked\")\r\nNode<K, V> findByObject(Object key);\n    @Override\r\npublic V get(Object key);\n    @Override\r\npublic Set<K> keySet();\n    @Override\r\npublic V put(K key, V value);\n    @Override\r\npublic V remove(Object key);\n    void removeInternal(Node<K, V> node, boolean unlink);\n    Node<K, V> removeInternalByKey(Object key);\n    private void rotateLeft(Node<K, V> root);\n    private void rotateRight(Node<K, V> root);\n    @Override\r\npublic int size();\n}"
      },
      {
        "id": "ReflectiveTypeAdapterFactory_getBoundFields",
        "package": "com.google.gson.internal.bind",
        "class": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
        "test-class": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory_getBoundFields_Test",
        "method-name": "getBoundFields(Gson, TypeToken<?>, Class<?>, boolean, boolean)",
        "source-path": "src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
        "test-path": "src/test/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory_getBoundFields_Test.java",
        "focal-method": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw, boolean blockInaccessible, boolean isRecord) {\r\n    Map<String, BoundField> result = new LinkedHashMap<>();\r\n    if (raw.isInterface()) {\r\n        return result;\r\n    }\r\n    Class<?> originalRaw = raw;\r\n    while (raw != Object.class) {\r\n        Field[] fields = raw.getDeclaredFields();\r\n        // For inherited fields, check if access to their declaring class is allowed\r\n        if ((raw != originalRaw) && (fields.length > 0)) {\r\n            FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n            if (filterResult == FilterResult.BLOCK_ALL) {\r\n                throw new JsonIOException(((((\"ReflectionAccessFilter does not permit using reflection for \" + raw) + \" (supertype of \") + originalRaw) + \"). Register a TypeAdapter for this type\") + \" or adjust the access filter.\");\r\n            }\r\n            blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n        for (Field field : fields) {\r\n            boolean serialize = includeField(field, true);\r\n            boolean deserialize = includeField(field, false);\r\n            if ((!serialize) && (!deserialize)) {\r\n                continue;\r\n            }\r\n            // The accessor method is only used for records. If the type is a record, we will read out values\r\n            // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\r\n            Method accessor = null;\r\n            if (isRecord) {\r\n                // If there is a static field on a record, there will not be an accessor. Instead we will use the default\r\n                // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\r\n                // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                if (Modifier.isStatic(field.getModifiers())) {\r\n                    deserialize = false;\r\n                } else {\r\n                    accessor = ReflectionHelper.getAccessor(raw, field);\r\n                    // If blockInaccessible, skip and perform access check later\r\n                    if (!blockInaccessible) {\r\n                        ReflectionHelper.makeAccessible(accessor);\r\n                    }\r\n                    // @SerializedName can be placed on accessor method, but it is not supported there\r\n                    // If field and method have annotation it is not easily possible to determine if accessor method\r\n                    // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\r\n                    if ((accessor.getAnnotation(SerializedName.class) != null) && (field.getAnnotation(SerializedName.class) == null)) {\r\n                        String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                        throw new JsonIOException((\"@SerializedName on \" + methodDescription) + \" is not supported\");\r\n                    }\r\n                }\r\n            }\r\n            // If blockInaccessible, skip and perform access check later\r\n            // For Records if the accessor method is used the field does not have to be made accessible\r\n            if ((!blockInaccessible) && (accessor == null)) {\r\n                ReflectionHelper.makeAccessible(field);\r\n            }\r\n            Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\r\n            List<String> fieldNames = getFieldNames(field);\r\n            BoundField previous = null;\r\n            for (int i = 0, size = fieldNames.size(); i < size; ++i) {\r\n                String name = fieldNames.get(i);\r\n                if (i != 0)\r\n                    serialize = false;\r\n                // only serialize the default name\r\n\r\n                BoundField boundField = createBoundField(context, field, accessor, name, TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\r\n                BoundField replaced = result.put(name, boundField);\r\n                if (previous == null)\r\n                    previous = replaced;\r\n\r\n            }\r\n            if (previous != null) {\r\n                throw new IllegalArgumentException((((((((\"Class \" + originalRaw.getName()) + \" declares multiple JSON fields named '\") + previous.name) + \"'; conflict is caused\") + \" by fields \") + ReflectionHelper.fieldToString(previous.field)) + \" and \") + ReflectionHelper.fieldToString(field));\r\n            }\r\n        }\r\n        type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n        raw = type.getRawType();\r\n    } \r\n    return result;\r\n}",
        "class-code": "package com.google.gson.internal.bind;\nimport com.google.gson.internal.ReflectionAccessFilterHelper;\nimport com.google.gson.annotations.JsonAdapter;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.internal.Excluder;\nimport java.util.LinkedHashMap;\nimport com.google.gson.FieldNamingStrategy;\nimport com.google.gson.JsonParseException;\nimport com.google.gson.Gson;\nimport com.google.gson.internal.ConstructorConstructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.$Gson$Types;\nimport com.google.gson.stream.JsonToken;\nimport java.lang.reflect.AccessibleObject;\nimport java.util.List;\nimport java.lang.reflect.Member;\nimport com.google.gson.internal.Primitives;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.internal.ObjectConstructor;\nimport java.util.Collections;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.ReflectionAccessFilter;\nimport com.google.gson.internal.reflect.ReflectionHelper;\nimport java.lang.reflect.Constructor;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport com.google.gson.stream.JsonWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport com.google.gson.JsonSyntaxException;\nimport java.lang.reflect.Type;\nimport com.google.gson.ReflectionAccessFilter.FilterResult;\nimport com.google.gson.TypeAdapter;\nimport java.util.Map;\nimport java.util.Arrays;\npublic final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {\n    private final List<ReflectionAccessFilter> reflectionFilters;\n        static abstract class BoundField {\r\n        final String name;\r\n    \r\n        final Field field;\r\n    \r\n        /**\r\n         * Name of the underlying field\r\n         */\r\n        final String fieldName;\r\n    \r\n        final boolean serialized;\r\n    \r\n        final boolean deserialized;\r\n    \r\n        protected BoundField(String name, Field field, boolean serialized, boolean deserialized) {\r\n            this.name = name;\r\n            this.field = field;\r\n            this.fieldName = field.getName();\r\n            this.serialized = serialized;\r\n            this.deserialized = deserialized;\r\n        }\r\n    \r\n        /**\r\n         * Read this field value from the source, and append its JSON value to the writer\r\n         */\r\n        abstract void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException;\r\n    \r\n        /**\r\n         * Read the value into the target array, used to provide constructor arguments for records\r\n         */\r\n        abstract void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException;\r\n    \r\n        /**\r\n         * Read the value from the reader, and set it on the corresponding field on target via reflection\r\n         */\r\n        abstract void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException;\r\n    }\nprivate Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw, boolean blockInaccessible, boolean isRecord) {\r\n        Map<String, BoundField> result = new LinkedHashMap<>();\r\n        if (raw.isInterface()) {\r\n            return result;\r\n        }\r\n        Class<?> originalRaw = raw;\r\n        while (raw != Object.class) {\r\n            Field[] fields = raw.getDeclaredFields();\r\n            // For inherited fields, check if access to their declaring class is allowed\r\n            if ((raw != originalRaw) && (fields.length > 0)) {\r\n                FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n                if (filterResult == FilterResult.BLOCK_ALL) {\r\n                    throw new JsonIOException(((((\"ReflectionAccessFilter does not permit using reflection for \" + raw) + \" (supertype of \") + originalRaw) + \"). Register a TypeAdapter for this type\") + \" or adjust the access filter.\");\r\n                }\r\n                blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\r\n            }\r\n            for (Field field : fields) {\r\n                boolean serialize = includeField(field, true);\r\n                boolean deserialize = includeField(field, false);\r\n                if ((!serialize) && (!deserialize)) {\r\n                    continue;\r\n                }\r\n                // The accessor method is only used for records. If the type is a record, we will read out values\r\n                // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\r\n                Method accessor = null;\r\n                if (isRecord) {\r\n                    // If there is a static field on a record, there will not be an accessor. Instead we will use the default\r\n                    // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\r\n                    // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                    if (Modifier.isStatic(field.getModifiers())) {\r\n                        deserialize = false;\r\n                    } else {\r\n                        accessor = ReflectionHelper.getAccessor(raw, field);\r\n                        // If blockInaccessible, skip and perform access check later\r\n                        if (!blockInaccessible) {\r\n                            ReflectionHelper.makeAccessible(accessor);\r\n                        }\r\n                        // @SerializedName can be placed on accessor method, but it is not supported there\r\n                        // If field and method have annotation it is not easily possible to determine if accessor method\r\n                        // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\r\n                        if ((accessor.getAnnotation(SerializedName.class) != null) && (field.getAnnotation(SerializedName.class) == null)) {\r\n                            String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                            throw new JsonIOException((\"@SerializedName on \" + methodDescription) + \" is not supported\");\r\n                        }\r\n                    }\r\n                }\r\n                // If blockInaccessible, skip and perform access check later\r\n                // For Records if the accessor method is used the field does not have to be made accessible\r\n                if ((!blockInaccessible) && (accessor == null)) {\r\n                    ReflectionHelper.makeAccessible(field);\r\n                }\r\n                Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\r\n                List<String> fieldNames = getFieldNames(field);\r\n                BoundField previous = null;\r\n                for (int i = 0, size = fieldNames.size(); i < size; ++i) {\r\n                    String name = fieldNames.get(i);\r\n                    if (i != 0)\r\n                        serialize = false;\r\n                    // only serialize the default name\r\n    \r\n                    BoundField boundField = createBoundField(context, field, accessor, name, TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\r\n                    BoundField replaced = result.put(name, boundField);\r\n                    if (previous == null)\r\n                        previous = replaced;\r\n    \r\n                }\r\n                if (previous != null) {\r\n                    throw new IllegalArgumentException((((((((\"Class \" + originalRaw.getName()) + \" declares multiple JSON fields named '\") + previous.name) + \"'; conflict is caused\") + \" by fields \") + ReflectionHelper.fieldToString(previous.field)) + \" and \") + ReflectionHelper.fieldToString(field));\r\n                }\r\n            }\r\n            type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n            raw = type.getRawType();\r\n        } \r\n        return result;\r\n    }\n@Override\r\npublic <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type);\n    private BoundField createBoundField(final Gson context, final Field field, final Method accessor, final String name, final TypeToken<?> fieldType, boolean serialize, boolean deserialize, final boolean blockInaccessible);\n    private List<String> getFieldNames(Field f);\n    private boolean includeField(Field f, boolean serialize);\n}"
      },
      {
        "id": "ObjectTypeAdapter_read",
        "package": "com.google.gson.internal.bind",
        "class": "com.google.gson.internal.bind.ObjectTypeAdapter",
        "test-class": "com.google.gson.internal.bind.ObjectTypeAdapter_read_Test",
        "method-name": "read(JsonReader)",
        "source-path": "src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java",
        "test-path": "src/test/java/com/google/gson/internal/bind/ObjectTypeAdapter_read_Test.java",
        "focal-method": "@Override\r\npublic Object read(JsonReader in) throws IOException {\r\n    // Either List or Map\r\n    Object current;\r\n    JsonToken peeked = in.peek();\r\n    current = tryBeginNesting(in, peeked);\r\n    if (current == null) {\r\n        return readTerminal(in, peeked);\r\n    }\r\n    Deque<Object> stack = new ArrayDeque<>();\r\n    while (true) {\r\n        while (in.hasNext()) {\r\n            String name = null;\r\n            // Name is only used for JSON object members\r\n            if (current instanceof Map) {\r\n                name = in.nextName();\r\n            }\r\n            peeked = in.peek();\r\n            Object value = tryBeginNesting(in, peeked);\r\n            boolean isNesting = value != null;\r\n            if (value == null) {\r\n                value = readTerminal(in, peeked);\r\n            }\r\n            if (current instanceof List) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                List<Object> list = ((List<Object>) (current));\r\n                list.add(value);\r\n            } else {\r\n                @SuppressWarnings(\"unchecked\")\r\n                Map<String, Object> map = ((Map<String, Object>) (current));\r\n                map.put(name, value);\r\n            }\r\n            if (isNesting) {\r\n                stack.addLast(current);\r\n                current = value;\r\n            }\r\n        } \r\n        // End current element\r\n        if (current instanceof List) {\r\n            in.endArray();\r\n        } else {\r\n            in.endObject();\r\n        }\r\n        if (stack.isEmpty()) {\r\n            return current;\r\n        } else {\r\n            // Continue with enclosing element\r\n            current = stack.removeLast();\r\n        }\r\n    } \r\n}",
        "class-code": "package com.google.gson.internal.bind;\nimport com.google.gson.TypeAdapterFactory;\nimport java.util.ArrayDeque;\nimport com.google.gson.internal.LinkedTreeMap;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonWriter;\nimport java.util.Deque;\nimport com.google.gson.Gson;\nimport com.google.gson.ToNumberPolicy;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.ToNumberStrategy;\nimport com.google.gson.TypeAdapter;\nimport java.util.List;\nimport java.util.Map;\nimport com.google.gson.stream.JsonReader;\npublic final class ObjectTypeAdapter extends TypeAdapter<Object> {\n    \n    @Override\r\n    public Object read(JsonReader in) throws IOException {\r\n        // Either List or Map\r\n        Object current;\r\n        JsonToken peeked = in.peek();\r\n        current = tryBeginNesting(in, peeked);\r\n        if (current == null) {\r\n            return readTerminal(in, peeked);\r\n        }\r\n        Deque<Object> stack = new ArrayDeque<>();\r\n        while (true) {\r\n            while (in.hasNext()) {\r\n                String name = null;\r\n                // Name is only used for JSON object members\r\n                if (current instanceof Map) {\r\n                    name = in.nextName();\r\n                }\r\n                peeked = in.peek();\r\n                Object value = tryBeginNesting(in, peeked);\r\n                boolean isNesting = value != null;\r\n                if (value == null) {\r\n                    value = readTerminal(in, peeked);\r\n                }\r\n                if (current instanceof List) {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    List<Object> list = ((List<Object>) (current));\r\n                    list.add(value);\r\n                } else {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Map<String, Object> map = ((Map<String, Object>) (current));\r\n                    map.put(name, value);\r\n                }\r\n                if (isNesting) {\r\n                    stack.addLast(current);\r\n                    current = value;\r\n                }\r\n            } \r\n            // End current element\r\n            if (current instanceof List) {\r\n                in.endArray();\r\n            } else {\r\n                in.endObject();\r\n            }\r\n            if (stack.isEmpty()) {\r\n                return current;\r\n            } else {\r\n                // Continue with enclosing element\r\n                current = stack.removeLast();\r\n            }\r\n        } \r\n    }\npublic static TypeAdapterFactory getFactory(ToNumberStrategy toNumberStrategy);\n    private Object readTerminal(JsonReader in, JsonToken peeked) throws IOException;\n    private Object tryBeginNesting(JsonReader in, JsonToken peeked) throws IOException;\n    @Override\r\npublic void write(JsonWriter out, Object value) throws IOException;\n}"
      },
      {
        "id": "$Gson$Types_getGenericSupertype",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.$Gson$Types",
        "test-class": "com.google.gson.internal.$Gson$Types_getGenericSupertype_Test",
        "method-name": "getGenericSupertype(Type, Class<?>, Class<?>)",
        "source-path": "src/main/java/com/google/gson/internal/$Gson$Types.java",
        "test-path": "src/test/java/com/google/gson/internal/$Gson$Types_getGenericSupertype_Test.java",
        "focal-method": "private static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> supertype) {\r\n    if (supertype == rawType) {\r\n        return context;\r\n    }\r\n    // we skip searching through interfaces if unknown is an interface\r\n    if (supertype.isInterface()) {\r\n        Class<?>[] interfaces = rawType.getInterfaces();\r\n        for (int i = 0, length = interfaces.length; i < length; i++) {\r\n            if (interfaces[i] == supertype) {\r\n                return rawType.getGenericInterfaces()[i];\r\n            } else if (supertype.isAssignableFrom(interfaces[i])) {\r\n                return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], supertype);\r\n            }\r\n        }\r\n    }\r\n    // check our supertypes\r\n    if (!rawType.isInterface()) {\r\n        while (rawType != Object.class) {\r\n            Class<?> rawSupertype = rawType.getSuperclass();\r\n            if (rawSupertype == supertype) {\r\n                return rawType.getGenericSuperclass();\r\n            } else if (supertype.isAssignableFrom(rawSupertype)) {\r\n                return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, supertype);\r\n            }\r\n            rawType = rawSupertype;\r\n        } \r\n    }\r\n    // we can't resolve this further\r\n    return supertype;\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.util.HashMap;\nimport static java.util.Objects.requireNonNull;\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.util.Properties;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.WildcardType;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.ParameterizedType;\nimport java.util.Collection;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\nimport java.util.Arrays;\npublic final class $Gson$Types {\n    static final Type[] EMPTY_TYPE_ARRAY = new Type[]{  };\n    private static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> supertype) {\r\n        if (supertype == rawType) {\r\n            return context;\r\n        }\r\n        // we skip searching through interfaces if unknown is an interface\r\n        if (supertype.isInterface()) {\r\n            Class<?>[] interfaces = rawType.getInterfaces();\r\n            for (int i = 0, length = interfaces.length; i < length; i++) {\r\n                if (interfaces[i] == supertype) {\r\n                    return rawType.getGenericInterfaces()[i];\r\n                } else if (supertype.isAssignableFrom(interfaces[i])) {\r\n                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], supertype);\r\n                }\r\n            }\r\n        }\r\n        // check our supertypes\r\n        if (!rawType.isInterface()) {\r\n            while (rawType != Object.class) {\r\n                Class<?> rawSupertype = rawType.getSuperclass();\r\n                if (rawSupertype == supertype) {\r\n                    return rawType.getGenericSuperclass();\r\n                } else if (supertype.isAssignableFrom(rawSupertype)) {\r\n                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, supertype);\r\n                }\r\n                rawType = rawSupertype;\r\n            } \r\n        }\r\n        // we can't resolve this further\r\n        return supertype;\r\n    }\npublic static GenericArrayType arrayOf(Type componentType);\n    public static Type canonicalize(Type type);\n    static void checkNotPrimitive(Type type);\n    public static boolean equals(Type a, Type b);\n    public static Type getArrayComponentType(Type array);\n    public static Type getCollectionElementType(Type context, Class<?> contextRawType);\n    public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType);\n    public static Class<?> getRawType(Type type);\n    public static ParameterizedType newParameterizedTypeWithOwner(Type ownerType, Type rawType, Type... typeArguments);\n    public static Type resolve(Type context, Class<?> contextRawType, Type toResolve);\n    public static WildcardType subtypeOf(Type bound);\n    public static WildcardType supertypeOf(Type bound);\n    public static String typeToString(Type type);\n}"
      },
      {
        "id": "JsonReader_readEscapeCharacter",
        "package": "com.google.gson.stream",
        "class": "com.google.gson.stream.JsonReader",
        "test-class": "com.google.gson.stream.JsonReader_readEscapeCharacter_Test",
        "method-name": "readEscapeCharacter()",
        "source-path": "src/main/java/com/google/gson/stream/JsonReader.java",
        "test-path": "src/test/java/com/google/gson/stream/JsonReader_readEscapeCharacter_Test.java",
        "focal-method": "@SuppressWarnings(\"fallthrough\")\r\nprivate char readEscapeCharacter() throws IOException {\r\n    if ((pos == limit) && (!fillBuffer(1))) {\r\n        throw syntaxError(\"Unterminated escape sequence\");\r\n    }\r\n    char escaped = buffer[pos++];\r\n    switch (escaped) {\r\n        case 'u' :\r\n            if (((pos + 4) > limit) && (!fillBuffer(4))) {\r\n                throw syntaxError(\"Unterminated escape sequence\");\r\n            }\r\n            // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\r\n            char result = 0;\r\n            for (int i = pos, end = i + 4; i < end; i++) {\r\n                char c = buffer[i];\r\n                result <<= 4;\r\n                if ((c >= '0') && (c <= '9')) {\r\n                    result += c - '0';\r\n                } else if ((c >= 'a') && (c <= 'f')) {\r\n                    result += (c - 'a') + 10;\r\n                } else if ((c >= 'A') && (c <= 'F')) {\r\n                    result += (c - 'A') + 10;\r\n                } else {\r\n                    throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\r\n                }\r\n            }\r\n            pos += 4;\r\n            return result;\r\n        case 't' :\r\n            return '\\t';\r\n        case 'b' :\r\n            return '\\b';\r\n        case 'n' :\r\n            return '\\n';\r\n        case 'r' :\r\n            return '\\r';\r\n        case 'f' :\r\n            return '\\f';\r\n        case '\\n' :\r\n            lineNumber++;\r\n            lineStart = pos;\r\n            // fall-through\r\n        case '\\'' :\r\n        case '\"' :\r\n        case '\\\\' :\r\n        case '/' :\r\n            return escaped;\r\n        default :\r\n            // throw error when none of the above cases are matched\r\n            throw syntaxError(\"Invalid escape sequence\");\r\n    }\r\n}",
        "class-code": "package com.google.gson.stream;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.Arrays;\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport java.io.Reader;\nimport java.io.EOFException;\npublic class JsonReader implements Closeable {\n    static final int BUFFER_SIZE = 1024;\n    private final char[] buffer = new char[BUFFER_SIZE];\n    private int pos = 0;\n    private int limit = 0;\n    private int lineNumber = 0;\n    private int lineStart = 0;\n    int peeked = PEEKED_NONE;\n    @SuppressWarnings(\"fallthrough\")\r\n    private char readEscapeCharacter() throws IOException {\r\n        if ((pos == limit) && (!fillBuffer(1))) {\r\n            throw syntaxError(\"Unterminated escape sequence\");\r\n        }\r\n        char escaped = buffer[pos++];\r\n        switch (escaped) {\r\n            case 'u' :\r\n                if (((pos + 4) > limit) && (!fillBuffer(4))) {\r\n                    throw syntaxError(\"Unterminated escape sequence\");\r\n                }\r\n                // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\r\n                char result = 0;\r\n                for (int i = pos, end = i + 4; i < end; i++) {\r\n                    char c = buffer[i];\r\n                    result <<= 4;\r\n                    if ((c >= '0') && (c <= '9')) {\r\n                        result += c - '0';\r\n                    } else if ((c >= 'a') && (c <= 'f')) {\r\n                        result += (c - 'a') + 10;\r\n                    } else if ((c >= 'A') && (c <= 'F')) {\r\n                        result += (c - 'A') + 10;\r\n                    } else {\r\n                        throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\r\n                    }\r\n                }\r\n                pos += 4;\r\n                return result;\r\n            case 't' :\r\n                return '\\t';\r\n            case 'b' :\r\n                return '\\b';\r\n            case 'n' :\r\n                return '\\n';\r\n            case 'r' :\r\n                return '\\r';\r\n            case 'f' :\r\n                return '\\f';\r\n            case '\\n' :\r\n                lineNumber++;\r\n                lineStart = pos;\r\n                // fall-through\r\n            case '\\'' :\r\n            case '\"' :\r\n            case '\\\\' :\r\n            case '/' :\r\n                return escaped;\r\n            default :\r\n                // throw error when none of the above cases are matched\r\n                throw syntaxError(\"Invalid escape sequence\");\r\n        }\r\n    }\npublic void beginArray() throws IOException;\n    public void beginObject() throws IOException;\n    @Override\r\npublic void close() throws IOException;\n    @SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException;\n    public void endArray() throws IOException;\n    public void endObject() throws IOException;\n    private boolean fillBuffer(int minimum) throws IOException;\n    public String getPath();\n    public String getPreviousPath();\n    public boolean hasNext() throws IOException;\n    public final boolean isLenient();\n    String locationString();\n    public boolean nextBoolean() throws IOException;\n    public double nextDouble() throws IOException;\n    public int nextInt() throws IOException;\n    public long nextLong() throws IOException;\n    public String nextName() throws IOException;\n    public void nextNull() throws IOException;\n    public String nextString() throws IOException;\n    public JsonToken peek() throws IOException;\n    public final void setLenient(boolean lenient);\n    public void skipValue() throws IOException;\n    private IOException syntaxError(String message) throws IOException;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "$Gson$Types_equals",
        "package": "com.google.gson.internal",
        "class": "com.google.gson.internal.$Gson$Types",
        "test-class": "com.google.gson.internal.$Gson$Types_equals_Test",
        "method-name": "equals(Type, Type)",
        "source-path": "src/main/java/com/google/gson/internal/$Gson$Types.java",
        "test-path": "src/test/java/com/google/gson/internal/$Gson$Types_equals_Test.java",
        "focal-method": "public static boolean equals(Type a, Type b) {\r\n    if (a == b) {\r\n        // also handles (a == null && b == null)\r\n        return true;\r\n    } else if (a instanceof Class) {\r\n        // Class already specifies equals().\r\n        return a.equals(b);\r\n    } else if (a instanceof ParameterizedType) {\r\n        if (!(b instanceof ParameterizedType)) {\r\n            return false;\r\n        }\r\n        // TODO: save a .clone() call\r\n        ParameterizedType pa = ((ParameterizedType) (a));\r\n        ParameterizedType pb = ((ParameterizedType) (b));\r\n        return (equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType())) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\r\n    } else if (a instanceof GenericArrayType) {\r\n        if (!(b instanceof GenericArrayType)) {\r\n            return false;\r\n        }\r\n        GenericArrayType ga = ((GenericArrayType) (a));\r\n        GenericArrayType gb = ((GenericArrayType) (b));\r\n        return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\r\n    } else if (a instanceof WildcardType) {\r\n        if (!(b instanceof WildcardType)) {\r\n            return false;\r\n        }\r\n        WildcardType wa = ((WildcardType) (a));\r\n        WildcardType wb = ((WildcardType) (b));\r\n        return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\r\n    } else if (a instanceof TypeVariable) {\r\n        if (!(b instanceof TypeVariable)) {\r\n            return false;\r\n        }\r\n        TypeVariable<?> va = ((TypeVariable<?>) (a));\r\n        TypeVariable<?> vb = ((TypeVariable<?>) (b));\r\n        return (va.getGenericDeclaration() == vb.getGenericDeclaration()) && va.getName().equals(vb.getName());\r\n    } else {\r\n        // This isn't a type we support. Could be a generic array type, wildcard type, etc.\r\n        return false;\r\n    }\r\n}",
        "class-code": "package com.google.gson.internal;\nimport java.util.HashMap;\nimport static java.util.Objects.requireNonNull;\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.util.Properties;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.WildcardType;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.ParameterizedType;\nimport java.util.Collection;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Map;\nimport java.io.Serializable;\nimport java.util.Arrays;\npublic final class $Gson$Types {\n    static final Type[] EMPTY_TYPE_ARRAY = new Type[]{  };\n    public static boolean equals(Type a, Type b) {\r\n        if (a == b) {\r\n            // also handles (a == null && b == null)\r\n            return true;\r\n        } else if (a instanceof Class) {\r\n            // Class already specifies equals().\r\n            return a.equals(b);\r\n        } else if (a instanceof ParameterizedType) {\r\n            if (!(b instanceof ParameterizedType)) {\r\n                return false;\r\n            }\r\n            // TODO: save a .clone() call\r\n            ParameterizedType pa = ((ParameterizedType) (a));\r\n            ParameterizedType pb = ((ParameterizedType) (b));\r\n            return (equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType())) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\r\n        } else if (a instanceof GenericArrayType) {\r\n            if (!(b instanceof GenericArrayType)) {\r\n                return false;\r\n            }\r\n            GenericArrayType ga = ((GenericArrayType) (a));\r\n            GenericArrayType gb = ((GenericArrayType) (b));\r\n            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\r\n        } else if (a instanceof WildcardType) {\r\n            if (!(b instanceof WildcardType)) {\r\n                return false;\r\n            }\r\n            WildcardType wa = ((WildcardType) (a));\r\n            WildcardType wb = ((WildcardType) (b));\r\n            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\r\n        } else if (a instanceof TypeVariable) {\r\n            if (!(b instanceof TypeVariable)) {\r\n                return false;\r\n            }\r\n            TypeVariable<?> va = ((TypeVariable<?>) (a));\r\n            TypeVariable<?> vb = ((TypeVariable<?>) (b));\r\n            return (va.getGenericDeclaration() == vb.getGenericDeclaration()) && va.getName().equals(vb.getName());\r\n        } else {\r\n            // This isn't a type we support. Could be a generic array type, wildcard type, etc.\r\n            return false;\r\n        }\r\n    }\npublic static GenericArrayType arrayOf(Type componentType);\n    public static Type canonicalize(Type type);\n    static void checkNotPrimitive(Type type);\n    private static boolean equal(Object a, Object b);\n    public static Type getArrayComponentType(Type array);\n    public static Type getCollectionElementType(Type context, Class<?> contextRawType);\n    public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType);\n    public static Class<?> getRawType(Type type);\n    public static ParameterizedType newParameterizedTypeWithOwner(Type ownerType, Type rawType, Type... typeArguments);\n    public static Type resolve(Type context, Class<?> contextRawType, Type toResolve);\n    public static WildcardType subtypeOf(Type bound);\n    public static WildcardType supertypeOf(Type bound);\n    public static String typeToString(Type type);\n}"
      }
    ]
  },
  "jdom2": {
    "project-name": "jdom2",
    "project-url": "jdom2",
    "focal-methods": [
      {
        "id": "AbstractStAXStreamProcessor_printDocument",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractStAXStreamProcessor",
        "test-class": "org.jdom2.output.support.AbstractStAXStreamProcessor_printDocument_Test",
        "method-name": "printDocument(XMLStreamWriter, FormatStack, NamespaceStack, Document)",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractStAXStreamProcessor.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractStAXStreamProcessor_printDocument_Test.java",
        "focal-method": "protected void printDocument(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Document doc) throws XMLStreamException {\r\n    if (fstack.isOmitDeclaration()) {\r\n        // this actually writes the declaration as version 1, UTF-8\r\n        out.writeStartDocument();\r\n        if (fstack.getLineSeparator() != null) {\r\n            out.writeCharacters(fstack.getLineSeparator());\r\n        }\r\n    } else if (fstack.isOmitEncoding()) {\r\n        out.writeStartDocument(\"1.0\");\r\n        if (fstack.getLineSeparator() != null) {\r\n            out.writeCharacters(fstack.getLineSeparator());\r\n        }\r\n    } else {\r\n        out.writeStartDocument(fstack.getEncoding(), \"1.0\");\r\n        if (fstack.getLineSeparator() != null) {\r\n            out.writeCharacters(fstack.getLineSeparator());\r\n        }\r\n    }\r\n    // we can output characters outside the Root element in StAX Event\r\n    // code... so, take advantage.\r\n    // If there is no root element then we cannot use the normal ways to\r\n    // access the ContentList because Document throws an exception.\r\n    // so we hack it and just access it by index.\r\n    List<Content> list = (doc.hasRootElement()) ? doc.getContent() : new ArrayList<Content>(doc.getContentSize());\r\n    if (list.isEmpty()) {\r\n        final int sz = doc.getContentSize();\r\n        for (int i = 0; i < sz; i++) {\r\n            list.add(doc.getContent(i));\r\n        }\r\n    }\r\n    Walker walker = buildWalker(fstack, list, false);\r\n    if (walker.hasNext()) {\r\n        while (walker.hasNext()) {\r\n            final Content c = walker.next();\r\n            // we do not ignore Text-like things in the Document.\r\n            // the walker creates the indenting for us.\r\n            if (c == null) {\r\n                // but, what we do is ensure it is all whitespace, and not CDATA\r\n                final String padding = walker.text();\r\n                if (((padding != null) && Verifier.isAllXMLWhitespace(padding)) && (!walker.isCDATA())) {\r\n                    // we do not use the escaping or text* method because this\r\n                    // content is outside of the root element, and thus is not\r\n                    // strict text.\r\n                    out.writeCharacters(padding);\r\n                }\r\n            } else {\r\n                switch (c.getCType()) {\r\n                    case Comment :\r\n                        printComment(out, fstack, ((Comment) (c)));\r\n                        break;\r\n                    case DocType :\r\n                        printDocType(out, fstack, ((DocType) (c)));\r\n                        break;\r\n                    case Element :\r\n                        printElement(out, fstack, nstack, ((Element) (c)));\r\n                        break;\r\n                    case ProcessingInstruction :\r\n                        printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                        break;\r\n                    case Text :\r\n                        final String padding = ((Text) (c)).getText();\r\n                        if ((padding != null) && Verifier.isAllXMLWhitespace(padding)) {\r\n                            // we do not use the escaping or text* method because this\r\n                            // content is outside of the root element, and thus is not\r\n                            // strict text.\r\n                            out.writeCharacters(padding);\r\n                        }\r\n                    default :\r\n                        // do nothing.\r\n                }\r\n            }\r\n        } \r\n        if (fstack.getLineSeparator() != null) {\r\n            out.writeCharacters(fstack.getLineSeparator());\r\n        }\r\n    }\r\n    out.writeEndDocument();\r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.Attribute;\nimport org.jdom2.Content.CType;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport org.jdom2.Document;\nimport org.jdom2.Verifier;\nimport org.jdom2.util.NamespaceStack;\nimport org.jdom2.output.StAXStreamOutputter;\nimport java.io.StringWriter;\nimport javax.xml.stream.XMLStreamException;\nimport org.jdom2.Content;\nimport org.jdom2.output.Format.TextMode;\nimport javax.xml.stream.XMLStreamWriter;\nimport org.jdom2.JDOMConstants;\nimport org.jdom2.ProcessingInstruction;\nimport java.util.List;\nimport org.jdom2.EntityRef;\nimport org.jdom2.output.Format;\nimport org.jdom2.CDATA;\nimport org.jdom2.Comment;\nimport java.util.Collections;\nimport org.jdom2.DocType;\npublic abstract class AbstractStAXStreamProcessor extends AbstractOutputProcessor implements StAXStreamProcessor {\n    \n    protected void printDocument(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Document doc) throws XMLStreamException {\r\n        if (fstack.isOmitDeclaration()) {\r\n            // this actually writes the declaration as version 1, UTF-8\r\n            out.writeStartDocument();\r\n            if (fstack.getLineSeparator() != null) {\r\n                out.writeCharacters(fstack.getLineSeparator());\r\n            }\r\n        } else if (fstack.isOmitEncoding()) {\r\n            out.writeStartDocument(\"1.0\");\r\n            if (fstack.getLineSeparator() != null) {\r\n                out.writeCharacters(fstack.getLineSeparator());\r\n            }\r\n        } else {\r\n            out.writeStartDocument(fstack.getEncoding(), \"1.0\");\r\n            if (fstack.getLineSeparator() != null) {\r\n                out.writeCharacters(fstack.getLineSeparator());\r\n            }\r\n        }\r\n        // we can output characters outside the Root element in StAX Event\r\n        // code... so, take advantage.\r\n        // If there is no root element then we cannot use the normal ways to\r\n        // access the ContentList because Document throws an exception.\r\n        // so we hack it and just access it by index.\r\n        List<Content> list = (doc.hasRootElement()) ? doc.getContent() : new ArrayList<Content>(doc.getContentSize());\r\n        if (list.isEmpty()) {\r\n            final int sz = doc.getContentSize();\r\n            for (int i = 0; i < sz; i++) {\r\n                list.add(doc.getContent(i));\r\n            }\r\n        }\r\n        Walker walker = buildWalker(fstack, list, false);\r\n        if (walker.hasNext()) {\r\n            while (walker.hasNext()) {\r\n                final Content c = walker.next();\r\n                // we do not ignore Text-like things in the Document.\r\n                // the walker creates the indenting for us.\r\n                if (c == null) {\r\n                    // but, what we do is ensure it is all whitespace, and not CDATA\r\n                    final String padding = walker.text();\r\n                    if (((padding != null) && Verifier.isAllXMLWhitespace(padding)) && (!walker.isCDATA())) {\r\n                        // we do not use the escaping or text* method because this\r\n                        // content is outside of the root element, and thus is not\r\n                        // strict text.\r\n                        out.writeCharacters(padding);\r\n                    }\r\n                } else {\r\n                    switch (c.getCType()) {\r\n                        case Comment :\r\n                            printComment(out, fstack, ((Comment) (c)));\r\n                            break;\r\n                        case DocType :\r\n                            printDocType(out, fstack, ((DocType) (c)));\r\n                            break;\r\n                        case Element :\r\n                            printElement(out, fstack, nstack, ((Element) (c)));\r\n                            break;\r\n                        case ProcessingInstruction :\r\n                            printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                            break;\r\n                        case Text :\r\n                            final String padding = ((Text) (c)).getText();\r\n                            if ((padding != null) && Verifier.isAllXMLWhitespace(padding)) {\r\n                                // we do not use the escaping or text* method because this\r\n                                // content is outside of the root element, and thus is not\r\n                                // strict text.\r\n                                out.writeCharacters(padding);\r\n                            }\r\n                        default :\r\n                            // do nothing.\r\n                    }\r\n                }\r\n            } \r\n            if (fstack.getLineSeparator() != null) {\r\n                out.writeCharacters(fstack.getLineSeparator());\r\n            }\r\n        }\r\n        out.writeEndDocument();\r\n    }\nprotected void printAttribute(final XMLStreamWriter out, final FormatStack fstack, final Attribute attribute) throws XMLStreamException;\n    protected void printCDATA(final XMLStreamWriter out, final FormatStack fstack, final CDATA cdata) throws XMLStreamException;\n    protected void printComment(final XMLStreamWriter out, final FormatStack fstack, final Comment comment) throws XMLStreamException;\n    protected void printContent(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws XMLStreamException;\n    protected void printDocType(final XMLStreamWriter out, final FormatStack fstack, final DocType docType) throws XMLStreamException;\n    protected void printElement(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Element element) throws XMLStreamException;\n    protected void printEntityRef(final XMLStreamWriter out, final FormatStack fstack, final EntityRef entity) throws XMLStreamException;\n    protected void printNamespace(final XMLStreamWriter out, final FormatStack fstack, final Namespace ns) throws XMLStreamException;\n    protected void printProcessingInstruction(final XMLStreamWriter out, final FormatStack fstack, final ProcessingInstruction pi) throws XMLStreamException;\n    protected void printText(final XMLStreamWriter out, final FormatStack fstack, final Text text) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final List<? extends Content> list) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final CDATA cdata) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Comment comment) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final DocType doctype) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Document doc) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Element element) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final EntityRef entity) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final ProcessingInstruction pi) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Text text) throws XMLStreamException;\n}"
      },
      {
        "id": "StringBin_locate",
        "package": "org.jdom2",
        "class": "org.jdom2.StringBin",
        "test-class": "org.jdom2.StringBin_locate_Test",
        "method-name": "locate(int, String, String[], int)",
        "source-path": "src/main/java/org/jdom2/StringBin.java",
        "test-path": "src/test/java/org/jdom2/StringBin_locate_Test.java",
        "focal-method": "private final int locate(final int hash, final String value, final String[] bucket, final int length) {\r\n    int left = 0;\r\n    int right = length - 1;\r\n    int mid = 0;\r\n    while (left <= right) {\r\n        mid = (left + right) >>> 1;\r\n        if (bucket[mid].hashCode() > hash) {\r\n            right = mid - 1;\r\n        } else if (bucket[mid].hashCode() < hash) {\r\n            left = mid + 1;\r\n        } else {\r\n            // have the same hashcode\r\n            // do a string-compare.\r\n            int cmp = value.compareTo(bucket[mid]);\r\n            if (cmp == 0) {\r\n                // equals.\r\n                return mid;\r\n            } else if (cmp < 0) {\r\n                // our input value comes before the bucket value, search\r\n                // backwards\r\n                while (((--mid) >= left) && (bucket[mid].hashCode() == hash)) {\r\n                    // we have gone back one, and we still have the same\r\n                    // hash code... let's compare.\r\n                    cmp = value.compareTo(bucket[mid]);\r\n                    if (cmp == 0) {\r\n                        // equals, found it.\r\n                        return mid;\r\n                    } else if (cmp > 0) {\r\n                        // we were searching backwards because we started at\r\n                        // the mid point which was after the input value.\r\n                        // now that we have found a value that comes\r\n                        // before the input value it means we have gone too\r\n                        // far... which in turn means the insertion point\r\n                        // is one place after where we are.\r\n                        return (-(mid + 1)) - 1;\r\n                    }\r\n                } \r\n                // this must mean that we ran out of data, or ran out of\r\n                // values with the same hashcode...\r\n                return (-(mid + 1)) - 1;\r\n            } else {\r\n                // we have a value that comes before the value with the\r\n                // same hash as us.\r\n                while (((++mid) <= right) && (bucket[mid].hashCode() == hash)) {\r\n                    // the next value exists and has the same hash code.\r\n                    cmp = value.compareTo(bucket[mid]);\r\n                    if (cmp == 0) {\r\n                        // found our value.\r\n                        return mid;\r\n                    } else if (cmp < 0) {\r\n                        // we were searching forwards because we started at\r\n                        // the mid point which was before the input value.\r\n                        // now that we have found a value that comes\r\n                        // after the input value it means we have gone too\r\n                        // far... which in turn means the insertion point\r\n                        // is at the point where we are.\r\n                        return (-mid) - 1;\r\n                    }\r\n                } \r\n                // we have run out of values, or the value we are on has a\r\n                // different hashcode.\r\n                return (-mid) - 1;\r\n            }\r\n        }\r\n    } \r\n    // nothing had the same hashcode.\r\n    return (-left) - 1;\r\n}",
        "class-code": "package org.jdom2;\nimport org.jdom2.internal.ArrayCopy;\nfinal class StringBin {\n    \n    private final int locate(final int hash, final String value, final String[] bucket, final int length) {\r\n        int left = 0;\r\n        int right = length - 1;\r\n        int mid = 0;\r\n        while (left <= right) {\r\n            mid = (left + right) >>> 1;\r\n            if (bucket[mid].hashCode() > hash) {\r\n                right = mid - 1;\r\n            } else if (bucket[mid].hashCode() < hash) {\r\n                left = mid + 1;\r\n            } else {\r\n                // have the same hashcode\r\n                // do a string-compare.\r\n                int cmp = value.compareTo(bucket[mid]);\r\n                if (cmp == 0) {\r\n                    // equals.\r\n                    return mid;\r\n                } else if (cmp < 0) {\r\n                    // our input value comes before the bucket value, search\r\n                    // backwards\r\n                    while (((--mid) >= left) && (bucket[mid].hashCode() == hash)) {\r\n                        // we have gone back one, and we still have the same\r\n                        // hash code... let's compare.\r\n                        cmp = value.compareTo(bucket[mid]);\r\n                        if (cmp == 0) {\r\n                            // equals, found it.\r\n                            return mid;\r\n                        } else if (cmp > 0) {\r\n                            // we were searching backwards because we started at\r\n                            // the mid point which was after the input value.\r\n                            // now that we have found a value that comes\r\n                            // before the input value it means we have gone too\r\n                            // far... which in turn means the insertion point\r\n                            // is one place after where we are.\r\n                            return (-(mid + 1)) - 1;\r\n                        }\r\n                    } \r\n                    // this must mean that we ran out of data, or ran out of\r\n                    // values with the same hashcode...\r\n                    return (-(mid + 1)) - 1;\r\n                } else {\r\n                    // we have a value that comes before the value with the\r\n                    // same hash as us.\r\n                    while (((++mid) <= right) && (bucket[mid].hashCode() == hash)) {\r\n                        // the next value exists and has the same hash code.\r\n                        cmp = value.compareTo(bucket[mid]);\r\n                        if (cmp == 0) {\r\n                            // found our value.\r\n                            return mid;\r\n                        } else if (cmp < 0) {\r\n                            // we were searching forwards because we started at\r\n                            // the mid point which was before the input value.\r\n                            // now that we have found a value that comes\r\n                            // after the input value it means we have gone too\r\n                            // far... which in turn means the insertion point\r\n                            // is at the point where we are.\r\n                            return (-mid) - 1;\r\n                        }\r\n                    } \r\n                    // we have run out of values, or the value we are on has a\r\n                    // different hashcode.\r\n                    return (-mid) - 1;\r\n                }\r\n            }\r\n        } \r\n        // nothing had the same hashcode.\r\n        return (-left) - 1;\r\n    }\npublic String reuse(final String value);\n    public int size();\n}"
      },
      {
        "id": "AbstractXMLOutputProcessor_printDocument",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractXMLOutputProcessor",
        "test-class": "org.jdom2.output.support.AbstractXMLOutputProcessor_printDocument_Test",
        "method-name": "printDocument(Writer, FormatStack, NamespaceStack, Document)",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractXMLOutputProcessor.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractXMLOutputProcessor_printDocument_Test.java",
        "focal-method": "protected void printDocument(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Document doc) throws IOException {\r\n    // If there is no root element then we cannot use the normal ways to\r\n    // access the ContentList because Document throws an exception.\r\n    // so we hack it and just access it by index.\r\n    List<Content> list = (doc.hasRootElement()) ? doc.getContent() : new ArrayList<Content>(doc.getContentSize());\r\n    if (list.isEmpty()) {\r\n        final int sz = doc.getContentSize();\r\n        for (int i = 0; i < sz; i++) {\r\n            list.add(doc.getContent(i));\r\n        }\r\n    }\r\n    printDeclaration(out, fstack);\r\n    Walker walker = buildWalker(fstack, list, true);\r\n    if (walker.hasNext()) {\r\n        while (walker.hasNext()) {\r\n            final Content c = walker.next();\r\n            // we do not ignore Text-like things in the Document.\r\n            // the walker creates the indenting for us.\r\n            if (c == null) {\r\n                // but, what we do is ensure it is all whitespace, and not CDATA\r\n                final String padding = walker.text();\r\n                if (((padding != null) && Verifier.isAllXMLWhitespace(padding)) && (!walker.isCDATA())) {\r\n                    // we do not use the escaping or text* method because this\r\n                    // content is outside of the root element, and thus is not\r\n                    // strict text.\r\n                    write(out, padding);\r\n                }\r\n            } else {\r\n                switch (c.getCType()) {\r\n                    case Comment :\r\n                        printComment(out, fstack, ((Comment) (c)));\r\n                        break;\r\n                    case DocType :\r\n                        printDocType(out, fstack, ((DocType) (c)));\r\n                        break;\r\n                    case Element :\r\n                        printElement(out, fstack, nstack, ((Element) (c)));\r\n                        break;\r\n                    case ProcessingInstruction :\r\n                        printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                        break;\r\n                    case Text :\r\n                        final String padding = ((Text) (c)).getText();\r\n                        if ((padding != null) && Verifier.isAllXMLWhitespace(padding)) {\r\n                            // we do not use the escaping or text* method because this\r\n                            // content is outside of the root element, and thus is not\r\n                            // strict text.\r\n                            write(out, padding);\r\n                        }\r\n                    default :\r\n                        // do nothing.\r\n                }\r\n            }\r\n        } \r\n        if (fstack.getLineSeparator() != null) {\r\n            write(out, fstack.getLineSeparator());\r\n        }\r\n    }\r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.IllegalDataException;\nimport org.jdom2.output.XMLOutputter;\nimport org.jdom2.Attribute;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport org.jdom2.Document;\nimport javax.xml.transform.Result;\nimport org.jdom2.Verifier;\nimport org.jdom2.util.NamespaceStack;\nimport org.jdom2.Content;\nimport org.jdom2.output.Format.TextMode;\nimport java.io.Writer;\nimport org.jdom2.ProcessingInstruction;\nimport java.util.List;\nimport org.jdom2.EntityRef;\nimport org.jdom2.output.Format;\nimport org.jdom2.CDATA;\nimport org.jdom2.Comment;\nimport java.util.Collections;\nimport org.jdom2.DocType;\npublic abstract class AbstractXMLOutputProcessor extends AbstractOutputProcessor implements XMLOutputProcessor {\n    protected static final String CDATAPRE = \"<![CDATA[\";\n    protected static final String CDATAPOST = \"]]>\";\n    protected void printDocument(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Document doc) throws IOException {\r\n        // If there is no root element then we cannot use the normal ways to\r\n        // access the ContentList because Document throws an exception.\r\n        // so we hack it and just access it by index.\r\n        List<Content> list = (doc.hasRootElement()) ? doc.getContent() : new ArrayList<Content>(doc.getContentSize());\r\n        if (list.isEmpty()) {\r\n            final int sz = doc.getContentSize();\r\n            for (int i = 0; i < sz; i++) {\r\n                list.add(doc.getContent(i));\r\n            }\r\n        }\r\n        printDeclaration(out, fstack);\r\n        Walker walker = buildWalker(fstack, list, true);\r\n        if (walker.hasNext()) {\r\n            while (walker.hasNext()) {\r\n                final Content c = walker.next();\r\n                // we do not ignore Text-like things in the Document.\r\n                // the walker creates the indenting for us.\r\n                if (c == null) {\r\n                    // but, what we do is ensure it is all whitespace, and not CDATA\r\n                    final String padding = walker.text();\r\n                    if (((padding != null) && Verifier.isAllXMLWhitespace(padding)) && (!walker.isCDATA())) {\r\n                        // we do not use the escaping or text* method because this\r\n                        // content is outside of the root element, and thus is not\r\n                        // strict text.\r\n                        write(out, padding);\r\n                    }\r\n                } else {\r\n                    switch (c.getCType()) {\r\n                        case Comment :\r\n                            printComment(out, fstack, ((Comment) (c)));\r\n                            break;\r\n                        case DocType :\r\n                            printDocType(out, fstack, ((DocType) (c)));\r\n                            break;\r\n                        case Element :\r\n                            printElement(out, fstack, nstack, ((Element) (c)));\r\n                            break;\r\n                        case ProcessingInstruction :\r\n                            printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                            break;\r\n                        case Text :\r\n                            final String padding = ((Text) (c)).getText();\r\n                            if ((padding != null) && Verifier.isAllXMLWhitespace(padding)) {\r\n                                // we do not use the escaping or text* method because this\r\n                                // content is outside of the root element, and thus is not\r\n                                // strict text.\r\n                                write(out, padding);\r\n                            }\r\n                        default :\r\n                            // do nothing.\r\n                    }\r\n                }\r\n            } \r\n            if (fstack.getLineSeparator() != null) {\r\n                write(out, fstack.getLineSeparator());\r\n            }\r\n        }\r\n    }\nprotected void attributeEscapedEntitiesFilter(final Writer out, final FormatStack fstack, final String value) throws IOException;\n    protected void printAttribute(final Writer out, final FormatStack fstack, final Attribute attribute) throws IOException;\n    protected void printCDATA(final Writer out, final FormatStack fstack, final CDATA cdata) throws IOException;\n    protected void printComment(final Writer out, final FormatStack fstack, final Comment comment) throws IOException;\n    protected void printContent(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws IOException;\n    protected void printDeclaration(final Writer out, final FormatStack fstack) throws IOException;\n    protected void printDocType(final Writer out, final FormatStack fstack, final DocType docType) throws IOException;\n    protected void printElement(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Element element) throws IOException;\n    protected void printEntityRef(final Writer out, final FormatStack fstack, final EntityRef entity) throws IOException;\n    protected void printNamespace(final Writer out, final FormatStack fstack, final Namespace ns) throws IOException;\n    protected void printProcessingInstruction(final Writer out, final FormatStack fstack, final ProcessingInstruction pi) throws IOException;\n    protected void printText(final Writer out, final FormatStack fstack, final Text text) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final List<? extends Content> list) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final CDATA cdata) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Comment comment) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final DocType doctype) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Document doc) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Element element) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final EntityRef entity) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final ProcessingInstruction pi) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Text text) throws IOException;\n    protected void textCDATA(final Writer out, final String text) throws IOException;\n    protected void textEntityRef(final Writer out, final String name) throws IOException;\n    protected void textRaw(final Writer out, final char ch) throws IOException;\n    protected void textRaw(final Writer out, final String str) throws IOException;\n    protected void write(final Writer out, final char c) throws IOException;\n    protected void write(final Writer out, final String str) throws IOException;\n}"
      },
      {
        "id": "DTDParser_formatInternal",
        "package": "org.jdom2.input.stax",
        "class": "org.jdom2.input.stax.DTDParser",
        "test-class": "org.jdom2.input.stax.DTDParser_formatInternal_Test",
        "method-name": "formatInternal(String)",
        "source-path": "src/main/java/org/jdom2/input/stax/DTDParser.java",
        "test-path": "src/test/java/org/jdom2/input/stax/DTDParser_formatInternal_Test.java",
        "focal-method": "private static String formatInternal(String internal) {\r\n    StringBuilder sb = new StringBuilder(internal.length());\r\n    char quote = ' ';\r\n    boolean white = true;\r\n    for (char ch : internal.toCharArray()) {\r\n        if (quote == ' ') {\r\n            // we are not in a quoted value...\r\n            if (isWhite(ch)) {\r\n                if (!white) {\r\n                    // this will be the first whitespace.\r\n                    // replace it with a single ' '\r\n                    sb.append(' ');\r\n                    white = true;\r\n                }\r\n                // subsequent (unquoted) whitespace is ignored\r\n            } else {\r\n                if ((ch == '\\'') || (ch == '\"')) {\r\n                    // we are entering a quoted value.\r\n                    quote = ch;\r\n                } else if (ch == '<') {\r\n                    // we are starting some form of declaration.\r\n                    sb.append(\"  \");\r\n                }\r\n                if (ch == '>') {\r\n                    // we are ending a declaration.\r\n                    if (white) {\r\n                        // the declaration ended with whitespace, which we\r\n                        // remove.\r\n                        sb.setCharAt(sb.length() - 1, ch);\r\n                    } else {\r\n                        // the declaration had no whitespace at the end. OK\r\n                        sb.append(ch);\r\n                    }\r\n                    // all declarations end with a new-line.\r\n                    sb.append('\\n');\r\n                    // and subsequent lines start as trimmed whitespace.\r\n                    white = true;\r\n                } else {\r\n                    sb.append(ch);\r\n                    white = false;\r\n                }\r\n            }\r\n        } else {\r\n            // we are in a quoted value...\r\n            if (ch == quote) {\r\n                // we are leaving the quoted value.\r\n                quote = ' ';\r\n            }\r\n            sb.append(ch);\r\n        }\r\n    }\r\n    return sb.toString();\r\n}",
        "class-code": "package org.jdom2.input.stax;\nimport java.util.regex.Pattern;\nimport org.jdom2.JDOMException;\nimport java.util.HashMap;\nimport java.util.regex.Matcher;\nimport org.jdom2.JDOMFactory;\nimport org.jdom2.DocType;\npublic class DTDParser {\n    \n    private static String formatInternal(String internal) {\r\n        StringBuilder sb = new StringBuilder(internal.length());\r\n        char quote = ' ';\r\n        boolean white = true;\r\n        for (char ch : internal.toCharArray()) {\r\n            if (quote == ' ') {\r\n                // we are not in a quoted value...\r\n                if (isWhite(ch)) {\r\n                    if (!white) {\r\n                        // this will be the first whitespace.\r\n                        // replace it with a single ' '\r\n                        sb.append(' ');\r\n                        white = true;\r\n                    }\r\n                    // subsequent (unquoted) whitespace is ignored\r\n                } else {\r\n                    if ((ch == '\\'') || (ch == '\"')) {\r\n                        // we are entering a quoted value.\r\n                        quote = ch;\r\n                    } else if (ch == '<') {\r\n                        // we are starting some form of declaration.\r\n                        sb.append(\"  \");\r\n                    }\r\n                    if (ch == '>') {\r\n                        // we are ending a declaration.\r\n                        if (white) {\r\n                            // the declaration ended with whitespace, which we\r\n                            // remove.\r\n                            sb.setCharAt(sb.length() - 1, ch);\r\n                        } else {\r\n                            // the declaration had no whitespace at the end. OK\r\n                            sb.append(ch);\r\n                        }\r\n                        // all declarations end with a new-line.\r\n                        sb.append('\\n');\r\n                        // and subsequent lines start as trimmed whitespace.\r\n                        white = true;\r\n                    } else {\r\n                        sb.append(ch);\r\n                        white = false;\r\n                    }\r\n                }\r\n            } else {\r\n                // we are in a quoted value...\r\n                if (ch == quote) {\r\n                    // we are leaving the quoted value.\r\n                    quote = ' ';\r\n                }\r\n                sb.append(ch);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\nprivate static final boolean isWhite(char ch);\n    public static DocType parse(final String input, final JDOMFactory factory) throws JDOMException;\n}"
      },
      {
        "id": "AbstractStAXStreamProcessor_printContent",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractStAXStreamProcessor",
        "test-class": "org.jdom2.output.support.AbstractStAXStreamProcessor_printContent_Test",
        "method-name": "printContent(XMLStreamWriter, FormatStack, NamespaceStack, Walker)",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractStAXStreamProcessor.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractStAXStreamProcessor_printContent_Test.java",
        "focal-method": "protected void printContent(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws XMLStreamException {\r\n    while (walker.hasNext()) {\r\n        final Content content = walker.next();\r\n        if (content == null) {\r\n            if (walker.isCDATA()) {\r\n                printCDATA(out, fstack, new CDATA(walker.text()));\r\n            } else {\r\n                printText(out, fstack, new Text(walker.text()));\r\n            }\r\n        } else {\r\n            switch (content.getCType()) {\r\n                case CDATA :\r\n                    printCDATA(out, fstack, ((CDATA) (content)));\r\n                    break;\r\n                case Comment :\r\n                    printComment(out, fstack, ((Comment) (content)));\r\n                    break;\r\n                case Element :\r\n                    printElement(out, fstack, nstack, ((Element) (content)));\r\n                    break;\r\n                case EntityRef :\r\n                    printEntityRef(out, fstack, ((EntityRef) (content)));\r\n                    break;\r\n                case ProcessingInstruction :\r\n                    printProcessingInstruction(out, fstack, ((ProcessingInstruction) (content)));\r\n                    break;\r\n                case Text :\r\n                    printText(out, fstack, ((Text) (content)));\r\n                    break;\r\n                case DocType :\r\n                    printDocType(out, fstack, ((DocType) (content)));\r\n                    break;\r\n                default :\r\n                    throw new IllegalStateException(\"Unexpected Content \" + content.getCType());\r\n            }\r\n        }\r\n    } \r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.Attribute;\nimport org.jdom2.Content.CType;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport org.jdom2.Document;\nimport org.jdom2.Verifier;\nimport org.jdom2.util.NamespaceStack;\nimport org.jdom2.output.StAXStreamOutputter;\nimport java.io.StringWriter;\nimport javax.xml.stream.XMLStreamException;\nimport org.jdom2.Content;\nimport org.jdom2.output.Format.TextMode;\nimport javax.xml.stream.XMLStreamWriter;\nimport org.jdom2.JDOMConstants;\nimport org.jdom2.ProcessingInstruction;\nimport java.util.List;\nimport org.jdom2.EntityRef;\nimport org.jdom2.output.Format;\nimport org.jdom2.CDATA;\nimport org.jdom2.Comment;\nimport java.util.Collections;\nimport org.jdom2.DocType;\npublic abstract class AbstractStAXStreamProcessor extends AbstractOutputProcessor implements StAXStreamProcessor {\n    \n    protected void printContent(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws XMLStreamException {\r\n        while (walker.hasNext()) {\r\n            final Content content = walker.next();\r\n            if (content == null) {\r\n                if (walker.isCDATA()) {\r\n                    printCDATA(out, fstack, new CDATA(walker.text()));\r\n                } else {\r\n                    printText(out, fstack, new Text(walker.text()));\r\n                }\r\n            } else {\r\n                switch (content.getCType()) {\r\n                    case CDATA :\r\n                        printCDATA(out, fstack, ((CDATA) (content)));\r\n                        break;\r\n                    case Comment :\r\n                        printComment(out, fstack, ((Comment) (content)));\r\n                        break;\r\n                    case Element :\r\n                        printElement(out, fstack, nstack, ((Element) (content)));\r\n                        break;\r\n                    case EntityRef :\r\n                        printEntityRef(out, fstack, ((EntityRef) (content)));\r\n                        break;\r\n                    case ProcessingInstruction :\r\n                        printProcessingInstruction(out, fstack, ((ProcessingInstruction) (content)));\r\n                        break;\r\n                    case Text :\r\n                        printText(out, fstack, ((Text) (content)));\r\n                        break;\r\n                    case DocType :\r\n                        printDocType(out, fstack, ((DocType) (content)));\r\n                        break;\r\n                    default :\r\n                        throw new IllegalStateException(\"Unexpected Content \" + content.getCType());\r\n                }\r\n            }\r\n        } \r\n    }\nprotected void printAttribute(final XMLStreamWriter out, final FormatStack fstack, final Attribute attribute) throws XMLStreamException;\n    protected void printCDATA(final XMLStreamWriter out, final FormatStack fstack, final CDATA cdata) throws XMLStreamException;\n    protected void printComment(final XMLStreamWriter out, final FormatStack fstack, final Comment comment) throws XMLStreamException;\n    protected void printDocType(final XMLStreamWriter out, final FormatStack fstack, final DocType docType) throws XMLStreamException;\n    protected void printDocument(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Document doc) throws XMLStreamException;\n    protected void printElement(final XMLStreamWriter out, final FormatStack fstack, final NamespaceStack nstack, final Element element) throws XMLStreamException;\n    protected void printEntityRef(final XMLStreamWriter out, final FormatStack fstack, final EntityRef entity) throws XMLStreamException;\n    protected void printNamespace(final XMLStreamWriter out, final FormatStack fstack, final Namespace ns) throws XMLStreamException;\n    protected void printProcessingInstruction(final XMLStreamWriter out, final FormatStack fstack, final ProcessingInstruction pi) throws XMLStreamException;\n    protected void printText(final XMLStreamWriter out, final FormatStack fstack, final Text text) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final List<? extends Content> list) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final CDATA cdata) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Comment comment) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final DocType doctype) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Document doc) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Element element) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final EntityRef entity) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final ProcessingInstruction pi) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLStreamWriter out, final Format format, final Text text) throws XMLStreamException;\n}"
      },
      {
        "id": "WalkerNORMALIZE_analyzeMultiText",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.WalkerNORMALIZE",
        "test-class": "org.jdom2.output.support.WalkerNORMALIZE_analyzeMultiText_Test",
        "method-name": "analyzeMultiText(MultiText, int, int)",
        "source-path": "src/main/java/org/jdom2/output/support/WalkerNORMALIZE.java",
        "test-path": "src/test/java/org/jdom2/output/support/WalkerNORMALIZE_analyzeMultiText_Test.java",
        "focal-method": "@Override\r\nprotected void analyzeMultiText(final MultiText mtext, final int offset, final int len) {\r\n    boolean needspace = false;\r\n    boolean between = false;\r\n    String ttext = null;\r\n    for (int i = 0; i < len; i++) {\r\n        final Content c = get(offset + i);\r\n        switch (c.getCType()) {\r\n            case Text :\r\n                ttext = c.getValue();\r\n                if (Verifier.isAllXMLWhitespace(ttext)) {\r\n                    if (between && (ttext.length() > 0)) {\r\n                        needspace = true;\r\n                    }\r\n                } else {\r\n                    if (between && (needspace || isSpaceFirst(ttext))) {\r\n                        mtext.appendText(Trim.NONE, \" \");\r\n                    }\r\n                    mtext.appendText(Trim.COMPACT, ttext);\r\n                    between = true;\r\n                    needspace = isSpaceLast(ttext);\r\n                }\r\n                break;\r\n            case CDATA :\r\n                ttext = c.getValue();\r\n                if (Verifier.isAllXMLWhitespace(ttext)) {\r\n                    if (between && (ttext.length() > 0)) {\r\n                        needspace = true;\r\n                    }\r\n                } else {\r\n                    if (between && (needspace || isSpaceFirst(ttext))) {\r\n                        mtext.appendText(Trim.NONE, \" \");\r\n                    }\r\n                    mtext.appendCDATA(Trim.COMPACT, ttext);\r\n                    between = true;\r\n                    needspace = isSpaceLast(ttext);\r\n                }\r\n                break;\r\n            case EntityRef :\r\n                // treat like any other content.\r\n                // raw.\r\n            default :\r\n                ttext = null;\r\n                if (between && needspace) {\r\n                    mtext.appendText(Trim.NONE, \" \");\r\n                }\r\n                mtext.appendRaw(c);\r\n                between = true;\r\n                needspace = false;\r\n                break;\r\n        }\r\n    }\r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.Content;\nimport java.util.List;\nimport org.jdom2.Verifier;\npublic class WalkerNORMALIZE extends AbstractFormattedWalker {\n    \n    @Override\r\n    protected void analyzeMultiText(final MultiText mtext, final int offset, final int len) {\r\n        boolean needspace = false;\r\n        boolean between = false;\r\n        String ttext = null;\r\n        for (int i = 0; i < len; i++) {\r\n            final Content c = get(offset + i);\r\n            switch (c.getCType()) {\r\n                case Text :\r\n                    ttext = c.getValue();\r\n                    if (Verifier.isAllXMLWhitespace(ttext)) {\r\n                        if (between && (ttext.length() > 0)) {\r\n                            needspace = true;\r\n                        }\r\n                    } else {\r\n                        if (between && (needspace || isSpaceFirst(ttext))) {\r\n                            mtext.appendText(Trim.NONE, \" \");\r\n                        }\r\n                        mtext.appendText(Trim.COMPACT, ttext);\r\n                        between = true;\r\n                        needspace = isSpaceLast(ttext);\r\n                    }\r\n                    break;\r\n                case CDATA :\r\n                    ttext = c.getValue();\r\n                    if (Verifier.isAllXMLWhitespace(ttext)) {\r\n                        if (between && (ttext.length() > 0)) {\r\n                            needspace = true;\r\n                        }\r\n                    } else {\r\n                        if (between && (needspace || isSpaceFirst(ttext))) {\r\n                            mtext.appendText(Trim.NONE, \" \");\r\n                        }\r\n                        mtext.appendCDATA(Trim.COMPACT, ttext);\r\n                        between = true;\r\n                        needspace = isSpaceLast(ttext);\r\n                    }\r\n                    break;\r\n                case EntityRef :\r\n                    // treat like any other content.\r\n                    // raw.\r\n                default :\r\n                    ttext = null;\r\n                    if (between && needspace) {\r\n                        mtext.appendText(Trim.NONE, \" \");\r\n                    }\r\n                    mtext.appendRaw(c);\r\n                    between = true;\r\n                    needspace = false;\r\n                    break;\r\n            }\r\n        }\r\n    }\nprivate boolean isSpaceFirst(String text);\n    private boolean isSpaceLast(String text);\n}"
      },
      {
        "id": "AbstractSAXOutputProcessor_printContent",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractSAXOutputProcessor",
        "test-class": "org.jdom2.output.support.AbstractSAXOutputProcessor_printContent_Test",
        "method-name": "printContent(SAXTarget, FormatStack, NamespaceStack, Walker)",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractSAXOutputProcessor.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractSAXOutputProcessor_printContent_Test.java",
        "focal-method": "protected void printContent(final SAXTarget out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws SAXException {\r\n    while (walker.hasNext()) {\r\n        final Content c = walker.next();\r\n        if (c == null) {\r\n            // Formatted Text or CDATA\r\n            final String text = walker.text();\r\n            if (walker.isCDATA()) {\r\n                printCDATA(out, fstack, new CDATA(text));\r\n            } else {\r\n                printText(out, fstack, new Text(text));\r\n            }\r\n        } else {\r\n            switch (c.getCType()) {\r\n                case CDATA :\r\n                    printCDATA(out, fstack, ((CDATA) (c)));\r\n                    break;\r\n                case Comment :\r\n                    printComment(out, fstack, ((Comment) (c)));\r\n                    break;\r\n                case DocType :\r\n                    // do nothing.\r\n                    break;\r\n                case Element :\r\n                    printElement(out, fstack, nstack, ((Element) (c)));\r\n                    break;\r\n                case EntityRef :\r\n                    printEntityRef(out, fstack, ((EntityRef) (c)));\r\n                    break;\r\n                case ProcessingInstruction :\r\n                    printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                    break;\r\n                case Text :\r\n                    printText(out, fstack, ((Text) (c)));\r\n                    break;\r\n            }\r\n        }\r\n    } \r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.xml.sax.InputSource;\nimport org.jdom2.output.XMLOutputter;\nimport org.jdom2.Attribute;\nimport org.jdom2.Element;\nimport org.jdom2.Document;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.ContentHandler;\nimport org.jdom2.util.NamespaceStack;\nimport org.xml.sax.ext.DeclHandler;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.jdom2.output.Format.TextMode;\nimport static org.jdom2.JDOMConstants.*;\nimport org.xml.sax.SAXParseException;\nimport org.jdom2.AttributeType;\nimport java.io.StringReader;\nimport java.util.List;\nimport org.xml.sax.helpers.XMLReaderFactory;\nimport org.xml.sax.helpers.AttributesImpl;\nimport org.jdom2.EntityRef;\nimport org.jdom2.output.Format;\nimport org.jdom2.Comment;\nimport java.util.Collections;\nimport org.xml.sax.XMLReader;\nimport org.jdom2.DocType;\nimport org.jdom2.JDOMException;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport org.xml.sax.helpers.DefaultHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport org.jdom2.Content;\nimport org.jdom2.ProcessingInstruction;\nimport org.xml.sax.DTDHandler;\nimport org.jdom2.CDATA;\npublic class AbstractSAXOutputProcessor extends AbstractOutputProcessor implements SAXOutputProcessor {\n    \n    protected void printContent(final SAXTarget out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws SAXException {\r\n        while (walker.hasNext()) {\r\n            final Content c = walker.next();\r\n            if (c == null) {\r\n                // Formatted Text or CDATA\r\n                final String text = walker.text();\r\n                if (walker.isCDATA()) {\r\n                    printCDATA(out, fstack, new CDATA(text));\r\n                } else {\r\n                    printText(out, fstack, new Text(text));\r\n                }\r\n            } else {\r\n                switch (c.getCType()) {\r\n                    case CDATA :\r\n                        printCDATA(out, fstack, ((CDATA) (c)));\r\n                        break;\r\n                    case Comment :\r\n                        printComment(out, fstack, ((Comment) (c)));\r\n                        break;\r\n                    case DocType :\r\n                        // do nothing.\r\n                        break;\r\n                    case Element :\r\n                        printElement(out, fstack, nstack, ((Element) (c)));\r\n                        break;\r\n                    case EntityRef :\r\n                        printEntityRef(out, fstack, ((EntityRef) (c)));\r\n                        break;\r\n                    case ProcessingInstruction :\r\n                        printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                        break;\r\n                    case Text :\r\n                        printText(out, fstack, ((Text) (c)));\r\n                        break;\r\n                }\r\n            }\r\n        } \r\n    }\nprotected XMLReader createParser() throws Exception;\n    protected void printCDATA(final SAXTarget out, final FormatStack fstack, final CDATA cdata) throws SAXException;\n    protected void printComment(final SAXTarget out, final FormatStack fstack, final Comment comment) throws SAXException;\n    protected void printDocType(final SAXTarget out, final FormatStack fstack, final DocType docType) throws SAXException;\n    protected void printDocument(final SAXTarget out, final FormatStack fstack, final NamespaceStack nstack, final Document document) throws SAXException;\n    protected void printElement(final SAXTarget out, final FormatStack fstack, final NamespaceStack nstack, final Element element) throws SAXException;\n    protected void printEntityRef(final SAXTarget out, final FormatStack fstack, final EntityRef entity) throws SAXException;\n    protected void printProcessingInstruction(final SAXTarget out, final FormatStack fstack, final ProcessingInstruction pi) throws SAXException;\n    protected void printText(final SAXTarget out, final FormatStack fstack, final Text text) throws SAXException;\n    @Override\r\npublic void process(SAXTarget out, Format format, List<? extends Content> list) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, CDATA cdata) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, Comment comment) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, DocType doctype) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, Document doc) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, Element element) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, EntityRef entity) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, ProcessingInstruction pi) throws JDOMException;\n    @Override\r\npublic void process(SAXTarget out, Format format, Text text) throws JDOMException;\n    @Override\r\npublic void processAsDocument(SAXTarget out, Format format, List<? extends Content> nodes) throws JDOMException;\n    @Override\r\npublic void processAsDocument(SAXTarget out, Format format, Element node) throws JDOMException;\n}"
      },
      {
        "id": "XPathHelper_getSingleStep",
        "package": "org.jdom2.xpath",
        "class": "org.jdom2.xpath.XPathHelper",
        "test-class": "org.jdom2.xpath.XPathHelper_getSingleStep_Test",
        "method-name": "getSingleStep(NamespaceAware, StringBuilder)",
        "source-path": "src/main/java/org/jdom2/xpath/XPathHelper.java",
        "test-path": "src/test/java/org/jdom2/xpath/XPathHelper_getSingleStep_Test.java",
        "focal-method": "private static final StringBuilder getSingleStep(final NamespaceAware nsa, final StringBuilder buffer) {\r\n    if (nsa instanceof Content) {\r\n        final Content content = ((Content) (nsa));\r\n        final Parent pnt = content.getParent();\r\n        if (content instanceof Text) {\r\n            // OR CDATA!\r\n            final List<?> sibs = (pnt == null) ? null : pnt.getContent(Filters.text());// CDATA\r\n\r\n            return getPositionPath(content, sibs, \"text()\", buffer);\r\n        } else if (content instanceof Comment) {\r\n            final List<?> sibs = (pnt == null) ? null : pnt.getContent(Filters.comment());\r\n            return getPositionPath(content, sibs, \"comment()\", buffer);\r\n        } else if (content instanceof ProcessingInstruction) {\r\n            final List<?> sibs = (pnt == null) ? null : pnt.getContent(Filters.processinginstruction());\r\n            return getPositionPath(content, sibs, \"processing-instruction()\", buffer);\r\n        } else if ((content instanceof Element) && (((Element) (content)).getNamespace() == Namespace.NO_NAMESPACE)) {\r\n            // simple XPath to a no-namespace Element.\r\n            final String ename = ((Element) (content)).getName();\r\n            final List<?> sibs = (pnt instanceof Element) ? ((Element) (pnt)).getChildren(ename) : null;\r\n            return getPositionPath(content, sibs, ename, buffer);\r\n        } else if (content instanceof Element) {\r\n            // complex XPath to an Element with Namespace...\r\n            // we do not want to have to prefix namespaces because that is\r\n            // essentially impossible to get right with the new JDOM2 API.\r\n            final Element emt = ((Element) (content));\r\n            // Note, the getChildren compares only the URI (not the prefix)\r\n            // so the results are the same as an XPath would be.\r\n            final List<?> sibs = (pnt instanceof Element) ? ((Element) (pnt)).getChildren(emt.getName(), emt.getNamespace()) : null;\r\n            String xps = (((\"*[local-name() = '\" + emt.getName()) + \"' and namespace-uri() = '\") + emt.getNamespaceURI()) + \"']\";\r\n            return getPositionPath(content, sibs, xps, buffer);\r\n        } else {\r\n            final List<?> sibs = (pnt == null) ? Collections.singletonList(nsa) : pnt.getContent();\r\n            return getPositionPath(content, sibs, \"node()\", buffer);\r\n        }\r\n    } else if (nsa instanceof Attribute) {\r\n        Attribute att = ((Attribute) (nsa));\r\n        if (att.getNamespace() == Namespace.NO_NAMESPACE) {\r\n            buffer.append(\"@\").append(att.getName());\r\n        } else {\r\n            buffer.append(\"@*[local-name() = '\").append(att.getName());\r\n            buffer.append(\"' and namespace-uri() = '\");\r\n            buffer.append(att.getNamespaceURI()).append(\"']\");\r\n        }\r\n    }\r\n    // do nothing...\r\n    return buffer;\r\n}",
        "class-code": "package org.jdom2.xpath;\nimport org.jdom2.NamespaceAware;\nimport org.jdom2.Attribute;\nimport org.jdom2.Parent;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport org.jdom2.Content;\nimport org.jdom2.filter.Filters;\nimport java.util.Iterator;\nimport org.jdom2.ProcessingInstruction;\nimport java.util.List;\nimport org.jdom2.Comment;\nimport java.util.Collections;\npublic final class XPathHelper {\n    \n    private static final StringBuilder getSingleStep(final NamespaceAware nsa, final StringBuilder buffer) {\r\n        if (nsa instanceof Content) {\r\n            final Content content = ((Content) (nsa));\r\n            final Parent pnt = content.getParent();\r\n            if (content instanceof Text) {\r\n                // OR CDATA!\r\n                final List<?> sibs = (pnt == null) ? null : pnt.getContent(Filters.text());// CDATA\r\n    \r\n                return getPositionPath(content, sibs, \"text()\", buffer);\r\n            } else if (content instanceof Comment) {\r\n                final List<?> sibs = (pnt == null) ? null : pnt.getContent(Filters.comment());\r\n                return getPositionPath(content, sibs, \"comment()\", buffer);\r\n            } else if (content instanceof ProcessingInstruction) {\r\n                final List<?> sibs = (pnt == null) ? null : pnt.getContent(Filters.processinginstruction());\r\n                return getPositionPath(content, sibs, \"processing-instruction()\", buffer);\r\n            } else if ((content instanceof Element) && (((Element) (content)).getNamespace() == Namespace.NO_NAMESPACE)) {\r\n                // simple XPath to a no-namespace Element.\r\n                final String ename = ((Element) (content)).getName();\r\n                final List<?> sibs = (pnt instanceof Element) ? ((Element) (pnt)).getChildren(ename) : null;\r\n                return getPositionPath(content, sibs, ename, buffer);\r\n            } else if (content instanceof Element) {\r\n                // complex XPath to an Element with Namespace...\r\n                // we do not want to have to prefix namespaces because that is\r\n                // essentially impossible to get right with the new JDOM2 API.\r\n                final Element emt = ((Element) (content));\r\n                // Note, the getChildren compares only the URI (not the prefix)\r\n                // so the results are the same as an XPath would be.\r\n                final List<?> sibs = (pnt instanceof Element) ? ((Element) (pnt)).getChildren(emt.getName(), emt.getNamespace()) : null;\r\n                String xps = (((\"*[local-name() = '\" + emt.getName()) + \"' and namespace-uri() = '\") + emt.getNamespaceURI()) + \"']\";\r\n                return getPositionPath(content, sibs, xps, buffer);\r\n            } else {\r\n                final List<?> sibs = (pnt == null) ? Collections.singletonList(nsa) : pnt.getContent();\r\n                return getPositionPath(content, sibs, \"node()\", buffer);\r\n            }\r\n        } else if (nsa instanceof Attribute) {\r\n            Attribute att = ((Attribute) (nsa));\r\n            if (att.getNamespace() == Namespace.NO_NAMESPACE) {\r\n                buffer.append(\"@\").append(att.getName());\r\n            } else {\r\n                buffer.append(\"@*[local-name() = '\").append(att.getName());\r\n                buffer.append(\"' and namespace-uri() = '\");\r\n                buffer.append(att.getNamespaceURI()).append(\"']\");\r\n            }\r\n        }\r\n        // do nothing...\r\n        return buffer;\r\n    }\npublic static String getAbsolutePath(final Attribute to);\n    public static String getAbsolutePath(final Content to);\n    private static StringBuilder getPositionPath(Object node, List<?> siblings, String pathToken, StringBuilder buffer);\n    public static String getRelativePath(final Attribute from, final Attribute to);\n    public static String getRelativePath(final Attribute from, final Content to);\n    public static String getRelativePath(final Content from, final Attribute to);\n    public static String getRelativePath(final Content from, final Content to);\n}"
      },
      {
        "id": "AbstractFormattedWalker_next",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractFormattedWalker",
        "test-class": "org.jdom2.output.support.AbstractFormattedWalker_next_Test",
        "method-name": "next()",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractFormattedWalker.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractFormattedWalker_next_Test.java",
        "focal-method": "@Override\r\npublic final Content next() {\r\n    if (!hasnext) {\r\n        throw new NoSuchElementException(\"Cannot walk off end of Content\");\r\n    }\r\n    if ((multitext != null) && ((mtpos + 1) >= mtsize)) {\r\n        // finished this multitext. need to move on.\r\n        multitext = null;\r\n        resetMultiText();\r\n    }\r\n    if (pendingmt != null) {\r\n        // we have a multi-text pending from the last block\r\n        // this will only be the case when the previous value was non-text.\r\n        if ((mtwasescape != null) && (fstack.getEscapeOutput() != mtwasescape.booleanValue())) {\r\n            // we calculated pending with one escape strategy, but it changed...\r\n            // we need to recalculate it....\r\n            mtsize = 0;\r\n            mtwasescape = fstack.getEscapeOutput();\r\n            analyzeMultiText(pendingmt, 0, mtsourcesize);\r\n            pendingmt.done();\r\n        }\r\n        multitext = pendingmt;\r\n        pendingmt = null;\r\n    }\r\n    if (multitext != null) {\r\n        // OK, we have text-like content to push back.\r\n        // and it still has values in it.\r\n        // advance the cursor\r\n        mtpos++;\r\n        final Content ret = (mttext[mtpos] == null) ? mtdata[mtpos] : null;\r\n        // we can calculate the hasnext\r\n        hasnext = ((mtpos + 1) < mtsize) || (pending != null);\r\n        // return null to indicate text content.\r\n        return ret;\r\n    }\r\n    // non-text, increment and return content.\r\n    final Content ret = pending;\r\n    pending = (content.hasNext()) ? content.next() : null;\r\n    // OK, we are returning some content.\r\n    // we need to determine the state of the next loop.\r\n    // cursor at this point has been advanced!\r\n    if (pending == null) {\r\n        hasnext = false;\r\n    } else // there is some more content.\r\n    // we need to inspect it to determine whether it is good\r\n    if (isTextLike(pending)) {\r\n        // calculate what this next text-like content looks like.\r\n        pendingmt = buildMultiText(false);\r\n        analyzeMultiText(pendingmt, 0, mtsourcesize);\r\n        pendingmt.done();\r\n        if (mtsize > 0) {\r\n            hasnext = true;\r\n        } else // all white text... perhaps we need indenting anyway.\r\n        // buildMultiText has moved on the pending value....\r\n        if ((pending != null) && (newlineindent != null)) {\r\n            // yes, we need indenting.\r\n            // redefine the pending.\r\n            resetMultiText();\r\n            pendingmt = holdingmt;\r\n            pendingmt.forceAppend(newlineindent);\r\n            pendingmt.done();\r\n            hasnext = true;\r\n        } else {\r\n            pendingmt = null;\r\n            hasnext = pending != null;\r\n        }\r\n    } else {\r\n        // it is non-text content... we have more content.\r\n        // but, we just returned non-text content. We may need to indent\r\n        if (newlineindent != null) {\r\n            resetMultiText();\r\n            pendingmt = holdingmt;\r\n            pendingmt.forceAppend(newlineindent);\r\n            pendingmt.done();\r\n        }\r\n        hasnext = true;\r\n    }\r\n    return ret;\r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.internal.ArrayCopy;\nimport org.jdom2.Content;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.List;\nimport org.jdom2.output.EscapeStrategy;\nimport org.jdom2.output.Format;\nimport org.jdom2.CDATA;\npublic abstract class AbstractFormattedWalker implements Walker {\n    private Content pending = null;\n    private final Iterator<? extends Content> content;\n    private final String newlineindent;\n    private final FormatStack fstack;\n    private boolean hasnext = true;\n    private MultiText multitext = null;\n    private MultiText pendingmt = null;\n    private final MultiText holdingmt = new MultiText();\n    private int mtsize = 0;\n    private int mtsourcesize = 0;\n    private Content[] mtdata = new Content[8];\n    private String[] mttext = new String[8];\n    private int mtpos = -1;\n    private Boolean mtwasescape;\n        /**\r\n     * Collect together the items that constitute formatted Text-like content.\r\n     *\r\n     * @author Rolf Lear\r\n     */\r\n    protected final class MultiText {\r\n        /**\r\n         * This is private so only this abstract class can create instances.\r\n         */\r\n        private MultiText() {\r\n        }\r\n    \r\n        /**\r\n         * Ensure we have space for at least one more text-like item.\r\n         */\r\n        private void ensurespace() {\r\n            if (mtsize >= mtdata.length) {\r\n                mtdata = ArrayCopy.copyOf(mtdata, (mtsize + 1) + (mtsize / 2));\r\n                mttext = ArrayCopy.copyOf(mttext, mtdata.length);\r\n            }\r\n        }\r\n    \r\n        /**\r\n         * Handle the case where we have been accumulating true text content,\r\n         * and the next item is not more text.\r\n         *\r\n         * @param postspace\r\n         * \t\ttrue if the last char in the text should be a space\r\n         */\r\n        private void closeText() {\r\n            if (mtbuffer.length() == 0) {\r\n                // empty text does not need adding at all.\r\n                return;\r\n            }\r\n            ensurespace();\r\n            mtdata[mtsize] = null;\r\n            mttext[mtsize++] = mtbuffer.toString();\r\n            mtbuffer.setLength(0);\r\n        }\r\n    \r\n        /**\r\n         * Append some text to the text-like sequence that will be treated as\r\n         * plain XML text (PCDATA). If the last content added to this text-like\r\n         * sequence then this new text will be appended directly to the previous\r\n         * text.\r\n         *\r\n         * @param trim\r\n         * \t\tHow to prepare the Text content\r\n         * @param text\r\n         * \t\tThe actual Text content.\r\n         */\r\n        public void appendText(final Trim trim, final String text) {\r\n            final int tlen = text.length();\r\n            if (tlen == 0) {\r\n                return;\r\n            }\r\n            String toadd = null;\r\n            switch (trim) {\r\n                case NONE :\r\n                    toadd = text;\r\n                    break;\r\n                case BOTH :\r\n                    toadd = Format.trimBoth(text);\r\n                    break;\r\n                case LEFT :\r\n                    toadd = Format.trimLeft(text);\r\n                    break;\r\n                case RIGHT :\r\n                    toadd = Format.trimRight(text);\r\n                    break;\r\n                case COMPACT :\r\n                    toadd = Format.compact(text);\r\n                    break;\r\n            }\r\n            if (toadd != null) {\r\n                toadd = escapeText(toadd);\r\n                mtbuffer.append(toadd);\r\n                mtgottext = true;\r\n            }\r\n        }\r\n    \r\n        private String escapeText(final String text) {\r\n            if ((escape == null) || (!fstack.getEscapeOutput())) {\r\n                return text;\r\n            }\r\n            return Format.escapeText(escape, endofline, text);\r\n        }\r\n    \r\n        private String escapeCDATA(final String text) {\r\n            if (escape == null) {\r\n                return text;\r\n            }\r\n            return text;\r\n        }\r\n    \r\n        /**\r\n         * Append some text to the text-like sequence that will be treated as\r\n         * CDATA.\r\n         *\r\n         * @param trim\r\n         * \t\tHow to prepare the CDATA content\r\n         * @param text\r\n         * \t\tThe actual CDATA content.\r\n         */\r\n        public void appendCDATA(final Trim trim, final String text) {\r\n            // this resets the mtbuffer too.\r\n            closeText();\r\n            String toadd = null;\r\n            switch (trim) {\r\n                case NONE :\r\n                    toadd = text;\r\n                    break;\r\n                case BOTH :\r\n                    toadd = Format.trimBoth(text);\r\n                    break;\r\n                case LEFT :\r\n                    toadd = Format.trimLeft(text);\r\n                    break;\r\n                case RIGHT :\r\n                    toadd = Format.trimRight(text);\r\n                    break;\r\n                case COMPACT :\r\n                    toadd = Format.compact(text);\r\n                    break;\r\n            }\r\n            toadd = escapeCDATA(toadd);\r\n            ensurespace();\r\n            // mark this as being CDATA text\r\n            mtdata[mtsize] = CDATATOKEN;\r\n            mttext[mtsize++] = toadd;\r\n            mtgottext = true;\r\n        }\r\n    \r\n        /**\r\n         * Simple method that ensures the text is processed, regardless of\r\n         * content, and is never escaped.\r\n         *\r\n         * @param text\r\n         */\r\n        private void forceAppend(final String text) {\r\n            mtgottext = true;\r\n            mtbuffer.append(text);\r\n        }\r\n    \r\n        /**\r\n         * Add some JDOM Content (typically an EntityRef) that will be treated\r\n         * as part of the Text-like sequence.\r\n         *\r\n         * @param c\r\n         * \t\tthe content to add.\r\n         */\r\n        public void appendRaw(final Content c) {\r\n            closeText();\r\n            ensurespace();\r\n            mttext[mtsize] = null;\r\n            mtdata[mtsize++] = c;\r\n            mtbuffer.setLength(0);\r\n        }\r\n    \r\n        /**\r\n         * Indicate that there is no further content to be added to the\r\n         * text-like sequence.\r\n         */\r\n        public void done() {\r\n            if (mtpostpad && (newlineindent != null)) {\r\n                // this will be ignored if there was not some content.\r\n                mtbuffer.append(newlineindent);\r\n            }\r\n            if (mtgottext) {\r\n                closeText();\r\n            }\r\n            mtbuffer.setLength(0);\r\n        }\r\n    }\n@Override\r\n    public final Content next() {\r\n        if (!hasnext) {\r\n            throw new NoSuchElementException(\"Cannot walk off end of Content\");\r\n        }\r\n        if ((multitext != null) && ((mtpos + 1) >= mtsize)) {\r\n            // finished this multitext. need to move on.\r\n            multitext = null;\r\n            resetMultiText();\r\n        }\r\n        if (pendingmt != null) {\r\n            // we have a multi-text pending from the last block\r\n            // this will only be the case when the previous value was non-text.\r\n            if ((mtwasescape != null) && (fstack.getEscapeOutput() != mtwasescape.booleanValue())) {\r\n                // we calculated pending with one escape strategy, but it changed...\r\n                // we need to recalculate it....\r\n                mtsize = 0;\r\n                mtwasescape = fstack.getEscapeOutput();\r\n                analyzeMultiText(pendingmt, 0, mtsourcesize);\r\n                pendingmt.done();\r\n            }\r\n            multitext = pendingmt;\r\n            pendingmt = null;\r\n        }\r\n        if (multitext != null) {\r\n            // OK, we have text-like content to push back.\r\n            // and it still has values in it.\r\n            // advance the cursor\r\n            mtpos++;\r\n            final Content ret = (mttext[mtpos] == null) ? mtdata[mtpos] : null;\r\n            // we can calculate the hasnext\r\n            hasnext = ((mtpos + 1) < mtsize) || (pending != null);\r\n            // return null to indicate text content.\r\n            return ret;\r\n        }\r\n        // non-text, increment and return content.\r\n        final Content ret = pending;\r\n        pending = (content.hasNext()) ? content.next() : null;\r\n        // OK, we are returning some content.\r\n        // we need to determine the state of the next loop.\r\n        // cursor at this point has been advanced!\r\n        if (pending == null) {\r\n            hasnext = false;\r\n        } else // there is some more content.\r\n        // we need to inspect it to determine whether it is good\r\n        if (isTextLike(pending)) {\r\n            // calculate what this next text-like content looks like.\r\n            pendingmt = buildMultiText(false);\r\n            analyzeMultiText(pendingmt, 0, mtsourcesize);\r\n            pendingmt.done();\r\n            if (mtsize > 0) {\r\n                hasnext = true;\r\n            } else // all white text... perhaps we need indenting anyway.\r\n            // buildMultiText has moved on the pending value....\r\n            if ((pending != null) && (newlineindent != null)) {\r\n                // yes, we need indenting.\r\n                // redefine the pending.\r\n                resetMultiText();\r\n                pendingmt = holdingmt;\r\n                pendingmt.forceAppend(newlineindent);\r\n                pendingmt.done();\r\n                hasnext = true;\r\n            } else {\r\n                pendingmt = null;\r\n                hasnext = pending != null;\r\n            }\r\n        } else {\r\n            // it is non-text content... we have more content.\r\n            // but, we just returned non-text content. We may need to indent\r\n            if (newlineindent != null) {\r\n                resetMultiText();\r\n                pendingmt = holdingmt;\r\n                pendingmt.forceAppend(newlineindent);\r\n                pendingmt.done();\r\n            }\r\n            hasnext = true;\r\n        }\r\n        return ret;\r\n    }\nprotected abstract void analyzeMultiText(MultiText mtext, int offset, int len);;\n    private final MultiText buildMultiText(final boolean first);\n    protected final Content get(final int index);\n    @Override\r\npublic final boolean hasNext();\n    @Override\r\npublic final boolean isAllText();\n    @Override\r\npublic final boolean isAllWhitespace();\n    @Override\r\npublic final boolean isCDATA();\n    private final boolean isTextLike(final Content c);\n    private void resetMultiText();\n    @Override\r\npublic final String text();\n}"
      },
      {
        "id": "StAXStreamBuilder_processPrunableElement",
        "package": "org.jdom2.input",
        "class": "org.jdom2.input.StAXStreamBuilder",
        "test-class": "org.jdom2.input.StAXStreamBuilder_processPrunableElement_Test",
        "method-name": "processPrunableElement(JDOMFactory, XMLStreamReader, int, StAXFilter)",
        "source-path": "src/main/java/org/jdom2/input/StAXStreamBuilder.java",
        "test-path": "src/test/java/org/jdom2/input/StAXStreamBuilder_processPrunableElement_Test.java",
        "focal-method": "private static final Element processPrunableElement(final JDOMFactory factory, final XMLStreamReader reader, final int topdepth, StAXFilter filter) throws XMLStreamException, JDOMException {\r\n    if (START_ELEMENT != reader.getEventType()) {\r\n        throw new JDOMException((\"JDOM requires that the XMLStreamReader \" + \"is at the START_ELEMENT state when retrieving an \") + \"Element Fragment.\");\r\n    }\r\n    final Element fragment = processElement(factory, reader);\r\n    Element current = fragment;\r\n    int depth = topdepth + 1;\r\n    String text = null;\r\n    while ((depth > topdepth) && reader.hasNext()) {\r\n        switch (reader.next()) {\r\n            case START_ELEMENT :\r\n                QName qn = reader.getName();\r\n                if (!filter.pruneElement(depth, qn.getLocalPart(), Namespace.getNamespace(qn.getPrefix(), qn.getNamespaceURI()))) {\r\n                    Element tmp = processElement(factory, reader);\r\n                    current.addContent(tmp);\r\n                    current = tmp;\r\n                    depth++;\r\n                } else {\r\n                    final int edepth = depth;\r\n                    depth++;\r\n                    int state = 0;\r\n                    while (((depth > edepth) && reader.hasNext()) && ((state = reader.next()) != END_DOCUMENT)) {\r\n                        if (state == START_ELEMENT) {\r\n                            depth++;\r\n                        } else if (state == END_ELEMENT) {\r\n                            depth--;\r\n                        }\r\n                    } \r\n                }\r\n                break;\r\n            case END_ELEMENT :\r\n                current = current.getParentElement();\r\n                depth--;\r\n                break;\r\n            case CDATA :\r\n                if ((text = filter.pruneCDATA(depth, reader.getText())) != null) {\r\n                    current.addContent(factory.cdata(text));\r\n                }\r\n                break;\r\n            case SPACE :\r\n            case CHARACTERS :\r\n                if ((text = filter.pruneText(depth, reader.getText())) != null) {\r\n                    current.addContent(factory.text(text));\r\n                }\r\n                break;\r\n            case COMMENT :\r\n                if ((text = filter.pruneComment(depth, reader.getText())) != null) {\r\n                    current.addContent(factory.comment(text));\r\n                }\r\n                break;\r\n            case ENTITY_REFERENCE :\r\n                if (!filter.pruneEntityRef(depth, reader.getLocalName())) {\r\n                    current.addContent(factory.entityRef(reader.getLocalName()));\r\n                }\r\n                break;\r\n            case PROCESSING_INSTRUCTION :\r\n                if (!filter.pruneProcessingInstruction(depth, reader.getPITarget())) {\r\n                    current.addContent(factory.processingInstruction(reader.getPITarget(), reader.getPIData()));\r\n                }\r\n                break;\r\n            default :\r\n                throw new JDOMException(\"Unexpected XMLStream event \" + reader.getEventType());\r\n        }\r\n    } \r\n    return fragment;\r\n}",
        "class-code": "package org.jdom2.input;\nimport org.jdom2.input.stax.StAXFilter;\nimport javax.xml.stream.XMLStreamReader;\nimport org.jdom2.JDOMException;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport javax.xml.namespace.QName;\nimport org.jdom2.JDOMFactory;\nimport org.jdom2.Namespace;\nimport org.jdom2.Document;\nimport org.jdom2.Verifier;\nimport org.jdom2.DefaultJDOMFactory;\nimport javax.xml.stream.XMLStreamException;\nimport org.jdom2.Content;\nimport org.jdom2.AttributeType;\nimport java.util.List;\nimport org.jdom2.input.stax.DTDParser;\nimport static javax.xml.stream.XMLStreamConstants.*;\npublic class StAXStreamBuilder {\n    \n    private static final Element processPrunableElement(final JDOMFactory factory, final XMLStreamReader reader, final int topdepth, StAXFilter filter) throws XMLStreamException, JDOMException {\r\n        if (START_ELEMENT != reader.getEventType()) {\r\n            throw new JDOMException((\"JDOM requires that the XMLStreamReader \" + \"is at the START_ELEMENT state when retrieving an \") + \"Element Fragment.\");\r\n        }\r\n        final Element fragment = processElement(factory, reader);\r\n        Element current = fragment;\r\n        int depth = topdepth + 1;\r\n        String text = null;\r\n        while ((depth > topdepth) && reader.hasNext()) {\r\n            switch (reader.next()) {\r\n                case START_ELEMENT :\r\n                    QName qn = reader.getName();\r\n                    if (!filter.pruneElement(depth, qn.getLocalPart(), Namespace.getNamespace(qn.getPrefix(), qn.getNamespaceURI()))) {\r\n                        Element tmp = processElement(factory, reader);\r\n                        current.addContent(tmp);\r\n                        current = tmp;\r\n                        depth++;\r\n                    } else {\r\n                        final int edepth = depth;\r\n                        depth++;\r\n                        int state = 0;\r\n                        while (((depth > edepth) && reader.hasNext()) && ((state = reader.next()) != END_DOCUMENT)) {\r\n                            if (state == START_ELEMENT) {\r\n                                depth++;\r\n                            } else if (state == END_ELEMENT) {\r\n                                depth--;\r\n                            }\r\n                        } \r\n                    }\r\n                    break;\r\n                case END_ELEMENT :\r\n                    current = current.getParentElement();\r\n                    depth--;\r\n                    break;\r\n                case CDATA :\r\n                    if ((text = filter.pruneCDATA(depth, reader.getText())) != null) {\r\n                        current.addContent(factory.cdata(text));\r\n                    }\r\n                    break;\r\n                case SPACE :\r\n                case CHARACTERS :\r\n                    if ((text = filter.pruneText(depth, reader.getText())) != null) {\r\n                        current.addContent(factory.text(text));\r\n                    }\r\n                    break;\r\n                case COMMENT :\r\n                    if ((text = filter.pruneComment(depth, reader.getText())) != null) {\r\n                        current.addContent(factory.comment(text));\r\n                    }\r\n                    break;\r\n                case ENTITY_REFERENCE :\r\n                    if (!filter.pruneEntityRef(depth, reader.getLocalName())) {\r\n                        current.addContent(factory.entityRef(reader.getLocalName()));\r\n                    }\r\n                    break;\r\n                case PROCESSING_INSTRUCTION :\r\n                    if (!filter.pruneProcessingInstruction(depth, reader.getPITarget())) {\r\n                        current.addContent(factory.processingInstruction(reader.getPITarget(), reader.getPIData()));\r\n                    }\r\n                    break;\r\n                default :\r\n                    throw new JDOMException(\"Unexpected XMLStream event \" + reader.getEventType());\r\n            }\r\n        } \r\n        return fragment;\r\n    }\npublic Document build(XMLStreamReader reader) throws JDOMException;\n    public List<Content> buildFragments(XMLStreamReader reader, StAXFilter filter) throws JDOMException;\n    public Content fragment(XMLStreamReader reader) throws JDOMException;\n    public JDOMFactory getFactory();\n    private static final Element processElement(final JDOMFactory factory, final XMLStreamReader reader);\n    public void setFactory(JDOMFactory factory);\n}"
      },
      {
        "id": "Element_getNamespace",
        "package": "org.jdom2",
        "class": "org.jdom2.Element",
        "test-class": "org.jdom2.Element_getNamespace_Test",
        "method-name": "getNamespace(String)",
        "source-path": "src/main/java/org/jdom2/Element.java",
        "test-path": "src/test/java/org/jdom2/Element_getNamespace_Test.java",
        "focal-method": "public Namespace getNamespace(final String prefix) {\r\n    if (prefix == null) {\r\n        return null;\r\n    }\r\n    if (NS_PREFIX_XML.equals(prefix)) {\r\n        // Namespace \"xml\" is always bound.\r\n        return Namespace.XML_NAMESPACE;\r\n    }\r\n    // Check if the prefix is the prefix for this element\r\n    if (prefix.equals(getNamespacePrefix())) {\r\n        return getNamespace();\r\n    }\r\n    // Scan the additional namespaces\r\n    if (additionalNamespaces != null) {\r\n        for (int i = 0; i < additionalNamespaces.size(); i++) {\r\n            final Namespace ns = additionalNamespaces.get(i);\r\n            if (prefix.equals(ns.getPrefix())) {\r\n                return ns;\r\n            }\r\n        }\r\n    }\r\n    if (attributes != null) {\r\n        for (final Attribute a : attributes) {\r\n            if (prefix.equals(a.getNamespacePrefix())) {\r\n                return a.getNamespace();\r\n            }\r\n        }\r\n    }\r\n    // If we still don't have a match, ask the parent\r\n    if (parent instanceof Element) {\r\n        return ((Element) (parent)).getNamespace(prefix);\r\n    }\r\n    return null;\r\n}",
        "class-code": "package org.jdom2;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.net.URISyntaxException;\nimport org.jdom2.ContentList.FilterList;\nimport java.net.URI;\nimport java.io.ObjectOutputStream;\nimport java.util.TreeMap;\nimport java.util.Comparator;\nimport org.jdom2.filter.Filter;\nimport org.jdom2.filter.ElementFilter;\nimport org.jdom2.util.IteratorIterable;\nimport static org.jdom2.JDOMConstants.NS_PREFIX_XML;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport static org.jdom2.JDOMConstants.NS_PREFIX_DEFAULT;\nimport java.util.Collections;\npublic class Element extends Content implements Parent {\n    protected String name;\n    protected Namespace namespace;\n    transient List<Namespace> additionalNamespaces = null;\n    transient AttributeList attributes = null;\n    transient ContentList content = new ContentList(this);\n    public Namespace getNamespace(final String prefix) {\r\n        if (prefix == null) {\r\n            return null;\r\n        }\r\n        if (NS_PREFIX_XML.equals(prefix)) {\r\n            // Namespace \"xml\" is always bound.\r\n            return Namespace.XML_NAMESPACE;\r\n        }\r\n        // Check if the prefix is the prefix for this element\r\n        if (prefix.equals(getNamespacePrefix())) {\r\n            return getNamespace();\r\n        }\r\n        // Scan the additional namespaces\r\n        if (additionalNamespaces != null) {\r\n            for (int i = 0; i < additionalNamespaces.size(); i++) {\r\n                final Namespace ns = additionalNamespaces.get(i);\r\n                if (prefix.equals(ns.getPrefix())) {\r\n                    return ns;\r\n                }\r\n            }\r\n        }\r\n        if (attributes != null) {\r\n            for (final Attribute a : attributes) {\r\n                if (prefix.equals(a.getNamespacePrefix())) {\r\n                    return a.getNamespace();\r\n                }\r\n            }\r\n        }\r\n        // If we still don't have a match, ask the parent\r\n        if (parent instanceof Element) {\r\n            return ((Element) (parent)).getNamespace(prefix);\r\n        }\r\n        return null;\r\n    }\n@Override\r\npublic Element addContent(final int index, final Collection<? extends Content> newContent);\n    @Override\r\npublic Element addContent(final int index, final Content child);\n    public Element addContent(final String str);\n    @Override\r\npublic Element addContent(final Collection<? extends Content> newContent);\n    @Override\r\npublic Element addContent(final Content child);\n    public boolean addNamespaceDeclaration(final Namespace additionalNamespace);\n    @Override\r\npublic void canContainContent(Content child, int index, boolean replace) throws IllegalAddException;\n    @Override\r\npublic Element clone();\n    @Override\r\npublic List<Content> cloneContent();\n    public boolean coalesceText(boolean recursively);\n    @Override\r\npublic Element detach();\n    public List<Namespace> getAdditionalNamespaces();\n    public Attribute getAttribute(final String attname);\n    public Attribute getAttribute(final String attname, final Namespace ns);\n    AttributeList getAttributeList();\n    public String getAttributeValue(final String attname);\n    public String getAttributeValue(final String attname, final String def);\n    public String getAttributeValue(final String attname, final Namespace ns);\n    public String getAttributeValue(final String attname, final Namespace ns, final String def);\n    public List<Attribute> getAttributes();\n    public Element getChild(final String cname);\n    public Element getChild(final String cname, final Namespace ns);\n    public String getChildText(final String cname);\n    public String getChildText(final String cname, final Namespace ns);\n    public String getChildTextNormalize(final String cname);\n    public String getChildTextNormalize(final String cname, final Namespace ns);\n    public String getChildTextTrim(final String cname);\n    public String getChildTextTrim(final String cname, final Namespace ns);\n    public List<Element> getChildren();\n    public List<Element> getChildren(final String cname);\n    public List<Element> getChildren(final String cname, final Namespace ns);\n    @Override\r\npublic List<Content> getContent();\n    @Override\r\npublic Content getContent(final int index);\n    @Override\r\npublic <E extends Content> List<E> getContent(final Filter<E> filter);\n    @Override\r\npublic int getContentSize();\n    @Override\r\npublic IteratorIterable<Content> getDescendants();\n    @Override\r\npublic <F extends Content> IteratorIterable<F> getDescendants(final Filter<F> filter);\n    public String getName();\n    public Namespace getNamespace();\n    public String getNamespacePrefix();\n    public String getNamespaceURI();\n    @Override\r\npublic List<Namespace> getNamespacesInScope();\n    @Override\r\npublic List<Namespace> getNamespacesInherited();\n    @Override\r\npublic List<Namespace> getNamespacesIntroduced();\n    public String getQualifiedName();\n    public String getText();\n    public String getTextNormalize();\n    public String getTextTrim();\n    @Override\r\npublic String getValue();\n    public URI getXMLBaseURI() throws URISyntaxException;\n    public boolean hasAdditionalNamespaces();\n    public boolean hasAttributes();\n    @Override\r\npublic int indexOf(final Content child);\n    public boolean isAncestor(final Element element);\n    public boolean isRootElement();\n    public boolean removeAttribute(final String attname);\n    public boolean removeAttribute(final String attname, final Namespace ns);\n    public boolean removeAttribute(final Attribute attribute);\n    public boolean removeChild(final String cname);\n    public boolean removeChild(final String cname, final Namespace ns);\n    public boolean removeChildren(final String cname);\n    public boolean removeChildren(final String cname, final Namespace ns);\n    @Override\r\npublic List<Content> removeContent();\n    @Override\r\npublic Content removeContent(final int index);\n    @Override\r\npublic boolean removeContent(final Content child);\n    @Override\r\npublic <F extends Content> List<F> removeContent(final Filter<F> filter);\n    public void removeNamespaceDeclaration(final Namespace additionalNamespace);\n    public Element setAttribute(final String name, final String value);\n    public Element setAttribute(final String name, final String value, final Namespace ns);\n    public Element setAttribute(final Attribute attribute);\n    public Element setAttributes(final Collection<? extends Attribute> newAttributes);\n    public Parent setContent(final int index, final Collection<? extends Content> newContent);\n    public Element setContent(final int index, final Content child);\n    public Element setContent(final Collection<? extends Content> newContent);\n    public Element setContent(final Content child);\n    public Element setName(final String name);\n    public Element setNamespace(Namespace namespace);\n    public Element setText(final String text);\n    public void sortAttributes(Comparator<? super Attribute> comparator);\n    public void sortChildren(Comparator<? super Element> comparator);\n    public void sortContent(Comparator<? super Content> comparator);\n    public <E extends Content> void sortContent(Filter<E> filter, Comparator<? super E> comparator);\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "Element_getNamespacesInScope",
        "package": "org.jdom2",
        "class": "org.jdom2.Element",
        "test-class": "org.jdom2.Element_getNamespacesInScope_Test",
        "method-name": "getNamespacesInScope()",
        "source-path": "src/main/java/org/jdom2/Element.java",
        "test-path": "src/test/java/org/jdom2/Element_getNamespacesInScope_Test.java",
        "focal-method": "@Override\r\npublic List<Namespace> getNamespacesInScope() {\r\n    // The assumption here is that all namespaces are valid,\r\n    // that there are no namespace collisions on this element\r\n    // This method is also the 'anchor' of the three getNamespaces*() methods\r\n    // It does not make reference to this Element instance's other\r\n    // getNamespace*() methods\r\n    TreeMap<String, Namespace> namespaces = new TreeMap<String, Namespace>();\r\n    namespaces.put(Namespace.XML_NAMESPACE.getPrefix(), Namespace.XML_NAMESPACE);\r\n    namespaces.put(getNamespacePrefix(), getNamespace());\r\n    if (additionalNamespaces != null) {\r\n        for (Namespace ns : getAdditionalNamespaces()) {\r\n            if (!namespaces.containsKey(ns.getPrefix())) {\r\n                namespaces.put(ns.getPrefix(), ns);\r\n            }\r\n        }\r\n    }\r\n    if (attributes != null) {\r\n        for (Attribute att : getAttributes()) {\r\n            Namespace ns = att.getNamespace();\r\n            if (!namespaces.containsKey(ns.getPrefix())) {\r\n                namespaces.put(ns.getPrefix(), ns);\r\n            }\r\n        }\r\n    }\r\n    // Right, we now have all the namespaces that are current on this ELement.\r\n    // Include any other namespaces that are inherited.\r\n    final Element pnt = getParentElement();\r\n    if (pnt != null) {\r\n        for (Namespace ns : pnt.getNamespacesInScope()) {\r\n            if (!namespaces.containsKey(ns.getPrefix())) {\r\n                namespaces.put(ns.getPrefix(), ns);\r\n            }\r\n        }\r\n    }\r\n    if ((pnt == null) && (!namespaces.containsKey(\"\"))) {\r\n        // we are the root element, and there is no 'default' namespace.\r\n        namespaces.put(Namespace.NO_NAMESPACE.getPrefix(), Namespace.NO_NAMESPACE);\r\n    }\r\n    ArrayList<Namespace> al = new ArrayList<Namespace>(namespaces.size());\r\n    al.add(getNamespace());\r\n    namespaces.remove(getNamespacePrefix());\r\n    al.addAll(namespaces.values());\r\n    return Collections.unmodifiableList(al);\r\n}",
        "class-code": "package org.jdom2;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.net.URISyntaxException;\nimport org.jdom2.ContentList.FilterList;\nimport java.net.URI;\nimport java.io.ObjectOutputStream;\nimport java.util.TreeMap;\nimport java.util.Comparator;\nimport org.jdom2.filter.Filter;\nimport org.jdom2.filter.ElementFilter;\nimport org.jdom2.util.IteratorIterable;\nimport static org.jdom2.JDOMConstants.NS_PREFIX_XML;\nimport java.io.ObjectInputStream;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport static org.jdom2.JDOMConstants.NS_PREFIX_DEFAULT;\nimport java.util.Collections;\npublic class Element extends Content implements Parent {\n    protected String name;\n    protected Namespace namespace;\n    transient List<Namespace> additionalNamespaces = null;\n    transient AttributeList attributes = null;\n    transient ContentList content = new ContentList(this);\n    @Override\r\n    public List<Namespace> getNamespacesInScope() {\r\n        // The assumption here is that all namespaces are valid,\r\n        // that there are no namespace collisions on this element\r\n        // This method is also the 'anchor' of the three getNamespaces*() methods\r\n        // It does not make reference to this Element instance's other\r\n        // getNamespace*() methods\r\n        TreeMap<String, Namespace> namespaces = new TreeMap<String, Namespace>();\r\n        namespaces.put(Namespace.XML_NAMESPACE.getPrefix(), Namespace.XML_NAMESPACE);\r\n        namespaces.put(getNamespacePrefix(), getNamespace());\r\n        if (additionalNamespaces != null) {\r\n            for (Namespace ns : getAdditionalNamespaces()) {\r\n                if (!namespaces.containsKey(ns.getPrefix())) {\r\n                    namespaces.put(ns.getPrefix(), ns);\r\n                }\r\n            }\r\n        }\r\n        if (attributes != null) {\r\n            for (Attribute att : getAttributes()) {\r\n                Namespace ns = att.getNamespace();\r\n                if (!namespaces.containsKey(ns.getPrefix())) {\r\n                    namespaces.put(ns.getPrefix(), ns);\r\n                }\r\n            }\r\n        }\r\n        // Right, we now have all the namespaces that are current on this ELement.\r\n        // Include any other namespaces that are inherited.\r\n        final Element pnt = getParentElement();\r\n        if (pnt != null) {\r\n            for (Namespace ns : pnt.getNamespacesInScope()) {\r\n                if (!namespaces.containsKey(ns.getPrefix())) {\r\n                    namespaces.put(ns.getPrefix(), ns);\r\n                }\r\n            }\r\n        }\r\n        if ((pnt == null) && (!namespaces.containsKey(\"\"))) {\r\n            // we are the root element, and there is no 'default' namespace.\r\n            namespaces.put(Namespace.NO_NAMESPACE.getPrefix(), Namespace.NO_NAMESPACE);\r\n        }\r\n        ArrayList<Namespace> al = new ArrayList<Namespace>(namespaces.size());\r\n        al.add(getNamespace());\r\n        namespaces.remove(getNamespacePrefix());\r\n        al.addAll(namespaces.values());\r\n        return Collections.unmodifiableList(al);\r\n    }\n@Override\r\npublic Element addContent(final int index, final Collection<? extends Content> newContent);\n    @Override\r\npublic Element addContent(final int index, final Content child);\n    public Element addContent(final String str);\n    @Override\r\npublic Element addContent(final Collection<? extends Content> newContent);\n    @Override\r\npublic Element addContent(final Content child);\n    public boolean addNamespaceDeclaration(final Namespace additionalNamespace);\n    @Override\r\npublic void canContainContent(Content child, int index, boolean replace) throws IllegalAddException;\n    @Override\r\npublic Element clone();\n    @Override\r\npublic List<Content> cloneContent();\n    public boolean coalesceText(boolean recursively);\n    @Override\r\npublic Element detach();\n    public List<Namespace> getAdditionalNamespaces();\n    public Attribute getAttribute(final String attname);\n    public Attribute getAttribute(final String attname, final Namespace ns);\n    AttributeList getAttributeList();\n    public String getAttributeValue(final String attname);\n    public String getAttributeValue(final String attname, final String def);\n    public String getAttributeValue(final String attname, final Namespace ns);\n    public String getAttributeValue(final String attname, final Namespace ns, final String def);\n    public List<Attribute> getAttributes();\n    public Element getChild(final String cname);\n    public Element getChild(final String cname, final Namespace ns);\n    public String getChildText(final String cname);\n    public String getChildText(final String cname, final Namespace ns);\n    public String getChildTextNormalize(final String cname);\n    public String getChildTextNormalize(final String cname, final Namespace ns);\n    public String getChildTextTrim(final String cname);\n    public String getChildTextTrim(final String cname, final Namespace ns);\n    public List<Element> getChildren();\n    public List<Element> getChildren(final String cname);\n    public List<Element> getChildren(final String cname, final Namespace ns);\n    @Override\r\npublic List<Content> getContent();\n    @Override\r\npublic Content getContent(final int index);\n    @Override\r\npublic <E extends Content> List<E> getContent(final Filter<E> filter);\n    @Override\r\npublic int getContentSize();\n    @Override\r\npublic IteratorIterable<Content> getDescendants();\n    @Override\r\npublic <F extends Content> IteratorIterable<F> getDescendants(final Filter<F> filter);\n    public String getName();\n    public Namespace getNamespace();\n    public Namespace getNamespace(final String prefix);\n    public String getNamespacePrefix();\n    public String getNamespaceURI();\n    @Override\r\npublic List<Namespace> getNamespacesInherited();\n    @Override\r\npublic List<Namespace> getNamespacesIntroduced();\n    public String getQualifiedName();\n    public String getText();\n    public String getTextNormalize();\n    public String getTextTrim();\n    @Override\r\npublic String getValue();\n    public URI getXMLBaseURI() throws URISyntaxException;\n    public boolean hasAdditionalNamespaces();\n    public boolean hasAttributes();\n    @Override\r\npublic int indexOf(final Content child);\n    public boolean isAncestor(final Element element);\n    public boolean isRootElement();\n    public boolean removeAttribute(final String attname);\n    public boolean removeAttribute(final String attname, final Namespace ns);\n    public boolean removeAttribute(final Attribute attribute);\n    public boolean removeChild(final String cname);\n    public boolean removeChild(final String cname, final Namespace ns);\n    public boolean removeChildren(final String cname);\n    public boolean removeChildren(final String cname, final Namespace ns);\n    @Override\r\npublic List<Content> removeContent();\n    @Override\r\npublic Content removeContent(final int index);\n    @Override\r\npublic boolean removeContent(final Content child);\n    @Override\r\npublic <F extends Content> List<F> removeContent(final Filter<F> filter);\n    public void removeNamespaceDeclaration(final Namespace additionalNamespace);\n    public Element setAttribute(final String name, final String value);\n    public Element setAttribute(final String name, final String value, final Namespace ns);\n    public Element setAttribute(final Attribute attribute);\n    public Element setAttributes(final Collection<? extends Attribute> newAttributes);\n    public Parent setContent(final int index, final Collection<? extends Content> newContent);\n    public Element setContent(final int index, final Content child);\n    public Element setContent(final Collection<? extends Content> newContent);\n    public Element setContent(final Content child);\n    public Element setName(final String name);\n    public Element setNamespace(Namespace namespace);\n    public Element setText(final String text);\n    public void sortAttributes(Comparator<? super Attribute> comparator);\n    public void sortChildren(Comparator<? super Element> comparator);\n    public void sortContent(Comparator<? super Content> comparator);\n    public <E extends Content> void sortContent(Filter<E> filter, Comparator<? super E> comparator);\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "AbstractXMLOutputProcessor_printContent",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractXMLOutputProcessor",
        "test-class": "org.jdom2.output.support.AbstractXMLOutputProcessor_printContent_Test",
        "method-name": "printContent(Writer, FormatStack, NamespaceStack, Walker)",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractXMLOutputProcessor.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractXMLOutputProcessor_printContent_Test.java",
        "focal-method": "protected void printContent(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws IOException {\r\n    while (walker.hasNext()) {\r\n        Content c = walker.next();\r\n        if (c == null) {\r\n            // it is a text value of some sort.\r\n            final String t = walker.text();\r\n            if (walker.isCDATA()) {\r\n                textCDATA(out, t);\r\n            } else {\r\n                textRaw(out, t);\r\n            }\r\n        } else {\r\n            switch (c.getCType()) {\r\n                case CDATA :\r\n                    printCDATA(out, fstack, ((CDATA) (c)));\r\n                    break;\r\n                case Comment :\r\n                    printComment(out, fstack, ((Comment) (c)));\r\n                    break;\r\n                case DocType :\r\n                    printDocType(out, fstack, ((DocType) (c)));\r\n                    break;\r\n                case Element :\r\n                    printElement(out, fstack, nstack, ((Element) (c)));\r\n                    break;\r\n                case EntityRef :\r\n                    printEntityRef(out, fstack, ((EntityRef) (c)));\r\n                    break;\r\n                case ProcessingInstruction :\r\n                    printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                    break;\r\n                case Text :\r\n                    printText(out, fstack, ((Text) (c)));\r\n                    break;\r\n            }\r\n        }\r\n    } \r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.IllegalDataException;\nimport org.jdom2.output.XMLOutputter;\nimport org.jdom2.Attribute;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport org.jdom2.Document;\nimport javax.xml.transform.Result;\nimport org.jdom2.Verifier;\nimport org.jdom2.util.NamespaceStack;\nimport org.jdom2.Content;\nimport org.jdom2.output.Format.TextMode;\nimport java.io.Writer;\nimport org.jdom2.ProcessingInstruction;\nimport java.util.List;\nimport org.jdom2.EntityRef;\nimport org.jdom2.output.Format;\nimport org.jdom2.CDATA;\nimport org.jdom2.Comment;\nimport java.util.Collections;\nimport org.jdom2.DocType;\npublic abstract class AbstractXMLOutputProcessor extends AbstractOutputProcessor implements XMLOutputProcessor {\n    protected static final String CDATAPRE = \"<![CDATA[\";\n    protected static final String CDATAPOST = \"]]>\";\n    protected void printContent(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Walker walker) throws IOException {\r\n        while (walker.hasNext()) {\r\n            Content c = walker.next();\r\n            if (c == null) {\r\n                // it is a text value of some sort.\r\n                final String t = walker.text();\r\n                if (walker.isCDATA()) {\r\n                    textCDATA(out, t);\r\n                } else {\r\n                    textRaw(out, t);\r\n                }\r\n            } else {\r\n                switch (c.getCType()) {\r\n                    case CDATA :\r\n                        printCDATA(out, fstack, ((CDATA) (c)));\r\n                        break;\r\n                    case Comment :\r\n                        printComment(out, fstack, ((Comment) (c)));\r\n                        break;\r\n                    case DocType :\r\n                        printDocType(out, fstack, ((DocType) (c)));\r\n                        break;\r\n                    case Element :\r\n                        printElement(out, fstack, nstack, ((Element) (c)));\r\n                        break;\r\n                    case EntityRef :\r\n                        printEntityRef(out, fstack, ((EntityRef) (c)));\r\n                        break;\r\n                    case ProcessingInstruction :\r\n                        printProcessingInstruction(out, fstack, ((ProcessingInstruction) (c)));\r\n                        break;\r\n                    case Text :\r\n                        printText(out, fstack, ((Text) (c)));\r\n                        break;\r\n                }\r\n            }\r\n        } \r\n    }\nprotected void attributeEscapedEntitiesFilter(final Writer out, final FormatStack fstack, final String value) throws IOException;\n    protected void printAttribute(final Writer out, final FormatStack fstack, final Attribute attribute) throws IOException;\n    protected void printCDATA(final Writer out, final FormatStack fstack, final CDATA cdata) throws IOException;\n    protected void printComment(final Writer out, final FormatStack fstack, final Comment comment) throws IOException;\n    protected void printDeclaration(final Writer out, final FormatStack fstack) throws IOException;\n    protected void printDocType(final Writer out, final FormatStack fstack, final DocType docType) throws IOException;\n    protected void printDocument(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Document doc) throws IOException;\n    protected void printElement(final Writer out, final FormatStack fstack, final NamespaceStack nstack, final Element element) throws IOException;\n    protected void printEntityRef(final Writer out, final FormatStack fstack, final EntityRef entity) throws IOException;\n    protected void printNamespace(final Writer out, final FormatStack fstack, final Namespace ns) throws IOException;\n    protected void printProcessingInstruction(final Writer out, final FormatStack fstack, final ProcessingInstruction pi) throws IOException;\n    protected void printText(final Writer out, final FormatStack fstack, final Text text) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final List<? extends Content> list) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final CDATA cdata) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Comment comment) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final DocType doctype) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Document doc) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Element element) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final EntityRef entity) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final ProcessingInstruction pi) throws IOException;\n    @Override\r\npublic void process(final Writer out, final Format format, final Text text) throws IOException;\n    protected void textCDATA(final Writer out, final String text) throws IOException;\n    protected void textEntityRef(final Writer out, final String name) throws IOException;\n    protected void textRaw(final Writer out, final char ch) throws IOException;\n    protected void textRaw(final Writer out, final String str) throws IOException;\n    protected void write(final Writer out, final char c) throws IOException;\n    protected void write(final Writer out, final String str) throws IOException;\n}"
      },
      {
        "id": "Format_escapeText",
        "package": "org.jdom2.output",
        "class": "org.jdom2.output.Format",
        "test-class": "org.jdom2.output.Format_escapeText_Test",
        "method-name": "escapeText(EscapeStrategy, String, String)",
        "source-path": "src/main/java/org/jdom2/output/Format.java",
        "test-path": "src/test/java/org/jdom2/output/Format_escapeText_Test.java",
        "focal-method": "public static final String escapeText(final EscapeStrategy strategy, final String eol, final String value) {\r\n    final int right = value.length();\r\n    int idx = 0;\r\n    checkloop : while (idx < right) {\r\n        final char ch = value.charAt(idx);\r\n        if ((((((ch == '<') || (ch == '>')) || (ch == '&')) || (ch == '\\r')) || (ch == '\\n')) || strategy.shouldEscape(ch)) {\r\n            break checkloop;\r\n        }\r\n        idx++;\r\n    } \r\n    if (idx == right) {\r\n        // no escape needed.\r\n        return value;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    if (idx > 0) {\r\n        sb.append(value, 0, idx);\r\n    }\r\n    char highsurrogate = 0;\r\n    while (idx < right) {\r\n        final char ch = value.charAt(idx++);\r\n        if (highsurrogate > 0) {\r\n            if (!Verifier.isLowSurrogate(ch)) {\r\n                throw new IllegalDataException(((\"Could not decode surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \" / 0x\") + Integer.toHexString(ch));\r\n            }\r\n            int chp = Verifier.decodeSurrogatePair(highsurrogate, ch);\r\n            sb.append((\"&#x\" + Integer.toHexString(chp)) + \";\");\r\n            highsurrogate = 0;\r\n            continue;\r\n        }\r\n        switch (ch) {\r\n            case '<' :\r\n                sb.append(\"&lt;\");\r\n                break;\r\n            case '>' :\r\n                sb.append(\"&gt;\");\r\n                break;\r\n            case '&' :\r\n                sb.append(\"&amp;\");\r\n                break;\r\n            case '\\r' :\r\n                sb.append(\"&#xD;\");\r\n                break;\r\n            case '\\n' :\r\n                if (eol != null) {\r\n                    sb.append(eol);\r\n                } else {\r\n                    sb.append('\\n');\r\n                }\r\n                break;\r\n            default :\r\n                if (strategy.shouldEscape(ch)) {\r\n                    // make sure what we are escaping is not the\r\n                    // beginning of a multi-byte character.\r\n                    if (Verifier.isHighSurrogate(ch)) {\r\n                        // this is a the high of a surrogate pair\r\n                        highsurrogate = ch;\r\n                    } else {\r\n                        sb.append((\"&#x\" + Integer.toHexString(ch)) + \";\");\r\n                    }\r\n                } else {\r\n                    sb.append(ch);\r\n                }\r\n                break;\r\n        }\r\n    } \r\n    if (highsurrogate > 0) {\r\n        throw new IllegalDataException((\"Surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \"truncated\");\r\n    }\r\n    return sb.toString();\r\n}",
        "class-code": "package org.jdom2.output;\nimport org.jdom2.IllegalDataException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport org.jdom2.Verifier;\npublic class Format implements Cloneable {\n    String indent = null;\n    String lineSeparator = STANDARD_LINE_SEPARATOR;\n    String encoding = STANDARD_ENCODING;\n    boolean omitDeclaration = false;\n    boolean omitEncoding = false;\n    boolean specifiedAttributesOnly = false;\n    boolean expandEmptyElements = false;\n    boolean ignoreTrAXEscapingPIs = false;\n    TextMode mode = TextMode.PRESERVE;\n    EscapeStrategy escapeStrategy = DefaultEscapeStrategy;\n    public static final String escapeText(final EscapeStrategy strategy, final String eol, final String value) {\r\n        final int right = value.length();\r\n        int idx = 0;\r\n        checkloop : while (idx < right) {\r\n            final char ch = value.charAt(idx);\r\n            if ((((((ch == '<') || (ch == '>')) || (ch == '&')) || (ch == '\\r')) || (ch == '\\n')) || strategy.shouldEscape(ch)) {\r\n                break checkloop;\r\n            }\r\n            idx++;\r\n        } \r\n        if (idx == right) {\r\n            // no escape needed.\r\n            return value;\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        if (idx > 0) {\r\n            sb.append(value, 0, idx);\r\n        }\r\n        char highsurrogate = 0;\r\n        while (idx < right) {\r\n            final char ch = value.charAt(idx++);\r\n            if (highsurrogate > 0) {\r\n                if (!Verifier.isLowSurrogate(ch)) {\r\n                    throw new IllegalDataException(((\"Could not decode surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \" / 0x\") + Integer.toHexString(ch));\r\n                }\r\n                int chp = Verifier.decodeSurrogatePair(highsurrogate, ch);\r\n                sb.append((\"&#x\" + Integer.toHexString(chp)) + \";\");\r\n                highsurrogate = 0;\r\n                continue;\r\n            }\r\n            switch (ch) {\r\n                case '<' :\r\n                    sb.append(\"&lt;\");\r\n                    break;\r\n                case '>' :\r\n                    sb.append(\"&gt;\");\r\n                    break;\r\n                case '&' :\r\n                    sb.append(\"&amp;\");\r\n                    break;\r\n                case '\\r' :\r\n                    sb.append(\"&#xD;\");\r\n                    break;\r\n                case '\\n' :\r\n                    if (eol != null) {\r\n                        sb.append(eol);\r\n                    } else {\r\n                        sb.append('\\n');\r\n                    }\r\n                    break;\r\n                default :\r\n                    if (strategy.shouldEscape(ch)) {\r\n                        // make sure what we are escaping is not the\r\n                        // beginning of a multi-byte character.\r\n                        if (Verifier.isHighSurrogate(ch)) {\r\n                            // this is a the high of a surrogate pair\r\n                            highsurrogate = ch;\r\n                        } else {\r\n                            sb.append((\"&#x\" + Integer.toHexString(ch)) + \";\");\r\n                        }\r\n                    } else {\r\n                        sb.append(ch);\r\n                    }\r\n                    break;\r\n            }\r\n        } \r\n        if (highsurrogate > 0) {\r\n            throw new IllegalDataException((\"Surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \"truncated\");\r\n        }\r\n        return sb.toString();\r\n    }\n@Override\r\npublic Format clone();\n    public static final String compact(String str);\n    public static final String escapeAttribute(final EscapeStrategy strategy, final String value);\n    public static Format getCompactFormat();\n    public String getEncoding();\n    public EscapeStrategy getEscapeStrategy();\n    public boolean getExpandEmptyElements();\n    public boolean getIgnoreTrAXEscapingPIs();\n    public String getIndent();\n    public String getLineSeparator();\n    public boolean getOmitDeclaration();\n    public boolean getOmitEncoding();\n    public static Format getPrettyFormat();\n    public static Format getRawFormat();\n    public Format.TextMode getTextMode();\n    public boolean isSpecifiedAttributesOnly();\n    public Format setEncoding(String encoding);\n    public Format setEscapeStrategy(EscapeStrategy strategy);\n    public Format setExpandEmptyElements(boolean expandEmptyElements);\n    public void setIgnoreTrAXEscapingPIs(boolean ignoreTrAXEscapingPIs);\n    public Format setIndent(String indent);\n    public Format setLineSeparator(String separator);\n    public Format setLineSeparator(LineSeparator separator);\n    public Format setOmitDeclaration(boolean omitDeclaration);\n    public Format setOmitEncoding(boolean omitEncoding);\n    public void setSpecifiedAttributesOnly(boolean specifiedAttributesOnly);\n    public Format setTextMode(Format.TextMode mode);\n    public static final String trimBoth(final String str);\n    public static final String trimLeft(final String str);\n    public static final String trimRight(String str);\n}"
      },
      {
        "id": "Verifier_isXMLPublicIDCharacter",
        "package": "org.jdom2",
        "class": "org.jdom2.Verifier",
        "test-class": "org.jdom2.Verifier_isXMLPublicIDCharacter_Test",
        "method-name": "isXMLPublicIDCharacter(char)",
        "source-path": "src/main/java/org/jdom2/Verifier.java",
        "test-path": "src/test/java/org/jdom2/Verifier_isXMLPublicIDCharacter_Test.java",
        "focal-method": "public static boolean isXMLPublicIDCharacter(final char c) {\r\n    // [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] |\r\n    // [-'()+,./:=?;*#@$_%]\r\n    if ((c >= 'a') && (c <= 'z'))\r\n        return true;\r\n\r\n    if ((c >= '?') && (c <= 'Z'))\r\n        return true;\r\n\r\n    if ((c >= '\\'') && (c <= ';'))\r\n        return true;\r\n\r\n    if (c == ' ')\r\n        return true;\r\n\r\n    if (c == '!')\r\n        return true;\r\n\r\n    if (c == '=')\r\n        return true;\r\n\r\n    if (c == '#')\r\n        return true;\r\n\r\n    if (c == '$')\r\n        return true;\r\n\r\n    if (c == '_')\r\n        return true;\r\n\r\n    if (c == '%')\r\n        return true;\r\n\r\n    if (c == '\\n')\r\n        return true;\r\n\r\n    if (c == '\\r')\r\n        return true;\r\n\r\n    if (c == '\\t')\r\n        return true;\r\n\r\n    return false;\r\n}",
        "class-code": "package org.jdom2;\nimport java.util.*;\npublic final class Verifier {\n    \n    public static boolean isXMLPublicIDCharacter(final char c) {\r\n        // [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] |\r\n        // [-'()+,./:=?;*#@$_%]\r\n        if ((c >= 'a') && (c <= 'z'))\r\n            return true;\r\n    \r\n        if ((c >= '?') && (c <= 'Z'))\r\n            return true;\r\n    \r\n        if ((c >= '\\'') && (c <= ';'))\r\n            return true;\r\n    \r\n        if (c == ' ')\r\n            return true;\r\n    \r\n        if (c == '!')\r\n            return true;\r\n    \r\n        if (c == '=')\r\n            return true;\r\n    \r\n        if (c == '#')\r\n            return true;\r\n    \r\n        if (c == '$')\r\n            return true;\r\n    \r\n        if (c == '_')\r\n            return true;\r\n    \r\n        if (c == '%')\r\n            return true;\r\n    \r\n        if (c == '\\n')\r\n            return true;\r\n    \r\n        if (c == '\\r')\r\n            return true;\r\n    \r\n        if (c == '\\t')\r\n            return true;\r\n    \r\n        return false;\r\n    }\npublic static String checkAttributeName(final String name);\n    public static String checkCDATASection(final String data);\n    public static String checkCharacterData(final String text);\n    public static String checkCommentData(final String data);\n    public static String checkElementName(final String name);\n    public static String checkNamespaceCollision(final Attribute attribute, final Element element);\n    public static String checkNamespaceCollision(final Attribute attribute, final Element element, final int ignoreatt);\n    public static String checkNamespaceCollision(final Namespace namespace, final List<?> list);\n    public static String checkNamespaceCollision(final Namespace namespace, final List<?> list, final int ignoreatt);\n    public static String checkNamespaceCollision(final Namespace namespace, final Attribute attribute);\n    public static String checkNamespaceCollision(final Namespace namespace, final Element element);\n    public static String checkNamespaceCollision(final Namespace namespace, final Element element, final int ignoreatt);\n    public static String checkNamespaceCollision(final Namespace namespace, final Namespace other);\n    public static String checkNamespacePrefix(final String prefix);\n    public static String checkNamespaceURI(final String uri);\n    public static String checkProcessingInstructionData(final String data);\n    public static String checkProcessingInstructionTarget(final String target);\n    public static String checkPublicID(final String publicID);\n    public static String checkSystemLiteral(final String systemLiteral);\n    public static String checkURI(final String uri);\n    public static String checkXMLName(final String name);\n    public static int decodeSurrogatePair(final char high, final char low);\n    public static final boolean isAllXMLWhitespace(final String value);\n    public static boolean isHexDigit(final char c);\n    public static boolean isHighSurrogate(final char ch);\n    public static boolean isLowSurrogate(final char ch);\n    public static boolean isURICharacter(final char c);\n    public static boolean isXMLCharacter(final int c);\n    public static boolean isXMLCombiningChar(final char c);\n    public static boolean isXMLDigit(final char c);\n    public static boolean isXMLExtender(final char c);\n    public static boolean isXMLLetter(final char c);\n    public static boolean isXMLLetterOrDigit(final char c);\n    public static boolean isXMLNameCharacter(final char c);\n    public static boolean isXMLNameStartCharacter(final char c);\n    public static boolean isXMLWhitespace(final char c);\n}"
      },
      {
        "id": "AbstractStAXEventProcessor_printContent",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractStAXEventProcessor",
        "test-class": "org.jdom2.output.support.AbstractStAXEventProcessor_printContent_Test",
        "method-name": "printContent(XMLEventConsumer, FormatStack, NamespaceStack, XMLEventFactory, Walker)",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractStAXEventProcessor.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractStAXEventProcessor_printContent_Test.java",
        "focal-method": "protected void printContent(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Walker walker) throws XMLStreamException {\r\n    while (walker.hasNext()) {\r\n        final Content content = walker.next();\r\n        if (content == null) {\r\n            if (walker.isCDATA()) {\r\n                printCDATA(out, fstack, eventfactory, new CDATA(walker.text()));\r\n            } else {\r\n                printText(out, fstack, eventfactory, new Text(walker.text()));\r\n            }\r\n        } else {\r\n            switch (content.getCType()) {\r\n                case CDATA :\r\n                    printCDATA(out, fstack, eventfactory, ((CDATA) (content)));\r\n                    break;\r\n                case Comment :\r\n                    printComment(out, fstack, eventfactory, ((Comment) (content)));\r\n                    break;\r\n                case Element :\r\n                    printElement(out, fstack, nstack, eventfactory, ((Element) (content)));\r\n                    break;\r\n                case EntityRef :\r\n                    printEntityRef(out, fstack, eventfactory, ((EntityRef) (content)));\r\n                    break;\r\n                case ProcessingInstruction :\r\n                    printProcessingInstruction(out, fstack, eventfactory, ((ProcessingInstruction) (content)));\r\n                    break;\r\n                case Text :\r\n                    printText(out, fstack, eventfactory, ((Text) (content)));\r\n                    break;\r\n                case DocType :\r\n                    printDocType(out, fstack, eventfactory, ((DocType) (content)));\r\n                    break;\r\n                default :\r\n                    throw new IllegalStateException(\"Unexpected Content \" + content.getCType());\r\n            }\r\n        }\r\n    } \r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.Attribute;\nimport javax.xml.stream.util.XMLEventConsumer;\nimport org.jdom2.Content.CType;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport javax.xml.stream.XMLEventFactory;\nimport org.jdom2.Document;\nimport org.jdom2.Verifier;\nimport org.jdom2.util.NamespaceStack;\nimport java.io.StringWriter;\nimport org.jdom2.output.Format.TextMode;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jdom2.EntityRef;\nimport org.jdom2.output.Format;\nimport org.jdom2.Comment;\nimport java.util.Collections;\nimport org.jdom2.DocType;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport javax.xml.stream.XMLStreamException;\nimport org.jdom2.Content;\nimport org.jdom2.output.StAXEventOutputter;\nimport org.jdom2.ProcessingInstruction;\nimport org.jdom2.CDATA;\npublic abstract class AbstractStAXEventProcessor extends AbstractOutputProcessor implements StAXEventProcessor {\n    \n    protected void printContent(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Walker walker) throws XMLStreamException {\r\n        while (walker.hasNext()) {\r\n            final Content content = walker.next();\r\n            if (content == null) {\r\n                if (walker.isCDATA()) {\r\n                    printCDATA(out, fstack, eventfactory, new CDATA(walker.text()));\r\n                } else {\r\n                    printText(out, fstack, eventfactory, new Text(walker.text()));\r\n                }\r\n            } else {\r\n                switch (content.getCType()) {\r\n                    case CDATA :\r\n                        printCDATA(out, fstack, eventfactory, ((CDATA) (content)));\r\n                        break;\r\n                    case Comment :\r\n                        printComment(out, fstack, eventfactory, ((Comment) (content)));\r\n                        break;\r\n                    case Element :\r\n                        printElement(out, fstack, nstack, eventfactory, ((Element) (content)));\r\n                        break;\r\n                    case EntityRef :\r\n                        printEntityRef(out, fstack, eventfactory, ((EntityRef) (content)));\r\n                        break;\r\n                    case ProcessingInstruction :\r\n                        printProcessingInstruction(out, fstack, eventfactory, ((ProcessingInstruction) (content)));\r\n                        break;\r\n                    case Text :\r\n                        printText(out, fstack, eventfactory, ((Text) (content)));\r\n                        break;\r\n                    case DocType :\r\n                        printDocType(out, fstack, eventfactory, ((DocType) (content)));\r\n                        break;\r\n                    default :\r\n                        throw new IllegalStateException(\"Unexpected Content \" + content.getCType());\r\n                }\r\n            }\r\n        } \r\n    }\nprotected void printCDATA(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final CDATA cdata) throws XMLStreamException;\n    protected void printComment(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final Comment comment) throws XMLStreamException;\n    protected void printDocType(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final DocType docType) throws XMLStreamException;\n    protected void printDocument(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Document doc) throws XMLStreamException;\n    protected void printElement(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Element element) throws XMLStreamException;\n    protected void printEntityRef(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final EntityRef entity) throws XMLStreamException;\n    protected void printProcessingInstruction(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final ProcessingInstruction pi) throws XMLStreamException;\n    protected void printText(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final Text text) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final List<? extends Content> list) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final CDATA cdata) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Comment comment) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final DocType doctype) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Document doc) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Element element) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final EntityRef entity) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final ProcessingInstruction pi) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Text text) throws XMLStreamException;\n}"
      },
      {
        "id": "Verifier_isXMLExtender",
        "package": "org.jdom2",
        "class": "org.jdom2.Verifier",
        "test-class": "org.jdom2.Verifier_isXMLExtender_Test",
        "method-name": "isXMLExtender(char)",
        "source-path": "src/main/java/org/jdom2/Verifier.java",
        "test-path": "src/test/java/org/jdom2/Verifier_isXMLExtender_Test.java",
        "focal-method": "public static boolean isXMLExtender(final char c) {\r\n    /* This function is not accellerated by the bitmask system because\r\n    there are no longer any actual calls to it from the JDOM code.\r\n    It used to be called by the isXMLNameCharacter() method before\r\n    the bitmask optimization. Now the VerifierBuilder code actually\r\n    calls this method instead.\r\n     */\r\n    if (c < 0xb6)\r\n        return false;\r\n    // quick short circuit\r\n\r\n    // Extenders\r\n    if (c == 0xb7)\r\n        return true;\r\n\r\n    if (c == 0x2d0)\r\n        return true;\r\n\r\n    if (c == 0x2d1)\r\n        return true;\r\n\r\n    if (c == 0x387)\r\n        return true;\r\n\r\n    if (c == 0x640)\r\n        return true;\r\n\r\n    if (c == 0xe46)\r\n        return true;\r\n\r\n    if (c == 0xec6)\r\n        return true;\r\n\r\n    if (c == 0x3005)\r\n        return true;\r\n\r\n    if (c < 0x3031)\r\n        return false;\r\n\r\n    if (c <= 0x3035)\r\n        return true;\r\n\r\n    if (c < 0x309d)\r\n        return false;\r\n\r\n    if (c <= 0x309e)\r\n        return true;\r\n\r\n    if (c < 0x30fc)\r\n        return false;\r\n\r\n    if (c <= 0x30fe)\r\n        return true;\r\n\r\n    return false;\r\n}",
        "class-code": "package org.jdom2;\nimport java.util.*;\npublic final class Verifier {\n    \n    public static boolean isXMLExtender(final char c) {\r\n        /* This function is not accellerated by the bitmask system because\r\n        there are no longer any actual calls to it from the JDOM code.\r\n        It used to be called by the isXMLNameCharacter() method before\r\n        the bitmask optimization. Now the VerifierBuilder code actually\r\n        calls this method instead.\r\n         */\r\n        if (c < 0xb6)\r\n            return false;\r\n        // quick short circuit\r\n    \r\n        // Extenders\r\n        if (c == 0xb7)\r\n            return true;\r\n    \r\n        if (c == 0x2d0)\r\n            return true;\r\n    \r\n        if (c == 0x2d1)\r\n            return true;\r\n    \r\n        if (c == 0x387)\r\n            return true;\r\n    \r\n        if (c == 0x640)\r\n            return true;\r\n    \r\n        if (c == 0xe46)\r\n            return true;\r\n    \r\n        if (c == 0xec6)\r\n            return true;\r\n    \r\n        if (c == 0x3005)\r\n            return true;\r\n    \r\n        if (c < 0x3031)\r\n            return false;\r\n    \r\n        if (c <= 0x3035)\r\n            return true;\r\n    \r\n        if (c < 0x309d)\r\n            return false;\r\n    \r\n        if (c <= 0x309e)\r\n            return true;\r\n    \r\n        if (c < 0x30fc)\r\n            return false;\r\n    \r\n        if (c <= 0x30fe)\r\n            return true;\r\n    \r\n        return false;\r\n    }\npublic static String checkAttributeName(final String name);\n    public static String checkCDATASection(final String data);\n    public static String checkCharacterData(final String text);\n    public static String checkCommentData(final String data);\n    public static String checkElementName(final String name);\n    public static String checkNamespaceCollision(final Attribute attribute, final Element element);\n    public static String checkNamespaceCollision(final Attribute attribute, final Element element, final int ignoreatt);\n    public static String checkNamespaceCollision(final Namespace namespace, final List<?> list);\n    public static String checkNamespaceCollision(final Namespace namespace, final List<?> list, final int ignoreatt);\n    public static String checkNamespaceCollision(final Namespace namespace, final Attribute attribute);\n    public static String checkNamespaceCollision(final Namespace namespace, final Element element);\n    public static String checkNamespaceCollision(final Namespace namespace, final Element element, final int ignoreatt);\n    public static String checkNamespaceCollision(final Namespace namespace, final Namespace other);\n    public static String checkNamespacePrefix(final String prefix);\n    public static String checkNamespaceURI(final String uri);\n    public static String checkProcessingInstructionData(final String data);\n    public static String checkProcessingInstructionTarget(final String target);\n    public static String checkPublicID(final String publicID);\n    public static String checkSystemLiteral(final String systemLiteral);\n    public static String checkURI(final String uri);\n    public static String checkXMLName(final String name);\n    public static int decodeSurrogatePair(final char high, final char low);\n    public static final boolean isAllXMLWhitespace(final String value);\n    public static boolean isHexDigit(final char c);\n    public static boolean isHighSurrogate(final char ch);\n    public static boolean isLowSurrogate(final char ch);\n    public static boolean isURICharacter(final char c);\n    public static boolean isXMLCharacter(final int c);\n    public static boolean isXMLCombiningChar(final char c);\n    public static boolean isXMLDigit(final char c);\n    public static boolean isXMLLetter(final char c);\n    public static boolean isXMLLetterOrDigit(final char c);\n    public static boolean isXMLNameCharacter(final char c);\n    public static boolean isXMLNameStartCharacter(final char c);\n    public static boolean isXMLPublicIDCharacter(final char c);\n    public static boolean isXMLWhitespace(final char c);\n}"
      },
      {
        "id": "AbstractStAXEventProcessor_printDocument",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.AbstractStAXEventProcessor",
        "test-class": "org.jdom2.output.support.AbstractStAXEventProcessor_printDocument_Test",
        "method-name": "printDocument(XMLEventConsumer, FormatStack, NamespaceStack, XMLEventFactory, Document)",
        "source-path": "src/main/java/org/jdom2/output/support/AbstractStAXEventProcessor.java",
        "test-path": "src/test/java/org/jdom2/output/support/AbstractStAXEventProcessor_printDocument_Test.java",
        "focal-method": "protected void printDocument(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Document doc) throws XMLStreamException {\r\n    if (fstack.isOmitDeclaration()) {\r\n        // this actually writes the declaration as version 1, UTF-8\r\n        out.add(eventfactory.createStartDocument(null, null));\r\n    } else if (fstack.isOmitEncoding()) {\r\n        out.add(eventfactory.createStartDocument(null, \"1.0\"));\r\n        if (fstack.getLineSeparator() != null) {\r\n            out.add(eventfactory.createCharacters(fstack.getLineSeparator()));\r\n        }\r\n    } else {\r\n        out.add(eventfactory.createStartDocument(fstack.getEncoding(), \"1.0\"));\r\n        if (fstack.getLineSeparator() != null) {\r\n            out.add(eventfactory.createCharacters(fstack.getLineSeparator()));\r\n        }\r\n    }\r\n    // If there is no root element then we cannot use the normal ways to\r\n    // access the ContentList because Document throws an exception.\r\n    // so we hack it and just access it by index.\r\n    List<Content> list = (doc.hasRootElement()) ? doc.getContent() : new ArrayList<Content>(doc.getContentSize());\r\n    if (list.isEmpty()) {\r\n        final int sz = doc.getContentSize();\r\n        for (int i = 0; i < sz; i++) {\r\n            list.add(doc.getContent(i));\r\n        }\r\n    }\r\n    Walker walker = buildWalker(fstack, list, false);\r\n    if (walker.hasNext()) {\r\n        while (walker.hasNext()) {\r\n            final Content c = walker.next();\r\n            // we do not ignore Text-like things in the Document.\r\n            // the walker creates the indenting for us.\r\n            if (c == null) {\r\n                // but, what we do is ensure it is all whitespace, and not CDATA\r\n                final String padding = walker.text();\r\n                if (((padding != null) && Verifier.isAllXMLWhitespace(padding)) && (!walker.isCDATA())) {\r\n                    // we do not use the escaping or text* method because this\r\n                    // content is outside of the root element, and thus is not\r\n                    // strict text.\r\n                    out.add(eventfactory.createCharacters(padding));\r\n                }\r\n            } else {\r\n                switch (c.getCType()) {\r\n                    case Comment :\r\n                        printComment(out, fstack, eventfactory, ((Comment) (c)));\r\n                        break;\r\n                    case DocType :\r\n                        printDocType(out, fstack, eventfactory, ((DocType) (c)));\r\n                        break;\r\n                    case Element :\r\n                        printElement(out, fstack, nstack, eventfactory, ((Element) (c)));\r\n                        break;\r\n                    case ProcessingInstruction :\r\n                        printProcessingInstruction(out, fstack, eventfactory, ((ProcessingInstruction) (c)));\r\n                        break;\r\n                    default :\r\n                        // do nothing.\r\n                }\r\n            }\r\n        } \r\n        if (fstack.getLineSeparator() != null) {\r\n            out.add(eventfactory.createCharacters(fstack.getLineSeparator()));\r\n        }\r\n    }\r\n    out.add(eventfactory.createEndDocument());\r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.Attribute;\nimport javax.xml.stream.util.XMLEventConsumer;\nimport org.jdom2.Content.CType;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport javax.xml.stream.XMLEventFactory;\nimport org.jdom2.Document;\nimport org.jdom2.Verifier;\nimport org.jdom2.util.NamespaceStack;\nimport java.io.StringWriter;\nimport org.jdom2.output.Format.TextMode;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jdom2.EntityRef;\nimport org.jdom2.output.Format;\nimport org.jdom2.Comment;\nimport java.util.Collections;\nimport org.jdom2.DocType;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport javax.xml.stream.XMLStreamException;\nimport org.jdom2.Content;\nimport org.jdom2.output.StAXEventOutputter;\nimport org.jdom2.ProcessingInstruction;\nimport org.jdom2.CDATA;\npublic abstract class AbstractStAXEventProcessor extends AbstractOutputProcessor implements StAXEventProcessor {\n    \n    protected void printDocument(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Document doc) throws XMLStreamException {\r\n        if (fstack.isOmitDeclaration()) {\r\n            // this actually writes the declaration as version 1, UTF-8\r\n            out.add(eventfactory.createStartDocument(null, null));\r\n        } else if (fstack.isOmitEncoding()) {\r\n            out.add(eventfactory.createStartDocument(null, \"1.0\"));\r\n            if (fstack.getLineSeparator() != null) {\r\n                out.add(eventfactory.createCharacters(fstack.getLineSeparator()));\r\n            }\r\n        } else {\r\n            out.add(eventfactory.createStartDocument(fstack.getEncoding(), \"1.0\"));\r\n            if (fstack.getLineSeparator() != null) {\r\n                out.add(eventfactory.createCharacters(fstack.getLineSeparator()));\r\n            }\r\n        }\r\n        // If there is no root element then we cannot use the normal ways to\r\n        // access the ContentList because Document throws an exception.\r\n        // so we hack it and just access it by index.\r\n        List<Content> list = (doc.hasRootElement()) ? doc.getContent() : new ArrayList<Content>(doc.getContentSize());\r\n        if (list.isEmpty()) {\r\n            final int sz = doc.getContentSize();\r\n            for (int i = 0; i < sz; i++) {\r\n                list.add(doc.getContent(i));\r\n            }\r\n        }\r\n        Walker walker = buildWalker(fstack, list, false);\r\n        if (walker.hasNext()) {\r\n            while (walker.hasNext()) {\r\n                final Content c = walker.next();\r\n                // we do not ignore Text-like things in the Document.\r\n                // the walker creates the indenting for us.\r\n                if (c == null) {\r\n                    // but, what we do is ensure it is all whitespace, and not CDATA\r\n                    final String padding = walker.text();\r\n                    if (((padding != null) && Verifier.isAllXMLWhitespace(padding)) && (!walker.isCDATA())) {\r\n                        // we do not use the escaping or text* method because this\r\n                        // content is outside of the root element, and thus is not\r\n                        // strict text.\r\n                        out.add(eventfactory.createCharacters(padding));\r\n                    }\r\n                } else {\r\n                    switch (c.getCType()) {\r\n                        case Comment :\r\n                            printComment(out, fstack, eventfactory, ((Comment) (c)));\r\n                            break;\r\n                        case DocType :\r\n                            printDocType(out, fstack, eventfactory, ((DocType) (c)));\r\n                            break;\r\n                        case Element :\r\n                            printElement(out, fstack, nstack, eventfactory, ((Element) (c)));\r\n                            break;\r\n                        case ProcessingInstruction :\r\n                            printProcessingInstruction(out, fstack, eventfactory, ((ProcessingInstruction) (c)));\r\n                            break;\r\n                        default :\r\n                            // do nothing.\r\n                    }\r\n                }\r\n            } \r\n            if (fstack.getLineSeparator() != null) {\r\n                out.add(eventfactory.createCharacters(fstack.getLineSeparator()));\r\n            }\r\n        }\r\n        out.add(eventfactory.createEndDocument());\r\n    }\nprotected void printCDATA(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final CDATA cdata) throws XMLStreamException;\n    protected void printComment(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final Comment comment) throws XMLStreamException;\n    protected void printContent(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Walker walker) throws XMLStreamException;\n    protected void printDocType(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final DocType docType) throws XMLStreamException;\n    protected void printElement(final XMLEventConsumer out, final FormatStack fstack, final NamespaceStack nstack, final XMLEventFactory eventfactory, final Element element) throws XMLStreamException;\n    protected void printEntityRef(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final EntityRef entity) throws XMLStreamException;\n    protected void printProcessingInstruction(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final ProcessingInstruction pi) throws XMLStreamException;\n    protected void printText(final XMLEventConsumer out, final FormatStack fstack, final XMLEventFactory eventfactory, final Text text) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final List<? extends Content> list) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final CDATA cdata) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Comment comment) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final DocType doctype) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Document doc) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Element element) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final EntityRef entity) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final ProcessingInstruction pi) throws XMLStreamException;\n    @Override\r\npublic void process(final XMLEventConsumer out, final Format format, final XMLEventFactory eventfactory, final Text text) throws XMLStreamException;\n}"
      },
      {
        "id": "WalkerTRIM_analyzeMultiText",
        "package": "org.jdom2.output.support",
        "class": "org.jdom2.output.support.WalkerTRIM",
        "test-class": "org.jdom2.output.support.WalkerTRIM_analyzeMultiText_Test",
        "method-name": "analyzeMultiText(MultiText, int, int)",
        "source-path": "src/main/java/org/jdom2/output/support/WalkerTRIM.java",
        "test-path": "src/test/java/org/jdom2/output/support/WalkerTRIM_analyzeMultiText_Test.java",
        "focal-method": "@Override\r\nprotected void analyzeMultiText(final MultiText mtext, int offset, int len) {\r\n    while (len > 0) {\r\n        final Content c = get(offset);\r\n        if (c instanceof Text) {\r\n            // either Text or CDATA\r\n            if (!Verifier.isAllXMLWhitespace(c.getValue())) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        offset++;\r\n        len--;\r\n    } \r\n    while (len > 0) {\r\n        final Content c = get((offset + len) - 1);\r\n        if (c instanceof Text) {\r\n            // either Text or CDATA\r\n            if (!Verifier.isAllXMLWhitespace(c.getValue())) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        len--;\r\n    } \r\n    for (int i = 0; i < len; i++) {\r\n        Trim trim = Trim.NONE;\r\n        if ((i + 1) == len) {\r\n            trim = Trim.RIGHT;\r\n        }\r\n        if (i == 0) {\r\n            trim = Trim.LEFT;\r\n        }\r\n        if (len == 1) {\r\n            trim = Trim.BOTH;\r\n        }\r\n        final Content c = get(offset + i);\r\n        switch (c.getCType()) {\r\n            case Text :\r\n                mtext.appendText(trim, c.getValue());\r\n                break;\r\n            case CDATA :\r\n                mtext.appendCDATA(trim, c.getValue());\r\n                break;\r\n            case EntityRef :\r\n                // treat like any other content.\r\n                // raw.\r\n            default :\r\n                mtext.appendRaw(c);\r\n                break;\r\n        }\r\n    }\r\n}",
        "class-code": "package org.jdom2.output.support;\nimport org.jdom2.Content;\nimport org.jdom2.Text;\nimport java.util.List;\nimport org.jdom2.Verifier;\npublic class WalkerTRIM extends AbstractFormattedWalker {\n    \n    @Override\r\n    protected void analyzeMultiText(final MultiText mtext, int offset, int len) {\r\n        while (len > 0) {\r\n            final Content c = get(offset);\r\n            if (c instanceof Text) {\r\n                // either Text or CDATA\r\n                if (!Verifier.isAllXMLWhitespace(c.getValue())) {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n            offset++;\r\n            len--;\r\n        } \r\n        while (len > 0) {\r\n            final Content c = get((offset + len) - 1);\r\n            if (c instanceof Text) {\r\n                // either Text or CDATA\r\n                if (!Verifier.isAllXMLWhitespace(c.getValue())) {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n            len--;\r\n        } \r\n        for (int i = 0; i < len; i++) {\r\n            Trim trim = Trim.NONE;\r\n            if ((i + 1) == len) {\r\n                trim = Trim.RIGHT;\r\n            }\r\n            if (i == 0) {\r\n                trim = Trim.LEFT;\r\n            }\r\n            if (len == 1) {\r\n                trim = Trim.BOTH;\r\n            }\r\n            final Content c = get(offset + i);\r\n            switch (c.getCType()) {\r\n                case Text :\r\n                    mtext.appendText(trim, c.getValue());\r\n                    break;\r\n                case CDATA :\r\n                    mtext.appendCDATA(trim, c.getValue());\r\n                    break;\r\n                case EntityRef :\r\n                    // treat like any other content.\r\n                    // raw.\r\n                default :\r\n                    mtext.appendRaw(c);\r\n                    break;\r\n            }\r\n        }\r\n    }\n;\n}"
      },
      {
        "id": "SAXHandler_startElement",
        "package": "org.jdom2.input.sax",
        "class": "org.jdom2.input.sax.SAXHandler",
        "test-class": "org.jdom2.input.sax.SAXHandler_startElement_Test",
        "method-name": "startElement(String, String, String, Attributes)",
        "source-path": "src/main/java/org/jdom2/input/sax/SAXHandler.java",
        "test-path": "src/test/java/org/jdom2/input/sax/SAXHandler_startElement_Test.java",
        "focal-method": "@Override\r\npublic void startElement(final String namespaceURI, String localName, final String qName, final Attributes atts) throws SAXException {\r\n    if (suppress)\r\n        return;\r\n\r\n    String prefix = \"\";\r\n    // If QName is set, then set prefix and local name as necessary\r\n    if (!\"\".equals(qName)) {\r\n        final int colon = qName.indexOf(':');\r\n        if (colon > 0) {\r\n            prefix = qName.substring(0, colon);\r\n        }\r\n        // If local name is not set, try to get it from the QName\r\n        if ((localName == null) || localName.equals(\"\")) {\r\n            localName = qName.substring(colon + 1);\r\n        }\r\n    }\r\n    // At this point either prefix and localName are set correctly or\r\n    // there is an error in the parser.\r\n    final Namespace namespace = Namespace.getNamespace(prefix, namespaceURI);\r\n    final Element element = (currentLocator == null) ? factory.element(localName, namespace) : factory.element(currentLocator.getLineNumber(), currentLocator.getColumnNumber(), localName, namespace);\r\n    // Take leftover declared namespaces and add them to this element's\r\n    // map of namespaces\r\n    if (declaredNamespaces.size() > 0) {\r\n        transferNamespaces(element);\r\n    }\r\n    flushCharacters();\r\n    if (atRoot) {\r\n        factory.setRoot(currentDocument, element);// Yes, use a factory\r\n\r\n        // call...\r\n        atRoot = false;\r\n    } else {\r\n        factory.addContent(getCurrentElement(), element);\r\n    }\r\n    currentElement = element;\r\n    // Handle attributes\r\n    for (int i = 0, len = atts.getLength(); i < len; i++) {\r\n        String attPrefix = \"\";\r\n        String attLocalName = atts.getLocalName(i);\r\n        final String attQName = atts.getQName(i);\r\n        final boolean specified = (atts instanceof Attributes2) ? ((Attributes2) (atts)).isSpecified(i) : true;\r\n        // If attribute QName is set, then set attribute prefix and\r\n        // attribute local name as necessary\r\n        if (!attQName.equals(\"\")) {\r\n            // Bypass any xmlns attributes which might appear, as we got\r\n            // them already in startPrefixMapping(). This is sometimes\r\n            // necessary when SAXHandler is used with another source than\r\n            // SAXBuilder, as with JDOMResult.\r\n            if (attQName.startsWith(\"xmlns:\") || attQName.equals(\"xmlns\")) {\r\n                continue;\r\n            }\r\n            final int attColon = attQName.indexOf(':');\r\n            if (attColon > 0) {\r\n                attPrefix = attQName.substring(0, attColon);\r\n            }\r\n            // If localName is not set, try to get it from the QName\r\n            if (\"\".equals(attLocalName)) {\r\n                attLocalName = attQName.substring(attColon + 1);\r\n            }\r\n        }\r\n        final AttributeType attType = AttributeType.getAttributeType(atts.getType(i));\r\n        final String attValue = atts.getValue(i);\r\n        final String attURI = atts.getURI(i);\r\n        if ((XMLConstants.XMLNS_ATTRIBUTE.equals(attLocalName) || XMLConstants.XMLNS_ATTRIBUTE.equals(attPrefix)) || XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(attURI)) {\r\n            // use the actual Namespace to check too, because, in theory, a\r\n            // namespace-aware parser does not need to set the qName unless\r\n            // the namespace-prefixes feature is set as well.\r\n            continue;\r\n        }\r\n        // At this point either attPrefix and attLocalName are set\r\n        // correctly or there is an error in the parser.\r\n        // just one thing to sort out....\r\n        // the prefix for the namespace.\r\n        if ((!\"\".equals(attURI)) && \"\".equals(attPrefix)) {\r\n            // the localname and qName are the same, but there is a\r\n            // Namspace URI. We need to figure out the namespace prefix.\r\n            // this is an unusual condition. Currently the only known\r\n            // trigger\r\n            // is when there is a fixed/defaulted attribute from a\r\n            // validating\r\n            // XMLSchema, and the attribute is in a different namespace\r\n            // than the rest of the document, this happens whenever there\r\n            // is an attribute definition that has form=\"qualified\".\r\n            // <xs:attribute name=\"attname\" form=\"qualified\" ... />\r\n            // or the schema sets attributeFormDefault=\"qualified\"\r\n            final HashMap<String, Namespace> tmpmap = new HashMap<String, Namespace>();\r\n            for (final Namespace nss : element.getNamespacesInScope()) {\r\n                if ((nss.getPrefix().length() > 0) && nss.getURI().equals(attURI)) {\r\n                    attPrefix = nss.getPrefix();\r\n                    break;\r\n                }\r\n                tmpmap.put(nss.getPrefix(), nss);\r\n            }\r\n            if (\"\".equals(attPrefix)) {\r\n                // we cannot find a 'prevailing' namespace that has a prefix\r\n                // that is for this namespace.\r\n                // This basically means that there's an XMLSchema, for the\r\n                // DEFAULT namespace, and there's a defaulted/fixed\r\n                // attribute definition in the XMLSchema that's targeted\r\n                // for this namespace,... but, the user has either not\r\n                // declared a prefixed version of the namespace, or has\r\n                // re-declared the same prefix at a lower level with a\r\n                // different namespace.\r\n                // All of these things are possible.\r\n                // Create some sort of default prefix.\r\n                int cnt = 0;\r\n                final String base = \"attns\";\r\n                String pfx = base + cnt;\r\n                while (tmpmap.containsKey(pfx)) {\r\n                    cnt++;\r\n                    pfx = base + cnt;\r\n                } \r\n                attPrefix = pfx;\r\n            }\r\n        }\r\n        final Namespace attNs = Namespace.getNamespace(attPrefix, attURI);\r\n        final Attribute attribute = factory.attribute(attLocalName, attValue, attType, attNs);\r\n        if (!specified) {\r\n            // it is a DTD defaulted value.\r\n            attribute.setSpecified(false);\r\n        }\r\n        factory.setAttribute(element, attribute);\r\n    }\r\n}",
        "class-code": "package org.jdom2.input.sax;\nimport java.util.HashMap;\nimport org.jdom2.Attribute;\nimport org.jdom2.Parent;\nimport org.jdom2.Element;\nimport java.util.ArrayList;\nimport org.xml.sax.Attributes;\nimport org.jdom2.JDOMFactory;\nimport org.jdom2.Document;\nimport org.xml.sax.SAXException;\nimport org.jdom2.DefaultJDOMFactory;\nimport org.xml.sax.Locator;\nimport org.xml.sax.ext.DeclHandler;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.jdom2.AttributeType;\nimport java.util.List;\nimport org.jdom2.EntityRef;\nimport org.jdom2.Comment;\nimport org.jdom2.DocType;\nimport org.jdom2.input.SAXBuilder;\nimport org.jdom2.Namespace;\nimport org.jdom2.Text;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.ext.Attributes2;\nimport javax.xml.XMLConstants;\nimport org.jdom2.ProcessingInstruction;\nimport java.util.Map;\nimport org.xml.sax.DTDHandler;\nimport org.jdom2.CDATA;\npublic class SAXHandler extends DefaultHandler implements LexicalHandler , DeclHandler , DTDHandler {\n    private final JDOMFactory factory;\n    private final List<Namespace> declaredNamespaces = new ArrayList<Namespace>(32);\n    private Document currentDocument = null;\n    private Element currentElement = null;\n    private Locator currentLocator = null;\n    private boolean atRoot = true;\n    private boolean suppress = false;\n    @Override\r\n    public void startElement(final String namespaceURI, String localName, final String qName, final Attributes atts) throws SAXException {\r\n        if (suppress)\r\n            return;\r\n    \r\n        String prefix = \"\";\r\n        // If QName is set, then set prefix and local name as necessary\r\n        if (!\"\".equals(qName)) {\r\n            final int colon = qName.indexOf(':');\r\n            if (colon > 0) {\r\n                prefix = qName.substring(0, colon);\r\n            }\r\n            // If local name is not set, try to get it from the QName\r\n            if ((localName == null) || localName.equals(\"\")) {\r\n                localName = qName.substring(colon + 1);\r\n            }\r\n        }\r\n        // At this point either prefix and localName are set correctly or\r\n        // there is an error in the parser.\r\n        final Namespace namespace = Namespace.getNamespace(prefix, namespaceURI);\r\n        final Element element = (currentLocator == null) ? factory.element(localName, namespace) : factory.element(currentLocator.getLineNumber(), currentLocator.getColumnNumber(), localName, namespace);\r\n        // Take leftover declared namespaces and add them to this element's\r\n        // map of namespaces\r\n        if (declaredNamespaces.size() > 0) {\r\n            transferNamespaces(element);\r\n        }\r\n        flushCharacters();\r\n        if (atRoot) {\r\n            factory.setRoot(currentDocument, element);// Yes, use a factory\r\n    \r\n            // call...\r\n            atRoot = false;\r\n        } else {\r\n            factory.addContent(getCurrentElement(), element);\r\n        }\r\n        currentElement = element;\r\n        // Handle attributes\r\n        for (int i = 0, len = atts.getLength(); i < len; i++) {\r\n            String attPrefix = \"\";\r\n            String attLocalName = atts.getLocalName(i);\r\n            final String attQName = atts.getQName(i);\r\n            final boolean specified = (atts instanceof Attributes2) ? ((Attributes2) (atts)).isSpecified(i) : true;\r\n            // If attribute QName is set, then set attribute prefix and\r\n            // attribute local name as necessary\r\n            if (!attQName.equals(\"\")) {\r\n                // Bypass any xmlns attributes which might appear, as we got\r\n                // them already in startPrefixMapping(). This is sometimes\r\n                // necessary when SAXHandler is used with another source than\r\n                // SAXBuilder, as with JDOMResult.\r\n                if (attQName.startsWith(\"xmlns:\") || attQName.equals(\"xmlns\")) {\r\n                    continue;\r\n                }\r\n                final int attColon = attQName.indexOf(':');\r\n                if (attColon > 0) {\r\n                    attPrefix = attQName.substring(0, attColon);\r\n                }\r\n                // If localName is not set, try to get it from the QName\r\n                if (\"\".equals(attLocalName)) {\r\n                    attLocalName = attQName.substring(attColon + 1);\r\n                }\r\n            }\r\n            final AttributeType attType = AttributeType.getAttributeType(atts.getType(i));\r\n            final String attValue = atts.getValue(i);\r\n            final String attURI = atts.getURI(i);\r\n            if ((XMLConstants.XMLNS_ATTRIBUTE.equals(attLocalName) || XMLConstants.XMLNS_ATTRIBUTE.equals(attPrefix)) || XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(attURI)) {\r\n                // use the actual Namespace to check too, because, in theory, a\r\n                // namespace-aware parser does not need to set the qName unless\r\n                // the namespace-prefixes feature is set as well.\r\n                continue;\r\n            }\r\n            // At this point either attPrefix and attLocalName are set\r\n            // correctly or there is an error in the parser.\r\n            // just one thing to sort out....\r\n            // the prefix for the namespace.\r\n            if ((!\"\".equals(attURI)) && \"\".equals(attPrefix)) {\r\n                // the localname and qName are the same, but there is a\r\n                // Namspace URI. We need to figure out the namespace prefix.\r\n                // this is an unusual condition. Currently the only known\r\n                // trigger\r\n                // is when there is a fixed/defaulted attribute from a\r\n                // validating\r\n                // XMLSchema, and the attribute is in a different namespace\r\n                // than the rest of the document, this happens whenever there\r\n                // is an attribute definition that has form=\"qualified\".\r\n                // <xs:attribute name=\"attname\" form=\"qualified\" ... />\r\n                // or the schema sets attributeFormDefault=\"qualified\"\r\n                final HashMap<String, Namespace> tmpmap = new HashMap<String, Namespace>();\r\n                for (final Namespace nss : element.getNamespacesInScope()) {\r\n                    if ((nss.getPrefix().length() > 0) && nss.getURI().equals(attURI)) {\r\n                        attPrefix = nss.getPrefix();\r\n                        break;\r\n                    }\r\n                    tmpmap.put(nss.getPrefix(), nss);\r\n                }\r\n                if (\"\".equals(attPrefix)) {\r\n                    // we cannot find a 'prevailing' namespace that has a prefix\r\n                    // that is for this namespace.\r\n                    // This basically means that there's an XMLSchema, for the\r\n                    // DEFAULT namespace, and there's a defaulted/fixed\r\n                    // attribute definition in the XMLSchema that's targeted\r\n                    // for this namespace,... but, the user has either not\r\n                    // declared a prefixed version of the namespace, or has\r\n                    // re-declared the same prefix at a lower level with a\r\n                    // different namespace.\r\n                    // All of these things are possible.\r\n                    // Create some sort of default prefix.\r\n                    int cnt = 0;\r\n                    final String base = \"attns\";\r\n                    String pfx = base + cnt;\r\n                    while (tmpmap.containsKey(pfx)) {\r\n                        cnt++;\r\n                        pfx = base + cnt;\r\n                    } \r\n                    attPrefix = pfx;\r\n                }\r\n            }\r\n            final Namespace attNs = Namespace.getNamespace(attPrefix, attURI);\r\n            final Attribute attribute = factory.attribute(attLocalName, attValue, attType, attNs);\r\n            if (!specified) {\r\n                // it is a DTD defaulted value.\r\n                attribute.setSpecified(false);\r\n            }\r\n            factory.setAttribute(element, attribute);\r\n        }\r\n    }\n@Override\r\npublic void attributeDecl(final String eName, final String aName, final String type, final String valueDefault, final String value);\n    @Override\r\npublic void characters(final char[] ch, final int start, final int length) throws SAXException;\n    @Override\r\npublic void comment(final char[] ch, final int start, final int length) throws SAXException;\n    @Override\r\npublic void elementDecl(final String name, final String model);\n    @Override\r\npublic void endCDATA() throws SAXException;\n    @Override\r\npublic void endDTD();\n    @Override\r\npublic void endElement(final String namespaceURI, final String localName, final String qName) throws SAXException;\n    @Override\r\npublic void endEntity(final String name) throws SAXException;\n    @Override\r\npublic void externalEntityDecl(final String name, final String publicID, final String systemID) throws SAXException;\n    protected void flushCharacters() throws SAXException;\n    protected void flushCharacters(final String data) throws SAXException;\n    public Element getCurrentElement() throws SAXException;\n    public Document getDocument();\n    public Locator getDocumentLocator();\n    public boolean getExpandEntities();\n    public JDOMFactory getFactory();\n    public boolean getIgnoringBoundaryWhitespace();\n    public boolean getIgnoringElementContentWhitespace();\n    @Override\r\npublic void ignorableWhitespace(final char[] ch, final int start, final int length) throws SAXException;\n    @Override\r\npublic void internalEntityDecl(final String name, final String value);\n    @Override\r\npublic void notationDecl(final String name, final String publicID, final String systemID) throws SAXException;\n    @Override\r\npublic void processingInstruction(final String target, final String data) throws SAXException;\n    protected void pushElement(final Element element);\n    public final void reset();\n    protected void resetSubCLass();\n    @Override\r\npublic void setDocumentLocator(final Locator locator);\n    public void setExpandEntities(final boolean expand);\n    public void setIgnoringBoundaryWhitespace(final boolean ignoringBoundaryWhite);\n    public void setIgnoringElementContentWhitespace(final boolean ignoringWhite);\n    @Override\r\npublic void skippedEntity(final String name) throws SAXException;\n    @Override\r\npublic void startCDATA();\n    @Override\r\npublic void startDTD(final String name, final String publicID, final String systemID) throws SAXException;\n    @Override\r\npublic void startDocument();\n    @Override\r\npublic void startEntity(final String name) throws SAXException;\n    @Override\r\npublic void startPrefixMapping(final String prefix, final String uri) throws SAXException;\n    private void transferNamespaces(final Element element);\n    @Override\r\npublic void unparsedEntityDecl(final String name, final String publicID, final String systemID, final String notationName);\n}"
      },
      {
        "id": "Format_escapeAttribute",
        "package": "org.jdom2.output",
        "class": "org.jdom2.output.Format",
        "test-class": "org.jdom2.output.Format_escapeAttribute_Test",
        "method-name": "escapeAttribute(EscapeStrategy, String)",
        "source-path": "src/main/java/org/jdom2/output/Format.java",
        "test-path": "src/test/java/org/jdom2/output/Format_escapeAttribute_Test.java",
        "focal-method": "public static final String escapeAttribute(final EscapeStrategy strategy, final String value) {\r\n    final int len = value.length();\r\n    int idx = 0;\r\n    checkloop : while (idx < len) {\r\n        final char ch = value.charAt(idx);\r\n        if ((((((((ch == '<') || (ch == '>')) || (ch == '&')) || (ch == '\\r')) || (ch == '\\n')) || (ch == '\"')) || (ch == '\\t')) || strategy.shouldEscape(ch)) {\r\n            break checkloop;\r\n        }\r\n        idx++;\r\n    } \r\n    if (idx == len) {\r\n        return value;\r\n    }\r\n    char highsurrogate = 0;\r\n    final StringBuilder sb = new StringBuilder(len + 5);\r\n    sb.append(value, 0, idx);\r\n    while (idx < len) {\r\n        final char ch = value.charAt(idx++);\r\n        if (highsurrogate > 0) {\r\n            if (!Verifier.isLowSurrogate(ch)) {\r\n                throw new IllegalDataException(((\"Could not decode surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \" / 0x\") + Integer.toHexString(ch));\r\n            }\r\n            int chp = Verifier.decodeSurrogatePair(highsurrogate, ch);\r\n            sb.append(\"&#x\");\r\n            sb.append(Integer.toHexString(chp));\r\n            sb.append(';');\r\n            highsurrogate = 0;\r\n            continue;\r\n        }\r\n        switch (ch) {\r\n            case '<' :\r\n                sb.append(\"&lt;\");\r\n                break;\r\n            case '>' :\r\n                sb.append(\"&gt;\");\r\n                break;\r\n            case '&' :\r\n                sb.append(\"&amp;\");\r\n                break;\r\n            case '\\r' :\r\n                sb.append(\"&#xD;\");\r\n                break;\r\n            case '\"' :\r\n                sb.append(\"&quot;\");\r\n                break;\r\n            case '\\t' :\r\n                sb.append(\"&#x9;\");\r\n                break;\r\n            case '\\n' :\r\n                sb.append(\"&#xA;\");\r\n                break;\r\n            default :\r\n                if (strategy.shouldEscape(ch)) {\r\n                    // make sure what we are escaping is not the\r\n                    // beginning of a multi-byte character.\r\n                    if (Verifier.isHighSurrogate(ch)) {\r\n                        // this is a the high of a surrogate pair\r\n                        highsurrogate = ch;\r\n                    } else {\r\n                        sb.append(\"&#x\");\r\n                        sb.append(Integer.toHexString(ch));\r\n                        sb.append(';');\r\n                    }\r\n                } else {\r\n                    sb.append(ch);\r\n                }\r\n                break;\r\n        }\r\n    } \r\n    if (highsurrogate > 0) {\r\n        throw new IllegalDataException((\"Surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \"truncated\");\r\n    }\r\n    return sb.toString();\r\n}",
        "class-code": "package org.jdom2.output;\nimport org.jdom2.IllegalDataException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport org.jdom2.Verifier;\npublic class Format implements Cloneable {\n    String indent = null;\n    String lineSeparator = STANDARD_LINE_SEPARATOR;\n    String encoding = STANDARD_ENCODING;\n    boolean omitDeclaration = false;\n    boolean omitEncoding = false;\n    boolean specifiedAttributesOnly = false;\n    boolean expandEmptyElements = false;\n    boolean ignoreTrAXEscapingPIs = false;\n    TextMode mode = TextMode.PRESERVE;\n    EscapeStrategy escapeStrategy = DefaultEscapeStrategy;\n    public static final String escapeAttribute(final EscapeStrategy strategy, final String value) {\r\n        final int len = value.length();\r\n        int idx = 0;\r\n        checkloop : while (idx < len) {\r\n            final char ch = value.charAt(idx);\r\n            if ((((((((ch == '<') || (ch == '>')) || (ch == '&')) || (ch == '\\r')) || (ch == '\\n')) || (ch == '\"')) || (ch == '\\t')) || strategy.shouldEscape(ch)) {\r\n                break checkloop;\r\n            }\r\n            idx++;\r\n        } \r\n        if (idx == len) {\r\n            return value;\r\n        }\r\n        char highsurrogate = 0;\r\n        final StringBuilder sb = new StringBuilder(len + 5);\r\n        sb.append(value, 0, idx);\r\n        while (idx < len) {\r\n            final char ch = value.charAt(idx++);\r\n            if (highsurrogate > 0) {\r\n                if (!Verifier.isLowSurrogate(ch)) {\r\n                    throw new IllegalDataException(((\"Could not decode surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \" / 0x\") + Integer.toHexString(ch));\r\n                }\r\n                int chp = Verifier.decodeSurrogatePair(highsurrogate, ch);\r\n                sb.append(\"&#x\");\r\n                sb.append(Integer.toHexString(chp));\r\n                sb.append(';');\r\n                highsurrogate = 0;\r\n                continue;\r\n            }\r\n            switch (ch) {\r\n                case '<' :\r\n                    sb.append(\"&lt;\");\r\n                    break;\r\n                case '>' :\r\n                    sb.append(\"&gt;\");\r\n                    break;\r\n                case '&' :\r\n                    sb.append(\"&amp;\");\r\n                    break;\r\n                case '\\r' :\r\n                    sb.append(\"&#xD;\");\r\n                    break;\r\n                case '\"' :\r\n                    sb.append(\"&quot;\");\r\n                    break;\r\n                case '\\t' :\r\n                    sb.append(\"&#x9;\");\r\n                    break;\r\n                case '\\n' :\r\n                    sb.append(\"&#xA;\");\r\n                    break;\r\n                default :\r\n                    if (strategy.shouldEscape(ch)) {\r\n                        // make sure what we are escaping is not the\r\n                        // beginning of a multi-byte character.\r\n                        if (Verifier.isHighSurrogate(ch)) {\r\n                            // this is a the high of a surrogate pair\r\n                            highsurrogate = ch;\r\n                        } else {\r\n                            sb.append(\"&#x\");\r\n                            sb.append(Integer.toHexString(ch));\r\n                            sb.append(';');\r\n                        }\r\n                    } else {\r\n                        sb.append(ch);\r\n                    }\r\n                    break;\r\n            }\r\n        } \r\n        if (highsurrogate > 0) {\r\n            throw new IllegalDataException((\"Surrogate pair 0x\" + Integer.toHexString(highsurrogate)) + \"truncated\");\r\n        }\r\n        return sb.toString();\r\n    }\n@Override\r\npublic Format clone();\n    public static final String compact(String str);\n    public static final String escapeText(final EscapeStrategy strategy, final String eol, final String value);\n    public static Format getCompactFormat();\n    public String getEncoding();\n    public EscapeStrategy getEscapeStrategy();\n    public boolean getExpandEmptyElements();\n    public boolean getIgnoreTrAXEscapingPIs();\n    public String getIndent();\n    public String getLineSeparator();\n    public boolean getOmitDeclaration();\n    public boolean getOmitEncoding();\n    public static Format getPrettyFormat();\n    public static Format getRawFormat();\n    public Format.TextMode getTextMode();\n    public boolean isSpecifiedAttributesOnly();\n    public Format setEncoding(String encoding);\n    public Format setEscapeStrategy(EscapeStrategy strategy);\n    public Format setExpandEmptyElements(boolean expandEmptyElements);\n    public void setIgnoreTrAXEscapingPIs(boolean ignoreTrAXEscapingPIs);\n    public Format setIndent(String indent);\n    public Format setLineSeparator(String separator);\n    public Format setLineSeparator(LineSeparator separator);\n    public Format setOmitDeclaration(boolean omitDeclaration);\n    public Format setOmitEncoding(boolean omitEncoding);\n    public void setSpecifiedAttributesOnly(boolean specifiedAttributesOnly);\n    public Format setTextMode(Format.TextMode mode);\n    public static final String trimBoth(final String str);\n    public static final String trimLeft(final String str);\n    public static final String trimRight(String str);\n}"
      }
    ]
  },
  "ruler": {
    "project-name": "ruler",
    "project-url": "ruler",
    "focal-methods": [
      {
        "id": "ByteMachine_doTransitionOn",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_doTransitionOn_Test",
        "method-name": "doTransitionOn(String, Set<NameState>, boolean)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_doTransitionOn_Test.java",
        "focal-method": "private void doTransitionOn(final String valString, final Set<NameState> transitionTo, boolean fieldValueIsNumeric) {\r\n    final Set<NameState> failedAnythingButs = new HashSet<>();\r\n    final byte[] val = valString.getBytes(StandardCharsets.UTF_8);\r\n    // we need to add the name state for key existence\r\n    addExistenceMatch(transitionTo);\r\n    // attempt to harvest the possible suffix match\r\n    addSuffixMatch(val, transitionTo, failedAnythingButs);\r\n    if (startStateMatch != null) {\r\n        transitionTo.add(startStateMatch.getNextNameState());\r\n    }\r\n    // we have to do old-school indexing rather than \"for (byte b : val)\" because there is some special-casing\r\n    // on transitions on the last byte in the value array\r\n    ByteTransition trans = startState;\r\n    for (int valIndex = 0; valIndex < val.length; valIndex++) {\r\n        final ByteTransition nextTrans = getTransition(trans, val[valIndex]);\r\n        attemptAddShortcutTransitionMatch(nextTrans, valString, EXACT, transitionTo);\r\n        if (!nextTrans.isShortcutTrans()) {\r\n            // process any matches hanging off this transition\r\n            for (ByteMatch match : nextTrans.getMatches()) {\r\n                switch (match.getPattern().type()) {\r\n                    case EXACT :\r\n                    case EQUALS_IGNORE_CASE :\r\n                    case WILDCARD :\r\n                        if (valIndex == (val.length - 1)) {\r\n                            transitionTo.add(match.getNextNameState());\r\n                        }\r\n                        break;\r\n                    case NUMERIC_EQ :\r\n                        // only matches at last character\r\n                        if (fieldValueIsNumeric && (valIndex == (val.length - 1))) {\r\n                            transitionTo.add(match.getNextNameState());\r\n                        }\r\n                        break;\r\n                    case PREFIX :\r\n                        transitionTo.add(match.getNextNameState());\r\n                        break;\r\n                    case ANYTHING_BUT_SUFFIX :\r\n                    case SUFFIX :\r\n                    case EXISTS :\r\n                        // we already harvested these matches via separate functions due to special matching\r\n                        // requirements, so just ignore them here.\r\n                        break;\r\n                    case NUMERIC_RANGE :\r\n                        // as soon as you see the match, you've matched\r\n                        Range range = ((Range) (match.getPattern()));\r\n                        if ((fieldValueIsNumeric && (!range.isCIDR)) || ((!fieldValueIsNumeric) && range.isCIDR)) {\r\n                            transitionTo.add(match.getNextNameState());\r\n                        }\r\n                        break;\r\n                    case ANYTHING_BUT :\r\n                        AnythingBut anythingBut = ((AnythingBut) (match.getPattern()));\r\n                        // only applies if at last character\r\n                        if ((valIndex == (val.length - 1)) && (anythingBut.isNumeric() == fieldValueIsNumeric)) {\r\n                            failedAnythingButs.add(match.getNextNameState());\r\n                        }\r\n                        break;\r\n                    case ANYTHING_BUT_IGNORE_CASE :\r\n                        // only applies if at last character\r\n                        if (valIndex == (val.length - 1)) {\r\n                            failedAnythingButs.add(match.getNextNameState());\r\n                        }\r\n                        break;\r\n                    case ANYTHING_BUT_PREFIX :\r\n                        failedAnythingButs.add(match.getNextNameState());\r\n                        break;\r\n                    default :\r\n                        throw new RuntimeException(\"Not implemented yet\");\r\n                }\r\n            }\r\n        }\r\n        trans = nextTrans.getTransitionForNextByteStates();\r\n        if (trans == null) {\r\n            break;\r\n        }\r\n    }\r\n    // This may look like premature optimization, but the first \"if\" here yields roughly 10x performance\r\n    // improvement.\r\n    if (!anythingButs.isEmpty()) {\r\n        if (!failedAnythingButs.isEmpty()) {\r\n            transitionTo.addAll(anythingButs.stream().filter(anythingBut -> !failedAnythingButs.contains(anythingBut)).collect(Collectors.toList()));\r\n        } else {\r\n            transitionTo.addAll(anythingButs);\r\n        }\r\n    }\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private final ByteState startState = new ByteState();\n    private ByteMatch startStateMatch;\n    private final Set<NameState> anythingButs = ConcurrentHashMap.newKeySet();\n    private void doTransitionOn(final String valString, final Set<NameState> transitionTo, boolean fieldValueIsNumeric) {\r\n        final Set<NameState> failedAnythingButs = new HashSet<>();\r\n        final byte[] val = valString.getBytes(StandardCharsets.UTF_8);\r\n        // we need to add the name state for key existence\r\n        addExistenceMatch(transitionTo);\r\n        // attempt to harvest the possible suffix match\r\n        addSuffixMatch(val, transitionTo, failedAnythingButs);\r\n        if (startStateMatch != null) {\r\n            transitionTo.add(startStateMatch.getNextNameState());\r\n        }\r\n        // we have to do old-school indexing rather than \"for (byte b : val)\" because there is some special-casing\r\n        // on transitions on the last byte in the value array\r\n        ByteTransition trans = startState;\r\n        for (int valIndex = 0; valIndex < val.length; valIndex++) {\r\n            final ByteTransition nextTrans = getTransition(trans, val[valIndex]);\r\n            attemptAddShortcutTransitionMatch(nextTrans, valString, EXACT, transitionTo);\r\n            if (!nextTrans.isShortcutTrans()) {\r\n                // process any matches hanging off this transition\r\n                for (ByteMatch match : nextTrans.getMatches()) {\r\n                    switch (match.getPattern().type()) {\r\n                        case EXACT :\r\n                        case EQUALS_IGNORE_CASE :\r\n                        case WILDCARD :\r\n                            if (valIndex == (val.length - 1)) {\r\n                                transitionTo.add(match.getNextNameState());\r\n                            }\r\n                            break;\r\n                        case NUMERIC_EQ :\r\n                            // only matches at last character\r\n                            if (fieldValueIsNumeric && (valIndex == (val.length - 1))) {\r\n                                transitionTo.add(match.getNextNameState());\r\n                            }\r\n                            break;\r\n                        case PREFIX :\r\n                            transitionTo.add(match.getNextNameState());\r\n                            break;\r\n                        case ANYTHING_BUT_SUFFIX :\r\n                        case SUFFIX :\r\n                        case EXISTS :\r\n                            // we already harvested these matches via separate functions due to special matching\r\n                            // requirements, so just ignore them here.\r\n                            break;\r\n                        case NUMERIC_RANGE :\r\n                            // as soon as you see the match, you've matched\r\n                            Range range = ((Range) (match.getPattern()));\r\n                            if ((fieldValueIsNumeric && (!range.isCIDR)) || ((!fieldValueIsNumeric) && range.isCIDR)) {\r\n                                transitionTo.add(match.getNextNameState());\r\n                            }\r\n                            break;\r\n                        case ANYTHING_BUT :\r\n                            AnythingBut anythingBut = ((AnythingBut) (match.getPattern()));\r\n                            // only applies if at last character\r\n                            if ((valIndex == (val.length - 1)) && (anythingBut.isNumeric() == fieldValueIsNumeric)) {\r\n                                failedAnythingButs.add(match.getNextNameState());\r\n                            }\r\n                            break;\r\n                        case ANYTHING_BUT_IGNORE_CASE :\r\n                            // only applies if at last character\r\n                            if (valIndex == (val.length - 1)) {\r\n                                failedAnythingButs.add(match.getNextNameState());\r\n                            }\r\n                            break;\r\n                        case ANYTHING_BUT_PREFIX :\r\n                            failedAnythingButs.add(match.getNextNameState());\r\n                            break;\r\n                        default :\r\n                            throw new RuntimeException(\"Not implemented yet\");\r\n                    }\r\n                }\r\n            }\r\n            trans = nextTrans.getTransitionForNextByteStates();\r\n            if (trans == null) {\r\n                break;\r\n            }\r\n        }\r\n        // This may look like premature optimization, but the first \"if\" here yields roughly 10x performance\r\n        // improvement.\r\n        if (!anythingButs.isEmpty()) {\r\n            if (!failedAnythingButs.isEmpty()) {\r\n                transitionTo.addAll(anythingButs.stream().filter(anythingBut -> !failedAnythingButs.contains(anythingBut)).collect(Collectors.toList()));\r\n            } else {\r\n                transitionTo.addAll(anythingButs);\r\n            }\r\n        }\r\n    }\nprivate void addExistenceMatch(final Set<NameState> transitionTo);\n    NameState addPattern(final Patterns pattern);\n    private void addSuffixMatch(final byte[] val, final Set<NameState> transitionTo, Set<NameState> failedAnythingButs);\n    private boolean attemptAddShortcutTransitionMatch(final ByteTransition transition, final String value, final MatchType expectedMatchType, final Set<NameState> transitionTo);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    NameState findPattern(final Patterns pattern);\n    public void gatherObjects(Set<Object> objectSet);\n    private static ByteTransition getTransition(ByteTransition trans, byte b);\n    private static ByteTransition getTransition(SingleByteTransition trans, InputCharacter character);\n    boolean isEmpty();\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "MachineComplexityEvaluator_evaluate",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.MachineComplexityEvaluator",
        "test-class": "software.amazon.event.ruler.MachineComplexityEvaluator_evaluate_Test",
        "method-name": "evaluate(ByteState)",
        "source-path": "src/main/java/software/amazon/event/ruler/MachineComplexityEvaluator.java",
        "test-path": "src/test/java/software/amazon/event/ruler/MachineComplexityEvaluator_evaluate_Test.java",
        "focal-method": "int evaluate(ByteState state) {\r\n    // Upfront cost: generate the map of all matches accessible from every state in the machine.\r\n    Map<SingleByteTransition, Set<ByteMatch>> matchesAccessibleFromEachTransition = getMatchesAccessibleFromEachTransition(state);\r\n    Set<ByteTransition> visited = new HashSet<>();\r\n    visited.add(state);\r\n    int maxSize = 0;\r\n    // We'll do a breadth-first-search but it shouldn't matter.\r\n    Queue<ByteTransition> transitions = new LinkedList<>(state.getTransitions());\r\n    while (!transitions.isEmpty()) {\r\n        ByteTransition transition = transitions.remove();\r\n        if (visited.contains(transition)) {\r\n            continue;\r\n        }\r\n        visited.add(transition);\r\n        // The sum of all the wildcard patterns accessible from each SingleByteTransition we are present in on our\r\n        // current traversal is the number of wildcard rule prefixes matching a theoretical worst-case input value.\r\n        int size = 0;\r\n        for (SingleByteTransition single : transition.expand()) {\r\n            size += getWildcardPatterns(matchesAccessibleFromEachTransition.get(single)).size();\r\n            // Look for \"transitions for all bytes\" (i.e. wildcard transitions). Since an input value that matches\r\n            // foo will also match foo*, we also need to include in our size wildcard patterns accessible from foo*.\r\n            ByteState nextState = single.getNextByteState();\r\n            if (nextState != null) {\r\n                Set<SingleByteTransition> transitionsForAllBytes = nextState.getTransitionForAllBytes().expand();\r\n                for (SingleByteTransition transitionForAllBytes : transitionsForAllBytes) {\r\n                    if ((!(transitionForAllBytes instanceof ByteMachine.EmptyByteTransition)) && (!transition.expand().contains(transitionForAllBytes))) {\r\n                        size += getWildcardPatterns(matchesAccessibleFromEachTransition.get(transitionForAllBytes)).size();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (size >= maxComplexity) {\r\n            return maxComplexity;\r\n        }\r\n        if (size > maxSize) {\r\n            maxSize = size;\r\n        }\r\n        // Load up our queue with the next round of transitions, where each transition represents a set of states\r\n        // that could be accessed with a particular byte value.\r\n        ByteTransition nextTransition = transition.getTransitionForNextByteStates();\r\n        if (nextTransition != null) {\r\n            transitions.addAll(nextTransition.getTransitions());\r\n        }\r\n    } \r\n    // Now that we have a maxSize for this ByteMachine, let's recursively get the maxSize for each next NameState\r\n    // accessible via any of this ByteMachine's matches. We will return the maximum maxSize.\r\n    int maxSizeFromNextNameStates = 0;\r\n    Set<ByteMatch> uniqueMatches = new HashSet<>();\r\n    for (Set<ByteMatch> matches : matchesAccessibleFromEachTransition.values()) {\r\n        uniqueMatches.addAll(matches);\r\n    }\r\n    for (ByteMatch match : uniqueMatches) {\r\n        NameState nextNameState = match.getNextNameState();\r\n        if (nextNameState != null) {\r\n            maxSizeFromNextNameStates = Math.max(maxSizeFromNextNameStates, nextNameState.evaluateComplexity(this));\r\n        }\r\n    }\r\n    return Math.max(maxSize, maxSizeFromNextNameStates);\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport static software.amazon.event.ruler.MatchType.WILDCARD;\nimport java.util.LinkedList;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Stack;\npublic class MachineComplexityEvaluator {\n    private final int maxComplexity;\n    int evaluate(ByteState state) {\r\n        // Upfront cost: generate the map of all matches accessible from every state in the machine.\r\n        Map<SingleByteTransition, Set<ByteMatch>> matchesAccessibleFromEachTransition = getMatchesAccessibleFromEachTransition(state);\r\n        Set<ByteTransition> visited = new HashSet<>();\r\n        visited.add(state);\r\n        int maxSize = 0;\r\n        // We'll do a breadth-first-search but it shouldn't matter.\r\n        Queue<ByteTransition> transitions = new LinkedList<>(state.getTransitions());\r\n        while (!transitions.isEmpty()) {\r\n            ByteTransition transition = transitions.remove();\r\n            if (visited.contains(transition)) {\r\n                continue;\r\n            }\r\n            visited.add(transition);\r\n            // The sum of all the wildcard patterns accessible from each SingleByteTransition we are present in on our\r\n            // current traversal is the number of wildcard rule prefixes matching a theoretical worst-case input value.\r\n            int size = 0;\r\n            for (SingleByteTransition single : transition.expand()) {\r\n                size += getWildcardPatterns(matchesAccessibleFromEachTransition.get(single)).size();\r\n                // Look for \"transitions for all bytes\" (i.e. wildcard transitions). Since an input value that matches\r\n                // foo will also match foo*, we also need to include in our size wildcard patterns accessible from foo*.\r\n                ByteState nextState = single.getNextByteState();\r\n                if (nextState != null) {\r\n                    Set<SingleByteTransition> transitionsForAllBytes = nextState.getTransitionForAllBytes().expand();\r\n                    for (SingleByteTransition transitionForAllBytes : transitionsForAllBytes) {\r\n                        if ((!(transitionForAllBytes instanceof ByteMachine.EmptyByteTransition)) && (!transition.expand().contains(transitionForAllBytes))) {\r\n                            size += getWildcardPatterns(matchesAccessibleFromEachTransition.get(transitionForAllBytes)).size();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (size >= maxComplexity) {\r\n                return maxComplexity;\r\n            }\r\n            if (size > maxSize) {\r\n                maxSize = size;\r\n            }\r\n            // Load up our queue with the next round of transitions, where each transition represents a set of states\r\n            // that could be accessed with a particular byte value.\r\n            ByteTransition nextTransition = transition.getTransitionForNextByteStates();\r\n            if (nextTransition != null) {\r\n                transitions.addAll(nextTransition.getTransitions());\r\n            }\r\n        } \r\n        // Now that we have a maxSize for this ByteMachine, let's recursively get the maxSize for each next NameState\r\n        // accessible via any of this ByteMachine's matches. We will return the maximum maxSize.\r\n        int maxSizeFromNextNameStates = 0;\r\n        Set<ByteMatch> uniqueMatches = new HashSet<>();\r\n        for (Set<ByteMatch> matches : matchesAccessibleFromEachTransition.values()) {\r\n            uniqueMatches.addAll(matches);\r\n        }\r\n        for (ByteMatch match : uniqueMatches) {\r\n            NameState nextNameState = match.getNextNameState();\r\n            if (nextNameState != null) {\r\n                maxSizeFromNextNameStates = Math.max(maxSizeFromNextNameStates, nextNameState.evaluateComplexity(this));\r\n            }\r\n        }\r\n        return Math.max(maxSize, maxSizeFromNextNameStates);\r\n    }\nprivate Map<SingleByteTransition, Set<ByteMatch>> getMatchesAccessibleFromEachTransition(ByteState state);\n    int getMaxComplexity();\n    private static Set<Patterns> getWildcardPatterns(Set<ByteMatch> matches);\n}"
      },
      {
        "id": "ByteMachine_findRangePattern",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_findRangePattern_Test",
        "method-name": "findRangePattern(Range)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_findRangePattern_Test.java",
        "focal-method": "private NameState findRangePattern(Range range) {\r\n    Set<NameState> nextNameStates = new HashSet<>();\r\n    NameState nextNameState = null;\r\n    ByteTransition forkTrans = startState;\r\n    int forkOffset = 0;\r\n    // bypass common prefix of range's bottom and top patterns\r\n    while (range.bottom[forkOffset] == range.top[forkOffset]) {\r\n        forkTrans = findNextByteStateForRangePattern(forkTrans, range.bottom[forkOffset++]);\r\n        if (forkTrans == null) {\r\n            return null;\r\n        }\r\n    } \r\n    // fill in matches in the fork state\r\n    for (byte bb : Range.digitSequence(range.bottom[forkOffset], range.top[forkOffset], false, false)) {\r\n        nextNameState = findMatchForRangePattern(bb, forkTrans, range);\r\n        if (nextNameState == null) {\r\n            return null;\r\n        }\r\n        nextNameStates.add(nextNameState);\r\n    }\r\n    // process all the transitions on the bottom range bytes\r\n    ByteTransition trans = forkTrans;\r\n    int lastMatchOffset = forkOffset;\r\n    for (int offsetB = forkOffset + 1; offsetB < (range.bottom.length - 1); offsetB++) {\r\n        byte b = range.bottom[offsetB];\r\n        if (b < Constants.MAX_DIGIT) {\r\n            while (lastMatchOffset < offsetB) {\r\n                trans = findNextByteStateForRangePattern(trans, range.bottom[lastMatchOffset++]);\r\n                if (trans == null) {\r\n                    return null;\r\n                }\r\n            } \r\n            assert lastMatchOffset == offsetB : \"lastMatchOffset == offsetB\";\r\n            for (byte bb : Range.digitSequence(b, Constants.MAX_DIGIT, false, true)) {\r\n                nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                if (nextNameState == null) {\r\n                    return null;\r\n                }\r\n                nextNameStates.add(nextNameState);\r\n            }\r\n        }\r\n    }\r\n    // now for last \"bottom\" digit\r\n    final byte lastBottom = range.bottom[range.bottom.length - 1];\r\n    final byte lastTop = range.top[range.top.length - 1];\r\n    if ((lastBottom < Constants.MAX_DIGIT) || (!range.openBottom)) {\r\n        while (lastMatchOffset < (range.bottom.length - 1)) {\r\n            trans = findNextByteStateForRangePattern(trans, range.bottom[lastMatchOffset++]);\r\n            if (trans == null) {\r\n                return null;\r\n            }\r\n        } \r\n        assert lastMatchOffset == (range.bottom.length - 1) : \"lastMatchOffset == (range.bottom.length - 1)\";\r\n        if (!range.openBottom) {\r\n            nextNameState = findMatchForRangePattern(lastBottom, trans, range);\r\n            if (nextNameState == null) {\r\n                return null;\r\n            }\r\n            nextNameStates.add(nextNameState);\r\n        }\r\n        // unless the last digit is also at the fork position, fill in the extra matches due to\r\n        // the strictly-less-than condition (see discussion above)\r\n        if (forkOffset < (range.bottom.length - 1)) {\r\n            for (byte bb : Range.digitSequence(lastBottom, Constants.MAX_DIGIT, false, true)) {\r\n                nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                if (nextNameState == null) {\r\n                    return null;\r\n                }\r\n                nextNameStates.add(nextNameState);\r\n            }\r\n        }\r\n    }\r\n    // now process transitions along the top range bytes\r\n    trans = forkTrans;\r\n    lastMatchOffset = forkOffset;\r\n    for (int offsetT = forkOffset + 1; offsetT < (range.top.length - 1); offsetT++) {\r\n        byte b = range.top[offsetT];\r\n        if (b > '0') {\r\n            while (lastMatchOffset < offsetT) {\r\n                trans = findNextByteStateForRangePattern(trans, range.top[lastMatchOffset++]);\r\n                if (trans == null) {\r\n                    return null;\r\n                }\r\n            } \r\n            assert lastMatchOffset == offsetT : \"lastMatchOffset == offsetT\";\r\n            for (byte bb : Range.digitSequence(((byte) ('0')), range.top[offsetT], true, false)) {\r\n                nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                if (nextNameState == null) {\r\n                    return null;\r\n                }\r\n                nextNameStates.add(nextNameState);\r\n            }\r\n        }\r\n    }\r\n    // now for last \"top\" digit\r\n    if ((lastTop > '0') || (!range.openTop)) {\r\n        while (lastMatchOffset < (range.top.length - 1)) {\r\n            trans = findNextByteStateForRangePattern(trans, range.top[lastMatchOffset++]);\r\n            if (trans == null) {\r\n                return null;\r\n            }\r\n        } \r\n        assert lastMatchOffset == (range.top.length - 1) : \"lastMatchOffset == (range.top.length - 1)\";\r\n        if (!range.openTop) {\r\n            nextNameState = findMatchForRangePattern(lastTop, trans, range);\r\n            if (nextNameState == null) {\r\n                return null;\r\n            }\r\n            nextNameStates.add(nextNameState);\r\n        }\r\n        // unless the last digit is also at the fork position, fill in the extra matches due to\r\n        // the strictly-less-than condition (see discussion above)\r\n        if (forkOffset < (range.top.length - 1)) {\r\n            for (byte bb : Range.digitSequence(((byte) ('0')), lastTop, true, false)) {\r\n                nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                if (nextNameState == null) {\r\n                    return null;\r\n                }\r\n                nextNameStates.add(nextNameState);\r\n            }\r\n        }\r\n    }\r\n    // There must only have one nextNameState object returned by this range pattern refer to\r\n    // addRangePattern() where only one nextNameState is used by one pattern.\r\n    assert nextNameStates.size() == 1 : \"nextNameStates.size() == 1\";\r\n    return nextNameState;\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private final ByteState startState = new ByteState();\n    private NameState findRangePattern(Range range) {\r\n        Set<NameState> nextNameStates = new HashSet<>();\r\n        NameState nextNameState = null;\r\n        ByteTransition forkTrans = startState;\r\n        int forkOffset = 0;\r\n        // bypass common prefix of range's bottom and top patterns\r\n        while (range.bottom[forkOffset] == range.top[forkOffset]) {\r\n            forkTrans = findNextByteStateForRangePattern(forkTrans, range.bottom[forkOffset++]);\r\n            if (forkTrans == null) {\r\n                return null;\r\n            }\r\n        } \r\n        // fill in matches in the fork state\r\n        for (byte bb : Range.digitSequence(range.bottom[forkOffset], range.top[forkOffset], false, false)) {\r\n            nextNameState = findMatchForRangePattern(bb, forkTrans, range);\r\n            if (nextNameState == null) {\r\n                return null;\r\n            }\r\n            nextNameStates.add(nextNameState);\r\n        }\r\n        // process all the transitions on the bottom range bytes\r\n        ByteTransition trans = forkTrans;\r\n        int lastMatchOffset = forkOffset;\r\n        for (int offsetB = forkOffset + 1; offsetB < (range.bottom.length - 1); offsetB++) {\r\n            byte b = range.bottom[offsetB];\r\n            if (b < Constants.MAX_DIGIT) {\r\n                while (lastMatchOffset < offsetB) {\r\n                    trans = findNextByteStateForRangePattern(trans, range.bottom[lastMatchOffset++]);\r\n                    if (trans == null) {\r\n                        return null;\r\n                    }\r\n                } \r\n                assert lastMatchOffset == offsetB : \"lastMatchOffset == offsetB\";\r\n                for (byte bb : Range.digitSequence(b, Constants.MAX_DIGIT, false, true)) {\r\n                    nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                    if (nextNameState == null) {\r\n                        return null;\r\n                    }\r\n                    nextNameStates.add(nextNameState);\r\n                }\r\n            }\r\n        }\r\n        // now for last \"bottom\" digit\r\n        final byte lastBottom = range.bottom[range.bottom.length - 1];\r\n        final byte lastTop = range.top[range.top.length - 1];\r\n        if ((lastBottom < Constants.MAX_DIGIT) || (!range.openBottom)) {\r\n            while (lastMatchOffset < (range.bottom.length - 1)) {\r\n                trans = findNextByteStateForRangePattern(trans, range.bottom[lastMatchOffset++]);\r\n                if (trans == null) {\r\n                    return null;\r\n                }\r\n            } \r\n            assert lastMatchOffset == (range.bottom.length - 1) : \"lastMatchOffset == (range.bottom.length - 1)\";\r\n            if (!range.openBottom) {\r\n                nextNameState = findMatchForRangePattern(lastBottom, trans, range);\r\n                if (nextNameState == null) {\r\n                    return null;\r\n                }\r\n                nextNameStates.add(nextNameState);\r\n            }\r\n            // unless the last digit is also at the fork position, fill in the extra matches due to\r\n            // the strictly-less-than condition (see discussion above)\r\n            if (forkOffset < (range.bottom.length - 1)) {\r\n                for (byte bb : Range.digitSequence(lastBottom, Constants.MAX_DIGIT, false, true)) {\r\n                    nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                    if (nextNameState == null) {\r\n                        return null;\r\n                    }\r\n                    nextNameStates.add(nextNameState);\r\n                }\r\n            }\r\n        }\r\n        // now process transitions along the top range bytes\r\n        trans = forkTrans;\r\n        lastMatchOffset = forkOffset;\r\n        for (int offsetT = forkOffset + 1; offsetT < (range.top.length - 1); offsetT++) {\r\n            byte b = range.top[offsetT];\r\n            if (b > '0') {\r\n                while (lastMatchOffset < offsetT) {\r\n                    trans = findNextByteStateForRangePattern(trans, range.top[lastMatchOffset++]);\r\n                    if (trans == null) {\r\n                        return null;\r\n                    }\r\n                } \r\n                assert lastMatchOffset == offsetT : \"lastMatchOffset == offsetT\";\r\n                for (byte bb : Range.digitSequence(((byte) ('0')), range.top[offsetT], true, false)) {\r\n                    nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                    if (nextNameState == null) {\r\n                        return null;\r\n                    }\r\n                    nextNameStates.add(nextNameState);\r\n                }\r\n            }\r\n        }\r\n        // now for last \"top\" digit\r\n        if ((lastTop > '0') || (!range.openTop)) {\r\n            while (lastMatchOffset < (range.top.length - 1)) {\r\n                trans = findNextByteStateForRangePattern(trans, range.top[lastMatchOffset++]);\r\n                if (trans == null) {\r\n                    return null;\r\n                }\r\n            } \r\n            assert lastMatchOffset == (range.top.length - 1) : \"lastMatchOffset == (range.top.length - 1)\";\r\n            if (!range.openTop) {\r\n                nextNameState = findMatchForRangePattern(lastTop, trans, range);\r\n                if (nextNameState == null) {\r\n                    return null;\r\n                }\r\n                nextNameStates.add(nextNameState);\r\n            }\r\n            // unless the last digit is also at the fork position, fill in the extra matches due to\r\n            // the strictly-less-than condition (see discussion above)\r\n            if (forkOffset < (range.top.length - 1)) {\r\n                for (byte bb : Range.digitSequence(((byte) ('0')), lastTop, true, false)) {\r\n                    nextNameState = findMatchForRangePattern(bb, trans, range);\r\n                    if (nextNameState == null) {\r\n                        return null;\r\n                    }\r\n                    nextNameStates.add(nextNameState);\r\n                }\r\n            }\r\n        }\r\n        // There must only have one nextNameState object returned by this range pattern refer to\r\n        // addRangePattern() where only one nextNameState is used by one pattern.\r\n        assert nextNameStates.size() == 1 : \"nextNameStates.size() == 1\";\r\n        return nextNameState;\r\n    }\nNameState addPattern(final Patterns pattern);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    private NameState findMatchForRangePattern(byte b, ByteTransition trans, Patterns pattern);\n    private ByteTransition findNextByteStateForRangePattern(ByteTransition trans, final byte b);\n    NameState findPattern(final Patterns pattern);\n    public void gatherObjects(Set<Object> objectSet);\n    boolean isEmpty();\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "ByteMachine_addEndOfMatch",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_addEndOfMatch_Test",
        "method-name": "addEndOfMatch(ByteState, ByteState, InputCharacter[], int, Patterns, NameState)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_addEndOfMatch_Test.java",
        "focal-method": "private NameState addEndOfMatch(ByteState state, ByteState prevState, final InputCharacter[] characters, final int charIndex, final Patterns pattern, final NameState nameStateCandidate) {\r\n    final int length = characters.length;\r\n    NameState nameState = (nameStateCandidate == null) ? new NameState() : nameStateCandidate;\r\n    if ((length == 1) && isWildcard(characters[0])) {\r\n        // Only character is '*'. Make the start state a match so empty input is matched.\r\n        startStateMatch = new ByteMatch(pattern, nameState);\r\n        return nameState;\r\n    }\r\n    ByteTransition trans = getTransition(state, characters[charIndex]);\r\n    // If it is shortcut transition, we need do adjustment first.\r\n    if ((!trans.isEmpty()) && trans.isShortcutTrans()) {\r\n        ShortcutTransition shortcut = ((ShortcutTransition) (trans));\r\n        ByteMatch match = shortcut.getMatch();\r\n        // In add/delete rule path, match must not be null and must not have other match\r\n        assert (match != null) && SHORTCUT_MATCH_TYPES.contains(match.getPattern().type());\r\n        // If it is the same pattern, just return.\r\n        if (pattern.equals(match.getPattern())) {\r\n            return match.getNextNameState();\r\n        }\r\n        // Have asserted current match pattern must be value patterns\r\n        String valueInCurrentPos = ((ValuePatterns) (match.getPattern())).pattern();\r\n        final InputCharacter[] charactersInCurrentPos = getParser().parse(match.getPattern().type(), valueInCurrentPos);\r\n        // find the position <m> where the common prefix ends.\r\n        int m = charIndex;\r\n        for (; (m < charactersInCurrentPos.length) && (m < length); m++) {\r\n            if (!charactersInCurrentPos[m].equals(characters[m])) {\r\n                break;\r\n            }\r\n        }\r\n        // Extend the prefix part in value to byte transitions, to avoid impact on concurrent read we need firstly\r\n        // make the new byte chain ready for using and leave the old transition removing to the last step.\r\n        // firstNewState will be head of new byte chain and, to avoid impact on concurrent match traffic in read\r\n        // path, it need be linked to current state chain after adjustment done.\r\n        ByteState firstNewState = null;\r\n        ByteState currentState = state;\r\n        for (int k = charIndex; k < m; k++) {\r\n            // we need keep the current state always pointed to last character.\r\n            if (k != (charactersInCurrentPos.length - 1)) {\r\n                final ByteState newByteState = new ByteState();\r\n                newByteState.setIndeterminatePrefix(currentState.hasIndeterminatePrefix());\r\n                if (k != charIndex) {\r\n                    putTransitionNextState(currentState, charactersInCurrentPos[k], shortcut, newByteState);\r\n                } else {\r\n                    firstNewState = newByteState;\r\n                }\r\n                currentState = newByteState;\r\n            }\r\n        }\r\n        // If it reached to last character, link the previous read transition in this character, else create\r\n        // shortcut transition. Note: at this time, the previous transition can still keep working.\r\n        boolean isShortcutNeeded = m < (charactersInCurrentPos.length - 1);\r\n        int indexToBeChange = (isShortcutNeeded) ? m : charactersInCurrentPos.length - 1;\r\n        putTransitionMatch(currentState, charactersInCurrentPos[indexToBeChange], isShortcutNeeded ? new ShortcutTransition() : EmptyByteTransition.INSTANCE, match);\r\n        removeTransition(currentState, charactersInCurrentPos[indexToBeChange], shortcut);\r\n        // At last, we link the new created chain to the byte state path, so no uncompleted change can be felt by\r\n        // reading thread. Note: we already confirmed there is only old shortcut transition at charIndex position,\r\n        // now we have move it to new position, so we can directly replace previous transition with new transition\r\n        // pointed to new byte state chain.\r\n        putTransitionNextState(state, characters[charIndex], shortcut, firstNewState);\r\n    }\r\n    // If there is a exact match transition on tail of path, after adjustment target transitions, we start\r\n    // looking at current remaining characters.\r\n    // If this is tail transition, go directly analyse the remaining characters, traverse to tail of chain:\r\n    boolean isEligibleForShortcut = true;\r\n    int j = charIndex;\r\n    for (; j < (length - 1); j++) {\r\n        // We do not want to re-use an existing state for the second last character in the case of a final-character\r\n        // wildcard pattern. In this case, we will have a self-referencing composite match state, which allows zero\r\n        // or many character to satisfy the wildcard. The self-reference would lead to unintended matches for the\r\n        // existing patterns.\r\n        if ((j == (length - 2)) && isWildcard(characters[j + 1])) {\r\n            break;\r\n        }\r\n        trans = getTransition(state, characters[j]);\r\n        if (trans.isEmpty()) {\r\n            break;\r\n        }\r\n        ByteState nextByteState = trans.getNextByteState();\r\n        if (nextByteState != null) {\r\n            // We cannot re-use a state with an indeterminate prefix without creating unintended matches.\r\n            if (nextByteState.hasIndeterminatePrefix()) {\r\n                // Since there is more path we are unable to traverse, this means we cannot insert shortcut without\r\n                // potentially ignoring matches further down path.\r\n                isEligibleForShortcut = false;\r\n                break;\r\n            }\r\n            prevState = state;\r\n            state = nextByteState;\r\n        } else {\r\n            // trans has match but no next state, we need prepare a next next state to add trans for either last\r\n            // character or shortcut byte.\r\n            final ByteState newByteState = new ByteState();\r\n            newByteState.setIndeterminatePrefix(state.hasIndeterminatePrefix());\r\n            // Stream will not be empty since trans has been verified as non-empty\r\n            SingleByteTransition single = trans.expand().iterator().next();\r\n            putTransitionNextState(state, characters[j], single, newByteState);\r\n            prevState = state;\r\n            state = newByteState;\r\n        }\r\n    }\r\n    // look for a chance to put in a shortcut transition.\r\n    // However, for the moment, we only do this for a JSON string match i.e beginning with \", not literals\r\n    // like true or false or numbers, because if we do this for numbers produced by\r\n    // ComparableNumber.generate(), they can be messed up by addRangePattern.\r\n    if (SHORTCUT_MATCH_TYPES.contains(pattern.type())) {\r\n        // For exactly match, if it is last character already, we just put the real transition with match there.\r\n        if (j == (length - 1)) {\r\n            return insertMatch(characters, j, state, nameState, pattern, prevState);\r\n        } else if (isEligibleForShortcut) {\r\n            // If current character is not last character, create the shortcut transition with the next\r\n            ByteMatch byteMatch = new ByteMatch(pattern, nameState);\r\n            addTransition(state, characters[j], new ShortcutTransition().setMatch(byteMatch));\r\n            addMatchReferences(byteMatch);\r\n            return nameState;\r\n        }\r\n    }\r\n    // For other match type, keep the old logic to extend all characters to byte state path and put the match in the\r\n    // tail state.\r\n    for (; j < (length - 1); j++) {\r\n        ByteState nextByteState = findOrMakeNextByteState(state, prevState, characters, j, pattern);\r\n        prevState = state;\r\n        state = nextByteState;\r\n    }\r\n    return insertMatch(characters, length - 1, state, nameState, pattern, prevState);\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private static final Set<MatchType> SHORTCUT_MATCH_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(EXACT)));\n    private ByteMatch startStateMatch;\n        public static final class EmptyByteTransition extends SingleByteTransition {\r\n        static final EmptyByteTransition INSTANCE = new EmptyByteTransition();\r\n    \r\n        @Override\r\n        public ByteState getNextByteState() {\r\n            return null;\r\n        }\r\n    \r\n        @Override\r\n        public SingleByteTransition setNextByteState(ByteState nextState) {\r\n            return nextState;\r\n        }\r\n    \r\n        @Override\r\n        public ByteTransition getTransition(byte utf8byte) {\r\n            return null;\r\n        }\r\n    \r\n        @Override\r\n        public ByteTransition getTransitionForAllBytes() {\r\n            return null;\r\n        }\r\n    \r\n        @Override\r\n        public Set<ByteTransition> getTransitions() {\r\n            return Collections.emptySet();\r\n        }\r\n    \r\n        @Override\r\n        public ByteMatch getMatch() {\r\n            return null;\r\n        }\r\n    \r\n        @Override\r\n        public Set<ShortcutTransition> getShortcuts() {\r\n            return Collections.emptySet();\r\n        }\r\n    \r\n        @Override\r\n        public SingleByteTransition setMatch(ByteMatch match) {\r\n            return match;\r\n        }\r\n    \r\n        @Override\r\n        public void gatherObjects(Set<Object> objectSet) {\r\n            objectSet.add(this);\r\n        }\r\n    }\nprivate NameState addEndOfMatch(ByteState state, ByteState prevState, final InputCharacter[] characters, final int charIndex, final Patterns pattern, final NameState nameStateCandidate) {\r\n        final int length = characters.length;\r\n        NameState nameState = (nameStateCandidate == null) ? new NameState() : nameStateCandidate;\r\n        if ((length == 1) && isWildcard(characters[0])) {\r\n            // Only character is '*'. Make the start state a match so empty input is matched.\r\n            startStateMatch = new ByteMatch(pattern, nameState);\r\n            return nameState;\r\n        }\r\n        ByteTransition trans = getTransition(state, characters[charIndex]);\r\n        // If it is shortcut transition, we need do adjustment first.\r\n        if ((!trans.isEmpty()) && trans.isShortcutTrans()) {\r\n            ShortcutTransition shortcut = ((ShortcutTransition) (trans));\r\n            ByteMatch match = shortcut.getMatch();\r\n            // In add/delete rule path, match must not be null and must not have other match\r\n            assert (match != null) && SHORTCUT_MATCH_TYPES.contains(match.getPattern().type());\r\n            // If it is the same pattern, just return.\r\n            if (pattern.equals(match.getPattern())) {\r\n                return match.getNextNameState();\r\n            }\r\n            // Have asserted current match pattern must be value patterns\r\n            String valueInCurrentPos = ((ValuePatterns) (match.getPattern())).pattern();\r\n            final InputCharacter[] charactersInCurrentPos = getParser().parse(match.getPattern().type(), valueInCurrentPos);\r\n            // find the position <m> where the common prefix ends.\r\n            int m = charIndex;\r\n            for (; (m < charactersInCurrentPos.length) && (m < length); m++) {\r\n                if (!charactersInCurrentPos[m].equals(characters[m])) {\r\n                    break;\r\n                }\r\n            }\r\n            // Extend the prefix part in value to byte transitions, to avoid impact on concurrent read we need firstly\r\n            // make the new byte chain ready for using and leave the old transition removing to the last step.\r\n            // firstNewState will be head of new byte chain and, to avoid impact on concurrent match traffic in read\r\n            // path, it need be linked to current state chain after adjustment done.\r\n            ByteState firstNewState = null;\r\n            ByteState currentState = state;\r\n            for (int k = charIndex; k < m; k++) {\r\n                // we need keep the current state always pointed to last character.\r\n                if (k != (charactersInCurrentPos.length - 1)) {\r\n                    final ByteState newByteState = new ByteState();\r\n                    newByteState.setIndeterminatePrefix(currentState.hasIndeterminatePrefix());\r\n                    if (k != charIndex) {\r\n                        putTransitionNextState(currentState, charactersInCurrentPos[k], shortcut, newByteState);\r\n                    } else {\r\n                        firstNewState = newByteState;\r\n                    }\r\n                    currentState = newByteState;\r\n                }\r\n            }\r\n            // If it reached to last character, link the previous read transition in this character, else create\r\n            // shortcut transition. Note: at this time, the previous transition can still keep working.\r\n            boolean isShortcutNeeded = m < (charactersInCurrentPos.length - 1);\r\n            int indexToBeChange = (isShortcutNeeded) ? m : charactersInCurrentPos.length - 1;\r\n            putTransitionMatch(currentState, charactersInCurrentPos[indexToBeChange], isShortcutNeeded ? new ShortcutTransition() : EmptyByteTransition.INSTANCE, match);\r\n            removeTransition(currentState, charactersInCurrentPos[indexToBeChange], shortcut);\r\n            // At last, we link the new created chain to the byte state path, so no uncompleted change can be felt by\r\n            // reading thread. Note: we already confirmed there is only old shortcut transition at charIndex position,\r\n            // now we have move it to new position, so we can directly replace previous transition with new transition\r\n            // pointed to new byte state chain.\r\n            putTransitionNextState(state, characters[charIndex], shortcut, firstNewState);\r\n        }\r\n        // If there is a exact match transition on tail of path, after adjustment target transitions, we start\r\n        // looking at current remaining characters.\r\n        // If this is tail transition, go directly analyse the remaining characters, traverse to tail of chain:\r\n        boolean isEligibleForShortcut = true;\r\n        int j = charIndex;\r\n        for (; j < (length - 1); j++) {\r\n            // We do not want to re-use an existing state for the second last character in the case of a final-character\r\n            // wildcard pattern. In this case, we will have a self-referencing composite match state, which allows zero\r\n            // or many character to satisfy the wildcard. The self-reference would lead to unintended matches for the\r\n            // existing patterns.\r\n            if ((j == (length - 2)) && isWildcard(characters[j + 1])) {\r\n                break;\r\n            }\r\n            trans = getTransition(state, characters[j]);\r\n            if (trans.isEmpty()) {\r\n                break;\r\n            }\r\n            ByteState nextByteState = trans.getNextByteState();\r\n            if (nextByteState != null) {\r\n                // We cannot re-use a state with an indeterminate prefix without creating unintended matches.\r\n                if (nextByteState.hasIndeterminatePrefix()) {\r\n                    // Since there is more path we are unable to traverse, this means we cannot insert shortcut without\r\n                    // potentially ignoring matches further down path.\r\n                    isEligibleForShortcut = false;\r\n                    break;\r\n                }\r\n                prevState = state;\r\n                state = nextByteState;\r\n            } else {\r\n                // trans has match but no next state, we need prepare a next next state to add trans for either last\r\n                // character or shortcut byte.\r\n                final ByteState newByteState = new ByteState();\r\n                newByteState.setIndeterminatePrefix(state.hasIndeterminatePrefix());\r\n                // Stream will not be empty since trans has been verified as non-empty\r\n                SingleByteTransition single = trans.expand().iterator().next();\r\n                putTransitionNextState(state, characters[j], single, newByteState);\r\n                prevState = state;\r\n                state = newByteState;\r\n            }\r\n        }\r\n        // look for a chance to put in a shortcut transition.\r\n        // However, for the moment, we only do this for a JSON string match i.e beginning with \", not literals\r\n        // like true or false or numbers, because if we do this for numbers produced by\r\n        // ComparableNumber.generate(), they can be messed up by addRangePattern.\r\n        if (SHORTCUT_MATCH_TYPES.contains(pattern.type())) {\r\n            // For exactly match, if it is last character already, we just put the real transition with match there.\r\n            if (j == (length - 1)) {\r\n                return insertMatch(characters, j, state, nameState, pattern, prevState);\r\n            } else if (isEligibleForShortcut) {\r\n                // If current character is not last character, create the shortcut transition with the next\r\n                ByteMatch byteMatch = new ByteMatch(pattern, nameState);\r\n                addTransition(state, characters[j], new ShortcutTransition().setMatch(byteMatch));\r\n                addMatchReferences(byteMatch);\r\n                return nameState;\r\n            }\r\n        }\r\n        // For other match type, keep the old logic to extend all characters to byte state path and put the match in the\r\n        // tail state.\r\n        for (; j < (length - 1); j++) {\r\n            ByteState nextByteState = findOrMakeNextByteState(state, prevState, characters, j, pattern);\r\n            prevState = state;\r\n            state = nextByteState;\r\n        }\r\n        return insertMatch(characters, length - 1, state, nameState, pattern, prevState);\r\n    }\nprivate void addMatchReferences(ByteMatch match);\n    NameState addPattern(final Patterns pattern);\n    private static void addTransition(ByteState state, InputCharacter character, SingleByteTransition transition);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    private ByteState findOrMakeNextByteState(ByteState state, ByteState prevState, final InputCharacter[] characters, int currentIndex, Patterns pattern);\n    NameState findPattern(final Patterns pattern);\n    public void gatherObjects(Set<Object> objectSet);\n    private static ByteTransition getTransition(ByteTransition trans, byte b);\n    private static ByteTransition getTransition(SingleByteTransition trans, InputCharacter character);\n    private NameState insertMatch(InputCharacter[] characters, int currentIndex, ByteState state, NameState nextNameState, Patterns pattern, ByteState prevState);\n    boolean isEmpty();\n    private static boolean isWildcard(InputCharacter character);\n    private static SingleByteTransition putTransitionMatch(ByteState state, InputCharacter character, SingleByteTransition transition, ByteMatch match);\n    private static void putTransitionNextState(ByteState state, InputCharacter character, SingleByteTransition transition, ByteState nextState);\n    private static void removeTransition(ByteState state, InputCharacter character, SingleByteTransition transition);\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "JsonRuleCompiler_processMatchExpression",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.JsonRuleCompiler",
        "test-class": "software.amazon.event.ruler.JsonRuleCompiler_processMatchExpression_Test",
        "method-name": "processMatchExpression(JsonParser)",
        "source-path": "src/main/java/software/amazon/event/ruler/JsonRuleCompiler.java",
        "test-path": "src/test/java/software/amazon/event/ruler/JsonRuleCompiler_processMatchExpression_Test.java",
        "focal-method": "private static Patterns processMatchExpression(final JsonParser parser) throws IOException {\r\n    final JsonToken matchTypeToken = parser.nextToken();\r\n    if (matchTypeToken != JsonToken.FIELD_NAME) {\r\n        barf(parser, \"Match expression name not found\");\r\n    }\r\n    final String matchTypeName = parser.getCurrentName();\r\n    if (Constants.EXACT_MATCH.equals(matchTypeName)) {\r\n        final JsonToken prefixToken = parser.nextToken();\r\n        if (prefixToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"exact match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.exactMatch(('\"' + parser.getText()) + '\"');\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.PREFIX_MATCH.equals(matchTypeName)) {\r\n        final JsonToken prefixToken = parser.nextToken();\r\n        if (prefixToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"prefix match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.prefixMatch('\"' + parser.getText());// note no trailing quote\r\n\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.SUFFIX_MATCH.equals(matchTypeName)) {\r\n        final JsonToken suffixToken = parser.nextToken();\r\n        if (suffixToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"suffix match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.suffixMatch(parser.getText() + '\"');// note no beginning quote\r\n\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.NUMERIC.equals(matchTypeName)) {\r\n        final JsonToken numericalExpressionToken = parser.nextToken();\r\n        if (numericalExpressionToken != JsonToken.START_ARRAY) {\r\n            barf(parser, (\"Value of \" + Constants.NUMERIC) + \" must be an array.\");\r\n        }\r\n        Patterns range = processNumericMatchExpression(parser);\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            tooManyElements(parser);\r\n        }\r\n        return range;\r\n    } else if (Constants.ANYTHING_BUT_MATCH.equals(matchTypeName)) {\r\n        boolean isIgnoreCase = false;\r\n        JsonToken anythingButExpressionToken = parser.nextToken();\r\n        if (anythingButExpressionToken == JsonToken.START_OBJECT) {\r\n            // there are a limited set of things we can apply Anything-But to\r\n            final JsonToken anythingButObject = parser.nextToken();\r\n            if (anythingButObject != JsonToken.FIELD_NAME) {\r\n                barf(parser, \"Anything-But expression name not found\");\r\n            }\r\n            final String anythingButObjectOp = parser.getCurrentName();\r\n            final boolean isPrefix = Constants.PREFIX_MATCH.equals(anythingButObjectOp);\r\n            final boolean isSuffix = Constants.SUFFIX_MATCH.equals(anythingButObjectOp);\r\n            isIgnoreCase = Constants.EQUALS_IGNORE_CASE.equals(anythingButObjectOp);\r\n            if (!isIgnoreCase) {\r\n                if ((!isPrefix) && (!isSuffix)) {\r\n                    barf(parser, \"Unsupported anything-but pattern: \" + anythingButObjectOp);\r\n                }\r\n                final JsonToken anythingButParamType = parser.nextToken();\r\n                if (anythingButParamType != JsonToken.VALUE_STRING) {\r\n                    barf(parser, \"prefix/suffix match pattern must be a string\");\r\n                }\r\n                final String text = parser.getText();\r\n                if (text.isEmpty()) {\r\n                    barf(parser, \"Null prefix/suffix not allowed\");\r\n                }\r\n                if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                    barf(parser, \"Only one key allowed in match expression\");\r\n                }\r\n                if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                    barf(parser, \"Only one key allowed in match expression\");\r\n                }\r\n                if (isPrefix) {\r\n                    return Patterns.anythingButPrefix('\"' + text);// note no trailing quote\r\n\r\n                } else {\r\n                    return Patterns.anythingButSuffix(text + '\"');// note no leading quote\r\n\r\n                }\r\n            } else {\r\n                // Step into anything-but's equals-ignore-case\r\n                anythingButExpressionToken = parser.nextToken();\r\n            }\r\n        }\r\n        if ((((anythingButExpressionToken != JsonToken.START_ARRAY) && (anythingButExpressionToken != JsonToken.VALUE_STRING)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_FLOAT)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_INT)) {\r\n            barf(parser, (\"Value of \" + Constants.ANYTHING_BUT_MATCH) + \" must be an array or single string/number value.\");\r\n        }\r\n        Patterns anythingBut;\r\n        if (anythingButExpressionToken == JsonToken.START_ARRAY) {\r\n            if (isIgnoreCase) {\r\n                anythingBut = processAnythingButEqualsIgnoreCaseListMatchExpression(parser);\r\n            } else {\r\n                anythingBut = processAnythingButListMatchExpression(parser);\r\n            }\r\n        } else if (isIgnoreCase) {\r\n            anythingBut = processAnythingButEqualsIgnoreCaseMatchExpression(parser, anythingButExpressionToken);\r\n        } else {\r\n            anythingBut = processAnythingButMatchExpression(parser, anythingButExpressionToken);\r\n        }\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            tooManyElements(parser);\r\n        }\r\n        // Complete the object closure for equals-ignore-case\r\n        if (isIgnoreCase && (parser.nextToken() != JsonToken.END_OBJECT)) {\r\n            tooManyElements(parser);\r\n        }\r\n        return anythingBut;\r\n    } else if (Constants.EXISTS_MATCH.equals(matchTypeName)) {\r\n        return processExistsExpression(parser);\r\n    } else if (Constants.CIDR.equals(matchTypeName)) {\r\n        final JsonToken cidrToken = parser.nextToken();\r\n        if (cidrToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"prefix match pattern must be a string\");\r\n        }\r\n        final Range cidr = CIDR.cidr(parser.getText());\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return cidr;\r\n    } else if (Constants.EQUALS_IGNORE_CASE.equals(matchTypeName)) {\r\n        final JsonToken equalsIgnoreCaseToken = parser.nextToken();\r\n        if (equalsIgnoreCaseToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"equals-ignore-case match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.equalsIgnoreCaseMatch(('\"' + parser.getText()) + '\"');\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.WILDCARD.equals(matchTypeName)) {\r\n        final JsonToken wildcardToken = parser.nextToken();\r\n        if (wildcardToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"wildcard match pattern must be a string\");\r\n        }\r\n        final String parserText = parser.getText();\r\n        final Patterns pattern = Patterns.wildcardMatch(('\"' + parserText) + '\"');\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else {\r\n        barf(parser, \"Unrecognized match type \" + matchTypeName);\r\n        return null;// unreachable statement, but java can't see that?\r\n\r\n    }\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport java.util.stream.Collectors;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport java.io.Reader;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashSet;\npublic class JsonRuleCompiler {\n    \n    private static Patterns processMatchExpression(final JsonParser parser) throws IOException {\r\n        final JsonToken matchTypeToken = parser.nextToken();\r\n        if (matchTypeToken != JsonToken.FIELD_NAME) {\r\n            barf(parser, \"Match expression name not found\");\r\n        }\r\n        final String matchTypeName = parser.getCurrentName();\r\n        if (Constants.EXACT_MATCH.equals(matchTypeName)) {\r\n            final JsonToken prefixToken = parser.nextToken();\r\n            if (prefixToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"exact match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.exactMatch(('\"' + parser.getText()) + '\"');\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.PREFIX_MATCH.equals(matchTypeName)) {\r\n            final JsonToken prefixToken = parser.nextToken();\r\n            if (prefixToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"prefix match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.prefixMatch('\"' + parser.getText());// note no trailing quote\r\n    \r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.SUFFIX_MATCH.equals(matchTypeName)) {\r\n            final JsonToken suffixToken = parser.nextToken();\r\n            if (suffixToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"suffix match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.suffixMatch(parser.getText() + '\"');// note no beginning quote\r\n    \r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.NUMERIC.equals(matchTypeName)) {\r\n            final JsonToken numericalExpressionToken = parser.nextToken();\r\n            if (numericalExpressionToken != JsonToken.START_ARRAY) {\r\n                barf(parser, (\"Value of \" + Constants.NUMERIC) + \" must be an array.\");\r\n            }\r\n            Patterns range = processNumericMatchExpression(parser);\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                tooManyElements(parser);\r\n            }\r\n            return range;\r\n        } else if (Constants.ANYTHING_BUT_MATCH.equals(matchTypeName)) {\r\n            boolean isIgnoreCase = false;\r\n            JsonToken anythingButExpressionToken = parser.nextToken();\r\n            if (anythingButExpressionToken == JsonToken.START_OBJECT) {\r\n                // there are a limited set of things we can apply Anything-But to\r\n                final JsonToken anythingButObject = parser.nextToken();\r\n                if (anythingButObject != JsonToken.FIELD_NAME) {\r\n                    barf(parser, \"Anything-But expression name not found\");\r\n                }\r\n                final String anythingButObjectOp = parser.getCurrentName();\r\n                final boolean isPrefix = Constants.PREFIX_MATCH.equals(anythingButObjectOp);\r\n                final boolean isSuffix = Constants.SUFFIX_MATCH.equals(anythingButObjectOp);\r\n                isIgnoreCase = Constants.EQUALS_IGNORE_CASE.equals(anythingButObjectOp);\r\n                if (!isIgnoreCase) {\r\n                    if ((!isPrefix) && (!isSuffix)) {\r\n                        barf(parser, \"Unsupported anything-but pattern: \" + anythingButObjectOp);\r\n                    }\r\n                    final JsonToken anythingButParamType = parser.nextToken();\r\n                    if (anythingButParamType != JsonToken.VALUE_STRING) {\r\n                        barf(parser, \"prefix/suffix match pattern must be a string\");\r\n                    }\r\n                    final String text = parser.getText();\r\n                    if (text.isEmpty()) {\r\n                        barf(parser, \"Null prefix/suffix not allowed\");\r\n                    }\r\n                    if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                        barf(parser, \"Only one key allowed in match expression\");\r\n                    }\r\n                    if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                        barf(parser, \"Only one key allowed in match expression\");\r\n                    }\r\n                    if (isPrefix) {\r\n                        return Patterns.anythingButPrefix('\"' + text);// note no trailing quote\r\n    \r\n                    } else {\r\n                        return Patterns.anythingButSuffix(text + '\"');// note no leading quote\r\n    \r\n                    }\r\n                } else {\r\n                    // Step into anything-but's equals-ignore-case\r\n                    anythingButExpressionToken = parser.nextToken();\r\n                }\r\n            }\r\n            if ((((anythingButExpressionToken != JsonToken.START_ARRAY) && (anythingButExpressionToken != JsonToken.VALUE_STRING)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_FLOAT)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_INT)) {\r\n                barf(parser, (\"Value of \" + Constants.ANYTHING_BUT_MATCH) + \" must be an array or single string/number value.\");\r\n            }\r\n            Patterns anythingBut;\r\n            if (anythingButExpressionToken == JsonToken.START_ARRAY) {\r\n                if (isIgnoreCase) {\r\n                    anythingBut = processAnythingButEqualsIgnoreCaseListMatchExpression(parser);\r\n                } else {\r\n                    anythingBut = processAnythingButListMatchExpression(parser);\r\n                }\r\n            } else if (isIgnoreCase) {\r\n                anythingBut = processAnythingButEqualsIgnoreCaseMatchExpression(parser, anythingButExpressionToken);\r\n            } else {\r\n                anythingBut = processAnythingButMatchExpression(parser, anythingButExpressionToken);\r\n            }\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                tooManyElements(parser);\r\n            }\r\n            // Complete the object closure for equals-ignore-case\r\n            if (isIgnoreCase && (parser.nextToken() != JsonToken.END_OBJECT)) {\r\n                tooManyElements(parser);\r\n            }\r\n            return anythingBut;\r\n        } else if (Constants.EXISTS_MATCH.equals(matchTypeName)) {\r\n            return processExistsExpression(parser);\r\n        } else if (Constants.CIDR.equals(matchTypeName)) {\r\n            final JsonToken cidrToken = parser.nextToken();\r\n            if (cidrToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"prefix match pattern must be a string\");\r\n            }\r\n            final Range cidr = CIDR.cidr(parser.getText());\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return cidr;\r\n        } else if (Constants.EQUALS_IGNORE_CASE.equals(matchTypeName)) {\r\n            final JsonToken equalsIgnoreCaseToken = parser.nextToken();\r\n            if (equalsIgnoreCaseToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"equals-ignore-case match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.equalsIgnoreCaseMatch(('\"' + parser.getText()) + '\"');\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.WILDCARD.equals(matchTypeName)) {\r\n            final JsonToken wildcardToken = parser.nextToken();\r\n            if (wildcardToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"wildcard match pattern must be a string\");\r\n            }\r\n            final String parserText = parser.getText();\r\n            final Patterns pattern = Patterns.wildcardMatch(('\"' + parserText) + '\"');\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else {\r\n            barf(parser, \"Unrecognized match type \" + matchTypeName);\r\n            return null;// unreachable statement, but java can't see that?\r\n    \r\n        }\r\n    }\nprivate static void barf(final JsonParser parser, final String message) throws JsonParseException;\n    public static String check(final byte[] source);\n    public static String check(final InputStream source);\n    public static String check(final Reader source);\n    public static String check(final String source);\n    public static List<Map<String, List<Patterns>>> compile(final byte[] source) throws IOException;\n    public static List<Map<String, List<Patterns>>> compile(final InputStream source) throws IOException;\n    public static List<Map<String, List<Patterns>>> compile(final Reader source) throws IOException;\n    public static List<Map<String, List<Patterns>>> compile(final String source) throws IOException;\n    private static Patterns processAnythingButEqualsIgnoreCaseListMatchExpression(JsonParser parser) throws JsonParseException;\n    private static Patterns processAnythingButEqualsIgnoreCaseMatchExpression(JsonParser parser, JsonToken anythingButExpressionToken) throws IOException;\n    private static Patterns processAnythingButListMatchExpression(JsonParser parser) throws JsonParseException;\n    private static Patterns processAnythingButMatchExpression(JsonParser parser, JsonToken anythingButExpressionToken) throws IOException;\n    private static Patterns processExistsExpression(final JsonParser parser) throws IOException;\n    private static Patterns processNumericMatchExpression(final JsonParser parser) throws IOException;\n    private static void tooManyElements(final JsonParser parser) throws JsonParseException;\n}"
      },
      {
        "id": "ByteMachine_addMatchReferences",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_addMatchReferences_Test",
        "method-name": "addMatchReferences(ByteMatch)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_addMatchReferences_Test.java",
        "focal-method": "private void addMatchReferences(ByteMatch match) {\r\n    Patterns pattern = match.getPattern();\r\n    switch (pattern.type()) {\r\n        case EXACT :\r\n        case PREFIX :\r\n        case EXISTS :\r\n        case EQUALS_IGNORE_CASE :\r\n        case WILDCARD :\r\n            break;\r\n        case SUFFIX :\r\n            hasSuffix.incrementAndGet();\r\n            break;\r\n        case NUMERIC_EQ :\r\n            hasNumeric.incrementAndGet();\r\n            break;\r\n        case NUMERIC_RANGE :\r\n            final Range range = ((Range) (pattern));\r\n            if (range.isCIDR) {\r\n                hasIP.incrementAndGet();\r\n            } else {\r\n                hasNumeric.incrementAndGet();\r\n            }\r\n            break;\r\n        case ANYTHING_BUT :\r\n            anythingButs.add(match.getNextNameState());\r\n            if (((AnythingBut) (pattern)).isNumeric()) {\r\n                hasNumeric.incrementAndGet();\r\n            }\r\n            break;\r\n        case ANYTHING_BUT_IGNORE_CASE :\r\n            anythingButs.add(match.getNextNameState());\r\n            break;\r\n        case ANYTHING_BUT_SUFFIX :\r\n            hasSuffix.incrementAndGet();\r\n            anythingButs.add(match.getNextNameState());\r\n            break;\r\n        case ANYTHING_BUT_PREFIX :\r\n            anythingButs.add(match.getNextNameState());\r\n            break;\r\n        default :\r\n            throw new AssertionError(\"Not implemented yet\");\r\n    }\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private final AtomicInteger hasNumeric = new AtomicInteger(0);\n    private final AtomicInteger hasIP = new AtomicInteger(0);\n    private final AtomicInteger hasSuffix = new AtomicInteger(0);\n    private final Set<NameState> anythingButs = ConcurrentHashMap.newKeySet();\n    private void addMatchReferences(ByteMatch match) {\r\n        Patterns pattern = match.getPattern();\r\n        switch (pattern.type()) {\r\n            case EXACT :\r\n            case PREFIX :\r\n            case EXISTS :\r\n            case EQUALS_IGNORE_CASE :\r\n            case WILDCARD :\r\n                break;\r\n            case SUFFIX :\r\n                hasSuffix.incrementAndGet();\r\n                break;\r\n            case NUMERIC_EQ :\r\n                hasNumeric.incrementAndGet();\r\n                break;\r\n            case NUMERIC_RANGE :\r\n                final Range range = ((Range) (pattern));\r\n                if (range.isCIDR) {\r\n                    hasIP.incrementAndGet();\r\n                } else {\r\n                    hasNumeric.incrementAndGet();\r\n                }\r\n                break;\r\n            case ANYTHING_BUT :\r\n                anythingButs.add(match.getNextNameState());\r\n                if (((AnythingBut) (pattern)).isNumeric()) {\r\n                    hasNumeric.incrementAndGet();\r\n                }\r\n                break;\r\n            case ANYTHING_BUT_IGNORE_CASE :\r\n                anythingButs.add(match.getNextNameState());\r\n                break;\r\n            case ANYTHING_BUT_SUFFIX :\r\n                hasSuffix.incrementAndGet();\r\n                anythingButs.add(match.getNextNameState());\r\n                break;\r\n            case ANYTHING_BUT_PREFIX :\r\n                anythingButs.add(match.getNextNameState());\r\n                break;\r\n            default :\r\n                throw new AssertionError(\"Not implemented yet\");\r\n        }\r\n    }\nNameState addPattern(final Patterns pattern);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    NameState findPattern(final Patterns pattern);\n    public void gatherObjects(Set<Object> objectSet);\n    boolean isEmpty();\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "JsonRuleCompiler_writeRules",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.JsonRuleCompiler",
        "test-class": "software.amazon.event.ruler.JsonRuleCompiler_writeRules_Test",
        "method-name": "writeRules(List<Map<String, List<Patterns>>>, String, JsonParser, boolean)",
        "source-path": "src/main/java/software/amazon/event/ruler/JsonRuleCompiler.java",
        "test-path": "src/test/java/software/amazon/event/ruler/JsonRuleCompiler_writeRules_Test.java",
        "focal-method": "private static void writeRules(final List<Map<String, List<Patterns>>> rules, final String name, final JsonParser parser, final boolean withQuotes) throws IOException {\r\n    JsonToken token;\r\n    final List<Patterns> values = new ArrayList<>();\r\n    while ((token = parser.nextToken()) != JsonToken.END_ARRAY) {\r\n        switch (token) {\r\n            case START_OBJECT :\r\n                values.add(processMatchExpression(parser));\r\n                break;\r\n            case VALUE_STRING :\r\n                final String toMatch = parser.getText();\r\n                final Range ipRange = CIDR.ipToRangeIfPossible(toMatch);\r\n                if (ipRange != null) {\r\n                    values.add(ipRange);\r\n                } else if (withQuotes) {\r\n                    values.add(Patterns.exactMatch(('\"' + toMatch) + '\"'));\r\n                } else {\r\n                    values.add(Patterns.exactMatch(toMatch));\r\n                }\r\n                break;\r\n            case VALUE_NUMBER_FLOAT :\r\n            case VALUE_NUMBER_INT :\r\n                /* If the rule specifies a match to a number, we'll insert matchers for both the\r\n                 literal expression and the ComparableNumber form. But the number might not\r\n                 be representable as a ComparableNumber, for example an AWS account number,\r\n                 so make that condition survivable.\r\n                 */\r\n                try {\r\n                    values.add(Patterns.numericEquals(parser.getDoubleValue()));\r\n                } catch (Exception e) {\r\n                    // no-op\r\n                }\r\n                values.add(Patterns.exactMatch(parser.getText()));\r\n                break;\r\n            case VALUE_NULL :\r\n            case VALUE_TRUE :\r\n            case VALUE_FALSE :\r\n                values.add(Patterns.exactMatch(parser.getText()));\r\n                break;\r\n            default :\r\n                barf(parser, \"Match value must be String, number, true, false, or null\");\r\n        }\r\n    } \r\n    if (values.isEmpty()) {\r\n        barf(parser, \"Empty arrays are not allowed\");\r\n    }\r\n    // If the rules list is empty, add the first rule\r\n    if (rules.isEmpty()) {\r\n        rules.add(new HashMap<>());\r\n    }\r\n    rules.forEach(rule -> rule.put(name, values));\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport java.util.stream.Collectors;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport java.io.Reader;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashSet;\npublic class JsonRuleCompiler {\n    \n    private static void writeRules(final List<Map<String, List<Patterns>>> rules, final String name, final JsonParser parser, final boolean withQuotes) throws IOException {\r\n        JsonToken token;\r\n        final List<Patterns> values = new ArrayList<>();\r\n        while ((token = parser.nextToken()) != JsonToken.END_ARRAY) {\r\n            switch (token) {\r\n                case START_OBJECT :\r\n                    values.add(processMatchExpression(parser));\r\n                    break;\r\n                case VALUE_STRING :\r\n                    final String toMatch = parser.getText();\r\n                    final Range ipRange = CIDR.ipToRangeIfPossible(toMatch);\r\n                    if (ipRange != null) {\r\n                        values.add(ipRange);\r\n                    } else if (withQuotes) {\r\n                        values.add(Patterns.exactMatch(('\"' + toMatch) + '\"'));\r\n                    } else {\r\n                        values.add(Patterns.exactMatch(toMatch));\r\n                    }\r\n                    break;\r\n                case VALUE_NUMBER_FLOAT :\r\n                case VALUE_NUMBER_INT :\r\n                    /* If the rule specifies a match to a number, we'll insert matchers for both the\r\n                     literal expression and the ComparableNumber form. But the number might not\r\n                     be representable as a ComparableNumber, for example an AWS account number,\r\n                     so make that condition survivable.\r\n                     */\r\n                    try {\r\n                        values.add(Patterns.numericEquals(parser.getDoubleValue()));\r\n                    } catch (Exception e) {\r\n                        // no-op\r\n                    }\r\n                    values.add(Patterns.exactMatch(parser.getText()));\r\n                    break;\r\n                case VALUE_NULL :\r\n                case VALUE_TRUE :\r\n                case VALUE_FALSE :\r\n                    values.add(Patterns.exactMatch(parser.getText()));\r\n                    break;\r\n                default :\r\n                    barf(parser, \"Match value must be String, number, true, false, or null\");\r\n            }\r\n        } \r\n        if (values.isEmpty()) {\r\n            barf(parser, \"Empty arrays are not allowed\");\r\n        }\r\n        // If the rules list is empty, add the first rule\r\n        if (rules.isEmpty()) {\r\n            rules.add(new HashMap<>());\r\n        }\r\n        rules.forEach(rule -> rule.put(name, values));\r\n    }\nprivate static void barf(final JsonParser parser, final String message) throws JsonParseException;\n    public static String check(final byte[] source);\n    public static String check(final InputStream source);\n    public static String check(final Reader source);\n    public static String check(final String source);\n    public static List<Map<String, List<Patterns>>> compile(final byte[] source) throws IOException;\n    public static List<Map<String, List<Patterns>>> compile(final InputStream source) throws IOException;\n    public static List<Map<String, List<Patterns>>> compile(final Reader source) throws IOException;\n    public static List<Map<String, List<Patterns>>> compile(final String source) throws IOException;\n    private static Patterns processMatchExpression(final JsonParser parser) throws IOException;\n}"
      },
      {
        "id": "Ruler_matches",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.Ruler",
        "test-class": "software.amazon.event.ruler.Ruler_matches_Test",
        "method-name": "matches(JsonNode, Patterns)",
        "source-path": "src/main/java/software/amazon/event/ruler/Ruler.java",
        "test-path": "src/test/java/software/amazon/event/ruler/Ruler_matches_Test.java",
        "focal-method": "private static boolean matches(final JsonNode val, final Patterns pattern) {\r\n    switch (pattern.type()) {\r\n        case EXACT :\r\n            ValuePatterns valuePattern = ((ValuePatterns) (pattern));\r\n            // if it's a string we match the \"-quoted form, otherwise (true, false, null) as-is.\r\n            final String compareTo = (val.isTextual()) ? ('\"' + val.asText()) + '\"' : val.asText();\r\n            return compareTo.equals(valuePattern.pattern());\r\n        case PREFIX :\r\n            valuePattern = ((ValuePatterns) (pattern));\r\n            return val.isTextual() && ('\"' + val.asText()).startsWith(valuePattern.pattern());\r\n        case ANYTHING_BUT :\r\n            assert pattern instanceof AnythingBut;\r\n            AnythingBut anythingButPattern = ((AnythingBut) (pattern));\r\n            if (val.isTextual()) {\r\n                return anythingButPattern.getValues().stream().noneMatch(v -> v.equals(('\"' + val.asText()) + '\"'));\r\n            } else if (val.isNumber()) {\r\n                return anythingButPattern.getValues().stream().noneMatch(v -> v.equals(ComparableNumber.generate(val.asDouble())));\r\n            }\r\n            return false;\r\n        case ANYTHING_BUT_IGNORE_CASE :\r\n            assert pattern instanceof AnythingButEqualsIgnoreCase;\r\n            AnythingButEqualsIgnoreCase anythingButIgnoreCasePattern = ((AnythingButEqualsIgnoreCase) (pattern));\r\n            if (val.isTextual()) {\r\n                return anythingButIgnoreCasePattern.getValues().stream().noneMatch(v -> v.equalsIgnoreCase(('\"' + val.asText()) + '\"'));\r\n            }\r\n            return false;\r\n        case ANYTHING_BUT_SUFFIX :\r\n            valuePattern = ((ValuePatterns) (pattern));\r\n            return !(val.isTextual() && (val.asText() + '\"').startsWith(valuePattern.pattern()));\r\n        case ANYTHING_BUT_PREFIX :\r\n            valuePattern = ((ValuePatterns) (pattern));\r\n            return !(val.isTextual() && ('\"' + val.asText()).startsWith(valuePattern.pattern()));\r\n        case NUMERIC_EQ :\r\n            valuePattern = ((ValuePatterns) (pattern));\r\n            return val.isNumber() && ComparableNumber.generate(val.asDouble()).equals(valuePattern.pattern());\r\n        case EXISTS :\r\n            return true;\r\n        case ABSENT :\r\n            return false;\r\n        case NUMERIC_RANGE :\r\n            final Range nr = ((Range) (pattern));\r\n            byte[] bytes;\r\n            if (nr.isCIDR) {\r\n                if (!val.isTextual()) {\r\n                    return false;\r\n                }\r\n                try {\r\n                    bytes = CIDR.ipToString(val.asText()).getBytes(StandardCharsets.UTF_8);\r\n                } catch (Exception e) {\r\n                    return false;\r\n                }\r\n            } else {\r\n                if (!val.isNumber()) {\r\n                    return false;\r\n                }\r\n                bytes = ComparableNumber.generate(val.asDouble()).getBytes(StandardCharsets.UTF_8);\r\n            }\r\n            final int comparedToBottom = compare(bytes, nr.bottom);\r\n            if ((comparedToBottom > 0) || ((comparedToBottom == 0) && (!nr.openBottom))) {\r\n                final int comparedToTop = compare(bytes, nr.top);\r\n                return (comparedToTop < 0) || ((comparedToTop == 0) && (!nr.openTop));\r\n            }\r\n            return false;\r\n        case EQUALS_IGNORE_CASE :\r\n            valuePattern = ((ValuePatterns) (pattern));\r\n            return val.isTextual() && (('\"' + val.asText()) + '\"').equalsIgnoreCase(valuePattern.pattern());\r\n        case WILDCARD :\r\n            valuePattern = ((ValuePatterns) (pattern));\r\n            return val.isTextual() && (('\"' + val.asText()) + '\"').matches(valuePattern.pattern().replaceAll(\"\\\\*\", \".*\"));\r\n        default :\r\n            throw new RuntimeException(\"Unsupported Pattern type \" + pattern.type());\r\n    }\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport java.nio.charset.StandardCharsets;\nimport java.io.IOException;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.List;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport java.util.Map;\nimport javax.annotation.concurrent.Immutable;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n@ThreadSafe\r\n@Immutable\r\npublic class Ruler {\n    \n    private static boolean matches(final JsonNode val, final Patterns pattern) {\r\n        switch (pattern.type()) {\r\n            case EXACT :\r\n                ValuePatterns valuePattern = ((ValuePatterns) (pattern));\r\n                // if it's a string we match the \"-quoted form, otherwise (true, false, null) as-is.\r\n                final String compareTo = (val.isTextual()) ? ('\"' + val.asText()) + '\"' : val.asText();\r\n                return compareTo.equals(valuePattern.pattern());\r\n            case PREFIX :\r\n                valuePattern = ((ValuePatterns) (pattern));\r\n                return val.isTextual() && ('\"' + val.asText()).startsWith(valuePattern.pattern());\r\n            case ANYTHING_BUT :\r\n                assert pattern instanceof AnythingBut;\r\n                AnythingBut anythingButPattern = ((AnythingBut) (pattern));\r\n                if (val.isTextual()) {\r\n                    return anythingButPattern.getValues().stream().noneMatch(v -> v.equals(('\"' + val.asText()) + '\"'));\r\n                } else if (val.isNumber()) {\r\n                    return anythingButPattern.getValues().stream().noneMatch(v -> v.equals(ComparableNumber.generate(val.asDouble())));\r\n                }\r\n                return false;\r\n            case ANYTHING_BUT_IGNORE_CASE :\r\n                assert pattern instanceof AnythingButEqualsIgnoreCase;\r\n                AnythingButEqualsIgnoreCase anythingButIgnoreCasePattern = ((AnythingButEqualsIgnoreCase) (pattern));\r\n                if (val.isTextual()) {\r\n                    return anythingButIgnoreCasePattern.getValues().stream().noneMatch(v -> v.equalsIgnoreCase(('\"' + val.asText()) + '\"'));\r\n                }\r\n                return false;\r\n            case ANYTHING_BUT_SUFFIX :\r\n                valuePattern = ((ValuePatterns) (pattern));\r\n                return !(val.isTextual() && (val.asText() + '\"').startsWith(valuePattern.pattern()));\r\n            case ANYTHING_BUT_PREFIX :\r\n                valuePattern = ((ValuePatterns) (pattern));\r\n                return !(val.isTextual() && ('\"' + val.asText()).startsWith(valuePattern.pattern()));\r\n            case NUMERIC_EQ :\r\n                valuePattern = ((ValuePatterns) (pattern));\r\n                return val.isNumber() && ComparableNumber.generate(val.asDouble()).equals(valuePattern.pattern());\r\n            case EXISTS :\r\n                return true;\r\n            case ABSENT :\r\n                return false;\r\n            case NUMERIC_RANGE :\r\n                final Range nr = ((Range) (pattern));\r\n                byte[] bytes;\r\n                if (nr.isCIDR) {\r\n                    if (!val.isTextual()) {\r\n                        return false;\r\n                    }\r\n                    try {\r\n                        bytes = CIDR.ipToString(val.asText()).getBytes(StandardCharsets.UTF_8);\r\n                    } catch (Exception e) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!val.isNumber()) {\r\n                        return false;\r\n                    }\r\n                    bytes = ComparableNumber.generate(val.asDouble()).getBytes(StandardCharsets.UTF_8);\r\n                }\r\n                final int comparedToBottom = compare(bytes, nr.bottom);\r\n                if ((comparedToBottom > 0) || ((comparedToBottom == 0) && (!nr.openBottom))) {\r\n                    final int comparedToTop = compare(bytes, nr.top);\r\n                    return (comparedToTop < 0) || ((comparedToTop == 0) && (!nr.openTop));\r\n                }\r\n                return false;\r\n            case EQUALS_IGNORE_CASE :\r\n                valuePattern = ((ValuePatterns) (pattern));\r\n                return val.isTextual() && (('\"' + val.asText()) + '\"').equalsIgnoreCase(valuePattern.pattern());\r\n            case WILDCARD :\r\n                valuePattern = ((ValuePatterns) (pattern));\r\n                return val.isTextual() && (('\"' + val.asText()) + '\"').matches(valuePattern.pattern().replaceAll(\"\\\\*\", \".*\"));\r\n            default :\r\n                throw new RuntimeException(\"Unsupported Pattern type \" + pattern.type());\r\n        }\r\n    }\nstatic int compare(final byte[] a, final byte[] b);\n    public static boolean matchesRule(final String event, final String rule) throws Exception;\n    static JsonNode tryToRetrievePath(JsonNode node, final List<String> path);\n}"
      },
      {
        "id": "ByteMachine_addRangePattern",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_addRangePattern_Test",
        "method-name": "addRangePattern(Range)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_addRangePattern_Test.java",
        "focal-method": "private NameState addRangePattern(final Range range) {\r\n    // we prepare for one new NameSate here which will be used for range match to point to next NameSate.\r\n    // however, it will not be used if match is already existing. in that case, we will reuse NameSate\r\n    // from that match.\r\n    NameState nextNameState = new NameState();\r\n    ByteState forkState = startState;\r\n    int forkOffset = 0;\r\n    // bypass common prefix of range's bottom and top patterns\r\n    while (range.bottom[forkOffset] == range.top[forkOffset]) {\r\n        forkState = findOrMakeNextByteStateForRangePattern(forkState, range.bottom, forkOffset++);\r\n    } \r\n    // now we've bypassed any initial positions where the top and bottom patterns are the same, and arrived\r\n    // at a position where the 'top' and 'bottom' bytes differ. Such a position must occur because we require\r\n    // that the bottom number be strictly less than the top number.  Let's call the current state the fork state.\r\n    // At the fork state, any byte between the top and bottom byte values means success, the value must be strictly\r\n    // greater than bottom and less than top.  That leaves the transitions for the bottom and top values.\r\n    // After the fork state, we arrive at a state where any digit greater than the next bottom value\r\n    // means success, because after the fork state we are already strictly less than the top value, and we\r\n    // know then that we are greater than the bottom value.  A digit equal to the bottom value leads us\r\n    // to another state where the same applies; anything greater than the bottom value is success.  Finally,\r\n    // when we come to the last digit, as before, anything greater than the bottom value is success, and\r\n    // being equal to the bottom value means failure if the interval is open, because the value is strictly\r\n    // equal to the bottom of the range.\r\n    // Following the top-byte transition out of the fork state leads to a state where the story is reversed;\r\n    // any digit lower than the top value means success, successive matches to the top value lead to similar\r\n    // states, and a final byte that matches the top value means failure if the interval is open at the top.\r\n    // There is a further complication. Consider the case [ > 00299 < 00500 ].  The machine we need to\r\n    // build is like this:\r\n    // State0 =0=> State1 ; State1 =0=> State2 ; State2 =3=> MATCH ; State2 =4=> MATCH\r\n    // That's it. Once you've seen 002 in the input, there's nothing that can follow that will be\r\n    // strictly greater than the remaining 299.  Once you've seen 005 there's nothing that can\r\n    // follow that will be strictly less than the remaining 500\r\n    // But this only works when the suffix of the bottom range pattern is all 9's or if the suffix of the\r\n    // top range pattern is all 0's\r\n    // What could be simpler?\r\n    // fill in matches in the fork state\r\n    for (byte bb : Range.digitSequence(range.bottom[forkOffset], range.top[forkOffset], false, false)) {\r\n        nextNameState = insertMatchForRangePattern(bb, forkState, nextNameState, range);\r\n    }\r\n    // process all the transitions on the bottom range bytes\r\n    ByteState state = forkState;\r\n    // lastMatchOffset is the last offset where we know we have to put in a match\r\n    int lastMatchOffset = forkOffset;\r\n    for (int offsetB = forkOffset + 1; offsetB < (range.bottom.length - 1); offsetB++) {\r\n        // if b is Constants.MAX_DIGIT, then we should hold off adding transitions until we see a non-maxDigit digit\r\n        // because of the special case described above.\r\n        byte b = range.bottom[offsetB];\r\n        if (b < Constants.MAX_DIGIT) {\r\n            // add transitions for any 9's we bypassed\r\n            while (lastMatchOffset < offsetB) {\r\n                state = findOrMakeNextByteStateForRangePattern(state, range.bottom, lastMatchOffset++);\r\n            } \r\n            assert lastMatchOffset == offsetB : \"lastMatchOffset == offsetB\";\r\n            assert state != null : \"state != null\";\r\n            // now add transitions for values greater than this non-9 digit\r\n            for (byte bb : Range.digitSequence(b, Constants.MAX_DIGIT, false, true)) {\r\n                nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n            }\r\n        }\r\n    }\r\n    // now for last \"bottom\" digit\r\n    final byte lastBottom = range.bottom[range.bottom.length - 1];\r\n    final byte lastTop = range.top[range.top.length - 1];\r\n    // similarly, if the last digit is 9 and we have openBottom, there can be no matches so we're done.\r\n    if ((lastBottom < Constants.MAX_DIGIT) || (!range.openBottom)) {\r\n        // add transitions for any 9's we bypassed\r\n        while (lastMatchOffset < (range.bottom.length - 1)) {\r\n            state = findOrMakeNextByteStateForRangePattern(state, range.bottom, lastMatchOffset++);\r\n        } \r\n        assert lastMatchOffset == (range.bottom.length - 1) : \"lastMatchOffset == (range.bottom.length - 1)\";\r\n        assert state != null : \"state != null\";\r\n        // now we insert matches for possible values of last digit\r\n        if (!range.openBottom) {\r\n            nextNameState = insertMatchForRangePattern(lastBottom, state, nextNameState, range);\r\n        }\r\n        // unless the last digit is also at the fork position, fill in the extra matches due to\r\n        // the strictly-less-than condition (see discussion above)\r\n        if (forkOffset < (range.bottom.length - 1)) {\r\n            for (byte bb : Range.digitSequence(lastBottom, Constants.MAX_DIGIT, false, true)) {\r\n                nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n            }\r\n        }\r\n    }\r\n    // now process transitions along the top range bytes\r\n    // restore the state and last match offset to fork position to start analyzing top value bytes ...\r\n    state = forkState;\r\n    lastMatchOffset = forkOffset;\r\n    for (int offsetT = forkOffset + 1; offsetT < (range.top.length - 1); offsetT++) {\r\n        // if b is '0', we should hold off adding transitions until we see a non-'0' digit.\r\n        byte b = range.top[offsetT];\r\n        // if need to add transition\r\n        if (b > '0') {\r\n            while (lastMatchOffset < offsetT) {\r\n                state = findOrMakeNextByteStateForRangePattern(state, range.top, lastMatchOffset++);\r\n            } \r\n            assert lastMatchOffset == offsetT : \"lastMatchOffset == offsetT\";\r\n            assert state != null : \"state != null\";\r\n            // now add transitions for values less than this non-0 digit\r\n            for (byte bb : Range.digitSequence(((byte) ('0')), range.top[offsetT], true, false)) {\r\n                nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n            }\r\n        }\r\n    }\r\n    // now for last \"top\" digit\r\n    // similarly, if the last digit is 0 and we have openTop, there can be no matches so we're done.\r\n    if ((lastTop > '0') || (!range.openTop)) {\r\n        // add transitions for any 0's we bypassed\r\n        while (lastMatchOffset < (range.top.length - 1)) {\r\n            state = findOrMakeNextByteStateForRangePattern(state, range.top, lastMatchOffset++);\r\n        } \r\n        assert lastMatchOffset == (range.top.length - 1) : \"lastMatchOffset == (range.top.length - 1)\";\r\n        assert state != null : \"state != null\";\r\n        // now we insert matches for possible values of last digit\r\n        if (!range.openTop) {\r\n            nextNameState = insertMatchForRangePattern(lastTop, state, nextNameState, range);\r\n        }\r\n        // unless the last digit is also at the fork position, fill in the extra matches due to\r\n        // the strictly-less-than condition (see discussion above)\r\n        if (forkOffset < (range.top.length - 1)) {\r\n            for (byte bb : Range.digitSequence(((byte) ('0')), lastTop, true, false)) {\r\n                nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n            }\r\n        }\r\n    }\r\n    return nextNameState;\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private final ByteState startState = new ByteState();\n    private NameState addRangePattern(final Range range) {\r\n        // we prepare for one new NameSate here which will be used for range match to point to next NameSate.\r\n        // however, it will not be used if match is already existing. in that case, we will reuse NameSate\r\n        // from that match.\r\n        NameState nextNameState = new NameState();\r\n        ByteState forkState = startState;\r\n        int forkOffset = 0;\r\n        // bypass common prefix of range's bottom and top patterns\r\n        while (range.bottom[forkOffset] == range.top[forkOffset]) {\r\n            forkState = findOrMakeNextByteStateForRangePattern(forkState, range.bottom, forkOffset++);\r\n        } \r\n        // now we've bypassed any initial positions where the top and bottom patterns are the same, and arrived\r\n        // at a position where the 'top' and 'bottom' bytes differ. Such a position must occur because we require\r\n        // that the bottom number be strictly less than the top number.  Let's call the current state the fork state.\r\n        // At the fork state, any byte between the top and bottom byte values means success, the value must be strictly\r\n        // greater than bottom and less than top.  That leaves the transitions for the bottom and top values.\r\n        // After the fork state, we arrive at a state where any digit greater than the next bottom value\r\n        // means success, because after the fork state we are already strictly less than the top value, and we\r\n        // know then that we are greater than the bottom value.  A digit equal to the bottom value leads us\r\n        // to another state where the same applies; anything greater than the bottom value is success.  Finally,\r\n        // when we come to the last digit, as before, anything greater than the bottom value is success, and\r\n        // being equal to the bottom value means failure if the interval is open, because the value is strictly\r\n        // equal to the bottom of the range.\r\n        // Following the top-byte transition out of the fork state leads to a state where the story is reversed;\r\n        // any digit lower than the top value means success, successive matches to the top value lead to similar\r\n        // states, and a final byte that matches the top value means failure if the interval is open at the top.\r\n        // There is a further complication. Consider the case [ > 00299 < 00500 ].  The machine we need to\r\n        // build is like this:\r\n        // State0 =0=> State1 ; State1 =0=> State2 ; State2 =3=> MATCH ; State2 =4=> MATCH\r\n        // That's it. Once you've seen 002 in the input, there's nothing that can follow that will be\r\n        // strictly greater than the remaining 299.  Once you've seen 005 there's nothing that can\r\n        // follow that will be strictly less than the remaining 500\r\n        // But this only works when the suffix of the bottom range pattern is all 9's or if the suffix of the\r\n        // top range pattern is all 0's\r\n        // What could be simpler?\r\n        // fill in matches in the fork state\r\n        for (byte bb : Range.digitSequence(range.bottom[forkOffset], range.top[forkOffset], false, false)) {\r\n            nextNameState = insertMatchForRangePattern(bb, forkState, nextNameState, range);\r\n        }\r\n        // process all the transitions on the bottom range bytes\r\n        ByteState state = forkState;\r\n        // lastMatchOffset is the last offset where we know we have to put in a match\r\n        int lastMatchOffset = forkOffset;\r\n        for (int offsetB = forkOffset + 1; offsetB < (range.bottom.length - 1); offsetB++) {\r\n            // if b is Constants.MAX_DIGIT, then we should hold off adding transitions until we see a non-maxDigit digit\r\n            // because of the special case described above.\r\n            byte b = range.bottom[offsetB];\r\n            if (b < Constants.MAX_DIGIT) {\r\n                // add transitions for any 9's we bypassed\r\n                while (lastMatchOffset < offsetB) {\r\n                    state = findOrMakeNextByteStateForRangePattern(state, range.bottom, lastMatchOffset++);\r\n                } \r\n                assert lastMatchOffset == offsetB : \"lastMatchOffset == offsetB\";\r\n                assert state != null : \"state != null\";\r\n                // now add transitions for values greater than this non-9 digit\r\n                for (byte bb : Range.digitSequence(b, Constants.MAX_DIGIT, false, true)) {\r\n                    nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n                }\r\n            }\r\n        }\r\n        // now for last \"bottom\" digit\r\n        final byte lastBottom = range.bottom[range.bottom.length - 1];\r\n        final byte lastTop = range.top[range.top.length - 1];\r\n        // similarly, if the last digit is 9 and we have openBottom, there can be no matches so we're done.\r\n        if ((lastBottom < Constants.MAX_DIGIT) || (!range.openBottom)) {\r\n            // add transitions for any 9's we bypassed\r\n            while (lastMatchOffset < (range.bottom.length - 1)) {\r\n                state = findOrMakeNextByteStateForRangePattern(state, range.bottom, lastMatchOffset++);\r\n            } \r\n            assert lastMatchOffset == (range.bottom.length - 1) : \"lastMatchOffset == (range.bottom.length - 1)\";\r\n            assert state != null : \"state != null\";\r\n            // now we insert matches for possible values of last digit\r\n            if (!range.openBottom) {\r\n                nextNameState = insertMatchForRangePattern(lastBottom, state, nextNameState, range);\r\n            }\r\n            // unless the last digit is also at the fork position, fill in the extra matches due to\r\n            // the strictly-less-than condition (see discussion above)\r\n            if (forkOffset < (range.bottom.length - 1)) {\r\n                for (byte bb : Range.digitSequence(lastBottom, Constants.MAX_DIGIT, false, true)) {\r\n                    nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n                }\r\n            }\r\n        }\r\n        // now process transitions along the top range bytes\r\n        // restore the state and last match offset to fork position to start analyzing top value bytes ...\r\n        state = forkState;\r\n        lastMatchOffset = forkOffset;\r\n        for (int offsetT = forkOffset + 1; offsetT < (range.top.length - 1); offsetT++) {\r\n            // if b is '0', we should hold off adding transitions until we see a non-'0' digit.\r\n            byte b = range.top[offsetT];\r\n            // if need to add transition\r\n            if (b > '0') {\r\n                while (lastMatchOffset < offsetT) {\r\n                    state = findOrMakeNextByteStateForRangePattern(state, range.top, lastMatchOffset++);\r\n                } \r\n                assert lastMatchOffset == offsetT : \"lastMatchOffset == offsetT\";\r\n                assert state != null : \"state != null\";\r\n                // now add transitions for values less than this non-0 digit\r\n                for (byte bb : Range.digitSequence(((byte) ('0')), range.top[offsetT], true, false)) {\r\n                    nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n                }\r\n            }\r\n        }\r\n        // now for last \"top\" digit\r\n        // similarly, if the last digit is 0 and we have openTop, there can be no matches so we're done.\r\n        if ((lastTop > '0') || (!range.openTop)) {\r\n            // add transitions for any 0's we bypassed\r\n            while (lastMatchOffset < (range.top.length - 1)) {\r\n                state = findOrMakeNextByteStateForRangePattern(state, range.top, lastMatchOffset++);\r\n            } \r\n            assert lastMatchOffset == (range.top.length - 1) : \"lastMatchOffset == (range.top.length - 1)\";\r\n            assert state != null : \"state != null\";\r\n            // now we insert matches for possible values of last digit\r\n            if (!range.openTop) {\r\n                nextNameState = insertMatchForRangePattern(lastTop, state, nextNameState, range);\r\n            }\r\n            // unless the last digit is also at the fork position, fill in the extra matches due to\r\n            // the strictly-less-than condition (see discussion above)\r\n            if (forkOffset < (range.top.length - 1)) {\r\n                for (byte bb : Range.digitSequence(((byte) ('0')), lastTop, true, false)) {\r\n                    nextNameState = insertMatchForRangePattern(bb, state, nextNameState, range);\r\n                }\r\n            }\r\n        }\r\n        return nextNameState;\r\n    }\nNameState addPattern(final Patterns pattern);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    private ByteState findOrMakeNextByteStateForRangePattern(ByteState state, final byte[] utf8bytes, int currentIndex);\n    NameState findPattern(final Patterns pattern);\n    public void gatherObjects(Set<Object> objectSet);\n    private NameState insertMatchForRangePattern(byte b, ByteState state, NameState nextNameState, Patterns pattern);\n    boolean isEmpty();\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "MachineComplexityEvaluator_getMatchesAccessibleFromEachTransition",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.MachineComplexityEvaluator",
        "test-class": "software.amazon.event.ruler.MachineComplexityEvaluator_getMatchesAccessibleFromEachTransition_Test",
        "method-name": "getMatchesAccessibleFromEachTransition(ByteState)",
        "source-path": "src/main/java/software/amazon/event/ruler/MachineComplexityEvaluator.java",
        "test-path": "src/test/java/software/amazon/event/ruler/MachineComplexityEvaluator_getMatchesAccessibleFromEachTransition_Test.java",
        "focal-method": "private Map<SingleByteTransition, Set<ByteMatch>> getMatchesAccessibleFromEachTransition(ByteState state) {\r\n    Map<SingleByteTransition, Set<ByteMatch>> result = new HashMap<>();\r\n    Set<SingleByteTransition> visited = new HashSet<>();\r\n    Stack<SingleByteTransition> stack = new Stack<>();\r\n    stack.push(state);\r\n    // We'll do a depth-first-search as a state's matches can only be computed once the computation is complete for\r\n    // all deeper states. Let's avoid recursion, which is prone to stack overflow.\r\n    while (!stack.isEmpty()) {\r\n        // Peek instead of pop. Need this transition to remain on stack so we can compute its matches once all\r\n        // deeper states are complete.\r\n        SingleByteTransition transition = stack.peek();\r\n        if (!result.containsKey(transition)) {\r\n            result.put(transition, new HashSet<>());\r\n        }\r\n        Set<ByteMatch> matches = result.get(transition);\r\n        // Visited means we have already processed this transition once (via peeking) and have since computed the\r\n        // matches for all deeper states. Time to compute this transition's matches then pop it from the stack.\r\n        if (visited.contains(transition)) {\r\n            ByteState nextState = transition.getNextByteState();\r\n            if (nextState != null) {\r\n                for (ByteTransition eachTransition : nextState.getTransitions()) {\r\n                    for (SingleByteTransition single : eachTransition.expand()) {\r\n                        matches.addAll(result.get(single));\r\n                    }\r\n                }\r\n            }\r\n            stack.pop();\r\n            continue;\r\n        }\r\n        visited.add(transition);\r\n        // Add all matches directly accessible from this transition.\r\n        matches.addAll(transition.getMatches());\r\n        // Push the next round of deeper states into the stack. By the time we return back to the current transition\r\n        // on the stack, all matches for deeper states will have been computed.\r\n        ByteState nextState = transition.getNextByteState();\r\n        if (nextState != null) {\r\n            for (ByteTransition eachTransition : nextState.getTransitions()) {\r\n                for (SingleByteTransition single : eachTransition.expand()) {\r\n                    if (!visited.contains(single)) {\r\n                        stack.push(single);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } \r\n    return result;\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport static software.amazon.event.ruler.MatchType.WILDCARD;\nimport java.util.LinkedList;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Stack;\npublic class MachineComplexityEvaluator {\n    \n    private Map<SingleByteTransition, Set<ByteMatch>> getMatchesAccessibleFromEachTransition(ByteState state) {\r\n        Map<SingleByteTransition, Set<ByteMatch>> result = new HashMap<>();\r\n        Set<SingleByteTransition> visited = new HashSet<>();\r\n        Stack<SingleByteTransition> stack = new Stack<>();\r\n        stack.push(state);\r\n        // We'll do a depth-first-search as a state's matches can only be computed once the computation is complete for\r\n        // all deeper states. Let's avoid recursion, which is prone to stack overflow.\r\n        while (!stack.isEmpty()) {\r\n            // Peek instead of pop. Need this transition to remain on stack so we can compute its matches once all\r\n            // deeper states are complete.\r\n            SingleByteTransition transition = stack.peek();\r\n            if (!result.containsKey(transition)) {\r\n                result.put(transition, new HashSet<>());\r\n            }\r\n            Set<ByteMatch> matches = result.get(transition);\r\n            // Visited means we have already processed this transition once (via peeking) and have since computed the\r\n            // matches for all deeper states. Time to compute this transition's matches then pop it from the stack.\r\n            if (visited.contains(transition)) {\r\n                ByteState nextState = transition.getNextByteState();\r\n                if (nextState != null) {\r\n                    for (ByteTransition eachTransition : nextState.getTransitions()) {\r\n                        for (SingleByteTransition single : eachTransition.expand()) {\r\n                            matches.addAll(result.get(single));\r\n                        }\r\n                    }\r\n                }\r\n                stack.pop();\r\n                continue;\r\n            }\r\n            visited.add(transition);\r\n            // Add all matches directly accessible from this transition.\r\n            matches.addAll(transition.getMatches());\r\n            // Push the next round of deeper states into the stack. By the time we return back to the current transition\r\n            // on the stack, all matches for deeper states will have been computed.\r\n            ByteState nextState = transition.getNextByteState();\r\n            if (nextState != null) {\r\n                for (ByteTransition eachTransition : nextState.getTransitions()) {\r\n                    for (SingleByteTransition single : eachTransition.expand()) {\r\n                        if (!visited.contains(single)) {\r\n                            stack.push(single);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } \r\n        return result;\r\n    }\nint evaluate(ByteState state);\n    int getMaxComplexity();\n}"
      },
      {
        "id": "ByteMachine_updateMatchReferences",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_updateMatchReferences_Test",
        "method-name": "updateMatchReferences(ByteMatch)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_updateMatchReferences_Test.java",
        "focal-method": "private void updateMatchReferences(ByteMatch match) {\r\n    Patterns pattern = match.getPattern();\r\n    switch (pattern.type()) {\r\n        case EXACT :\r\n        case PREFIX :\r\n        case EXISTS :\r\n        case EQUALS_IGNORE_CASE :\r\n        case WILDCARD :\r\n            break;\r\n        case SUFFIX :\r\n            hasSuffix.decrementAndGet();\r\n            break;\r\n        case NUMERIC_EQ :\r\n            hasNumeric.decrementAndGet();\r\n            break;\r\n        case NUMERIC_RANGE :\r\n            final Range range = ((Range) (pattern));\r\n            if (range.isCIDR) {\r\n                hasIP.decrementAndGet();\r\n            } else {\r\n                hasNumeric.decrementAndGet();\r\n            }\r\n            break;\r\n        case ANYTHING_BUT :\r\n            anythingButs.remove(match.getNextNameState());\r\n            if (((AnythingBut) (pattern)).isNumeric()) {\r\n                hasNumeric.decrementAndGet();\r\n            }\r\n            break;\r\n        case ANYTHING_BUT_IGNORE_CASE :\r\n            anythingButs.remove(match.getNextNameState());\r\n            break;\r\n        case ANYTHING_BUT_SUFFIX :\r\n            hasSuffix.decrementAndGet();\r\n            anythingButs.remove(match.getNextNameState());\r\n            break;\r\n        case ANYTHING_BUT_PREFIX :\r\n            anythingButs.remove(match.getNextNameState());\r\n            break;\r\n        default :\r\n            throw new AssertionError(\"Not implemented yet\");\r\n    }\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private final AtomicInteger hasNumeric = new AtomicInteger(0);\n    private final AtomicInteger hasIP = new AtomicInteger(0);\n    private final AtomicInteger hasSuffix = new AtomicInteger(0);\n    private final Set<NameState> anythingButs = ConcurrentHashMap.newKeySet();\n    private void updateMatchReferences(ByteMatch match) {\r\n        Patterns pattern = match.getPattern();\r\n        switch (pattern.type()) {\r\n            case EXACT :\r\n            case PREFIX :\r\n            case EXISTS :\r\n            case EQUALS_IGNORE_CASE :\r\n            case WILDCARD :\r\n                break;\r\n            case SUFFIX :\r\n                hasSuffix.decrementAndGet();\r\n                break;\r\n            case NUMERIC_EQ :\r\n                hasNumeric.decrementAndGet();\r\n                break;\r\n            case NUMERIC_RANGE :\r\n                final Range range = ((Range) (pattern));\r\n                if (range.isCIDR) {\r\n                    hasIP.decrementAndGet();\r\n                } else {\r\n                    hasNumeric.decrementAndGet();\r\n                }\r\n                break;\r\n            case ANYTHING_BUT :\r\n                anythingButs.remove(match.getNextNameState());\r\n                if (((AnythingBut) (pattern)).isNumeric()) {\r\n                    hasNumeric.decrementAndGet();\r\n                }\r\n                break;\r\n            case ANYTHING_BUT_IGNORE_CASE :\r\n                anythingButs.remove(match.getNextNameState());\r\n                break;\r\n            case ANYTHING_BUT_SUFFIX :\r\n                hasSuffix.decrementAndGet();\r\n                anythingButs.remove(match.getNextNameState());\r\n                break;\r\n            case ANYTHING_BUT_PREFIX :\r\n                anythingButs.remove(match.getNextNameState());\r\n                break;\r\n            default :\r\n                throw new AssertionError(\"Not implemented yet\");\r\n        }\r\n    }\nNameState addPattern(final Patterns pattern);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    NameState findPattern(final Patterns pattern);\n    public void gatherObjects(Set<Object> objectSet);\n    boolean isEmpty();\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "ByteMachine_deleteRangePattern",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_deleteRangePattern_Test",
        "method-name": "deleteRangePattern(Range)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_deleteRangePattern_Test.java",
        "focal-method": "private void deleteRangePattern(Range range) {\r\n    // if range to be deleted does not exist, just return\r\n    if (findRangePattern(range) == null) {\r\n        return;\r\n    }\r\n    // Inside Range pattern, there are bottom value and top value, this function will traverse each byte of bottom\r\n    // and top value separately to hunt down all matches eligible to be deleted.\r\n    // The ArrayDequeue is used to save all byteStates in transition path since state associated with first byte of\r\n    // value to state associated with last byte of value. Then, checkAndDeleteStateAlongTraversedPath function will\r\n    // check each state saved in ArrayDequeue along reverse direction of traversing path and recursively check and\r\n    // delete match and state if it is eligible.\r\n    // Note: byteState is deletable only when it has no match and no transition to next byteState.\r\n    // Refer to definition of class ComparableNumber, the max length in bytes for Number type is 16,\r\n    // so here we take 16 as ArrayDeque capacity which is defined as ComparableNumber.MAX_BYTE_LENGTH.\r\n    final ArrayDeque<AbstractMap.SimpleImmutableEntry<Byte, ByteTransition>> byteStatesTraversePathAlongRangeBottomValue = new ArrayDeque<>(ComparableNumber.MAX_LENGTH_IN_BYTES);\r\n    final ArrayDeque<AbstractMap.SimpleImmutableEntry<Byte, ByteTransition>> byteStatesTraversePathAlongRangeTopValue = new ArrayDeque<>(ComparableNumber.MAX_LENGTH_IN_BYTES);\r\n    ByteTransition forkState = startState;\r\n    int forkOffset = 0;\r\n    byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[0], forkState));\r\n    byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[0], forkState));\r\n    // bypass common prefix of range's bottom and top patterns\r\n    // we need move forward the state and save all states traversed for checking later.\r\n    while (range.bottom[forkOffset] == range.top[forkOffset]) {\r\n        forkState = findNextByteStateForRangePattern(forkState, range.bottom[forkOffset]);\r\n        assert forkState != null : \"forkState != null\";\r\n        byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[forkOffset], forkState));\r\n        byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[forkOffset], forkState));\r\n        forkOffset++;\r\n    } \r\n    // when bottom byte on forkOffset position < top byte in same position, there must be matches existing\r\n    // in this state, go ahead to delete matches in the fork state.\r\n    for (byte bb : Range.digitSequence(range.bottom[forkOffset], range.top[forkOffset], false, false)) {\r\n        deleteMatches(getParser().parse(bb), forkState, range);\r\n    }\r\n    // process all the transitions on the bottom range bytes\r\n    ByteTransition state = forkState;\r\n    int lastMatchOffset = forkOffset;\r\n    // see explanation in addRangePattern(), we need delete state and match accordingly.\r\n    for (int offsetB = forkOffset + 1; offsetB < (range.bottom.length - 1); offsetB++) {\r\n        byte b = range.bottom[offsetB];\r\n        if (b < Constants.MAX_DIGIT) {\r\n            while (lastMatchOffset < offsetB) {\r\n                state = findNextByteStateForRangePattern(state, range.bottom[lastMatchOffset]);\r\n                assert state != null : \"state must be existing for this pattern\";\r\n                byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[lastMatchOffset], state));\r\n                lastMatchOffset++;\r\n            } \r\n            assert lastMatchOffset == offsetB : \"lastMatchOffset == offsetB\";\r\n            for (byte bb : Range.digitSequence(b, Constants.MAX_DIGIT, false, true)) {\r\n                deleteMatches(getParser().parse(bb), state, range);\r\n            }\r\n        }\r\n    }\r\n    // now for last \"bottom\" digit\r\n    // see explanation in addRangePattern(), we need to delete states and matches accordingly.\r\n    final byte lastBottom = range.bottom[range.bottom.length - 1];\r\n    final byte lastTop = range.top[range.top.length - 1];\r\n    if ((lastBottom < Constants.MAX_DIGIT) || (!range.openBottom)) {\r\n        while (lastMatchOffset < (range.bottom.length - 1)) {\r\n            state = findNextByteStateForRangePattern(state, range.bottom[lastMatchOffset]);\r\n            assert state != null : \"state != null\";\r\n            byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[lastMatchOffset], state));\r\n            lastMatchOffset++;\r\n        } \r\n        assert lastMatchOffset == (range.bottom.length - 1) : \"lastMatchOffset == range.bottom.length - 1\";\r\n        if (!range.openBottom) {\r\n            deleteMatches(getParser().parse(lastBottom), state, range);\r\n        }\r\n        // unless the last digit is also at the fork position, fill in the extra matches due to\r\n        // the strictly-less-than condition (see discussion above)\r\n        if (forkOffset < (range.bottom.length - 1)) {\r\n            for (byte bb : Range.digitSequence(lastBottom, Constants.MAX_DIGIT, false, true)) {\r\n                deleteMatches(getParser().parse(bb), state, range);\r\n            }\r\n        }\r\n    }\r\n    // now process transitions along the top range bytes\r\n    // see explanation in addRangePattern(), we need to delete states and matches accordingly.\r\n    state = forkState;\r\n    lastMatchOffset = forkOffset;\r\n    for (int offsetT = forkOffset + 1; offsetT < (range.top.length - 1); offsetT++) {\r\n        byte b = range.top[offsetT];\r\n        if (b > '0') {\r\n            while (lastMatchOffset < offsetT) {\r\n                state = findNextByteStateForRangePattern(state, range.top[lastMatchOffset]);\r\n                assert state != null : \"state must be existing for this pattern\";\r\n                byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[lastMatchOffset], state));\r\n                lastMatchOffset++;\r\n            } \r\n            assert lastMatchOffset == offsetT : \"lastMatchOffset == offsetT\";\r\n            for (byte bb : Range.digitSequence(((byte) ('0')), range.top[offsetT], true, false)) {\r\n                deleteMatches(getParser().parse(bb), state, range);\r\n            }\r\n        }\r\n    }\r\n    // now for last \"top\" digit.\r\n    // see explanation in addRangePattern(), we need to delete states and matches accordingly.\r\n    if ((lastTop > '0') || (!range.openTop)) {\r\n        while (lastMatchOffset < (range.top.length - 1)) {\r\n            state = findNextByteStateForRangePattern(state, range.top[lastMatchOffset]);\r\n            assert state != null : \"state != null\";\r\n            byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[lastMatchOffset], state));\r\n            lastMatchOffset++;\r\n        } \r\n        assert lastMatchOffset == (range.top.length - 1) : \"lastMatchOffset == range.top.length - 1\";\r\n        if (!range.openTop) {\r\n            deleteMatches(getParser().parse(lastTop), state, range);\r\n        }\r\n        // unless the last digit is also at the fork position, fill in the extra matches due to\r\n        // the strictly-less-than condition (see discussion above)\r\n        if (forkOffset < (range.top.length - 1)) {\r\n            for (byte bb : Range.digitSequence(((byte) ('0')), lastTop, true, false)) {\r\n                deleteMatches(getParser().parse(bb), state, range);\r\n            }\r\n        }\r\n    }\r\n    // by now we should have deleted all matches in all associated byteStates,\r\n    // now we start cleaning up ineffective byteSates along states traversed path we saved before.\r\n    checkAndDeleteStateAlongTraversedPath(byteStatesTraversePathAlongRangeBottomValue);\r\n    checkAndDeleteStateAlongTraversedPath(byteStatesTraversePathAlongRangeTopValue);\r\n    // well done now, we have deleted all matches pattern matched and cleaned all empty state as if that pattern\r\n    // wasn't added into machine before.\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private final ByteState startState = new ByteState();\n    private void deleteRangePattern(Range range) {\r\n        // if range to be deleted does not exist, just return\r\n        if (findRangePattern(range) == null) {\r\n            return;\r\n        }\r\n        // Inside Range pattern, there are bottom value and top value, this function will traverse each byte of bottom\r\n        // and top value separately to hunt down all matches eligible to be deleted.\r\n        // The ArrayDequeue is used to save all byteStates in transition path since state associated with first byte of\r\n        // value to state associated with last byte of value. Then, checkAndDeleteStateAlongTraversedPath function will\r\n        // check each state saved in ArrayDequeue along reverse direction of traversing path and recursively check and\r\n        // delete match and state if it is eligible.\r\n        // Note: byteState is deletable only when it has no match and no transition to next byteState.\r\n        // Refer to definition of class ComparableNumber, the max length in bytes for Number type is 16,\r\n        // so here we take 16 as ArrayDeque capacity which is defined as ComparableNumber.MAX_BYTE_LENGTH.\r\n        final ArrayDeque<AbstractMap.SimpleImmutableEntry<Byte, ByteTransition>> byteStatesTraversePathAlongRangeBottomValue = new ArrayDeque<>(ComparableNumber.MAX_LENGTH_IN_BYTES);\r\n        final ArrayDeque<AbstractMap.SimpleImmutableEntry<Byte, ByteTransition>> byteStatesTraversePathAlongRangeTopValue = new ArrayDeque<>(ComparableNumber.MAX_LENGTH_IN_BYTES);\r\n        ByteTransition forkState = startState;\r\n        int forkOffset = 0;\r\n        byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[0], forkState));\r\n        byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[0], forkState));\r\n        // bypass common prefix of range's bottom and top patterns\r\n        // we need move forward the state and save all states traversed for checking later.\r\n        while (range.bottom[forkOffset] == range.top[forkOffset]) {\r\n            forkState = findNextByteStateForRangePattern(forkState, range.bottom[forkOffset]);\r\n            assert forkState != null : \"forkState != null\";\r\n            byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[forkOffset], forkState));\r\n            byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[forkOffset], forkState));\r\n            forkOffset++;\r\n        } \r\n        // when bottom byte on forkOffset position < top byte in same position, there must be matches existing\r\n        // in this state, go ahead to delete matches in the fork state.\r\n        for (byte bb : Range.digitSequence(range.bottom[forkOffset], range.top[forkOffset], false, false)) {\r\n            deleteMatches(getParser().parse(bb), forkState, range);\r\n        }\r\n        // process all the transitions on the bottom range bytes\r\n        ByteTransition state = forkState;\r\n        int lastMatchOffset = forkOffset;\r\n        // see explanation in addRangePattern(), we need delete state and match accordingly.\r\n        for (int offsetB = forkOffset + 1; offsetB < (range.bottom.length - 1); offsetB++) {\r\n            byte b = range.bottom[offsetB];\r\n            if (b < Constants.MAX_DIGIT) {\r\n                while (lastMatchOffset < offsetB) {\r\n                    state = findNextByteStateForRangePattern(state, range.bottom[lastMatchOffset]);\r\n                    assert state != null : \"state must be existing for this pattern\";\r\n                    byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[lastMatchOffset], state));\r\n                    lastMatchOffset++;\r\n                } \r\n                assert lastMatchOffset == offsetB : \"lastMatchOffset == offsetB\";\r\n                for (byte bb : Range.digitSequence(b, Constants.MAX_DIGIT, false, true)) {\r\n                    deleteMatches(getParser().parse(bb), state, range);\r\n                }\r\n            }\r\n        }\r\n        // now for last \"bottom\" digit\r\n        // see explanation in addRangePattern(), we need to delete states and matches accordingly.\r\n        final byte lastBottom = range.bottom[range.bottom.length - 1];\r\n        final byte lastTop = range.top[range.top.length - 1];\r\n        if ((lastBottom < Constants.MAX_DIGIT) || (!range.openBottom)) {\r\n            while (lastMatchOffset < (range.bottom.length - 1)) {\r\n                state = findNextByteStateForRangePattern(state, range.bottom[lastMatchOffset]);\r\n                assert state != null : \"state != null\";\r\n                byteStatesTraversePathAlongRangeBottomValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.bottom[lastMatchOffset], state));\r\n                lastMatchOffset++;\r\n            } \r\n            assert lastMatchOffset == (range.bottom.length - 1) : \"lastMatchOffset == range.bottom.length - 1\";\r\n            if (!range.openBottom) {\r\n                deleteMatches(getParser().parse(lastBottom), state, range);\r\n            }\r\n            // unless the last digit is also at the fork position, fill in the extra matches due to\r\n            // the strictly-less-than condition (see discussion above)\r\n            if (forkOffset < (range.bottom.length - 1)) {\r\n                for (byte bb : Range.digitSequence(lastBottom, Constants.MAX_DIGIT, false, true)) {\r\n                    deleteMatches(getParser().parse(bb), state, range);\r\n                }\r\n            }\r\n        }\r\n        // now process transitions along the top range bytes\r\n        // see explanation in addRangePattern(), we need to delete states and matches accordingly.\r\n        state = forkState;\r\n        lastMatchOffset = forkOffset;\r\n        for (int offsetT = forkOffset + 1; offsetT < (range.top.length - 1); offsetT++) {\r\n            byte b = range.top[offsetT];\r\n            if (b > '0') {\r\n                while (lastMatchOffset < offsetT) {\r\n                    state = findNextByteStateForRangePattern(state, range.top[lastMatchOffset]);\r\n                    assert state != null : \"state must be existing for this pattern\";\r\n                    byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[lastMatchOffset], state));\r\n                    lastMatchOffset++;\r\n                } \r\n                assert lastMatchOffset == offsetT : \"lastMatchOffset == offsetT\";\r\n                for (byte bb : Range.digitSequence(((byte) ('0')), range.top[offsetT], true, false)) {\r\n                    deleteMatches(getParser().parse(bb), state, range);\r\n                }\r\n            }\r\n        }\r\n        // now for last \"top\" digit.\r\n        // see explanation in addRangePattern(), we need to delete states and matches accordingly.\r\n        if ((lastTop > '0') || (!range.openTop)) {\r\n            while (lastMatchOffset < (range.top.length - 1)) {\r\n                state = findNextByteStateForRangePattern(state, range.top[lastMatchOffset]);\r\n                assert state != null : \"state != null\";\r\n                byteStatesTraversePathAlongRangeTopValue.addFirst(new AbstractMap.SimpleImmutableEntry<>(range.top[lastMatchOffset], state));\r\n                lastMatchOffset++;\r\n            } \r\n            assert lastMatchOffset == (range.top.length - 1) : \"lastMatchOffset == range.top.length - 1\";\r\n            if (!range.openTop) {\r\n                deleteMatches(getParser().parse(lastTop), state, range);\r\n            }\r\n            // unless the last digit is also at the fork position, fill in the extra matches due to\r\n            // the strictly-less-than condition (see discussion above)\r\n            if (forkOffset < (range.top.length - 1)) {\r\n                for (byte bb : Range.digitSequence(((byte) ('0')), lastTop, true, false)) {\r\n                    deleteMatches(getParser().parse(bb), state, range);\r\n                }\r\n            }\r\n        }\r\n        // by now we should have deleted all matches in all associated byteStates,\r\n        // now we start cleaning up ineffective byteSates along states traversed path we saved before.\r\n        checkAndDeleteStateAlongTraversedPath(byteStatesTraversePathAlongRangeBottomValue);\r\n        checkAndDeleteStateAlongTraversedPath(byteStatesTraversePathAlongRangeTopValue);\r\n        // well done now, we have deleted all matches pattern matched and cleaned all empty state as if that pattern\r\n        // wasn't added into machine before.\r\n    }\nNameState addPattern(final Patterns pattern);\n    private void checkAndDeleteStateAlongTraversedPath(ArrayDeque<AbstractMap.SimpleImmutableEntry<Byte, ByteTransition>> byteStateQueue);\n    private void deleteMatches(InputCharacter character, ByteTransition transition, Patterns pattern);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    private ByteTransition findNextByteStateForRangePattern(ByteTransition trans, final byte b);\n    NameState findPattern(final Patterns pattern);\n    private NameState findRangePattern(Range range);\n    public void gatherObjects(Set<Object> objectSet);\n    boolean isEmpty();\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "RuleCompiler_processMatchExpression",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.RuleCompiler",
        "test-class": "software.amazon.event.ruler.RuleCompiler_processMatchExpression_Test",
        "method-name": "processMatchExpression(JsonParser)",
        "source-path": "src/main/java/software/amazon/event/ruler/RuleCompiler.java",
        "test-path": "src/test/java/software/amazon/event/ruler/RuleCompiler_processMatchExpression_Test.java",
        "focal-method": "private static Patterns processMatchExpression(final JsonParser parser) throws IOException {\r\n    final JsonToken matchTypeToken = parser.nextToken();\r\n    if (matchTypeToken != JsonToken.FIELD_NAME) {\r\n        barf(parser, \"Match expression name not found\");\r\n    }\r\n    final String matchTypeName = parser.getCurrentName();\r\n    if (Constants.EXACT_MATCH.equals(matchTypeName)) {\r\n        final JsonToken prefixToken = parser.nextToken();\r\n        if (prefixToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"exact match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.exactMatch(('\"' + parser.getText()) + '\"');\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.PREFIX_MATCH.equals(matchTypeName)) {\r\n        final JsonToken prefixToken = parser.nextToken();\r\n        if (prefixToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"prefix match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.prefixMatch('\"' + parser.getText());// note no trailing quote\r\n\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.SUFFIX_MATCH.equals(matchTypeName)) {\r\n        final JsonToken suffixToken = parser.nextToken();\r\n        if (suffixToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"suffix match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.suffixMatch(parser.getText() + '\"');// note no beginning quote\r\n\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.NUMERIC.equals(matchTypeName)) {\r\n        final JsonToken numericalExpressionToken = parser.nextToken();\r\n        if (numericalExpressionToken != JsonToken.START_ARRAY) {\r\n            barf(parser, (\"Value of \" + Constants.NUMERIC) + \" must be an array.\");\r\n        }\r\n        Patterns range = processNumericMatchExpression(parser);\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            tooManyElements(parser);\r\n        }\r\n        return range;\r\n    } else if (Constants.ANYTHING_BUT_MATCH.equals(matchTypeName)) {\r\n        boolean isIgnoreCase = false;\r\n        JsonToken anythingButExpressionToken = parser.nextToken();\r\n        if (anythingButExpressionToken == JsonToken.START_OBJECT) {\r\n            // there are a limited set of things we can apply Anything-But to\r\n            final JsonToken anythingButObject = parser.nextToken();\r\n            if (anythingButObject != JsonToken.FIELD_NAME) {\r\n                barf(parser, \"Anything-But expression name not found\");\r\n            }\r\n            final String anythingButObjectOp = parser.getCurrentName();\r\n            final boolean isPrefix = Constants.PREFIX_MATCH.equals(anythingButObjectOp);\r\n            final boolean isSuffix = Constants.SUFFIX_MATCH.equals(anythingButObjectOp);\r\n            isIgnoreCase = Constants.EQUALS_IGNORE_CASE.equals(anythingButObjectOp);\r\n            if (!isIgnoreCase) {\r\n                if ((!isPrefix) && (!isSuffix)) {\r\n                    barf(parser, \"Unsupported anything-but pattern: \" + anythingButObjectOp);\r\n                }\r\n                final JsonToken anythingButParamType = parser.nextToken();\r\n                if (anythingButParamType != JsonToken.VALUE_STRING) {\r\n                    barf(parser, \"prefix/suffix match pattern must be a string\");\r\n                }\r\n                final String text = parser.getText();\r\n                if (text.isEmpty()) {\r\n                    barf(parser, \"Null prefix/suffix not allowed\");\r\n                }\r\n                if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                    barf(parser, \"Only one key allowed in match expression\");\r\n                }\r\n                if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                    barf(parser, \"Only one key allowed in match expression\");\r\n                }\r\n                if (isPrefix) {\r\n                    return Patterns.anythingButPrefix('\"' + text);// note no trailing quote\r\n\r\n                } else {\r\n                    return Patterns.anythingButSuffix(text + '\"');// note no leading quote\r\n\r\n                }\r\n            } else {\r\n                // Step into the anything-but's ignore-case\r\n                anythingButExpressionToken = parser.nextToken();\r\n            }\r\n        }\r\n        if ((((anythingButExpressionToken != JsonToken.START_ARRAY) && (anythingButExpressionToken != JsonToken.VALUE_STRING)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_FLOAT)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_INT)) {\r\n            barf(parser, (\"Value of \" + Constants.ANYTHING_BUT_MATCH) + \" must be an array or single string/number value.\");\r\n        }\r\n        Patterns anythingBut;\r\n        if (anythingButExpressionToken == JsonToken.START_ARRAY) {\r\n            if (isIgnoreCase) {\r\n                anythingBut = processAnythingButEqualsIgnoreCaseListMatchExpression(parser);\r\n            } else {\r\n                anythingBut = processAnythingButListMatchExpression(parser);\r\n            }\r\n        } else if (isIgnoreCase) {\r\n            anythingBut = processAnythingButEqualsIgnoreCaseMatchExpression(parser, anythingButExpressionToken);\r\n        } else {\r\n            anythingBut = processAnythingButMatchExpression(parser, anythingButExpressionToken);\r\n        }\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            tooManyElements(parser);\r\n        }\r\n        // If its an ignore-case, we have another\r\n        // object end to consume...\r\n        if (isIgnoreCase && (parser.nextToken() != JsonToken.END_OBJECT)) {\r\n            tooManyElements(parser);\r\n        }\r\n        return anythingBut;\r\n    } else if (Constants.EXISTS_MATCH.equals(matchTypeName)) {\r\n        return processExistsExpression(parser);\r\n    } else if (Constants.CIDR.equals(matchTypeName)) {\r\n        final JsonToken cidrToken = parser.nextToken();\r\n        if (cidrToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"prefix match pattern must be a string\");\r\n        }\r\n        final Range cidr = CIDR.cidr(parser.getText());\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return cidr;\r\n    } else if (Constants.EQUALS_IGNORE_CASE.equals(matchTypeName)) {\r\n        final JsonToken equalsIgnoreCaseToken = parser.nextToken();\r\n        if (equalsIgnoreCaseToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"equals-ignore-case match pattern must be a string\");\r\n        }\r\n        final Patterns pattern = Patterns.equalsIgnoreCaseMatch(('\"' + parser.getText()) + '\"');\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else if (Constants.WILDCARD.equals(matchTypeName)) {\r\n        final JsonToken wildcardToken = parser.nextToken();\r\n        if (wildcardToken != JsonToken.VALUE_STRING) {\r\n            barf(parser, \"wildcard match pattern must be a string\");\r\n        }\r\n        final String parserText = parser.getText();\r\n        final Patterns pattern = Patterns.wildcardMatch(('\"' + parserText) + '\"');\r\n        if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n            barf(parser, \"Only one key allowed in match expression\");\r\n        }\r\n        return pattern;\r\n    } else {\r\n        barf(parser, \"Unrecognized match type \" + matchTypeName);\r\n        return null;// unreachable statement, but java can't see that?\r\n\r\n    }\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport java.util.ArrayDeque;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport java.util.Deque;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport java.io.Reader;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashSet;\npublic final class RuleCompiler {\n    \n    private static Patterns processMatchExpression(final JsonParser parser) throws IOException {\r\n        final JsonToken matchTypeToken = parser.nextToken();\r\n        if (matchTypeToken != JsonToken.FIELD_NAME) {\r\n            barf(parser, \"Match expression name not found\");\r\n        }\r\n        final String matchTypeName = parser.getCurrentName();\r\n        if (Constants.EXACT_MATCH.equals(matchTypeName)) {\r\n            final JsonToken prefixToken = parser.nextToken();\r\n            if (prefixToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"exact match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.exactMatch(('\"' + parser.getText()) + '\"');\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.PREFIX_MATCH.equals(matchTypeName)) {\r\n            final JsonToken prefixToken = parser.nextToken();\r\n            if (prefixToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"prefix match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.prefixMatch('\"' + parser.getText());// note no trailing quote\r\n    \r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.SUFFIX_MATCH.equals(matchTypeName)) {\r\n            final JsonToken suffixToken = parser.nextToken();\r\n            if (suffixToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"suffix match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.suffixMatch(parser.getText() + '\"');// note no beginning quote\r\n    \r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.NUMERIC.equals(matchTypeName)) {\r\n            final JsonToken numericalExpressionToken = parser.nextToken();\r\n            if (numericalExpressionToken != JsonToken.START_ARRAY) {\r\n                barf(parser, (\"Value of \" + Constants.NUMERIC) + \" must be an array.\");\r\n            }\r\n            Patterns range = processNumericMatchExpression(parser);\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                tooManyElements(parser);\r\n            }\r\n            return range;\r\n        } else if (Constants.ANYTHING_BUT_MATCH.equals(matchTypeName)) {\r\n            boolean isIgnoreCase = false;\r\n            JsonToken anythingButExpressionToken = parser.nextToken();\r\n            if (anythingButExpressionToken == JsonToken.START_OBJECT) {\r\n                // there are a limited set of things we can apply Anything-But to\r\n                final JsonToken anythingButObject = parser.nextToken();\r\n                if (anythingButObject != JsonToken.FIELD_NAME) {\r\n                    barf(parser, \"Anything-But expression name not found\");\r\n                }\r\n                final String anythingButObjectOp = parser.getCurrentName();\r\n                final boolean isPrefix = Constants.PREFIX_MATCH.equals(anythingButObjectOp);\r\n                final boolean isSuffix = Constants.SUFFIX_MATCH.equals(anythingButObjectOp);\r\n                isIgnoreCase = Constants.EQUALS_IGNORE_CASE.equals(anythingButObjectOp);\r\n                if (!isIgnoreCase) {\r\n                    if ((!isPrefix) && (!isSuffix)) {\r\n                        barf(parser, \"Unsupported anything-but pattern: \" + anythingButObjectOp);\r\n                    }\r\n                    final JsonToken anythingButParamType = parser.nextToken();\r\n                    if (anythingButParamType != JsonToken.VALUE_STRING) {\r\n                        barf(parser, \"prefix/suffix match pattern must be a string\");\r\n                    }\r\n                    final String text = parser.getText();\r\n                    if (text.isEmpty()) {\r\n                        barf(parser, \"Null prefix/suffix not allowed\");\r\n                    }\r\n                    if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                        barf(parser, \"Only one key allowed in match expression\");\r\n                    }\r\n                    if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                        barf(parser, \"Only one key allowed in match expression\");\r\n                    }\r\n                    if (isPrefix) {\r\n                        return Patterns.anythingButPrefix('\"' + text);// note no trailing quote\r\n    \r\n                    } else {\r\n                        return Patterns.anythingButSuffix(text + '\"');// note no leading quote\r\n    \r\n                    }\r\n                } else {\r\n                    // Step into the anything-but's ignore-case\r\n                    anythingButExpressionToken = parser.nextToken();\r\n                }\r\n            }\r\n            if ((((anythingButExpressionToken != JsonToken.START_ARRAY) && (anythingButExpressionToken != JsonToken.VALUE_STRING)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_FLOAT)) && (anythingButExpressionToken != JsonToken.VALUE_NUMBER_INT)) {\r\n                barf(parser, (\"Value of \" + Constants.ANYTHING_BUT_MATCH) + \" must be an array or single string/number value.\");\r\n            }\r\n            Patterns anythingBut;\r\n            if (anythingButExpressionToken == JsonToken.START_ARRAY) {\r\n                if (isIgnoreCase) {\r\n                    anythingBut = processAnythingButEqualsIgnoreCaseListMatchExpression(parser);\r\n                } else {\r\n                    anythingBut = processAnythingButListMatchExpression(parser);\r\n                }\r\n            } else if (isIgnoreCase) {\r\n                anythingBut = processAnythingButEqualsIgnoreCaseMatchExpression(parser, anythingButExpressionToken);\r\n            } else {\r\n                anythingBut = processAnythingButMatchExpression(parser, anythingButExpressionToken);\r\n            }\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                tooManyElements(parser);\r\n            }\r\n            // If its an ignore-case, we have another\r\n            // object end to consume...\r\n            if (isIgnoreCase && (parser.nextToken() != JsonToken.END_OBJECT)) {\r\n                tooManyElements(parser);\r\n            }\r\n            return anythingBut;\r\n        } else if (Constants.EXISTS_MATCH.equals(matchTypeName)) {\r\n            return processExistsExpression(parser);\r\n        } else if (Constants.CIDR.equals(matchTypeName)) {\r\n            final JsonToken cidrToken = parser.nextToken();\r\n            if (cidrToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"prefix match pattern must be a string\");\r\n            }\r\n            final Range cidr = CIDR.cidr(parser.getText());\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return cidr;\r\n        } else if (Constants.EQUALS_IGNORE_CASE.equals(matchTypeName)) {\r\n            final JsonToken equalsIgnoreCaseToken = parser.nextToken();\r\n            if (equalsIgnoreCaseToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"equals-ignore-case match pattern must be a string\");\r\n            }\r\n            final Patterns pattern = Patterns.equalsIgnoreCaseMatch(('\"' + parser.getText()) + '\"');\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else if (Constants.WILDCARD.equals(matchTypeName)) {\r\n            final JsonToken wildcardToken = parser.nextToken();\r\n            if (wildcardToken != JsonToken.VALUE_STRING) {\r\n                barf(parser, \"wildcard match pattern must be a string\");\r\n            }\r\n            final String parserText = parser.getText();\r\n            final Patterns pattern = Patterns.wildcardMatch(('\"' + parserText) + '\"');\r\n            if (parser.nextToken() != JsonToken.END_OBJECT) {\r\n                barf(parser, \"Only one key allowed in match expression\");\r\n            }\r\n            return pattern;\r\n        } else {\r\n            barf(parser, \"Unrecognized match type \" + matchTypeName);\r\n            return null;// unreachable statement, but java can't see that?\r\n    \r\n        }\r\n    }\nprivate static void barf(final JsonParser parser, final String message) throws JsonParseException;\n    public static String check(final byte[] source);\n    public static String check(final InputStream source);\n    public static String check(final Reader source);\n    public static String check(final String source);\n    public static Map<String, List<Patterns>> compile(final byte[] source) throws IOException;\n    public static Map<String, List<Patterns>> compile(final InputStream source) throws IOException;\n    public static Map<String, List<Patterns>> compile(final Reader source) throws IOException;\n    public static Map<String, List<Patterns>> compile(final String source) throws IOException;\n    private static Patterns processAnythingButEqualsIgnoreCaseListMatchExpression(JsonParser parser) throws JsonParseException;\n    private static Patterns processAnythingButEqualsIgnoreCaseMatchExpression(JsonParser parser, JsonToken anythingButExpressionToken) throws IOException;\n    private static Patterns processAnythingButListMatchExpression(JsonParser parser) throws JsonParseException;\n    private static Patterns processAnythingButMatchExpression(JsonParser parser, JsonToken anythingButExpressionToken) throws IOException;\n    private static Patterns processExistsExpression(final JsonParser parser) throws IOException;\n    private static Patterns processNumericMatchExpression(final JsonParser parser) throws IOException;\n    private static void tooManyElements(final JsonParser parser) throws JsonParseException;\n}"
      },
      {
        "id": "ByteMachine_findMatchPattern",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.ByteMachine",
        "test-class": "software.amazon.event.ruler.ByteMachine_findMatchPattern_Test",
        "method-name": "findMatchPattern(InputCharacter[], Patterns)",
        "source-path": "src/main/java/software/amazon/event/ruler/ByteMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/ByteMachine_findMatchPattern_Test.java",
        "focal-method": "private NameState findMatchPattern(final InputCharacter[] characters, final Patterns pattern) {\r\n    Set<SingleByteTransition> transitionsToProcess = new HashSet<>();\r\n    transitionsToProcess.add(startState);\r\n    ByteTransition shortcutTrans = null;\r\n    // Iterate down all possible paths in machine that match characters.\r\n    outerLoop : for (int i = 0; i < (characters.length - 1); i++) {\r\n        Set<SingleByteTransition> nextTransitionsToProcess = new HashSet<>();\r\n        for (SingleByteTransition trans : transitionsToProcess) {\r\n            ByteTransition nextTrans = getTransition(trans, characters[i]);\r\n            for (SingleByteTransition eachTrans : nextTrans.expand()) {\r\n                // Shortcut and stop outer character loop\r\n                if (SHORTCUT_MATCH_TYPES.contains(pattern.type()) && eachTrans.isShortcutTrans()) {\r\n                    shortcutTrans = eachTrans;\r\n                    break outerLoop;\r\n                }\r\n                SingleByteTransition nextByteState = eachTrans.getNextByteState();\r\n                if (nextByteState == null) {\r\n                    return null;\r\n                }\r\n                // We are interested in the first state that hasn't simply led back to trans\r\n                if (trans != nextByteState) {\r\n                    nextTransitionsToProcess.add(nextByteState);\r\n                }\r\n            }\r\n        }\r\n        transitionsToProcess = nextTransitionsToProcess;\r\n    }\r\n    // Get all possible transitions for final character.\r\n    Set<ByteTransition> finalTransitionsToProcess = new HashSet<>();\r\n    if (shortcutTrans != null) {\r\n        finalTransitionsToProcess.add(shortcutTrans);\r\n    } else {\r\n        for (SingleByteTransition trans : transitionsToProcess) {\r\n            finalTransitionsToProcess.add(getTransition(trans, characters[characters.length - 1]));\r\n        }\r\n    }\r\n    // Check matches for all possible final transitions until we find the pattern we are looking for.\r\n    for (ByteTransition nextTrans : finalTransitionsToProcess) {\r\n        for (ByteMatch match : nextTrans.getMatches()) {\r\n            if (match.getPattern().equals(pattern)) {\r\n                return match.getNextNameState();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport software.amazon.event.ruler.input.InputMultiByteSet;\nimport java.util.Set;\nimport static software.amazon.event.ruler.MatchType.ANYTHING_BUT_SUFFIX;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport java.util.AbstractMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport static software.amazon.event.ruler.input.DefaultParser.getParser;\nimport static software.amazon.event.ruler.MatchType.EXACT;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputCharacter;\nimport java.util.HashSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.ArrayDeque;\nimport static software.amazon.event.ruler.MatchType.SUFFIX;\nimport software.amazon.event.ruler.input.InputCharacterType;\nimport static software.amazon.event.ruler.MatchType.EXISTS;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_FIRST_BYTE_FOR_ONE_BYTE_CHAR;\nimport static software.amazon.event.ruler.input.MultiByte.MAX_NON_FIRST_BYTE;\nimport java.nio.charset.StandardCharsets;\nimport static software.amazon.event.ruler.CompoundByteTransition.coalesce;\nimport javax.annotation.concurrent.ThreadSafe;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport com.fasterxml.jackson.core.io.doubleparser.FastDoubleParser;\nimport static software.amazon.event.ruler.input.MultiByte.MIN_FIRST_BYTE_FOR_TWO_BYTE_CHAR;\nimport software.amazon.event.ruler.input.InputByte;\nimport software.amazon.event.ruler.input.MultiByte;\nimport java.util.Arrays;\n@ThreadSafe\r\nclass ByteMachine {\n    private static final Set<MatchType> SHORTCUT_MATCH_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(EXACT)));\n    private final ByteState startState = new ByteState();\n    private NameState findMatchPattern(final InputCharacter[] characters, final Patterns pattern) {\r\n        Set<SingleByteTransition> transitionsToProcess = new HashSet<>();\r\n        transitionsToProcess.add(startState);\r\n        ByteTransition shortcutTrans = null;\r\n        // Iterate down all possible paths in machine that match characters.\r\n        outerLoop : for (int i = 0; i < (characters.length - 1); i++) {\r\n            Set<SingleByteTransition> nextTransitionsToProcess = new HashSet<>();\r\n            for (SingleByteTransition trans : transitionsToProcess) {\r\n                ByteTransition nextTrans = getTransition(trans, characters[i]);\r\n                for (SingleByteTransition eachTrans : nextTrans.expand()) {\r\n                    // Shortcut and stop outer character loop\r\n                    if (SHORTCUT_MATCH_TYPES.contains(pattern.type()) && eachTrans.isShortcutTrans()) {\r\n                        shortcutTrans = eachTrans;\r\n                        break outerLoop;\r\n                    }\r\n                    SingleByteTransition nextByteState = eachTrans.getNextByteState();\r\n                    if (nextByteState == null) {\r\n                        return null;\r\n                    }\r\n                    // We are interested in the first state that hasn't simply led back to trans\r\n                    if (trans != nextByteState) {\r\n                        nextTransitionsToProcess.add(nextByteState);\r\n                    }\r\n                }\r\n            }\r\n            transitionsToProcess = nextTransitionsToProcess;\r\n        }\r\n        // Get all possible transitions for final character.\r\n        Set<ByteTransition> finalTransitionsToProcess = new HashSet<>();\r\n        if (shortcutTrans != null) {\r\n            finalTransitionsToProcess.add(shortcutTrans);\r\n        } else {\r\n            for (SingleByteTransition trans : transitionsToProcess) {\r\n                finalTransitionsToProcess.add(getTransition(trans, characters[characters.length - 1]));\r\n            }\r\n        }\r\n        // Check matches for all possible final transitions until we find the pattern we are looking for.\r\n        for (ByteTransition nextTrans : finalTransitionsToProcess) {\r\n            for (ByteMatch match : nextTrans.getMatches()) {\r\n                if (match.getPattern().equals(pattern)) {\r\n                    return match.getNextNameState();\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\nNameState addPattern(final Patterns pattern);\n    void deletePattern(final Patterns pattern);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    NameState findPattern(final Patterns pattern);\n    public void gatherObjects(Set<Object> objectSet);\n    private static ByteTransition getTransition(ByteTransition trans, byte b);\n    private static ByteTransition getTransition(SingleByteTransition trans, InputCharacter character);\n    boolean isEmpty();\n    @Override\r\npublic String toString();\n    Set<NameState> transitionOn(String valString);\n}"
      },
      {
        "id": "GenericMachine_deleteStep",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.GenericMachine",
        "test-class": "software.amazon.event.ruler.GenericMachine_deleteStep_Test",
        "method-name": "deleteStep(NameState, List<String>, int, Map<String, List<Patterns>>, T, List<String>)",
        "source-path": "src/main/java/software/amazon/event/ruler/GenericMachine.java",
        "test-path": "src/test/java/software/amazon/event/ruler/GenericMachine_deleteStep_Test.java",
        "focal-method": "private void deleteStep(final NameState state, final List<String> keys, final int keyIndex, final Map<String, List<Patterns>> patterns, final T ruleName, List<String> deletedKeys) {\r\n    final String key = keys.get(keyIndex);\r\n    ByteMachine byteMachine = state.getTransitionOn(key);\r\n    NameMatcher<NameState> nameMatcher = state.getKeyTransitionOn(key);\r\n    // matchers are null, we have nothing to delete.\r\n    if ((byteMachine == null) && (nameMatcher == null)) {\r\n        return;\r\n    }\r\n    for (Patterns pattern : patterns.get(key)) {\r\n        NameState nextNameState = null;\r\n        if (isNamePattern(pattern)) {\r\n            if (nameMatcher != null) {\r\n                nextNameState = nameMatcher.findPattern(pattern);\r\n            }\r\n        } else if (byteMachine != null) {\r\n            nextNameState = byteMachine.findPattern(pattern);\r\n        }\r\n        if (nextNameState != null) {\r\n            // if this was the last step, then reaching the last state means the rule matched.\r\n            final int nextKeyIndex = keyIndex + 1;\r\n            if (nextKeyIndex == keys.size()) {\r\n                if (nextNameState.hasRule(ruleName)) {\r\n                    nextNameState.deleteRule(ruleName);\r\n                    // only when this state have no rules and no next transition, we could remove it.\r\n                    if (checkAndDeleteNameState(nextNameState, state, key, pattern)) {\r\n                        deletedKeys.add(key);\r\n                    }\r\n                }\r\n            } else {\r\n                deleteStep(nextNameState, keys, nextKeyIndex, patterns, ruleName, deletedKeys);\r\n                // only when this state have no rules and no next transition, we could remove it.\r\n                if (checkAndDeleteNameState(nextNameState, state, key, pattern)) {\r\n                    deletedKeys.add(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport java.util.stream.Collectors;\nimport java.util.HashMap;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport java.io.Reader;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Arrays;\nimport javax.annotation.Nonnull;\nimport java.util.HashSet;\nimport java.util.Collections;\npublic class GenericMachine<T> {\n    \n    private void deleteStep(final NameState state, final List<String> keys, final int keyIndex, final Map<String, List<Patterns>> patterns, final T ruleName, List<String> deletedKeys) {\r\n        final String key = keys.get(keyIndex);\r\n        ByteMachine byteMachine = state.getTransitionOn(key);\r\n        NameMatcher<NameState> nameMatcher = state.getKeyTransitionOn(key);\r\n        // matchers are null, we have nothing to delete.\r\n        if ((byteMachine == null) && (nameMatcher == null)) {\r\n            return;\r\n        }\r\n        for (Patterns pattern : patterns.get(key)) {\r\n            NameState nextNameState = null;\r\n            if (isNamePattern(pattern)) {\r\n                if (nameMatcher != null) {\r\n                    nextNameState = nameMatcher.findPattern(pattern);\r\n                }\r\n            } else if (byteMachine != null) {\r\n                nextNameState = byteMachine.findPattern(pattern);\r\n            }\r\n            if (nextNameState != null) {\r\n                // if this was the last step, then reaching the last state means the rule matched.\r\n                final int nextKeyIndex = keyIndex + 1;\r\n                if (nextKeyIndex == keys.size()) {\r\n                    if (nextNameState.hasRule(ruleName)) {\r\n                        nextNameState.deleteRule(ruleName);\r\n                        // only when this state have no rules and no next transition, we could remove it.\r\n                        if (checkAndDeleteNameState(nextNameState, state, key, pattern)) {\r\n                            deletedKeys.add(key);\r\n                        }\r\n                    }\r\n                } else {\r\n                    deleteStep(nextNameState, keys, nextKeyIndex, patterns, ruleName, deletedKeys);\r\n                    // only when this state have no rules and no next transition, we could remove it.\r\n                    if (checkAndDeleteNameState(nextNameState, state, key, pattern)) {\r\n                        deletedKeys.add(key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\npublic void addPatternRule(final T name, final Map<String, List<Patterns>> namevals);\n    public void addRule(final T name, final byte[] json) throws IOException;\n    public void addRule(final T name, final InputStream json) throws IOException;\n    public void addRule(final T name, final Reader json) throws IOException;\n    public void addRule(final T name, final String json) throws IOException;\n    public void addRule(final T name, final Map<String, List<String>> namevals);\n    public int approximateObjectCount();\n    private boolean checkAndDeleteNameState(final NameState currentNameState, final NameState parentNameState, final String key, Patterns pattern);\n    public void deletePatternRule(final T name, final Map<String, List<Patterns>> namevals);\n    public void deleteRule(final T name, final InputStream json) throws IOException;\n    public void deleteRule(final T name, final Reader json) throws IOException;\n    public void deleteRule(final T name, final String json) throws IOException;\n    public void deleteRule(final T name, final Map<String, List<String>> namevals);\n    public int evaluateComplexity(MachineComplexityEvaluator evaluator);\n    final NameState getStartState();\n    public boolean isEmpty();\n    boolean isFieldStepUsed(final String stepName);\n    private boolean isNamePattern(Patterns pattern);\n    @SuppressWarnings(\"unchecked\")\r\npublic List<T> rulesForEvent(final String[] event);\n    @SuppressWarnings(\"unchecked\")\r\npublic List<T> rulesForEvent(final List<String> event);\n    @SuppressWarnings(\"unchecked\")\r\npublic List<T> rulesForJSONEvent(final JsonNode eventRoot);\n    @SuppressWarnings(\"unchecked\")\r\npublic List<T> rulesForJSONEvent(final String jsonEvent) throws Exception;\n    @Override\r\npublic String toString();\n}"
      },
      {
        "id": "RuleCompiler_writeRules",
        "package": "software.amazon.event.ruler",
        "class": "software.amazon.event.ruler.RuleCompiler",
        "test-class": "software.amazon.event.ruler.RuleCompiler_writeRules_Test",
        "method-name": "writeRules(Map<String, List<Patterns>>, String, JsonParser, boolean)",
        "source-path": "src/main/java/software/amazon/event/ruler/RuleCompiler.java",
        "test-path": "src/test/java/software/amazon/event/ruler/RuleCompiler_writeRules_Test.java",
        "focal-method": "private static void writeRules(final Map<String, List<Patterns>> rule, final String name, final JsonParser parser, final boolean withQuotes) throws IOException {\r\n    JsonToken token;\r\n    final List<Patterns> values = new ArrayList<>();\r\n    while ((token = parser.nextToken()) != JsonToken.END_ARRAY) {\r\n        switch (token) {\r\n            case START_OBJECT :\r\n                values.add(processMatchExpression(parser));\r\n                break;\r\n            case VALUE_STRING :\r\n                final String toMatch = parser.getText();\r\n                final Range ipRange = CIDR.ipToRangeIfPossible(toMatch);\r\n                if (ipRange != null) {\r\n                    values.add(ipRange);\r\n                } else if (withQuotes) {\r\n                    values.add(Patterns.exactMatch(('\"' + toMatch) + '\"'));\r\n                } else {\r\n                    values.add(Patterns.exactMatch(toMatch));\r\n                }\r\n                break;\r\n            case VALUE_NUMBER_FLOAT :\r\n            case VALUE_NUMBER_INT :\r\n                /* If the rule specifies a match to a number, we'll insert matchers for both the\r\n                 literal expression and the ComparableNumber form. But the number might not\r\n                 be representble as a ComparableNumber, for example an AWS account number,\r\n                 so make that condition survivable.\r\n                 */\r\n                try {\r\n                    values.add(Patterns.numericEquals(parser.getDoubleValue()));\r\n                } catch (Exception e) {\r\n                    // no-op\r\n                }\r\n                values.add(Patterns.exactMatch(parser.getText()));\r\n                break;\r\n            case VALUE_NULL :\r\n            case VALUE_TRUE :\r\n            case VALUE_FALSE :\r\n                values.add(Patterns.exactMatch(parser.getText()));\r\n                break;\r\n            default :\r\n                barf(parser, \"Match value must be String, number, true, false, or null\");\r\n        }\r\n    } \r\n    if (values.isEmpty()) {\r\n        barf(parser, \"Empty arrays are not allowed\");\r\n    }\r\n    rule.put(name, values);\r\n}",
        "class-code": "package software.amazon.event.ruler;\nimport java.util.ArrayDeque;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport java.util.Deque;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport java.io.Reader;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashSet;\npublic final class RuleCompiler {\n    \n    private static void writeRules(final Map<String, List<Patterns>> rule, final String name, final JsonParser parser, final boolean withQuotes) throws IOException {\r\n        JsonToken token;\r\n        final List<Patterns> values = new ArrayList<>();\r\n        while ((token = parser.nextToken()) != JsonToken.END_ARRAY) {\r\n            switch (token) {\r\n                case START_OBJECT :\r\n                    values.add(processMatchExpression(parser));\r\n                    break;\r\n                case VALUE_STRING :\r\n                    final String toMatch = parser.getText();\r\n                    final Range ipRange = CIDR.ipToRangeIfPossible(toMatch);\r\n                    if (ipRange != null) {\r\n                        values.add(ipRange);\r\n                    } else if (withQuotes) {\r\n                        values.add(Patterns.exactMatch(('\"' + toMatch) + '\"'));\r\n                    } else {\r\n                        values.add(Patterns.exactMatch(toMatch));\r\n                    }\r\n                    break;\r\n                case VALUE_NUMBER_FLOAT :\r\n                case VALUE_NUMBER_INT :\r\n                    /* If the rule specifies a match to a number, we'll insert matchers for both the\r\n                     literal expression and the ComparableNumber form. But the number might not\r\n                     be representble as a ComparableNumber, for example an AWS account number,\r\n                     so make that condition survivable.\r\n                     */\r\n                    try {\r\n                        values.add(Patterns.numericEquals(parser.getDoubleValue()));\r\n                    } catch (Exception e) {\r\n                        // no-op\r\n                    }\r\n                    values.add(Patterns.exactMatch(parser.getText()));\r\n                    break;\r\n                case VALUE_NULL :\r\n                case VALUE_TRUE :\r\n                case VALUE_FALSE :\r\n                    values.add(Patterns.exactMatch(parser.getText()));\r\n                    break;\r\n                default :\r\n                    barf(parser, \"Match value must be String, number, true, false, or null\");\r\n            }\r\n        } \r\n        if (values.isEmpty()) {\r\n            barf(parser, \"Empty arrays are not allowed\");\r\n        }\r\n        rule.put(name, values);\r\n    }\nprivate static void barf(final JsonParser parser, final String message) throws JsonParseException;\n    public static String check(final byte[] source);\n    public static String check(final InputStream source);\n    public static String check(final Reader source);\n    public static String check(final String source);\n    public static Map<String, List<Patterns>> compile(final byte[] source) throws IOException;\n    public static Map<String, List<Patterns>> compile(final InputStream source) throws IOException;\n    public static Map<String, List<Patterns>> compile(final Reader source) throws IOException;\n    public static Map<String, List<Patterns>> compile(final String source) throws IOException;\n    private static Patterns processMatchExpression(final JsonParser parser) throws IOException;\n}"
      }
    ]
  },
  "windward": {
    "project-name": "windward",
    "project-url": "windward",
    "focal-methods": [
      {
        "id": "AntPathMatcher_isMatch",
        "package": "org.flmelody.util",
        "class": "org.flmelody.util.AntPathMatcher",
        "test-class": "org.flmelody.util.AntPathMatcher_isMatch_Test",
        "method-name": "isMatch(String, String)",
        "source-path": "src/main/java/org/flmelody/util/AntPathMatcher.java",
        "test-path": "src/test/java/org/flmelody/util/AntPathMatcher_isMatch_Test.java",
        "focal-method": "public boolean isMatch(final String pattern, final String path) {\r\n    if (pattern.isEmpty()) {\r\n        return path.isEmpty();\r\n    } else if (path.isEmpty() && (pattern.charAt(0) == pathSeparator)) {\r\n        if (matchStart) {\r\n            return true;\r\n        } else if ((pattern.length() == 2) && (pattern.charAt(1) == ASTERISK)) {\r\n            return false;\r\n        }\r\n        return isMatch(pattern.substring(1), path);\r\n    }\r\n    final char patternStart = pattern.charAt(0);\r\n    if (patternStart == ASTERISK) {\r\n        if (pattern.length() == 1) {\r\n            return path.isEmpty() || ((path.charAt(0) != pathSeparator) && isMatch(pattern, path.substring(1)));\r\n        } else if (doubleAsteriskMatch(pattern, path)) {\r\n            return true;\r\n        }\r\n        int start = 0;\r\n        while (start < path.length()) {\r\n            if (isMatch(pattern.substring(1), path.substring(start))) {\r\n                return true;\r\n            }\r\n            start++;\r\n        } \r\n        return isMatch(pattern.substring(1), path.substring(start));\r\n    }\r\n    int pointer = skipBlanks(path);\r\n    return ((!path.isEmpty()) && (compareChar(path.charAt(pointer), patternStart) || (patternStart == QUESTION))) && isMatch(pattern.substring(1), path.substring(pointer + 1));\r\n}",
        "class-code": "package org.flmelody.util;\n\npublic class AntPathMatcher {\n    private static final char ASTERISK = '*';\n    private static final char QUESTION = '?';\n    private final char pathSeparator;\n    private final boolean matchStart;\n    public boolean isMatch(final String pattern, final String path) {\r\n        if (pattern.isEmpty()) {\r\n            return path.isEmpty();\r\n        } else if (path.isEmpty() && (pattern.charAt(0) == pathSeparator)) {\r\n            if (matchStart) {\r\n                return true;\r\n            } else if ((pattern.length() == 2) && (pattern.charAt(1) == ASTERISK)) {\r\n                return false;\r\n            }\r\n            return isMatch(pattern.substring(1), path);\r\n        }\r\n        final char patternStart = pattern.charAt(0);\r\n        if (patternStart == ASTERISK) {\r\n            if (pattern.length() == 1) {\r\n                return path.isEmpty() || ((path.charAt(0) != pathSeparator) && isMatch(pattern, path.substring(1)));\r\n            } else if (doubleAsteriskMatch(pattern, path)) {\r\n                return true;\r\n            }\r\n            int start = 0;\r\n            while (start < path.length()) {\r\n                if (isMatch(pattern.substring(1), path.substring(start))) {\r\n                    return true;\r\n                }\r\n                start++;\r\n            } \r\n            return isMatch(pattern.substring(1), path.substring(start));\r\n        }\r\n        int pointer = skipBlanks(path);\r\n        return ((!path.isEmpty()) && (compareChar(path.charAt(pointer), patternStart) || (patternStart == QUESTION))) && isMatch(pattern.substring(1), path.substring(pointer + 1));\r\n    }\nprivate boolean compareChar(final char pathChar, final char patternChar);\n    private boolean doubleAsteriskMatch(final String pattern, final String path);\n    public static AntPathMatcher.Builder newBuild();\n    private int skipBlanks(final String path);\n}"
      },
      {
        "id": "AbstractRouterGroup_matchRouter",
        "package": "org.flmelody.core",
        "class": "org.flmelody.core.AbstractRouterGroup",
        "test-class": "org.flmelody.core.AbstractRouterGroup_matchRouter_Test",
        "method-name": "matchRouter(String, String)",
        "source-path": "src/main/java/org/flmelody/core/AbstractRouterGroup.java",
        "test-path": "src/test/java/org/flmelody/core/AbstractRouterGroup_matchRouter_Test.java",
        "focal-method": "@Override\r\npublic <R> R matchRouter(String relativePath, String method) {\r\n    if (!relativePath.startsWith(groupPath)) {\r\n        return null;\r\n    }\r\n    if (relativePath.endsWith(UrlUtil.SLASH) && (!UrlUtil.SLASH.equals(relativePath))) {\r\n        relativePath = relativePath.replaceFirst(\"/$\", \"\");\r\n    }\r\n    relativePath = relativePath.replaceAll(\"[{}]\", \"\");\r\n    if (!routers.containsKey(relativePath)) {\r\n        Set<String> routerKeys = routers.keySet();\r\n        for (String routerKey : routerKeys) {\r\n            Pattern compiledPattern = Pattern.compile(\"\\\\{(.*?)}\");\r\n            Matcher compiledMatcher = compiledPattern.matcher(routerKey);\r\n            if (!compiledMatcher.find()) {\r\n                // If it's a GET request, try to match it again using Ant-style path patterns\r\n                if (HttpMethod.GET.name().equalsIgnoreCase(method) && resourceRouter) {\r\n                    Boolean result = matchedRouter.get(relativePath);\r\n                    if (Boolean.TRUE.equals(result)) {\r\n                        // noinspection unchecked\r\n                        return ((R) (routers.get(routerKey).get(method)));\r\n                    } else {\r\n                        boolean matched = antPathMatcher.isMatch(routerKey, relativePath);\r\n                        matchedRouter.put(relativePath, matched);\r\n                        if (matched) {\r\n                            // noinspection unchecked\r\n                            return ((R) (routers.get(routerKey).get(method)));\r\n                        }\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n            String routerRegex = routerKey.replaceAll(\"\\\\{(.*?)}\", \"(.+)\");\r\n            if (relativePath.matches(routerRegex)) {\r\n                // Expected router\r\n                int pathCount = new StringTokenizer(relativePath, UrlUtil.SLASH).countTokens();\r\n                int routerCount = new StringTokenizer(routerRegex, UrlUtil.SLASH).countTokens();\r\n                if (pathCount != routerCount) {\r\n                    return null;\r\n                }\r\n                FunctionMetaInfo<?> functionMetaInfo = ((FunctionMetaInfo<?>) (routers.get(routerKey).get(method)));\r\n                if (functionMetaInfo == null) {\r\n                    return null;\r\n                }\r\n                Map<String, Object> pathVariables = functionMetaInfo.getPathVariables();\r\n                List<String> keys = new ArrayList<>(pathVariables.keySet());\r\n                Pattern pattern = Pattern.compile(routerRegex);\r\n                Matcher matcher = pattern.matcher(relativePath);\r\n                int groupCount = matcher.groupCount();\r\n                while (matcher.find()) {\r\n                    for (int j = 0; j < Math.min(groupCount, keys.size()); j++) {\r\n                        pathVariables.put(keys.get(j), matcher.group(j + 1));\r\n                    }\r\n                } \r\n                // noinspection unchecked\r\n                return ((R) (functionMetaInfo));\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    // noinspection unchecked\r\n    return ((R) (routers.get(relativePath).get(method)));\r\n}",
        "class-code": "package org.flmelody.core;\nimport org.flmelody.core.ws.WebSocketWindwardContext;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.regex.Matcher;\nimport org.flmelody.core.context.support.SseWindwardContext;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.flmelody.core.context.SimpleWindwardContext;\nimport java.util.function.Consumer;\nimport org.flmelody.core.context.WindwardContext;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport org.flmelody.support.FunctionDefinition;\nimport java.util.Collections;\nimport java.util.regex.Pattern;\nimport org.flmelody.core.wind.event.RouterBindEvent;\nimport org.flmelody.util.UrlUtil;\nimport org.flmelody.core.context.ResourceWindwardContext;\nimport org.flmelody.core.context.EnhancedWindwardContext;\nimport java.util.StringTokenizer;\nimport org.flmelody.support.EnhancedFunction;\nimport org.flmelody.core.exception.WindwardException;\nimport org.flmelody.core.context.support.HttpKind;\nimport java.util.Map;\nimport org.flmelody.util.AntPathMatcher;\nimport org.flmelody.core.plugin.resource.ResourcePluginProxy;\nimport org.flmelody.core.exception.RouterMappingException;\npublic abstract class AbstractRouterGroup<M> implements RouterGroup<M> {\n    private String groupPath;\n    private final Map<String, Map<String, ? super Object>> routers = Collections.synchronizedMap(new LinkedHashMap<>(2 << 3));\n    private final AntPathMatcher antPathMatcher = AntPathMatcher.newBuild().build();\n    private final Map<String, Boolean> matchedRouter = new ConcurrentHashMap<>();\n    protected boolean resourceRouter;\n    @Override\r\n    public <R> R matchRouter(String relativePath, String method) {\r\n        if (!relativePath.startsWith(groupPath)) {\r\n            return null;\r\n        }\r\n        if (relativePath.endsWith(UrlUtil.SLASH) && (!UrlUtil.SLASH.equals(relativePath))) {\r\n            relativePath = relativePath.replaceFirst(\"/$\", \"\");\r\n        }\r\n        relativePath = relativePath.replaceAll(\"[{}]\", \"\");\r\n        if (!routers.containsKey(relativePath)) {\r\n            Set<String> routerKeys = routers.keySet();\r\n            for (String routerKey : routerKeys) {\r\n                Pattern compiledPattern = Pattern.compile(\"\\\\{(.*?)}\");\r\n                Matcher compiledMatcher = compiledPattern.matcher(routerKey);\r\n                if (!compiledMatcher.find()) {\r\n                    // If it's a GET request, try to match it again using Ant-style path patterns\r\n                    if (HttpMethod.GET.name().equalsIgnoreCase(method) && resourceRouter) {\r\n                        Boolean result = matchedRouter.get(relativePath);\r\n                        if (Boolean.TRUE.equals(result)) {\r\n                            // noinspection unchecked\r\n                            return ((R) (routers.get(routerKey).get(method)));\r\n                        } else {\r\n                            boolean matched = antPathMatcher.isMatch(routerKey, relativePath);\r\n                            matchedRouter.put(relativePath, matched);\r\n                            if (matched) {\r\n                                // noinspection unchecked\r\n                                return ((R) (routers.get(routerKey).get(method)));\r\n                            }\r\n                            continue;\r\n                        }\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                String routerRegex = routerKey.replaceAll(\"\\\\{(.*?)}\", \"(.+)\");\r\n                if (relativePath.matches(routerRegex)) {\r\n                    // Expected router\r\n                    int pathCount = new StringTokenizer(relativePath, UrlUtil.SLASH).countTokens();\r\n                    int routerCount = new StringTokenizer(routerRegex, UrlUtil.SLASH).countTokens();\r\n                    if (pathCount != routerCount) {\r\n                        return null;\r\n                    }\r\n                    FunctionMetaInfo<?> functionMetaInfo = ((FunctionMetaInfo<?>) (routers.get(routerKey).get(method)));\r\n                    if (functionMetaInfo == null) {\r\n                        return null;\r\n                    }\r\n                    Map<String, Object> pathVariables = functionMetaInfo.getPathVariables();\r\n                    List<String> keys = new ArrayList<>(pathVariables.keySet());\r\n                    Pattern pattern = Pattern.compile(routerRegex);\r\n                    Matcher matcher = pattern.matcher(relativePath);\r\n                    int groupCount = matcher.groupCount();\r\n                    while (matcher.find()) {\r\n                        for (int j = 0; j < Math.min(groupCount, keys.size()); j++) {\r\n                            pathVariables.put(keys.get(j), matcher.group(j + 1));\r\n                        }\r\n                    } \r\n                    // noinspection unchecked\r\n                    return ((R) (functionMetaInfo));\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        // noinspection unchecked\r\n        return ((R) (routers.get(relativePath).get(method)));\r\n    }\n@Override\r\npublic RouterGroup<M> delete(String relativePath, Consumer<SimpleWindwardContext> consumer);\n    @Override\r\npublic <R> RouterGroup<M> delete(String relativePath, Supplier<R> supplier);\n    @Override\r\npublic <C extends EnhancedWindwardContext & HttpKind> RouterGroup<M> delete(String relativePath, EnhancedFunction<C, ?> function);\n    @Override\r\npublic M end();\n    @Override\r\npublic RouterGroup<M> get(String relativePath, Consumer<SimpleWindwardContext> consumer);\n    @Override\r\npublic <R> RouterGroup<M> get(String relativePath, Supplier<R> supplier);\n    @Override\r\npublic <C extends EnhancedWindwardContext & HttpKind> RouterGroup<M> get(String relativePath, EnhancedFunction<C, ?> function);\n    @Override\r\npublic RouterGroup<M> http(HttpMethod httpMethod, String relativePath, Consumer<SimpleWindwardContext> consumer);\n    @Override\r\npublic <R> RouterGroup<M> http(HttpMethod httpMethod, String relativePath, Supplier<R> supplier);\n    @Override\r\npublic <C extends EnhancedWindwardContext & HttpKind> RouterGroup<M> http(HttpMethod httpMethod, String relativePath, EnhancedFunction<C, ?> function);\n    @Override\r\npublic RouterGroup<M> post(String relativePath, Consumer<SimpleWindwardContext> consumer);\n    @Override\r\npublic <R> RouterGroup<M> post(String relativePath, Supplier<R> supplier);\n    @Override\r\npublic <C extends EnhancedWindwardContext & HttpKind> RouterGroup<M> post(String relativePath, EnhancedFunction<C, ?> function);\n    @Override\r\npublic RouterGroup<M> put(String relativePath, Consumer<SimpleWindwardContext> consumer);\n    @Override\r\npublic <R> RouterGroup<M> put(String relativePath, Supplier<R> supplier);\n    @Override\r\npublic <C extends EnhancedWindwardContext & HttpKind> RouterGroup<M> put(String relativePath, EnhancedFunction<C, ?> function);\n    @Override\r\npublic RouterGroup<M> resources(String staticResourceLocation, String... pathPatterns);\n    protected void setGroupPath(String groupPath);\n    @Override\r\npublic RouterGroup<M> sse(String relativePath, EnhancedFunction<SseWindwardContext, SseEjector> function);\n    @Override\r\npublic RouterGroup<M> ws(String relativePath, Consumer<WebSocketWindwardContext> consumer);\n}"
      }
    ]
  }
}