{
  "project": "commons-codec",
  "source": {
    "org.apache.commons.codec.binary.Base16": {
      "fields": [
        {
          "variable_name": "BITS_PER_ENCODED_BYTE",
          "variable_type": "int"
        },
        {
          "variable_name": "BYTES_PER_ENCODED_BLOCK",
          "variable_type": "int"
        },
        {
          "variable_name": "BYTES_PER_UNENCODED_BLOCK",
          "variable_type": "int"
        },
        {
          "variable_name": "UPPER_CASE_DECODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "UPPER_CASE_ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "LOWER_CASE_DECODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "LOWER_CASE_ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "MASK_4BITS",
          "variable_type": "int"
        },
        {
          "variable_name": "decodeTable",
          "variable_type": "byte"
        },
        {
          "variable_name": "encodeTable",
          "variable_type": "byte"
        }
      ],
      "constructors": [
        {
          "body": "public Base16()\n{\r\n    this(false);\r\n}",
          "signature": "Base16()",
          "parameters": [],
          "javadoc": "\n     * Constructs a Base16 codec used for decoding and encoding.\n     "
        },
        {
          "body": "public Base16(final boolean lowerCase)\n{\r\n    this(lowerCase, DECODING_POLICY_DEFAULT);\r\n}",
          "signature": "Base16(boolean)",
          "parameters": [
            {
              "variable_name": "lowerCase",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base16 codec used for decoding and encoding.\n     *\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.\n     "
        },
        {
          "body": "private Base16(final boolean lowerCase, final byte[] encodeTable, final CodecPolicy decodingPolicy)\n{\r\n    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, 0, 0, PAD_DEFAULT, decodingPolicy);\r\n    Objects.requireNonNull(encodeTable, \"encodeTable\");\r\n    this.encodeTable = encodeTable;\r\n    this.decodeTable = encodeTable == LOWER_CASE_ENCODE_TABLE ? LOWER_CASE_DECODE_TABLE : UPPER_CASE_DECODE_TABLE;\r\n}",
          "signature": "Base16(boolean, byte[], CodecPolicy)",
          "parameters": [
            {
              "variable_name": "lowerCase",
              "variable_type": "boolean"
            },
            {
              "variable_name": "encodeTable",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base16 codec used for decoding and encoding.\n     *\n     * @param lowerCase      if {@code true} then use a lower-case Base16 alphabet.\n     * @param encodeTable    the encode table.\n     * @param decodingPolicy Decoding policy.\n     "
        },
        {
          "body": "public Base16(final boolean lowerCase, final CodecPolicy decodingPolicy)\n{\r\n    this(lowerCase, lowerCase ? LOWER_CASE_ENCODE_TABLE : UPPER_CASE_ENCODE_TABLE, decodingPolicy);\r\n}",
          "signature": "Base16(boolean, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "lowerCase",
              "variable_type": "boolean"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base16 codec used for decoding and encoding.\n     *\n     * @param lowerCase      if {@code true} then use a lower-case Base16 alphabet.\n     * @param decodingPolicy Decoding policy.\n     "
        }
      ],
      "methods": {
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "charsToProcess / BYTES_PER_ENCODED_BLOCK",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16.validateTrailingCharacter()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "data.length - offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16.decodeOctet(byte)",
                "arguments": [
                  {
                    "variable_name": "data[offset]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": " void decode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ]
          }
        ],
        "decodeOctet": [
          {
            "call_methods": [],
            "signature": "private int decodeOctet(byte)",
            "parameters": [
              {
                "variable_name": "octet",
                "variable_type": "byte"
              }
            ]
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "size",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": " void encode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ]
          }
        ],
        "isInAlphabet": [
          {
            "call_methods": [],
            "signature": "public boolean isInAlphabet(byte)",
            "parameters": [
              {
                "variable_name": "octet",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Returns whether or not the {@code octet} is in the Base16 alphabet.\n     *\n     * @param octet The value to test.\n     *\n     * @return {@code true} if the value is defined in the Base16 alphabet {@code false} otherwise.\n     "
          }
        ],
        "validateTrailingCharacter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "private void validateTrailingCharacter()",
            "parameters": [],
            "javadoc": "\n     * Validates whether decoding allows an entire final trailing character that cannot be used for a complete byte.\n     *\n     * @throws IllegalArgumentException if strict decoding is enabled\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Provides Base16 encoding and decoding.\n *\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * This implementation strictly follows RFC 4648, and as such unlike the {@link Base32} and {@link Base64} implementations, it does not ignore invalid alphabet\n * characters or whitespace, neither does it offer chunking or padding characters.\n * </p>\n * <p>\n * The only additional feature above those specified in RFC 4648 is support for working with a lower-case alphabet in addition to the default upper-case\n * alphabet.\n * </p>\n *\n * @see <a href=\"https://tools.ietf.org/html/rfc4648#section-8\">RFC 4648 - 8. Base 16 Encoding</a>\n *\n * @since 1.15\n "
    },
    "org.apache.commons.codec.binary.Base16InputStream": {
      "fields": [],
      "constructors": [
        {
          "body": "public Base16InputStream(final InputStream inputStream)\n{\r\n    this(inputStream, false);\r\n}",
          "signature": "Base16InputStream(InputStream)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            }
          ],
          "javadoc": "\n     * Constructs a Base16InputStream such that all data read is Base16-decoded from the original provided InputStream.\n     *\n     * @param inputStream InputStream to wrap.\n     "
        },
        {
          "body": "public Base16InputStream(final InputStream inputStream, final boolean doEncode)\n{\r\n    this(inputStream, doEncode, false);\r\n}",
          "signature": "Base16InputStream(InputStream, boolean)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base16InputStream such that all data read is either Base16-encoded or Base16-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream InputStream to wrap.\n     * @param doEncode true if we should encode all data read from us, false if we should decode.\n     "
        },
        {
          "body": "public Base16InputStream(final InputStream inputStream, final boolean doEncode, final boolean lowerCase)\n{\r\n    this(inputStream, doEncode, lowerCase, CodecPolicy.LENIENT);\r\n}",
          "signature": "Base16InputStream(InputStream, boolean, boolean)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lowerCase",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base16InputStream such that all data read is either Base16-encoded or Base16-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream InputStream to wrap.\n     * @param doEncode true if we should encode all data read from us, false if we should decode.\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.\n     "
        },
        {
          "body": "public Base16InputStream(final InputStream inputStream, final boolean doEncode, final boolean lowerCase, final CodecPolicy decodingPolicy)\n{\r\n    super(inputStream, new Base16(lowerCase, decodingPolicy), doEncode);\r\n}",
          "signature": "Base16InputStream(InputStream, boolean, boolean, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lowerCase",
              "variable_type": "boolean"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base16InputStream such that all data read is either Base16-encoded or Base16-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream InputStream to wrap.\n     * @param doEncode true if we should encode all data read from us, false if we should decode.\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.\n     * @param decodingPolicy Decoding policy.\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Provides Base16 encoding and decoding in a streaming fashion (unlimited size).\n * <p>\n * The default behavior of the Base16InputStream is to DECODE, whereas the default behavior of the\n * {@link Base16OutputStream} is to ENCODE, but this behavior can be overridden by using a different constructor.\n * </p>\n *\n * @since 1.15\n "
    },
    "org.apache.commons.codec.binary.Base16OutputStream": {
      "fields": [],
      "constructors": [
        {
          "body": "public Base16OutputStream(final OutputStream outputStream)\n{\r\n    this(outputStream, true);\r\n}",
          "signature": "Base16OutputStream(OutputStream)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            }
          ],
          "javadoc": "\n     * Constructs a Base16OutputStream such that all data written is Hex-encoded to the original provided OutputStream.\n     *\n     * @param outputStream OutputStream to wrap.\n     "
        },
        {
          "body": "public Base16OutputStream(final OutputStream outputStream, final boolean doEncode)\n{\r\n    this(outputStream, doEncode, false);\r\n}",
          "signature": "Base16OutputStream(OutputStream, boolean)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base16OutputStream such that all data written is either Hex-encoded or Hex-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream OutputStream to wrap.\n     * @param doEncode true if we should encode all data written to us, false if we should decode.\n     "
        },
        {
          "body": "public Base16OutputStream(final OutputStream outputStream, final boolean doEncode, final boolean lowerCase)\n{\r\n    this(outputStream, doEncode, lowerCase, CodecPolicy.LENIENT);\r\n}",
          "signature": "Base16OutputStream(OutputStream, boolean, boolean)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lowerCase",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base16OutputStream such that all data written is either Hex-encoded or Hex-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream OutputStream to wrap.\n     * @param doEncode true if we should encode all data written to us, false if we should decode.\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.\n     "
        },
        {
          "body": "public Base16OutputStream(final OutputStream outputStream, final boolean doEncode, final boolean lowerCase, final CodecPolicy decodingPolicy)\n{\r\n    super(outputStream, new Base16(lowerCase, decodingPolicy), doEncode);\r\n}",
          "signature": "Base16OutputStream(OutputStream, boolean, boolean, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lowerCase",
              "variable_type": "boolean"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base16OutputStream such that all data written is either Hex-encoded or Hex-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream OutputStream to wrap.\n     * @param doEncode true if we should encode all data written to us, false if we should decode.\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet.\n     * @param decodingPolicy Decoding policy.\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Provides Hex encoding and decoding in a streaming fashion (unlimited size).\n * <p>\n * The default behavior of the HexOutputStream is to ENCODE, whereas the default behavior of the\n * {@link Base16InputStream} is to DECODE. But this behavior can be overridden by using a different constructor.\n * </p>\n *\n * @since 1.15\n "
    },
    "org.apache.commons.codec.binary.Base32": {
      "fields": [
        {
          "variable_name": "BITS_PER_ENCODED_BYTE",
          "variable_type": "int"
        },
        {
          "variable_name": "BYTES_PER_ENCODED_BLOCK",
          "variable_type": "int"
        },
        {
          "variable_name": "BYTES_PER_UNENCODED_BLOCK",
          "variable_type": "int"
        },
        {
          "variable_name": "DECODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "HEX_DECODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "HEX_ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "MASK_5BITS",
          "variable_type": "int"
        },
        {
          "variable_name": "MASK_4BITS",
          "variable_type": "long"
        },
        {
          "variable_name": "MASK_3BITS",
          "variable_type": "long"
        },
        {
          "variable_name": "MASK_2BITS",
          "variable_type": "long"
        },
        {
          "variable_name": "MASK_1BITS",
          "variable_type": "long"
        },
        {
          "variable_name": "decodeTable",
          "variable_type": "byte"
        },
        {
          "variable_name": "encodeSize",
          "variable_type": "int"
        },
        {
          "variable_name": "encodeTable",
          "variable_type": "byte"
        },
        {
          "variable_name": "lineSeparator",
          "variable_type": "byte"
        }
      ],
      "constructors": [
        {
          "body": "public Base32()\n{\r\n    this(false);\r\n}",
          "signature": "Base32()",
          "parameters": [],
          "javadoc": "\n     * Constructs a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     "
        },
        {
          "body": "public Base32(final boolean useHex)\n{\r\n    this(0, null, useHex, PAD_DEFAULT);\r\n}",
          "signature": "Base32(boolean)",
          "parameters": [
            {
              "variable_name": "useHex",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     * @param useHex if {@code true} then use Base32 Hex alphabet\n     "
        },
        {
          "body": "public Base32(final boolean useHex, final byte padding)\n{\r\n    this(0, null, useHex, padding);\r\n}",
          "signature": "Base32(boolean, byte)",
          "parameters": [
            {
              "variable_name": "useHex",
              "variable_type": "boolean"
            },
            {
              "variable_name": "padding",
              "variable_type": "byte"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     * @param useHex  if {@code true} then use Base32 Hex alphabet\n     * @param padding byte used as padding byte.\n     "
        },
        {
          "body": "public Base32(final byte pad)\n{\r\n    this(false, pad);\r\n}",
          "signature": "Base32(byte)",
          "parameters": [
            {
              "variable_name": "pad",
              "variable_type": "byte"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is 0 (no chunking).\n     * </p>\n     *\n     * @param pad byte used as padding byte.\n     "
        },
        {
          "body": "public Base32(final int lineLength)\n{\r\n    this(lineLength, CHUNK_SEPARATOR);\r\n}",
          "signature": "Base32(int)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\n     * </p>\n     *\n     * @param lineLength Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0, then\n     *                   the output will not be divided into lines (chunks). Ignored when decoding.\n     "
        },
        {
          "body": "public Base32(final int lineLength, final byte[] lineSeparator)\n{\r\n    this(lineLength, lineSeparator, false, PAD_DEFAULT);\r\n}",
          "signature": "Base32(int, byte[])",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,\n     *                      then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters.\n     "
        },
        {
          "body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex)\n{\r\n    this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\r\n}",
          "signature": "Base32(int, byte[], boolean)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "useHex",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,\n     *                      then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.\n     * @param useHex        if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.\n     "
        },
        {
          "body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding)\n{\r\n    this(lineLength, lineSeparator, useHex, padding, DECODING_POLICY_DEFAULT);\r\n}",
          "signature": "Base32(int, byte[], boolean, byte)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "useHex",
              "variable_type": "boolean"
            },
            {
              "variable_name": "padding",
              "variable_type": "byte"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength    Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,\n     *                      then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator Each line of encoded data will end with this sequence of bytes.\n     * @param useHex        if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param padding       padding byte.\n     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.\n     "
        },
        {
          "body": "public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte padding, final CodecPolicy decodingPolicy)\n{\r\n    this(lineLength, lineSeparator, useHex ? HEX_ENCODE_TABLE : ENCODE_TABLE, padding, decodingPolicy);\r\n}",
          "signature": "Base32(int, byte[], boolean, byte, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "useHex",
              "variable_type": "boolean"
            },
            {
              "variable_name": "padding",
              "variable_type": "byte"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,\n     *                       then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes.\n     * @param useHex         if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\n     * @param padding        padding byte.\n     * @param decodingPolicy The decoding policy.\n     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.\n     * @since 1.15\n     "
        },
        {
          "body": "private Base32(final int lineLength, final byte[] lineSeparator, final byte[] encodeTable, final byte padding, final CodecPolicy decodingPolicy)\n{\r\n    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, toLength(lineSeparator), padding, decodingPolicy);\r\n    Objects.requireNonNull(encodeTable, \"encodeTable\");\r\n    this.encodeTable = encodeTable;\r\n    this.decodeTable = encodeTable == HEX_ENCODE_TABLE ? HEX_DECODE_TABLE : DECODE_TABLE;\r\n    if (lineLength > 0) {\r\n        if (lineSeparator == null) {\r\n            throw new IllegalArgumentException(\"lineLength \" + lineLength + \" > 0, but lineSeparator is null\");\r\n        }\r\n        final byte[] lineSeparatorCopy = lineSeparator.clone();\r\n        // Must be done after initializing the tables\r\n        if (containsAlphabetOrPad(lineSeparatorCopy)) {\r\n            final String sep = StringUtils.newStringUtf8(lineSeparatorCopy);\r\n            throw new IllegalArgumentException(\"lineSeparator must not contain Base32 characters: [\" + sep + \"]\");\r\n        }\r\n        this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparatorCopy.length;\r\n        this.lineSeparator = lineSeparatorCopy;\r\n    } else {\r\n        this.encodeSize = BYTES_PER_ENCODED_BLOCK;\r\n        this.lineSeparator = null;\r\n    }\r\n    if (isInAlphabet(padding) || Character.isWhitespace(padding)) {\r\n        throw new IllegalArgumentException(\"pad must not be in alphabet or whitespace\");\r\n    }\r\n}",
          "signature": "Base32(int, byte[], byte[], byte, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "encodeTable",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "padding",
              "variable_type": "byte"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base32 / Base32 Hex codec used for decoding and encoding.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n     * </p>\n     *\n     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 8). If lineLength &lt;= 0,\n     *                       then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes.\n     * @param encodeTable    A Base32 alphabet.\n     * @param padding        padding byte.\n     * @param decodingPolicy The decoding policy.\n     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base32 characters. Or the lineLength &gt; 0 and lineSeparator is null.\n     "
        }
      ],
      "methods": {
        "builder": [
          {
            "call_methods": [],
            "signature": "public static Builder builder()",
            "parameters": [],
            "javadoc": "\n     * Creates a new Builder.\n     *\n     * @return a new Builder.\n     * @since 1.17.0\n     "
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "decodeSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.validateTrailingCharacters()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.validateCharacter(long, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "MASK_2BITS",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": " void decode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "inPos",
                "variable_type": "int"
              },
              {
                "variable_name": "inAvail",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once with the data to decode, and once with\n     * inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are silently ignored, but has implications\n     * for other bytes, too. This method subscribes to the garbage-in, garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Output is written to {@link org.apache.commons.codec.binary.BaseNCodec.Context#buffer Context#buffer} as 8-bit octets, using\n     * {@link org.apache.commons.codec.binary.BaseNCodec.Context#pos Context#pos} as the buffer position\n     * </p>\n     *\n     * @param input   byte[] array of ASCII data to Base32 decode.\n     * @param inPos   Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for decoding.\n     * @param context the context to be used\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "lineSeparator",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "context.pos",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "lineSeparator.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "encodeSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": " void encode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "inPos",
                "variable_type": "int"
              },
              {
                "variable_name": "inAvail",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with\n     * inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 5).\n     * </p>\n     *\n     * @param input   byte[] array of binary data to Base32 encode.\n     * @param inPos   Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     "
          }
        ],
        "getLineSeparator": [
          {
            "call_methods": [],
            "signature": " byte[] getLineSeparator()",
            "parameters": [],
            "javadoc": "\n     * Gets the line separator (for testing only).\n     *\n     * @return the line separator.\n     "
          }
        ],
        "isInAlphabet": [
          {
            "call_methods": [],
            "signature": "public boolean isInAlphabet(byte)",
            "parameters": [
              {
                "variable_name": "octet",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Returns whether or not the {@code octet} is in the Base32 alphabet.\n     *\n     * @param octet The value to test\n     * @return {@code true} if the value is defined in the Base32 alphabet {@code false} otherwise.\n     "
          }
        ],
        "validateCharacter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "private void validateCharacter(long, Context)",
            "parameters": [
              {
                "variable_name": "emptyBitsMask",
                "variable_type": "long"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * Validates whether decoding the final trailing character is possible in the context of the set of possible base 32 values.\n     * <p>\n     * The character is valid if the lower bits within the provided mask are zero. This is used to test the final trailing base-32 digit is zero in the bits\n     * that will be discarded.\n     * </p>\n     *\n     * @param emptyBitsMask The mask of the lower bits that should be empty\n     * @param context       the context to be used\n     *\n     * @throws IllegalArgumentException if the bits being checked contain any non-zero value\n     "
          }
        ],
        "validateTrailingCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "private void validateTrailingCharacters()",
            "parameters": [],
            "javadoc": "\n     * Validates whether decoding allows final trailing characters that cannot be created during encoding.\n     *\n     * @throws IllegalArgumentException if strict decoding is enabled\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Provides Base32 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>.\n *\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * </p>\n * <ul>\n * <li>Whether to use the \"base32hex\" variant instead of the default \"base32\"</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * <p>\n * This class operates directly on byte streams, and not character streams.\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * You can configure instances with the {@link Builder}.\n * </p>\n * <pre>\n * Base32 base32 = Base32.builder()\n *   .setDecodingPolicy(DecodingPolicy.LENIENT) // default is lenient\n *   .setEncodeTable(customEncodeTable)\n *   .setLineLength(0)                          // default is none\n *   .setLineSeparator('\\r', '\\n')              // default is CR LF\n *   .setPadding('=')                           // default is =\n *   .get()\n * </pre>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.Base32.Builder": {
      "fields": [],
      "constructors": [
        {
          "body": "public Builder()\n{\r\n    super(ENCODE_TABLE);\r\n}",
          "signature": "Builder()",
          "parameters": [],
          "javadoc": "\n         * Constructs a new instance.\n         "
        }
      ],
      "methods": {
        "get": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getLineSeparator()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getDecodingPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getLineLength()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getPadding()",
                "arguments": [],
                "return_type": "byte"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getEncodeTable()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Base32 get()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Builds {@link Base32} instances.\n     *\n     * @since 1.17.0\n     "
    },
    "org.apache.commons.codec.binary.Base32InputStream": {
      "fields": [],
      "constructors": [
        {
          "body": "public Base32InputStream(final InputStream inputStream)\n{\r\n    this(inputStream, false);\r\n}",
          "signature": "Base32InputStream(InputStream)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            }
          ],
          "javadoc": "\n     * Constructs a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     "
        },
        {
          "body": "public Base32InputStream(final InputStream inputStream, final boolean doEncode)\n{\r\n    super(inputStream, new Base32(false), doEncode);\r\n}",
          "signature": "Base32InputStream(InputStream, boolean)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     "
        },
        {
          "body": "public Base32InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator)\n{\r\n    super(inputStream, new Base32(lineLength, lineSeparator), doEncode);\r\n}",
          "signature": "Base32InputStream(InputStream, boolean, int, byte[])",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Constructs a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     "
        },
        {
          "body": "public Base32InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy)\n{\r\n    super(inputStream, new Base32(lineLength, lineSeparator, false, BaseNCodec.PAD_DEFAULT, decodingPolicy), doEncode);\r\n}",
          "signature": "Base32InputStream(InputStream, boolean, int, byte[], CodecPolicy)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     * @param decodingPolicy\n     *            The decoding policy.\n     * @since 1.15\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base32InputStream is to DECODE, whereas the default behavior of the Base32OutputStream\n * is to ENCODE, but this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.Base32OutputStream": {
      "fields": [],
      "constructors": [
        {
          "body": "public Base32OutputStream(final OutputStream outputStream)\n{\r\n    this(outputStream, true);\r\n}",
          "signature": "Base32OutputStream(OutputStream)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            }
          ],
          "javadoc": "\n     * Constructs a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     "
        },
        {
          "body": "public Base32OutputStream(final OutputStream outputStream, final boolean doEncode)\n{\r\n    super(outputStream, new Base32(false), doEncode);\r\n}",
          "signature": "Base32OutputStream(OutputStream, boolean)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     "
        },
        {
          "body": "public Base32OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator)\n{\r\n    super(outputStream, new Base32(lineLength, lineSeparator), doEncode);\r\n}",
          "signature": "Base32OutputStream(OutputStream, boolean, int, byte[])",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Constructs a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     "
        },
        {
          "body": "public Base32OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy)\n{\r\n    super(outputStream, new Base32(lineLength, lineSeparator, false, BaseNCodec.PAD_DEFAULT, decodingPolicy), doEncode);\r\n}",
          "signature": "Base32OutputStream(OutputStream, boolean, int, byte[], CodecPolicy)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     * @param decodingPolicy The decoding policy.\n     * @since 1.15\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base32OutputStream is to ENCODE, whereas the default behavior of the Base32InputStream\n * is to DECODE. But this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * <b>Note:</b> It is mandatory to close the stream after the last byte has been written to it, otherwise the\n * final padding will be omitted and the resulting data will be incomplete/inconsistent.\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.Base64": {
      "fields": [
        {
          "variable_name": "BITS_PER_ENCODED_BYTE",
          "variable_type": "int"
        },
        {
          "variable_name": "BYTES_PER_UNENCODED_BLOCK",
          "variable_type": "int"
        },
        {
          "variable_name": "BYTES_PER_ENCODED_BLOCK",
          "variable_type": "int"
        },
        {
          "variable_name": "ALPHABET_LENGTH",
          "variable_type": "int"
        },
        {
          "variable_name": "DECODING_TABLE_LENGTH",
          "variable_type": "int"
        },
        {
          "variable_name": "STANDARD_ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "URL_SAFE_ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "DECODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "MASK_6BITS",
          "variable_type": "int"
        },
        {
          "variable_name": "MASK_4BITS",
          "variable_type": "int"
        },
        {
          "variable_name": "MASK_2BITS",
          "variable_type": "int"
        },
        {
          "variable_name": "encodeTable",
          "variable_type": "byte"
        },
        {
          "variable_name": "decodeTable",
          "variable_type": "byte"
        },
        {
          "variable_name": "lineSeparator",
          "variable_type": "byte"
        },
        {
          "variable_name": "encodeSize",
          "variable_type": "int"
        },
        {
          "variable_name": "isUrlSafe",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public Base64()\n{\r\n    this(0);\r\n}",
          "signature": "Base64()",
          "parameters": [],
          "javadoc": "\n     * Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     "
        },
        {
          "body": "public Base64(final boolean urlSafe)\n{\r\n    this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\r\n}",
          "signature": "Base64(boolean)",
          "parameters": [
            {
              "variable_name": "urlSafe",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param urlSafe\n     *            if {@code true}, URL-safe encoding is used. In most cases this should be set to\n     *            {@code false}.\n     * @since 1.4\n     "
        },
        {
          "body": "public Base64(final int lineLength)\n{\r\n    this(lineLength, CHUNK_SEPARATOR);\r\n}",
          "signature": "Base64(int)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            }
          ],
          "javadoc": "\n     * Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @since 1.4\n     "
        },
        {
          "body": "public Base64(final int lineLength, final byte[] lineSeparator)\n{\r\n    this(lineLength, lineSeparator, false);\r\n}",
          "signature": "Base64(int, byte[])",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @throws IllegalArgumentException\n     *             Thrown when the provided lineSeparator included some base64 characters.\n     * @since 1.4\n     "
        },
        {
          "body": "public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe)\n{\r\n    this(lineLength, lineSeparator, PAD_DEFAULT, toUrlSafeEncodeTable(urlSafe), DECODING_POLICY_DEFAULT);\r\n}",
          "signature": "Base64(int, byte[], boolean)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "urlSafe",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\n     * @throws IllegalArgumentException\n     *             Thrown when the {@code lineSeparator} contains Base64 characters.\n     * @since 1.4\n     "
        },
        {
          "body": "public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe, final CodecPolicy decodingPolicy)\n{\r\n    this(lineLength, lineSeparator, PAD_DEFAULT, toUrlSafeEncodeTable(urlSafe), decodingPolicy);\r\n}",
          "signature": "Base64(int, byte[], boolean, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "urlSafe",
              "variable_type": "boolean"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\n     *            decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\n     * @param decodingPolicy The decoding policy.\n     * @throws IllegalArgumentException\n     *             Thrown when the {@code lineSeparator} contains Base64 characters.\n     * @since 1.15\n     "
        },
        {
          "body": "private Base64(final int lineLength, final byte[] lineSeparator, final byte padding, final byte[] encodeTable, final CodecPolicy decodingPolicy)\n{\r\n    super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength, toLength(lineSeparator), padding, decodingPolicy);\r\n    Objects.requireNonNull(encodeTable, \"encodeTable\");\r\n    if (encodeTable.length != ALPHABET_LENGTH) {\r\n        throw new IllegalArgumentException(\"encodeTable must have exactly 64 entries.\");\r\n    }\r\n    this.isUrlSafe = encodeTable == URL_SAFE_ENCODE_TABLE;\r\n    if (encodeTable == STANDARD_ENCODE_TABLE || this.isUrlSafe) {\r\n        decodeTable = DECODE_TABLE;\r\n        // No need of a defensive copy of an internal table.\r\n        this.encodeTable = encodeTable;\r\n    } else {\r\n        this.encodeTable = encodeTable.clone();\r\n        this.decodeTable = calculateDecodeTable(this.encodeTable);\r\n    }\r\n    // TODO could be simplified if there is no requirement to reject invalid line sep when length <=0\r\n    // @see test case Base64Test.testConstructors()\r\n    if (lineSeparator != null) {\r\n        final byte[] lineSeparatorCopy = lineSeparator.clone();\r\n        if (containsAlphabetOrPad(lineSeparatorCopy)) {\r\n            final String sep = StringUtils.newStringUtf8(lineSeparatorCopy);\r\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\r\n        }\r\n        if (lineLength > 0) {\r\n            // null line-sep forces no chunking rather than throwing IAE\r\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparatorCopy.length;\r\n            this.lineSeparator = lineSeparatorCopy;\r\n        } else {\r\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\r\n            this.lineSeparator = null;\r\n        }\r\n    } else {\r\n        this.encodeSize = BYTES_PER_ENCODED_BLOCK;\r\n        this.lineSeparator = null;\r\n    }\r\n}",
          "signature": "Base64(int, byte[], byte, byte[], CodecPolicy)",
          "parameters": [
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "padding",
              "variable_type": "byte"
            },
            {
              "variable_name": "encodeTable",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     *\n     * @param lineLength     Each line of encoded data will be at most of the given length (rounded down to the nearest multiple of 4). If lineLength &lt;= 0,\n     *                       then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator  Each line of encoded data will end with this sequence of bytes; the constructor makes a defensive copy. May be null.\n     * @param padding        padding byte.\n     * @param encodeTable    The manual encodeTable - a byte array of 64 chars.\n     * @param decodingPolicy The decoding policy.\n     * @throws IllegalArgumentException Thrown when the {@code lineSeparator} contains Base64 characters.\n     "
        }
      ],
      "methods": {
        "builder": [
          {
            "call_methods": [],
            "signature": "public static Builder builder()",
            "parameters": [],
            "javadoc": "\n     * Creates a new Builder.\n     *\n     * @return a new Builder.\n     * @since 1.17.0\n     "
          }
        ],
        "decodeBase64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "base64Data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] decodeBase64(byte[])",
            "parameters": [
              {
                "variable_name": "base64Data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes Base64 data into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64String",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] decodeBase64(String)",
            "parameters": [
              {
                "variable_name": "base64String",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a Base64 String into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     "
          }
        ],
        "decodeInteger": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static BigInteger decodeInteger(byte[])",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     "
          }
        ],
        "encodeBase64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] encodeBase64(byte[])",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean)",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "isChunked",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] encodeBase64(byte[], boolean)",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "isChunked",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean, int)",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "isChunked",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "urlSafe",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "Integer.MAX_VALUE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] encodeBase64(byte[], boolean, boolean)",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "isChunked",
                "variable_type": "boolean"
              },
              {
                "variable_name": "urlSafe",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[])",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static byte[] encodeBase64(byte[], boolean, boolean, int)",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "isChunked",
                "variable_type": "boolean"
              },
              {
                "variable_name": "urlSafe",
                "variable_type": "boolean"
              },
              {
                "variable_name": "maxResultSize",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     "
          }
        ],
        "encodeBase64Chunked": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] encodeBase64Chunked(byte[])",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks\n     "
          }
        ],
        "encodeBase64String": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodeBase64(binaryData, false)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String encodeBase64String(byte[])",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behavior of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5).\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\n     "
          }
        ],
        "encodeBase64URLSafe": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean)",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] encodeBase64URLSafe(byte[])",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     "
          }
        ],
        "encodeBase64URLSafeString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodeBase64(binaryData, false, true)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean)",
                "arguments": [
                  {
                    "variable_name": "binaryData",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String encodeBase64URLSafeString(byte[])",
            "parameters": [
              {
                "variable_name": "binaryData",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     "
          }
        ],
        "encodeInteger": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "toIntegerBytes(bigInteger)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.toIntegerBytes(java.math.BigInteger)",
                "arguments": [
                  {
                    "variable_name": "bigInteger",
                    "variable_type": "java.math.BigInteger"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.Objects.requireNonNull(T, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bigInteger",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "\"bigInteger\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public static byte[] encodeInteger(BigInteger)",
            "parameters": [
              {
                "variable_name": "bigInteger",
                "variable_type": "java.math.BigInteger"
              }
            ],
            "javadoc": "\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param bigInteger\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4\n     "
          }
        ],
        "isArrayByteBase64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "arrayOctet",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public static boolean isArrayByteBase64(byte[])",
            "parameters": [
              {
                "variable_name": "arrayOctet",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         {@code false}, otherwise\n     * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0.\n     "
          }
        ],
        "isBase64": [
          {
            "call_methods": [],
            "signature": "public static boolean isBase64(byte)",
            "parameters": [
              {
                "variable_name": "octet",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Returns whether or not the {@code octet} is in the base 64 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the base 64 alphabet, {@code false} otherwise.\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Character.isWhitespace(int)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public static boolean isBase64(byte[])",
            "parameters": [
              {
                "variable_name": "arrayOctet",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         {@code false}, otherwise\n     * @since 1.5\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(base64)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static boolean isBase64(String)",
            "parameters": [
              {
                "variable_name": "base64",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param base64\n     *            String to test\n     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if\n     *         the String is empty; {@code false}, otherwise\n     *  @since 1.5\n     "
          }
        ],
        "toIntegerBytes": [
          {
            "call_methods": [
              {
                "signature": "java.math.BigInteger.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "bigBytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "startSrc",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "resizedBytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "startDst",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "len",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.math.BigInteger.bitLength()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " static byte[] toIntegerBytes(BigInteger)",
            "parameters": [
              {
                "variable_name": "bigInt",
                "variable_type": "java.math.BigInteger"
              }
            ],
            "javadoc": "\n     * Returns a byte-array representation of a {@code BigInteger} without sign bit.\n     *\n     * @param bigInt\n     *            {@code BigInteger} to be converted\n     * @return a byte array representation of the BigInteger parameter\n     "
          }
        ],
        "toUrlSafeEncodeTable": [
          {
            "call_methods": [],
            "signature": "private static byte[] toUrlSafeEncodeTable(boolean)",
            "parameters": [
              {
                "variable_name": "urlSafe",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "calculateDecodeTable": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "decodeTable",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) -1",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private byte[] calculateDecodeTable(byte[])",
            "parameters": [
              {
                "variable_name": "encodeTable",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates a decode table for a given encode table.\n     *\n     * @param encodeTable that is used to determine decode lookup table\n     * @return decodeTable\n     "
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "decodeSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.validateTrailingCharacter()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.validateCharacter(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "MASK_4BITS",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": " void decode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "inPos",
                "variable_type": "int"
              },
              {
                "variable_name": "inAvail",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param input\n     *            byte[] array of ASCII data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for decoding.\n     * @param context\n     *            the context to be used\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "lineSeparator",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "context.pos",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "lineSeparator.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "encodeSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": " void encode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "in",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "inPos",
                "variable_type": "int"
              },
              {
                "variable_name": "inAvail",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, to flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p><b>Note: no padding is added when encoding using the URL-safe alphabet.</b></p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context\n     *            the context to be used\n     "
          }
        ],
        "getLineSeparator": [
          {
            "call_methods": [],
            "signature": " byte[] getLineSeparator()",
            "parameters": [],
            "javadoc": "\n     * Gets the line separator (for testing only).\n     *\n     * @return the line separator.\n     "
          }
        ],
        "isInAlphabet": [
          {
            "call_methods": [],
            "signature": "protected boolean isInAlphabet(byte)",
            "parameters": [
              {
                "variable_name": "octet",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Returns whether or not the {@code octet} is in the Base64 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the Base64 alphabet {@code false} otherwise.\n     "
          }
        ],
        "isUrlSafe": [
          {
            "call_methods": [],
            "signature": "public boolean isUrlSafe()",
            "parameters": [],
            "javadoc": "\n     * Returns our current encode mode. True if we're URL-safe, false otherwise.\n     *\n     * @return true if we're in URL-safe mode, false otherwise.\n     * @since 1.4\n     "
          }
        ],
        "validateCharacter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "private void validateCharacter(int, Context)",
            "parameters": [
              {
                "variable_name": "emptyBitsMask",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * Validates whether decoding the final trailing character is possible in the context\n     * of the set of possible base 64 values.\n     * <p>\n     * The character is valid if the lower bits within the provided mask are zero. This\n     * is used to test the final trailing base-64 digit is zero in the bits that will be discarded.\n     * </p>\n     *\n     * @param emptyBitsMask The mask of the lower bits that should be empty\n     * @param context the context to be used\n     *\n     * @throws IllegalArgumentException if the bits being checked contain any non-zero value\n     "
          }
        ],
        "validateTrailingCharacter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "private void validateTrailingCharacter()",
            "parameters": [],
            "javadoc": "\n     * Validates whether decoding allows an entire final trailing character that cannot be\n     * used for a complete byte.\n     *\n     * @throws IllegalArgumentException if strict decoding is enabled\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Provides Base64 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * </p>\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * <p>\n * The URL-safe parameter is only applied to encode operations. Decoding seamlessly handles both modes.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only\n * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,\n * UTF-8, etc).\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * You can configure instances with the {@link Builder}.\n * </p>\n * <pre>\n * Base64 base64 = Base64.builder()\n *   .setDecodingPolicy(DecodingPolicy.LENIENT) // default is lenient, null resets to default\n *   .setEncodeTable(customEncodeTable)         // default is built in, null resets to default\n *   .setLineLength(0)                          // default is none\n *   .setLineSeparator('\\r', '\\n')              // default is CR LF, null resets to default\n *   .setPadding('=')                           // default is =\n *   .setUrlSafe(false)                         // default is false\n *   .get()\n * </pre>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.0\n "
    },
    "org.apache.commons.codec.binary.Base64.Builder": {
      "fields": [],
      "constructors": [
        {
          "body": "public Builder()\n{\r\n    super(STANDARD_ENCODE_TABLE);\r\n}",
          "signature": "Builder()",
          "parameters": [],
          "javadoc": "\n         * Constructs a new instance.\n         "
        }
      ],
      "methods": {
        "get": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getLineSeparator()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getDecodingPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getLineLength()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getPadding()",
                "arguments": [],
                "return_type": "byte"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.getEncodeTable()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Base64 get()",
            "parameters": []
          }
        ],
        "setUrlSafe": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setEncodeTable(byte...)",
                "arguments": [
                  {
                    "variable_name": "toUrlSafeEncodeTable(urlSafe)",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.toUrlSafeEncodeTable(boolean)",
                "arguments": [
                  {
                    "variable_name": "urlSafe",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Builder setUrlSafe(boolean)",
            "parameters": [
              {
                "variable_name": "urlSafe",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n         * Sets the URL-safe encoding policy.\n         *\n         * @param urlSafe URL-safe encoding policy, null resets to the default.\n         * @return this.\n         "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Builds {@link Base64} instances.\n     *\n     * @since 1.17.0\n     "
    },
    "org.apache.commons.codec.binary.Base64InputStream": {
      "fields": [],
      "constructors": [
        {
          "body": "public Base64InputStream(final InputStream inputStream)\n{\r\n    this(inputStream, false);\r\n}",
          "signature": "Base64InputStream(InputStream)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            }
          ],
          "javadoc": "\n     * Constructs a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     "
        },
        {
          "body": "public Base64InputStream(final InputStream inputStream, final boolean doEncode)\n{\r\n    super(inputStream, new Base64(false), doEncode);\r\n}",
          "signature": "Base64InputStream(InputStream, boolean)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     "
        },
        {
          "body": "public Base64InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator)\n{\r\n    super(inputStream, new Base64(lineLength, lineSeparator), doEncode);\r\n}",
          "signature": "Base64InputStream(InputStream, boolean, int, byte[])",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Constructs a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     "
        },
        {
          "body": "public Base64InputStream(final InputStream inputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy)\n{\r\n    super(inputStream, new Base64(lineLength, lineSeparator, false, decodingPolicy), doEncode);\r\n}",
          "signature": "Base64InputStream(InputStream, boolean, int, byte[], CodecPolicy)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     *\n     * @param inputStream\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     * @param decodingPolicy The decoding policy.\n     * @since 1.15\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base64InputStream is to DECODE, whereas the default behavior of the Base64OutputStream\n * is to ENCODE, but this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n "
    },
    "org.apache.commons.codec.binary.Base64OutputStream": {
      "fields": [],
      "constructors": [
        {
          "body": "public Base64OutputStream(final OutputStream outputStream)\n{\r\n    this(outputStream, true);\r\n}",
          "signature": "Base64OutputStream(OutputStream)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            }
          ],
          "javadoc": "\n     * Constructs a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     "
        },
        {
          "body": "public Base64OutputStream(final OutputStream outputStream, final boolean doEncode)\n{\r\n    super(outputStream, new Base64(false), doEncode);\r\n}",
          "signature": "Base64OutputStream(OutputStream, boolean)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     "
        },
        {
          "body": "public Base64OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator)\n{\r\n    super(outputStream, new Base64(lineLength, lineSeparator), doEncode);\r\n}",
          "signature": "Base64OutputStream(OutputStream, boolean, int, byte[])",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Constructs a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     "
        },
        {
          "body": "public Base64OutputStream(final OutputStream outputStream, final boolean doEncode, final int lineLength, final byte[] lineSeparator, final CodecPolicy decodingPolicy)\n{\r\n    super(outputStream, new Base64(lineLength, lineSeparator, false, decodingPolicy), doEncode);\r\n}",
          "signature": "Base64OutputStream(OutputStream, boolean, int, byte[], CodecPolicy)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "lineSeparator",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n     * original provided OutputStream.\n     *\n     * @param outputStream\n     *            OutputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data written to us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            the nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If\n     *            doEncode is false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     * @param decodingPolicy The decoding policy.\n     * @since 1.15\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base64OutputStream is to ENCODE, whereas the default behavior of the Base64InputStream\n * is to DECODE. But this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * <b>Note:</b> It is mandatory to close the stream after the last byte has been written to it, otherwise the\n * final padding will be omitted and the resulting data will be incomplete/inconsistent.\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n "
    },
    "org.apache.commons.codec.binary.BaseNCodec": {
      "fields": [
        {
          "variable_name": "EOF",
          "variable_type": "int"
        },
        {
          "variable_name": "MIME_CHUNK_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "PEM_CHUNK_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "DEFAULT_BUFFER_RESIZE_FACTOR",
          "variable_type": "int"
        },
        {
          "variable_name": "DEFAULT_BUFFER_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "MAX_BUFFER_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "MASK_8BITS",
          "variable_type": "int"
        },
        {
          "variable_name": "PAD_DEFAULT",
          "variable_type": "byte"
        },
        {
          "variable_name": "DECODING_POLICY_DEFAULT",
          "variable_type": "org.apache.commons.codec.CodecPolicy"
        },
        {
          "variable_name": "CHUNK_SEPARATOR",
          "variable_type": "byte"
        },
        {
          "variable_name": "PAD",
          "variable_type": "byte"
        },
        {
          "variable_name": "pad",
          "variable_type": "byte"
        },
        {
          "variable_name": "unencodedBlockSize",
          "variable_type": "int"
        },
        {
          "variable_name": "encodedBlockSize",
          "variable_type": "int"
        },
        {
          "variable_name": "lineLength",
          "variable_type": "int"
        },
        {
          "variable_name": "chunkSeparatorLength",
          "variable_type": "int"
        },
        {
          "variable_name": "decodingPolicy",
          "variable_type": "org.apache.commons.codec.CodecPolicy"
        }
      ],
      "constructors": [
        {
          "body": "protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength)\n{\r\n    this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, PAD_DEFAULT);\r\n}",
          "signature": "BaseNCodec(int, int, int, int)",
          "parameters": [
            {
              "variable_name": "unencodedBlockSize",
              "variable_type": "int"
            },
            {
              "variable_name": "encodedBlockSize",
              "variable_type": "int"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "chunkSeparatorLength",
              "variable_type": "int"
            }
          ],
          "javadoc": "\n     * Constructs a new instance.\n     * <p>\n     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.\n     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.\n     * </p>\n     *\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n     * @param lineLength if &gt; 0, use chunking with a length {@code lineLength}\n     * @param chunkSeparatorLength the chunk separator length, if relevant\n     "
        },
        {
          "body": "protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength, final byte pad)\n{\r\n    this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, pad, DECODING_POLICY_DEFAULT);\r\n}",
          "signature": "BaseNCodec(int, int, int, int, byte)",
          "parameters": [
            {
              "variable_name": "unencodedBlockSize",
              "variable_type": "int"
            },
            {
              "variable_name": "encodedBlockSize",
              "variable_type": "int"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "chunkSeparatorLength",
              "variable_type": "int"
            },
            {
              "variable_name": "pad",
              "variable_type": "byte"
            }
          ],
          "javadoc": "\n     * Constructs a new instance.\n     * <p>\n     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.\n     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.\n     * </p>\n     *\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n     * @param lineLength if &gt; 0, use chunking with a length {@code lineLength}\n     * @param chunkSeparatorLength the chunk separator length, if relevant\n     * @param pad byte used as padding byte.\n     "
        },
        {
          "body": "protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize, final int lineLength, final int chunkSeparatorLength, final byte pad, final CodecPolicy decodingPolicy)\n{\r\n    this.unencodedBlockSize = unencodedBlockSize;\r\n    this.encodedBlockSize = encodedBlockSize;\r\n    final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\r\n    this.lineLength = useChunking ? lineLength / encodedBlockSize * encodedBlockSize : 0;\r\n    this.chunkSeparatorLength = chunkSeparatorLength;\r\n    this.pad = pad;\r\n    this.decodingPolicy = Objects.requireNonNull(decodingPolicy, \"codecPolicy\");\r\n}",
          "signature": "BaseNCodec(int, int, int, int, byte, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "unencodedBlockSize",
              "variable_type": "int"
            },
            {
              "variable_name": "encodedBlockSize",
              "variable_type": "int"
            },
            {
              "variable_name": "lineLength",
              "variable_type": "int"
            },
            {
              "variable_name": "chunkSeparatorLength",
              "variable_type": "int"
            },
            {
              "variable_name": "pad",
              "variable_type": "byte"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructs a new instance.\n     * <p>\n     * Note {@code lineLength} is rounded down to the nearest multiple of the encoded block size.\n     * If {@code chunkSeparatorLength} is zero, then chunking is disabled.\n     * </p>\n     *\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\n     * @param lineLength if &gt; 0, use chunking with a length {@code lineLength}\n     * @param chunkSeparatorLength the chunk separator length, if relevant\n     * @param pad byte used as padding byte.\n     * @param decodingPolicy Decoding policy.\n     * @since 1.15\n     "
        }
      ],
      "methods": {
        "createPositiveCapacity": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Math.max(int, int)",
                "arguments": [
                  {
                    "variable_name": "minCapacity",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MAX_BUFFER_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private static int createPositiveCapacity(int)",
            "parameters": [
              {
                "variable_name": "minCapacity",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Create a positive capacity at least as large the minimum required capacity.\n     * If the minimum capacity is negative then this throws an OutOfMemoryError as no array\n     * can be allocated.\n     *\n     * @param minCapacity the minimum capacity\n     * @return the capacity\n     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n     "
          }
        ],
        "getChunkSeparator": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.clone()",
                "arguments": [],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public static byte[] getChunkSeparator()",
            "parameters": [],
            "javadoc": "\n     * Gets a copy of the chunk separator per RFC 2045 section 2.1.\n     *\n     * @return the chunk separator\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     * @since 1.15\n     "
          }
        ],
        "isWhiteSpace": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Character.isWhitespace(int)",
                "arguments": [
                  {
                    "variable_name": "byteToCheck",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "protected static boolean isWhiteSpace(byte)",
            "parameters": [
              {
                "variable_name": "byteToCheck",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Checks if a byte value is whitespace or not.\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     * @see Character#isWhitespace(int)\n     * @deprecated Use {@link Character#isWhitespace(int)}.\n     "
          }
        ],
        "resizeBuffer": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.createPositiveCapacity(int)",
                "arguments": [
                  {
                    "variable_name": "minCapacity",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.Integer.compareUnsigned(int, int)",
                "arguments": [
                  {
                    "variable_name": "newCapacity",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "minCapacity",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "context.buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "newCapacity",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private static byte[] resizeBuffer(Context, int)",
            "parameters": [
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              },
              {
                "variable_name": "minCapacity",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n     * @param context the context to be used\n     * @param minCapacity the minimum required capacity\n     * @return the resized byte[] buffer\n     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n     "
          }
        ],
        "toLength": [
          {
            "call_methods": [],
            "signature": " static int toLength(byte[])",
            "parameters": [
              {
                "variable_name": "array",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Gets the array length or 0 if null.\n     *\n     * @param array the array or null.\n     * @return the array length or 0 if null.\n     "
          }
        ],
        "available": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.hasData(org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": " int available(Context)",
            "parameters": [
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * Returns the amount of buffered data available for reading.\n     *\n     * @param context the context to be used\n     * @return The amount of buffered data available for reading.\n     "
          }
        ],
        "containsAlphabetOrPad": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "protected boolean containsAlphabetOrPad(byte[])",
            "parameters": [
              {
                "variable_name": "arrayOctet",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n     *\n     * Intended for use in checking line-ending arrays\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if any byte is a valid character in the alphabet or PAD; {@code false} otherwise\n     "
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.readResults(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "result.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "pArray.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public byte[] decode(byte[])",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes a byte[] containing characters in the Base-N alphabet.\n     *\n     * @param pArray\n     *            A byte array containing Base-N character data\n     * @return a byte array containing binary data\n     "
          },
          {
            "call_methods": [],
            "signature": " abstract void decode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "i",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\n     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n     *\n     * @param obj\n     *            Object to decode\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String\n     *         supplied.\n     * @throws DecoderException\n     *             if the parameter supplied is not of type byte[]\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(pArray)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] decode(String)",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a String containing characters in the Base-N alphabet.\n     *\n     * @param pArray\n     *            A String containing Base-N character data\n     * @return a byte array containing binary data\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "pArray.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public byte[] encode(byte[])",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A byte array containing only the base N alphabetic character data\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.readResults(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buf.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public byte[] encode(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Encodes a byte[] containing binary data, into a byte[] containing\n     * characters in the alphabet.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @param offset\n     *            initial offset of the subarray.\n     * @param length\n     *            length of the subarray.\n     * @return A byte array containing only the base N alphabetic character data\n     * @since 1.11\n     "
          },
          {
            "call_methods": [],
            "signature": " abstract void encode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "i",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]\n     "
          }
        ],
        "encodeAsString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encode(pArray)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String encodeAsString(byte[])",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n     * Uses UTF8 encoding.\n     * <p>\n     * This is a duplicate of {@link #encodeToString(byte[])}; it was merged during refactoring.\n     * </p>\n     *\n     * @param pArray a byte array containing binary data\n     * @return String containing only character data in the appropriate alphabet.\n     * @since 1.5\n    "
          }
        ],
        "encodeToString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encode(pArray)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "pArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String encodeToString(byte[])",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base-N character data\n     "
          }
        ],
        "ensureBufferSize": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Math.max(int, int)",
                "arguments": [
                  {
                    "variable_name": "size",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "getDefaultBufferSize()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getDefaultBufferSize()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.resizeBuffer(org.apache.commons.codec.binary.BaseNCodec.Context, int)",
                "arguments": [
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  },
                  {
                    "variable_name": "context.pos + size",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "protected byte[] ensureBufferSize(int, Context)",
            "parameters": [
              {
                "variable_name": "size",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * Ensure that the buffer has room for {@code size} bytes\n     *\n     * @param size minimum spare space required\n     * @param context the context to be used\n     * @return the buffer\n     "
          }
        ],
        "getCodecPolicy": [
          {
            "call_methods": [],
            "signature": "public CodecPolicy getCodecPolicy()",
            "parameters": [],
            "javadoc": "\n     * Returns the decoding behavior policy.\n     *\n     * <p>\n     * The default is lenient. If the decoding policy is strict, then decoding will raise an\n     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding. Decoding will compose\n     * trailing bits into 8-bit bytes and discard the remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15\n     "
          }
        ],
        "getDefaultBufferSize": [
          {
            "call_methods": [],
            "signature": "protected int getDefaultBufferSize()",
            "parameters": [],
            "javadoc": "\n     * Gets the default buffer size. Can be overridden.\n     *\n     * @return the default buffer size.\n     "
          }
        ],
        "getEncodedLength": [
          {
            "call_methods": [],
            "signature": "public long getEncodedLength(byte[])",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the amount of space needed to encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     *\n     * @return amount of space needed to encode the supplied array.\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\n     "
          }
        ],
        "hasData": [
          {
            "call_methods": [],
            "signature": " boolean hasData(Context)",
            "parameters": [
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * Returns true if this object has buffered data for reading.\n     *\n     * @param context the context to be used\n     * @return true if there is data still available for reading.\n     "
          }
        ],
        "isInAlphabet": [
          {
            "call_methods": [],
            "signature": "protected abstract boolean isInAlphabet(byte)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Returns whether or not the {@code octet} is in the current alphabet.\n     * Does not allow whitespace or pad.\n     *\n     * @param value The value to test\n     *\n     * @return {@code true} if the value is defined in the current alphabet, {@code false} otherwise.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte)",
                "arguments": [
                  {
                    "variable_name": "octet",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Character.isWhitespace(int)",
                "arguments": [
                  {
                    "variable_name": "octet",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isInAlphabet(byte[], boolean)",
            "parameters": [
              {
                "variable_name": "arrayOctet",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "allowWSPad",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Tests a given byte array to see if it contains only valid characters within the alphabet.\n     * The method optionally treats whitespace and pad as valid.\n     *\n     * @param arrayOctet byte array to test\n     * @param allowWSPad if {@code true}, then whitespace and PAD are also allowed\n     *\n     * @return {@code true} if all bytes are valid characters in the alphabet or if the byte array is empty;\n     *         {@code false}, otherwise\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(basen)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "basen",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public boolean isInAlphabet(String)",
            "parameters": [
              {
                "variable_name": "basen",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Tests a given String to see if it contains only valid characters within the alphabet.\n     * The method treats whitespace and PAD as valid.\n     *\n     * @param basen String to test\n     * @return {@code true} if all characters in the String are valid characters in the alphabet or if\n     *         the String is empty; {@code false}, otherwise\n     * @see #isInAlphabet(byte[], boolean)\n     "
          }
        ],
        "isStrictDecoding": [
          {
            "call_methods": [],
            "signature": "public boolean isStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Returns true if decoding behavior is strict. Decoding will raise an {@link IllegalArgumentException} if trailing\n     * bits are not part of a valid encoding.\n     *\n     * <p>\n     * The default is false for lenient decoding. Decoding will compose trailing bits into 8-bit bytes and discard the\n     * remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15\n     "
          }
        ],
        "readResults": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "context.buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "context.readPos",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "bPos",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "len",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.available(org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.hasData(org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "available(context)",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bAvail",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": " int readResults(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "bPos",
                "variable_type": "int"
              },
              {
                "variable_name": "bAvail",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ],
            "javadoc": "\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * <p>\n     * Package private for access from I/O streams.\n     * </p>\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @param context\n     *            the context to be used\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Abstract superclass for Base-N encoders and decoders.\n *\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n "
    },
    "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder": {
      "fields": [
        {
          "variable_name": "decodingPolicy",
          "variable_type": "org.apache.commons.codec.CodecPolicy"
        },
        {
          "variable_name": "lineLength",
          "variable_type": "int"
        },
        {
          "variable_name": "lineSeparator",
          "variable_type": "byte"
        },
        {
          "variable_name": "defaultEncodeTable",
          "variable_type": "byte"
        },
        {
          "variable_name": "encodeTable",
          "variable_type": "byte"
        },
        {
          "variable_name": "padding",
          "variable_type": "byte"
        }
      ],
      "constructors": [
        {
          "body": " AbstractBuilder(final byte[] defaultEncodeTable)\n{\r\n    this.defaultEncodeTable = defaultEncodeTable;\r\n    this.encodeTable = defaultEncodeTable;\r\n}",
          "signature": "AbstractBuilder(byte[])",
          "parameters": [
            {
              "variable_name": "defaultEncodeTable",
              "variable_type": "byte[]"
            }
          ]
        }
      ],
      "methods": {
        "asThis": [
          {
            "call_methods": [],
            "signature": " B asThis()",
            "parameters": []
          }
        ],
        "getDecodingPolicy": [
          {
            "call_methods": [],
            "signature": " CodecPolicy getDecodingPolicy()",
            "parameters": []
          }
        ],
        "getEncodeTable": [
          {
            "call_methods": [],
            "signature": " byte[] getEncodeTable()",
            "parameters": []
          }
        ],
        "getLineLength": [
          {
            "call_methods": [],
            "signature": " int getLineLength()",
            "parameters": []
          }
        ],
        "getLineSeparator": [
          {
            "call_methods": [],
            "signature": " byte[] getLineSeparator()",
            "parameters": []
          }
        ],
        "getPadding": [
          {
            "call_methods": [],
            "signature": " byte getPadding()",
            "parameters": []
          }
        ],
        "setDecodingPolicy": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.asThis()",
                "arguments": [],
                "return_type": "B"
              }
            ],
            "signature": "public B setDecodingPolicy(CodecPolicy)",
            "parameters": [
              {
                "variable_name": "decodingPolicy",
                "variable_type": "org.apache.commons.codec.CodecPolicy"
              }
            ],
            "javadoc": "\n         * Sets the decoding policy.\n         *\n         * @param decodingPolicy the decoding policy, null resets to the default.\n         * @return this.\n         "
          }
        ],
        "setEncodeTable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.asThis()",
                "arguments": [],
                "return_type": "B"
              }
            ],
            "signature": "public B setEncodeTable(byte...)",
            "parameters": [
              {
                "variable_name": "encodeTable",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n         * Sets the encode table.\n         *\n         * @param encodeTable the encode table, null resets to the default.\n         * @return this.\n         "
          }
        ],
        "setLineLength": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.asThis()",
                "arguments": [],
                "return_type": "B"
              },
              {
                "signature": "java.lang.Math.max(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "lineLength",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public B setLineLength(int)",
            "parameters": [
              {
                "variable_name": "lineLength",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n         * Sets the line length.\n         *\n         * @param lineLength the line length, less than 0 resets to the default.\n         * @return this.\n         "
          }
        ],
        "setLineSeparator": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.asThis()",
                "arguments": [],
                "return_type": "B"
              }
            ],
            "signature": "public B setLineSeparator(byte...)",
            "parameters": [
              {
                "variable_name": "lineSeparator",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n         * Sets the line separator.\n         *\n         * @param lineSeparator the line separator, null resets to the default.\n         * @return this.\n         "
          }
        ],
        "setPadding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.asThis()",
                "arguments": [],
                "return_type": "B"
              }
            ],
            "signature": "public B setPadding(byte)",
            "parameters": [
              {
                "variable_name": "padding",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n         * Sets the padding byte.\n         *\n         * @param padding the padding byte.\n         * @return this.\n         "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Builds {@link Base64} instances.\n     *\n     * @param <T> the codec type to build.\n     * @param <B> the codec builder subtype.\n     * @since 1.17.0\n     "
    },
    "org.apache.commons.codec.binary.BaseNCodec.Context": {
      "fields": [
        {
          "variable_name": "ibitWorkArea",
          "variable_type": "int"
        },
        {
          "variable_name": "lbitWorkArea",
          "variable_type": "long"
        },
        {
          "variable_name": "buffer",
          "variable_type": "byte"
        },
        {
          "variable_name": "pos",
          "variable_type": "int"
        },
        {
          "variable_name": "readPos",
          "variable_type": "int"
        },
        {
          "variable_name": "eof",
          "variable_type": "boolean"
        },
        {
          "variable_name": "currentLinePos",
          "variable_type": "int"
        },
        {
          "variable_name": "modulus",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, \" + \"modulus=%s, pos=%s, readPos=%s]\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "this.getClass().getSimpleName()",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "Arrays.toString(buffer)",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "currentLinePos",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "eof",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "ibitWorkArea",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "lbitWorkArea",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "modulus",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "pos",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "readPos",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getSimpleName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Arrays.toString(byte[])",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String toString()",
            "parameters": [],
            "javadoc": "\n         * Returns a String useful for debugging (especially within a debugger.)\n         *\n         * @return a String useful for debugging.\n         "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Holds thread context so classes can be thread-safe.\n     *\n     * This class is not itself thread-safe; each thread must allocate its own copy.\n     "
    },
    "org.apache.commons.codec.binary.BaseNCodecInputStream": {
      "fields": [
        {
          "variable_name": "baseNCodec",
          "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
        },
        {
          "variable_name": "doEncode",
          "variable_type": "boolean"
        },
        {
          "variable_name": "singleByte",
          "variable_type": "byte"
        },
        {
          "variable_name": "buf",
          "variable_type": "byte"
        },
        {
          "variable_name": "context",
          "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
        }
      ],
      "constructors": [
        {
          "body": "protected BaseNCodecInputStream(final InputStream inputStream, final BaseNCodec baseNCodec, final boolean doEncode)\n{\r\n    super(inputStream);\r\n    this.doEncode = doEncode;\r\n    this.baseNCodec = baseNCodec;\r\n    this.buf = new byte[doEncode ? 4096 : 8192];\r\n}",
          "signature": "BaseNCodecInputStream(InputStream, BaseNCodec, boolean)",
          "parameters": [
            {
              "variable_name": "inputStream",
              "variable_type": "java.io.InputStream"
            },
            {
              "variable_name": "baseNCodec",
              "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a new instance.\n     *\n     * @param inputStream the input stream\n     * @param baseNCodec the codec\n     * @param doEncode set to true to perform encoding, else decoding\n     "
        }
      ],
      "methods": {
        "available": [
          {
            "call_methods": [],
            "signature": "public int available()",
            "parameters": [],
            "javadoc": "\n     * {@inheritDoc}\n     *\n     * @return {@code 0} if the {@link InputStream} has reached {@code EOF},\n     * {@code 1} otherwise\n     * @since 1.7\n     "
          }
        ],
        "isStrictDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Returns true if decoding behavior is strict. Decoding will raise an\n     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding.\n     *\n     * <p>\n     * The default is false for lenient encoding. Decoding will compose trailing bits\n     * into 8-bit bytes and discard the remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15\n     "
          }
        ],
        "mark": [
          {
            "call_methods": [],
            "signature": "public synchronized void mark(int)",
            "parameters": [
              {
                "variable_name": "readLimit",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Marks the current position in this input stream.\n     * <p>\n     * The {@link #mark} method of {@link BaseNCodecInputStream} does nothing.\n     * </p>\n     *\n     * @param readLimit the maximum limit of bytes that can be read before the mark position becomes invalid.\n     * @see #markSupported()\n     * @since 1.7\n     "
          }
        ],
        "markSupported": [
          {
            "call_methods": [],
            "signature": "public boolean markSupported()",
            "parameters": [],
            "javadoc": "\n     * {@inheritDoc}\n     *\n     * @return Always returns {@code false}\n     "
          }
        ],
        "read": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "singleByte",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public int read()",
            "parameters": [],
            "javadoc": "\n     * Reads one {@code byte} from this input stream.\n     *\n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.io.InputStream.read(byte[])",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.readResults(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "array",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset + readLen",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "len - readLen",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.Objects.requireNonNull(T, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "array",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "\"array\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.hasData(org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public int read(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "array",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "len",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Attempts to read {@code len} bytes into the specified {@code b} array starting at {@code offset}\n     * from this InputStream.\n     *\n     * @param array\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     *\n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     "
          }
        ],
        "reset": [
          {
            "call_methods": [],
            "signature": "public synchronized void reset()",
            "parameters": [],
            "javadoc": "\n     * Repositions this stream to the position at the time the mark method was last called on this input stream.\n     * <p>\n     * The {@link #reset} method of {@link BaseNCodecInputStream} does nothing except throw an {@link IOException}.\n     * </p>\n     *\n     * @throws IOException if this method is invoked\n     * @since 1.7\n     "
          }
        ],
        "skip": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Math.min(long, long)",
                "arguments": [
                  {
                    "variable_name": "b.length",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "todo",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "len",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public long skip(long)",
            "parameters": [
              {
                "variable_name": "n",
                "variable_type": "long"
              }
            ],
            "javadoc": "\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the provided skip length is negative\n     * @since 1.7\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Abstract superclass for Base-N input streams.\n *\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.BaseNCodecOutputStream": {
      "fields": [
        {
          "variable_name": "doEncode",
          "variable_type": "boolean"
        },
        {
          "variable_name": "baseNCodec",
          "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
        },
        {
          "variable_name": "singleByte",
          "variable_type": "byte"
        },
        {
          "variable_name": "context",
          "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
        }
      ],
      "constructors": [
        {
          "body": "public BaseNCodecOutputStream(final OutputStream outputStream, final BaseNCodec basedCodec, final boolean doEncode)\n{\r\n    super(outputStream);\r\n    this.baseNCodec = basedCodec;\r\n    this.doEncode = doEncode;\r\n}",
          "signature": "BaseNCodecOutputStream(OutputStream, BaseNCodec, boolean)",
          "parameters": [
            {
              "variable_name": "outputStream",
              "variable_type": "java.io.OutputStream"
            },
            {
              "variable_name": "basedCodec",
              "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
            },
            {
              "variable_name": "doEncode",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a new instance.\n     *\n     * TODO should this be protected?\n     *\n     * @param outputStream the underlying output or null.\n     * @param basedCodec a BaseNCodec.\n     * @param doEncode true to encode, false to decode, TODO should be an enum?\n     "
        }
      ],
      "methods": {
        "close": [
          {
            "call_methods": [
              {
                "signature": "java.io.OutputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.flush()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.eof()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void close()",
            "parameters": [],
            "javadoc": "\n     * Closes this output stream and releases any system resources associated with the stream.\n     * <p>\n     * To write the EOF marker without closing the stream, call {@link #eof()} or use an\n     * <a href=\"https://commons.apache.org/proper/commons-io/\">Apache Commons IO</a> <a href=\n     * \"https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html\"\n     * >CloseShieldOutputStream</a>.\n     * </p>\n     *\n     * @throws IOException\n     *             if an I/O error occurs.\n     "
          }
        ],
        "eof": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "singleByte",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "EOF",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "singleByte",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "EOF",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void eof()",
            "parameters": [],
            "javadoc": "\n     * Writes EOF.\n     *\n     * @since 1.11\n     "
          }
        ],
        "flush": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.flush(boolean)",
                "arguments": [
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void flush()",
            "parameters": [],
            "javadoc": "\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n     *\n     * @throws IOException\n     *             if an I/O error occurs.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.io.OutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.available(org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.readResults(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "avail",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.io.OutputStream.flush()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "private void flush(boolean)",
            "parameters": [
              {
                "variable_name": "propagate",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propagate is\n     * true, the wrapped stream will also be flushed.\n     *\n     * @param propagate\n     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n     * @throws IOException\n     *             if an I/O error occurs.\n     "
          }
        ],
        "isStrictDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Returns true if decoding behavior is strict. Decoding will raise an\n     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding.\n     *\n     * <p>\n     * The default is false for lenient encoding. Decoding will compose trailing bits\n     * into 8-bit bytes and discard the remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15\n     "
          }
        ],
        "write": [
          {
            "call_methods": [
              {
                "signature": "java.util.Objects.requireNonNull(T, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "array",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "\"array\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "array",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "len",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "array",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "len",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.flush(boolean)",
                "arguments": [
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void write(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "array",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "len",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Writes {@code len} bytes from the specified {@code b} array starting at {@code offset} to this\n     * output stream.\n     *\n     * @param array\n     *            source byte array\n     * @param offset\n     *            where to start reading the bytes\n     * @param len\n     *            maximum number of bytes to write\n     *\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "singleByte",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void write(int)",
            "parameters": [
              {
                "variable_name": "i",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Writes the specified {@code byte} to this output stream.\n     *\n     * @param i\n     *            source byte\n     * @throws IOException\n     *             if an I/O error occurs.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Abstract superclass for Base-N output streams.\n * <p>\n * To write the EOF marker without closing the stream, call {@link #eof()} or use an <a\n * href=\"https://commons.apache.org/proper/commons-io/\">Apache Commons IO</a> <a href=\n * \"https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html\"\n * >CloseShieldOutputStream</a>.\n * </p>\n *\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.BinaryCodec": {
      "fields": [
        {
          "variable_name": "EMPTY_CHAR_ARRAY",
          "variable_type": "char"
        },
        {
          "variable_name": "EMPTY_BYTE_ARRAY",
          "variable_type": "byte"
        },
        {
          "variable_name": "BIT_0",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_1",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_2",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_3",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_4",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_5",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_6",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_7",
          "variable_type": "int"
        },
        {
          "variable_name": "BITS",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "fromAscii": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
                "arguments": [
                  {
                    "variable_name": "ascii",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public static byte[] fromAscii(byte[])",
            "parameters": [
              {
                "variable_name": "ascii",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     "
          },
          {
            "call_methods": [],
            "signature": "public static byte[] fromAscii(char[])",
            "parameters": [
              {
                "variable_name": "ascii",
                "variable_type": "char[]"
              }
            ],
            "javadoc": "\n     * Decodes a char array where each char represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each char represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a char in the char array argument\n     "
          }
        ],
        "isEmpty": [
          {
            "call_methods": [],
            "signature": " static boolean isEmpty(byte[])",
            "parameters": [
              {
                "variable_name": "array",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns {@code true} if the given array is {@code null} or empty (size 0.)\n     *\n     * @param array\n     *            the source array\n     * @return {@code true} if the given array is {@code null} or empty (size 0.)\n     "
          }
        ],
        "toAsciiBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
                "arguments": [
                  {
                    "variable_name": "raw",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public static byte[] toAsciiBytes(byte[])",
            "parameters": [
              {
                "variable_name": "raw",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n     * char.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 character bytes for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     "
          }
        ],
        "toAsciiChars": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.isEmpty(byte[])",
                "arguments": [
                  {
                    "variable_name": "raw",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public static char[] toAsciiChars(byte[])",
            "parameters": [
              {
                "variable_name": "raw",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 characters for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     "
          }
        ],
        "toAsciiString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[])",
                "arguments": [
                  {
                    "variable_name": "raw",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static String toAsciiString(byte[])",
            "parameters": [
              {
                "variable_name": "raw",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return a String of 0 and 1 characters representing the binary data\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     "
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "ascii",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] decode(byte[])",
            "parameters": [
              {
                "variable_name": "ascii",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) ascii",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[])",
                "arguments": [
                  {
                    "variable_name": "(char[]) ascii",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "ascii",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @throws DecoderException\n     *                  if argument is not a byte[], char[] or String\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "raw",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] encode(byte[])",
            "parameters": [
              {
                "variable_name": "raw",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return 0 and 1 ASCII character bytes one for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) raw",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "raw",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 chars.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return 0 and 1 ASCII character chars one for each bit of the argument\n     * @throws EncoderException\n     *                  if the argument is not a byte[]\n     * @see org.apache.commons.codec.Encoder#encode(Object)\n     "
          }
        ],
        "toByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[])",
                "arguments": [
                  {
                    "variable_name": "ascii.toCharArray()",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public byte[] toByteArray(String)",
            "parameters": [
              {
                "variable_name": "ascii",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  String of '0' and '1' characters\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Converts between byte arrays and strings of \"0\"s and \"1\"s.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * TODO: may want to add more bit vector functions like and/or/xor/nand\n * TODO: also might be good to generate boolean[] from byte[] et cetera.\n *\n * @since 1.3\n "
    },
    "org.apache.commons.codec.binary.CharSequenceUtils": {
      "fields": [],
      "constructors": [],
      "methods": {
        "regionMatches": [
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index1++",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.Character.toUpperCase(char)",
                "arguments": [
                  {
                    "variable_name": "c1",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.Character.toLowerCase(char)",
                "arguments": [
                  {
                    "variable_name": "c1",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)",
                "arguments": [
                  {
                    "variable_name": "ignoreCase",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "thisStart",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "(String) substring",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "start",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": " static boolean regionMatches(CharSequence, boolean, int, CharSequence, int, int)",
            "parameters": [
              {
                "variable_name": "cs",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "ignoreCase",
                "variable_type": "boolean"
              },
              {
                "variable_name": "thisStart",
                "variable_type": "int"
              },
              {
                "variable_name": "substring",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "start",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Green implementation of regionMatches.\n     *\n     * <p>\n     * Note: This function differs from the current implementation in Apache Commons Lang\n     * where the input indices are not valid. It is only used within this package.\n     * </p>\n     *\n     * @param cs\n     *            the {@code CharSequence} to be processed\n     * @param ignoreCase\n     *            whether or not to be case-insensitive\n     * @param thisStart\n     *            the index to start on the {@code cs} CharSequence\n     * @param substring\n     *            the {@code CharSequence} to be looked for\n     * @param start\n     *            the index to start on the {@code substring} CharSequence\n     * @param length\n     *            character length of the region\n     * @return whether the region matched\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * <p>\n * Operations on {@link CharSequence} that are {@code null} safe.\n * </p>\n * <p>\n * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release).\n * </p>\n *\n * @see CharSequence\n * @since 1.10\n "
    },
    "org.apache.commons.codec.binary.Hex": {
      "fields": [
        {
          "variable_name": "DEFAULT_CHARSET",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "DEFAULT_CHARSET_NAME",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "DIGITS_LOWER",
          "variable_type": "char"
        },
        {
          "variable_name": "DIGITS_UPPER",
          "variable_type": "char"
        },
        {
          "variable_name": "charset",
          "variable_type": "java.nio.charset.Charset"
        }
      ],
      "constructors": [
        {
          "body": "public Hex()\n{\r\n    // use default encoding\r\n    this.charset = DEFAULT_CHARSET;\r\n}",
          "signature": "Hex()",
          "parameters": [],
          "javadoc": "\n     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}\n     "
        },
        {
          "body": "public Hex(final Charset charset)\n{\r\n    this.charset = charset;\r\n}",
          "signature": "Hex(Charset)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.nio.charset.Charset"
            }
          ],
          "javadoc": "\n     * Creates a new codec with the given Charset.\n     *\n     * @param charset the charset.\n     * @since 1.7\n     "
        },
        {
          "body": "public Hex(final String charsetName)\n{\r\n    this(Charset.forName(charsetName));\r\n}",
          "signature": "Hex(String)",
          "parameters": [
            {
              "variable_name": "charsetName",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Creates a new codec with the given charset name.\n     *\n     * @param charsetName the charset name.\n     * @throws java.nio.charset.UnsupportedCharsetException If the named charset is unavailable\n     * @since 1.4\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\n     "
        }
      ],
      "methods": {
        "decodeHex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[], byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static byte[] decodeHex(char[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "char[]"
              }
            ],
            "javadoc": "\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param data An array of characters containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied char array.\n     * @throws DecoderException Thrown if an odd number of characters or illegal characters are supplied\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.toDigit(char, int)",
                "arguments": [
                  {
                    "variable_name": "data[j]",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "j",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int decodeHex(char[], byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "char[]"
              },
              {
                "variable_name": "out",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "outOffset",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param data An array of characters containing hexadecimal digits\n     * @param out A byte array to contain the binary data decoded from the supplied char array.\n     * @param outOffset The position within {@code out} to start writing the decoded bytes.\n     * @return the number of bytes written to {@code out}.\n     * @throws DecoderException Thrown if an odd number of characters or illegal characters are supplied\n     * @since 1.15\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "data.toCharArray()",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public static byte[] decodeHex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Converts a String representing hexadecimal values into an array of bytes of those same values. The returned array\n     * will be half the length of the passed String, as it takes two characters to represent any given byte. An\n     * exception is thrown if the passed String has an odd number of elements.\n     *\n     * @param data A String containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied char array.\n     * @throws DecoderException Thrown if an odd number of characters or illegal characters are supplied\n     * @since 1.11\n     "
          }
        ],
        "encodeHex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static char[] encodeHex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data a byte[] to convert to hexadecimal characters\n     * @return A char[] containing lower-case hexadecimal characters\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], char[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "toAlphabet(toLowerCase)",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.toAlphabet(boolean)",
                "arguments": [
                  {
                    "variable_name": "toLowerCase",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static char[] encodeHex(byte[], boolean)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "toLowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data        a byte[] to convert to Hex characters\n     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase\n     * @return A char[] containing hexadecimal characters in the selected case\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], int, int, char[], char[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "dataLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "toDigits",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "new char[dataLength << 1]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "protected static char[] encodeHex(byte[], char[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "toDigits",
                "variable_type": "char[]"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\n     * given byte.\n     *\n     * @param data     a byte[] to convert to hexadecimal characters\n     * @param toDigits the output alphabet (must contain at least 16 chars)\n     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either\n     *         upper- or lower-case hex.\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], int, int, char[], char[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "dataOffset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "dataLen",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "toAlphabet(toLowerCase)",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "new char[dataLen << 1]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.toAlphabet(boolean)",
                "arguments": [
                  {
                    "variable_name": "toLowerCase",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static char[] encodeHex(byte[], int, int, boolean)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "dataOffset",
                "variable_type": "int"
              },
              {
                "variable_name": "dataLen",
                "variable_type": "int"
              },
              {
                "variable_name": "toLowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     *\n     * @param data a byte[] to convert to hexadecimal characters\n     * @param dataOffset the position in {@code data} to start encoding from\n     * @param dataLen the number of bytes from {@code dataOffset} to encode\n     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase\n     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either\n     *         upper- or lower-case hex.\n     * @since 1.15\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], int, int, char[], char[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "dataOffset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "dataLen",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "toAlphabet(toLowerCase)",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "out",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "outOffset",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.toAlphabet(boolean)",
                "arguments": [
                  {
                    "variable_name": "toLowerCase",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static void encodeHex(byte[], int, int, boolean, char[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "dataOffset",
                "variable_type": "int"
              },
              {
                "variable_name": "dataLen",
                "variable_type": "int"
              },
              {
                "variable_name": "toLowerCase",
                "variable_type": "boolean"
              },
              {
                "variable_name": "out",
                "variable_type": "char[]"
              },
              {
                "variable_name": "outOffset",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     *\n     * @param data a byte[] to convert to hexadecimal characters\n     * @param dataOffset the position in {@code data} to start encoding from\n     * @param dataLen the number of bytes from {@code dataOffset} to encode\n     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase\n     * @param out a char[] which will hold the resultant appropriate characters from the alphabet.\n     * @param outOffset the position within {@code out} at which to start writing the encoded characters.\n     * @since 1.15\n     "
          },
          {
            "call_methods": [],
            "signature": "private static char[] encodeHex(byte[], int, int, char[], char[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "dataOffset",
                "variable_type": "int"
              },
              {
                "variable_name": "dataLen",
                "variable_type": "int"
              },
              {
                "variable_name": "toDigits",
                "variable_type": "char[]"
              },
              {
                "variable_name": "out",
                "variable_type": "char[]"
              },
              {
                "variable_name": "outOffset",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\n     *\n     * @param data a byte[] to convert to hexadecimal characters\n     * @param dataOffset the position in {@code data} to start encoding from\n     * @param dataLen the number of bytes from {@code dataOffset} to encode\n     * @param toDigits the output alphabet (must contain at least 16 chars)\n     * @param out a char[] which will hold the resultant appropriate characters from the alphabet.\n     * @param outOffset the position within {@code out} at which to start writing the encoded characters.\n     * @return the given {@code out}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static char[] encodeHex(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order. The\n     * returned array will be double the length of the passed array, as it takes two characters to represent any given\n     * byte.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param data a byte buffer to convert to hexadecimal characters\n     * @return A char[] containing lower-case hexadecimal characters\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer, char[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "toAlphabet(toLowerCase)",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.toAlphabet(boolean)",
                "arguments": [
                  {
                    "variable_name": "toLowerCase",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static char[] encodeHex(ByteBuffer, boolean)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              },
              {
                "variable_name": "toLowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order. The\n     * returned array will be double the length of the passed array, as it takes two characters to represent any given\n     * byte.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param data        a byte buffer to convert to hexadecimal characters\n     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase\n     * @return A char[] containing hexadecimal characters in the selected case\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], char[])",
                "arguments": [
                  {
                    "variable_name": "toByteArray(byteBuffer)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "toDigits",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.toByteArray(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "byteBuffer",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "protected static char[] encodeHex(ByteBuffer, char[])",
            "parameters": [
              {
                "variable_name": "byteBuffer",
                "variable_type": "java.nio.ByteBuffer"
              },
              {
                "variable_name": "toDigits",
                "variable_type": "char[]"
              }
            ],
            "javadoc": "\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order. The\n     * returned array will be double the length of the passed array, as it takes two characters to represent any given\n     * byte.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param byteBuffer a byte buffer to convert to hexadecimal characters\n     * @param toDigits   the output alphabet (must be at least 16 characters)\n     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either\n     *         upper- or lower-case hex.\n     * @since 1.11\n     "
          }
        ],
        "encodeHexString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static String encodeHexString(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * @param data a byte[] to convert to hexadecimal characters\n     * @return A String containing lower-case hexadecimal characters\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "toLowerCase",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static String encodeHexString(byte[], boolean)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "toLowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * @param data        a byte[] to convert to hexadecimal characters\n     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase\n     * @return A String containing lower-case hexadecimal characters\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static String encodeHexString(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param data a byte buffer to convert to hexadecimal characters\n     * @return A String containing lower-case hexadecimal characters\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "toLowerCase",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public static String encodeHexString(ByteBuffer, boolean)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              },
              {
                "variable_name": "toLowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param data        a byte buffer to convert to hexadecimal characters\n     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase\n     * @return A String containing lower-case hexadecimal characters\n     * @since 1.11\n     "
          }
        ],
        "toAlphabet": [
          {
            "call_methods": [],
            "signature": "private static char[] toAlphabet(boolean)",
            "parameters": [
              {
                "variable_name": "toLowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Converts a boolean to an alphabet.\n     *\n     * @param toLowerCase true for lowercase, false for uppercase.\n     * @return an alphabet.\n     "
          }
        ],
        "toByteArray": [
          {
            "call_methods": [
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.hasArray()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.get(byte[])",
                "arguments": [
                  {
                    "variable_name": "byteArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.position(int)",
                "arguments": [
                  {
                    "variable_name": "remaining",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "private static byte[] toByteArray(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "byteBuffer",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Convert the byte buffer to a byte array. All bytes identified by\n     * {@link ByteBuffer#remaining()} will be used.\n     *\n     * @param byteBuffer the byte buffer\n     * @return the byte[]\n     "
          }
        ],
        "toDigit": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Character.digit(char, int)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "16",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "protected static int toDigit(char, int)",
            "parameters": [
              {
                "variable_name": "ch",
                "variable_type": "char"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Converts a hexadecimal character to an integer.\n     *\n     * @param ch    A character to convert to an integer digit\n     * @param index The index of the character in the source\n     * @return An integer\n     * @throws DecoderException Thrown if ch is an illegal hexadecimal character\n     "
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "new String(array, getCharset()).toCharArray()",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public byte[] decode(byte[])",
            "parameters": [
              {
                "variable_name": "array",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param array An array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException Thrown if an odd number of characters is supplied to this function\n     * @see #decodeHex(char[])\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "new String(toByteArray(buffer), getCharset()).toCharArray()",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.toByteArray(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] decode(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "buffer",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Converts a buffer of character bytes representing hexadecimal values into an array of bytes of those same values.\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param buffer An array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException Thrown if an odd number of characters is supplied to this function\n     * @see #decodeHex(char[])\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "(char[]) object",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) object",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "(ByteBuffer) object",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "((String) object).toCharArray()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "object",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\n     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\n     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param object A String, ByteBuffer, byte[], or an array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException Thrown if an odd number of characters is supplied to this function or the object is not\n     *                          a String or char[]\n     * @see #decodeHex(char[])\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "this.getCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "array",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public byte[] encode(byte[])",
            "parameters": [
              {
                "variable_name": "array",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each\n     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\n     * represent any given byte.\n     * <p>\n     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\n     * {@link #getCharset()}.\n     * </p>\n     *\n     * @param array a byte[] to convert to hexadecimal characters\n     * @return A byte[] containing the bytes of the lower-case hexadecimal characters\n     * @since 1.7 No longer throws IllegalStateException if the charsetName is invalid.\n     * @see #encodeHex(byte[])\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "this.getCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "array",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public byte[] encode(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "array",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Converts byte buffer into an array of bytes for the characters representing the hexadecimal values of each byte\n     * in order. The returned array will be double the length of the passed array, as it takes two characters to\n     * represent any given byte.\n     *\n     * <p>The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\n     * {@link #getCharset()}.</p>\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param array a byte buffer to convert to hexadecimal characters\n     * @return A byte[] containing the bytes of the lower-case hexadecimal characters\n     * @see #encodeHex(byte[])\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "this.getCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "byteArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.toByteArray(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "(ByteBuffer) object",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "object",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\n     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\n     * characters to represent any given byte.\n     * <p>\n     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\n     * {@link #getCharset()}.\n     * </p>\n     *\n     * @param object a String, ByteBuffer, or byte[] to convert to hexadecimal characters\n     * @return A char[] containing lower-case hexadecimal characters\n     * @throws EncoderException Thrown if the given object is not a String or byte[]\n     * @see #encodeHex(byte[])\n     "
          }
        ],
        "getCharset": [
          {
            "call_methods": [],
            "signature": "public Charset getCharset()",
            "parameters": [],
            "javadoc": "\n     * Gets the charset.\n     *\n     * @return the charset.\n     * @since 1.7\n     "
          }
        ],
        "getCharsetName": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String getCharsetName()",
            "parameters": [],
            "javadoc": "\n     * Gets the charset name.\n     *\n     * @return the charset name.\n     * @since 1.4\n     "
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String toString()",
            "parameters": [],
            "javadoc": "\n     * Returns a string representation of the object, which includes the charset name.\n     *\n     * @return a string representation of the object.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Converts hexadecimal Strings. The Charset used for certain operation can be set, the default is set in\n * {@link #DEFAULT_CHARSET_NAME}\n *\n * This class is thread-safe.\n *\n * @since 1.1\n "
    },
    "org.apache.commons.codec.binary.StringUtils": {
      "fields": [],
      "constructors": [
        {
          "body": "public StringUtils()\n{\r\n    // empty\r\n}",
          "signature": "StringUtils()",
          "parameters": [],
          "javadoc": "\n     * TODO Make private in 2.0.\n     *\n     * @deprecated TODO Make private in 2.0.\n     "
        }
      ],
      "methods": {
        "equals": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "cs2",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(java.lang.CharSequence, boolean, int, java.lang.CharSequence, int, int)",
                "arguments": [
                  {
                    "variable_name": "cs1",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "cs2",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "cs1.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public static boolean equals(CharSequence, CharSequence)",
            "parameters": [
              {
                "variable_name": "cs1",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "cs2",
                "variable_type": "java.lang.CharSequence"
              }
            ],
            "javadoc": "\n     * <p>\n     * Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * {@code null}s are handled without exceptions. Two {@code null} references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be {@code null}\n     * @param cs2\n     *            the second CharSequence, may be {@code null}\n     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n     * @since 1.10\n     "
          }
        ],
        "getByteBuffer": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "charset",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.wrap(byte[])",
                "arguments": [
                  {
                    "variable_name": "string.getBytes(charset)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "private static ByteBuffer getByteBuffer(String, Charset)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return the encoded bytes\n     "
          }
        ],
        "getByteBufferUtf8": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getByteBuffer(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public static ByteBuffer getByteBufferUtf8(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     * @since 1.11\n     "
          }
        ],
        "getBytes": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "charset",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private static byte[] getBytes(String, Charset)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return the encoded bytes\n     "
          }
        ],
        "getBytesIso8859_1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytes(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] getBytesIso8859_1(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#ISO_8859_1} is not initialized, which should never happen\n     *             since it is required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     "
          }
        ],
        "getBytesUnchecked": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newIllegalStateException(java.lang.String, java.io.UnsupportedEncodingException)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "e",
                    "variable_type": "java.io.UnsupportedEncodingException"
                  }
                ],
                "return_type": "java.lang.IllegalStateException"
              }
            ],
            "signature": "public static byte[] getBytesUnchecked(String, String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)\n     "
          }
        ],
        "getBytesUsAscii": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytes(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardCharsets.US_ASCII",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] getBytesUsAscii(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     "
          }
        ],
        "getBytesUtf16": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytes(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_16",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] getBytesUtf16(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     "
          }
        ],
        "getBytesUtf16Be": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytes(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_16BE",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] getBytesUtf16Be(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     "
          }
        ],
        "getBytesUtf16Le": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytes(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_16LE",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] getBytesUtf16Le(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     "
          }
        ],
        "getBytesUtf8": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytes(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] getBytesUtf8(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     "
          }
        ],
        "newIllegalStateException": [
          {
            "call_methods": [],
            "signature": "private static IllegalStateException newIllegalStateException(String, UnsupportedEncodingException)",
            "parameters": [
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "e",
                "variable_type": "java.io.UnsupportedEncodingException"
              }
            ]
          }
        ],
        "newString": [
          {
            "call_methods": [],
            "signature": "private static String newString(byte[], Charset)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "charset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the given charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}; not {@code null}\n     * @return A new {@code String} decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if charset is {@code null}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newIllegalStateException(java.lang.String, java.io.UnsupportedEncodingException)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "e",
                    "variable_type": "java.io.UnsupportedEncodingException"
                  }
                ],
                "return_type": "java.lang.IllegalStateException"
              }
            ],
            "signature": "public static String newString(byte[], String)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new {@code String} decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)\n     "
          }
        ],
        "newStringIso8859_1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String newStringIso8859_1(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @return A new {@code String} decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#ISO_8859_1} is not initialized, which should never happen\n     *             since it is required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     "
          }
        ],
        "newStringUsAscii": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "StandardCharsets.US_ASCII",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String newStringUsAscii(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the US-ASCII charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     "
          }
        ],
        "newStringUtf16": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_16",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String newStringUtf16(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16 charset\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     "
          }
        ],
        "newStringUtf16Be": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_16BE",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String newStringUtf16Be(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     "
          }
        ],
        "newStringUtf16Le": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_16LE",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String newStringUtf16Le(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     "
          }
        ],
        "newStringUtf8": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String newStringUtf8(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a new {@code String} by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-8 charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in standard {@link Charset}.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see Charset\n * @see StandardCharsets\n * @since 1.4\n "
    },
    "org.apache.commons.codec.BinaryDecoder": {
      "fields": [],
      "constructors": [],
      "methods": {
        "decode": [
          {
            "call_methods": [],
            "signature": " abstract byte[] decode(byte[])",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes a byte array and returns the results as a byte array.\n     *\n     * @param source\n     *            A byte array which has been encoded with the appropriate encoder\n     * @return a byte array that contains decoded content\n     * @throws DecoderException\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\n     "
          }
        ]
      },
      "is_interface": true,
      "javadoc": "\n * Defines common decoding methods for byte array decoders.\n "
    },
    "org.apache.commons.codec.BinaryEncoder": {
      "fields": [],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [],
            "signature": " abstract byte[] encode(byte[])",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes a byte array and return the encoded data as a byte array.\n     *\n     * @param source\n     *            Data to be encoded\n     * @return A byte array containing the encoded data\n     * @throws EncoderException\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\n     "
          }
        ]
      },
      "is_interface": true,
      "javadoc": "\n * Defines common encoding methods for byte array encoders.\n "
    },
    "org.apache.commons.codec.CharEncoding": {
      "fields": [
        {
          "variable_name": "ISO_8859_1",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "US_ASCII",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "UTF_16",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "UTF_16BE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "UTF_16LE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "UTF_8",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [
        {
          "body": "public CharEncoding()\n{\r\n    // empty\r\n}",
          "signature": "CharEncoding()",
          "parameters": [],
          "javadoc": "\n     * TODO Make private in 2.0.\n     *\n     * @deprecated TODO Make private in 2.0.\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Character encoding names required of every implementation of the Java platform.\n *\n * From the Java documentation for {@link Charset}:\n * <p>\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n * release documentation for your implementation to see if any other encodings are supported. Consult the release\n * documentation for your implementation to see if any other encodings are supported.</cite>\n * </p>\n *\n * <ul>\n * <li>{@code US-ASCII}<p>\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</p></li>\n * <li>{@code ISO-8859-1}<p>\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</p></li>\n * <li>{@code UTF-8}<p>\n * Eight-bit Unicode Transformation Format.</p></li>\n * <li>{@code UTF-16BE}<p>\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</p></li>\n * <li>{@code UTF-16LE}<p>\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</p></li>\n * <li>{@code UTF-16}<p>\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n * accepted on input, big-endian used on output.)</p></li>\n * </ul>\n *\n * This perhaps would best belong in the [lang] project. Even if a similar interface is defined in [lang], it is not\n * foreseen that [codec] would be made to depend on [lang].\n *\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see Charset\n * @since 1.4\n "
    },
    "org.apache.commons.codec.Charsets": {
      "fields": [
        {
          "variable_name": "ISO_8859_1",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "US_ASCII",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "UTF_16",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "UTF_16BE",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "UTF_16LE",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "UTF_8",
          "variable_type": "java.nio.charset.Charset"
        }
      ],
      "constructors": [
        {
          "body": "public Charsets()\n{\r\n    // empty\r\n}",
          "signature": "Charsets()",
          "parameters": [],
          "javadoc": "\n     * TODO Make private in 2.0.\n     *\n     * @deprecated TODO Make private in 2.0.\n     "
        }
      ],
      "methods": {
        "toCharset": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.defaultCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              }
            ],
            "signature": "public static Charset toCharset(Charset)",
            "parameters": [
              {
                "variable_name": "charset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Returns the given Charset or the default Charset if the given Charset is null.\n     *\n     * @param charset\n     *            A charset or null.\n     * @return the given Charset or the default Charset if the given Charset is null\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.defaultCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "java.nio.charset.Charset.forName(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charset",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.charset.Charset"
              }
            ],
            "signature": "public static Charset toCharset(String)",
            "parameters": [
              {
                "variable_name": "charset",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charset\n     *            The name of the requested charset, may be null.\n     * @return a Charset for the named charset\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Charsets required of every implementation of the Java platform.\n *\n * From the Java documentation <a href=\"https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard\n * charsets</a>:\n * <p>\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n * release documentation for your implementation to see if any other encodings are supported. Consult the release\n * documentation for your implementation to see if any other encodings are supported. </cite>\n * </p>\n *\n * <ul>\n * <li>{@code US-ASCII}<p>\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</p></li>\n * <li>{@code ISO-8859-1}<p>\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</p></li>\n * <li>{@code UTF-8}<p>\n * Eight-bit Unicode Transformation Format.</p></li>\n * <li>{@code UTF-16BE}<p>\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</p></li>\n * <li>{@code UTF-16LE}<p>\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</p></li>\n * <li>{@code UTF-16}<p>\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n * accepted on input, big-endian used on output.)</p></li>\n * </ul>\n *\n * This perhaps would best belong in the Commons Lang project. Even if a similar class is defined in Commons Lang, it is\n * not foreseen that Commons Codec would be made to depend on Commons Lang.\n *\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @since 1.7\n "
    },
    "org.apache.commons.codec.cli.Digest": {
      "fields": [
        {
          "variable_name": "algorithm",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "args",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "inputs",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [
        {
          "body": "private Digest(final String[] args)\n{\r\n    Objects.requireNonNull(args);\r\n    final int argsLength = args.length;\r\n    if (argsLength == 0) {\r\n        throw new IllegalArgumentException(String.format(\"Usage: java %s [algorithm] [FILE|DIRECTORY|string] ...\", Digest.class.getName()));\r\n    }\r\n    this.args = args;\r\n    this.algorithm = args[0];\r\n    if (argsLength <= 1) {\r\n        this.inputs = null;\r\n    } else {\r\n        this.inputs = Arrays.copyOfRange(args, 1, argsLength);\r\n    }\r\n}",
          "signature": "Digest(String[])",
          "parameters": [
            {
              "variable_name": "args",
              "variable_type": "java.lang.String[]"
            }
          ]
        }
      ],
      "methods": {
        "main": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.cli.Digest.run()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public static void main(String[])",
            "parameters": [
              {
                "variable_name": "args",
                "variable_type": "java.lang.String[]"
              }
            ],
            "javadoc": "\n     * Runs the digest algorithm in {@code args[0]} on the file in {@code args[1]}. If there is no {@code args[1]}, use\n     * standard input.\n     *\n     * <p>\n     * The algorithm can also be {@code ALL} or {@code *} to output one line for each known algorithm.\n     * </p>\n     *\n     * @param args\n     *            {@code args[0]} is one of {@link MessageDigestAlgorithms} name,\n     *            {@link MessageDigest} name, {@code ALL}, or {@code *}.\n     *            {@code args[1+]} is a FILE/DIRECTORY/String.\n     * @throws IOException if an error occurs\n     "
          }
        ],
        "println": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.cli.Digest.println(java.lang.String, byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "prefix",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "digest",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void println(String, byte[])",
            "parameters": [
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "digest",
                "variable_type": "byte[]"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "prefix + Hex.encodeHexString(digest) + (fileName != null ? \"  \" + fileName : \"\")",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "digest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private void println(String, byte[], String)",
            "parameters": [
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "digest",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "fileName",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "run": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm.toUpperCase(Locale.ROOT)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithms.values()",
                "arguments": [],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String, java.security.MessageDigest)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.security.MessageDigest"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.ROOT",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equalsIgnoreCase(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"ALL\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"*\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.run(java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.values()",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.run(java.lang.String, java.security.MessageDigest)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void run()",
            "parameters": []
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.File)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "file",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "Charset.defaultCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.println(java.lang.String, byte[])",
                "arguments": [
                  {
                    "variable_name": "prefix",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "DigestUtils.digest(messageDigest, System.in)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "System.in",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.charset.Charset.defaultCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "java.io.File.isFile()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.run(java.lang.String, java.security.MessageDigest, java.io.File[])",
                "arguments": [
                  {
                    "variable_name": "prefix",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "listFiles",
                    "variable_type": "java.io.File[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.println(java.lang.String, byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "prefix",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "DigestUtils.digest(messageDigest, file)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.File.isDirectory()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.io.File.listFiles()",
                "arguments": [],
                "return_type": "java.io.File[]"
              }
            ],
            "signature": "private void run(String, MessageDigest)",
            "parameters": [
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.File)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "file",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.File.isFile()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.println(java.lang.String, byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "prefix",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "DigestUtils.digest(messageDigest, file)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "file.getName()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.File.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private void run(String, MessageDigest, File[])",
            "parameters": [
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "files",
                "variable_type": "java.io.File[]"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.run(java.lang.String, java.security.MessageDigest)",
                "arguments": [
                  {
                    "variable_name": "prefix",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void run(String, String)",
            "parameters": [
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.run(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm + \" \"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void run(String[])",
            "parameters": [
              {
                "variable_name": "digestAlgorithms",
                "variable_type": "java.lang.String[]"
              }
            ]
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"%s %s\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "super.toString()",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "Arrays.toString(args)",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Arrays.toString(java.lang.Object[])",
                "arguments": [
                  {
                    "variable_name": "args",
                    "variable_type": "java.lang.Object[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * A minimal command line to run digest over files, directories or a string.\n *\n * @see #main(String[])\n * @since 1.11\n "
    },
    "org.apache.commons.codec.Decoder": {
      "fields": [],
      "constructors": [],
      "methods": {
        "decode": [
          {
            "call_methods": [],
            "signature": " abstract Object decode(Object)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes an \"encoded\" Object and returns a \"decoded\" Object. Note that the implementation of this interface will\n     * try to cast the Object parameter to the specific type expected by a particular Decoder implementation. If a\n     * {@link ClassCastException} occurs this decode method will throw a DecoderException.\n     *\n     * @param source\n     *            the object to decode\n     * @return a 'decoded\" object\n     * @throws DecoderException\n     *             a decoder exception can be thrown for any number of reasons. Some good candidates are that the\n     *             parameter passed to this method is null, a param cannot be cast to the appropriate type for a\n     *             specific encoder.\n     "
          }
        ]
      },
      "is_interface": true,
      "javadoc": "\n * Provides the highest level of abstraction for Decoders.\n * <p>\n * This is the sister interface of {@link Encoder}. All Decoders implement this common generic interface.\n * Allows a user to pass a generic Object to any Decoder implementation in the codec package.\n * </p>\n * <p>\n * One of the two interfaces at the center of the codec package.\n * </p>\n "
    },
    "org.apache.commons.codec.DecoderException": {
      "fields": [
        {
          "variable_name": "serialVersionUID",
          "variable_type": "long"
        }
      ],
      "constructors": [
        {
          "body": "public DecoderException()\n{\r\n}",
          "signature": "DecoderException()",
          "parameters": [],
          "javadoc": "\n     * Constructs a new exception with {@code null} as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     "
        },
        {
          "body": "public DecoderException(final String message)\n{\r\n    super(message);\r\n}",
          "signature": "DecoderException(String)",
          "parameters": [
            {
              "variable_name": "message",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     "
        },
        {
          "body": "public DecoderException(final String message, final Throwable cause)\n{\r\n    super(message, cause);\r\n}",
          "signature": "DecoderException(String, Throwable)",
          "parameters": [
            {
              "variable_name": "message",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "cause",
              "variable_type": "java.lang.Throwable"
            }
          ],
          "javadoc": "\n     * Constructs a new exception with the specified detail message and cause.\n     * <p>\n     * Note that the detail message associated with {@code cause} is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     "
        },
        {
          "body": "public DecoderException(final Throwable cause)\n{\r\n    super(cause);\r\n}",
          "signature": "DecoderException(Throwable)",
          "parameters": [
            {
              "variable_name": "cause",
              "variable_type": "java.lang.Throwable"
            }
          ],
          "javadoc": "\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of {@code cause}).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Thrown when there is a failure condition during the decoding process. This exception is thrown when a {@link Decoder}\n * encounters a decoding specific exception such as invalid data, or characters outside of the expected range.\n "
    },
    "org.apache.commons.codec.digest.B64": {
      "fields": [
        {
          "variable_name": "B64T_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "B64T_ARRAY",
          "variable_type": "char"
        }
      ],
      "constructors": [],
      "methods": {
        "b64from24bit": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "B64T_ARRAY[w & 0x3f]",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": " static void b64from24bit(byte, byte, byte, int, StringBuilder)",
            "parameters": [
              {
                "variable_name": "b2",
                "variable_type": "byte"
              },
              {
                "variable_name": "b1",
                "variable_type": "byte"
              },
              {
                "variable_name": "b0",
                "variable_type": "byte"
              },
              {
                "variable_name": "outLen",
                "variable_type": "int"
              },
              {
                "variable_name": "buffer",
                "variable_type": "java.lang.StringBuilder"
              }
            ],
            "javadoc": "\n     * Base64 like conversion of bytes to ASCII chars.\n     *\n     * @param b2\n     *            A byte from the result.\n     * @param b1\n     *            A byte from the result.\n     * @param b0\n     *            A byte from the result.\n     * @param outLen\n     *            The number of expected output chars.\n     * @param buffer\n     *            Where the output chars is appended to.\n     "
          }
        ],
        "getRandomSalt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "num",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "new SecureRandom()",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": " static String getRandomSalt(int)",
            "parameters": [
              {
                "variable_name": "num",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates a string of random chars from the B64T set.\n     * <p>\n     * The salt is generated with {@link SecureRandom}.\n     * </p>\n     *\n     * @param num Number of chars to generate.\n     * @return a random salt {@link String}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "random.nextInt(B64T_STRING.length())",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "B64T_STRING.charAt(random.nextInt(B64T_STRING.length()))",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.util.Random.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "B64T_STRING.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " static String getRandomSalt(int, Random)",
            "parameters": [
              {
                "variable_name": "num",
                "variable_type": "int"
              },
              {
                "variable_name": "random",
                "variable_type": "java.util.Random"
              }
            ],
            "javadoc": "\n     * Generates a string of random chars from the B64T set.\n     * <p>\n     * The salt is generated with the {@link Random} provided.\n     * </p>\n     *\n     * @param num Number of chars to generate.\n     * @param random an instance of {@link Random}.\n     * @return a random salt {@link String}.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Base64-like method to convert binary bytes into ASCII chars.\n * <p>\n * TODO: Can Base64 be reused?\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n "
    },
    "org.apache.commons.codec.digest.Blake3": {
      "fields": [
        {
          "variable_name": "BLOCK_LEN",
          "variable_type": "int"
        },
        {
          "variable_name": "BLOCK_INTS",
          "variable_type": "int"
        },
        {
          "variable_name": "KEY_LEN",
          "variable_type": "int"
        },
        {
          "variable_name": "KEY_INTS",
          "variable_type": "int"
        },
        {
          "variable_name": "OUT_LEN",
          "variable_type": "int"
        },
        {
          "variable_name": "CHUNK_LEN",
          "variable_type": "int"
        },
        {
          "variable_name": "CHAINING_VALUE_INTS",
          "variable_type": "int"
        },
        {
          "variable_name": "IV",
          "variable_type": "int"
        },
        {
          "variable_name": "CHUNK_START",
          "variable_type": "int"
        },
        {
          "variable_name": "CHUNK_END",
          "variable_type": "int"
        },
        {
          "variable_name": "PARENT",
          "variable_type": "int"
        },
        {
          "variable_name": "ROOT",
          "variable_type": "int"
        },
        {
          "variable_name": "KEYED_HASH",
          "variable_type": "int"
        },
        {
          "variable_name": "DERIVE_KEY_CONTEXT",
          "variable_type": "int"
        },
        {
          "variable_name": "DERIVE_KEY_MATERIAL",
          "variable_type": "int"
        },
        {
          "variable_name": "MSG_SCHEDULE",
          "variable_type": "byte"
        },
        {
          "variable_name": "engineState",
          "variable_type": "org.apache.commons.codec.digest.Blake3.EngineState"
        }
      ],
      "constructors": [
        {
          "body": "private Blake3(final int[] key, final int flags)\n{\r\n    engineState = new EngineState(key, flags);\r\n}",
          "signature": "Blake3(int[], int)",
          "parameters": [
            {
              "variable_name": "key",
              "variable_type": "int[]"
            },
            {
              "variable_name": "flags",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "checkBufferArgs": [
          {
            "call_methods": [
              {
                "signature": "java.util.Objects.requireNonNull(T)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "T"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "private static void checkBufferArgs(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "buffer",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ],
        "compress": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "IV",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "state",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.round(int[], int[], byte[])",
                "arguments": [
                  {
                    "variable_name": "state",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "blockWords",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "schedule",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOf(int[], int)",
                "arguments": [
                  {
                    "variable_name": "chainingValue",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "BLOCK_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "private static int[] compress(int[], int[], int, long, int)",
            "parameters": [
              {
                "variable_name": "chainingValue",
                "variable_type": "int[]"
              },
              {
                "variable_name": "blockWords",
                "variable_type": "int[]"
              },
              {
                "variable_name": "blockLength",
                "variable_type": "int"
              },
              {
                "variable_name": "counter",
                "variable_type": "long"
              },
              {
                "variable_name": "flags",
                "variable_type": "int"
              }
            ]
          }
        ],
        "g": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Integer.rotateRight(int, int)",
                "arguments": [
                  {
                    "variable_name": "state[d] ^ state[a]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "16",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private static void g(int[], int, int, int, int, int, int)",
            "parameters": [
              {
                "variable_name": "state",
                "variable_type": "int[]"
              },
              {
                "variable_name": "a",
                "variable_type": "int"
              },
              {
                "variable_name": "b",
                "variable_type": "int"
              },
              {
                "variable_name": "c",
                "variable_type": "int"
              },
              {
                "variable_name": "d",
                "variable_type": "int"
              },
              {
                "variable_name": "mx",
                "variable_type": "int"
              },
              {
                "variable_name": "my",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * The mixing function, G, which mixes either a column or a diagonal.\n     "
          }
        ],
        "hash": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.initHash()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.doFinalize(int)",
                "arguments": [
                  {
                    "variable_name": "OUT_LEN",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hash(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the Blake3 hash of the provided data.\n     *\n     * @param data source array to absorb data from\n     * @return 32-byte hash squeezed from the provided data\n     * @throws NullPointerException if data is null\n     "
          }
        ],
        "initHash": [
          {
            "call_methods": [],
            "signature": "public static Blake3 initHash()",
            "parameters": [],
            "javadoc": "\n     * Constructs a fresh Blake3 hash function. The instance returned functions as an arbitrary length message digest.\n     *\n     * @return fresh Blake3 instance in hashed mode\n     "
          }
        ],
        "initKeyDerivationFunction": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "kdfContext",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "kdfContext.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Objects.requireNonNull(T)",
                "arguments": [
                  {
                    "variable_name": "kdfContext",
                    "variable_type": "T"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "key.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.unpackInts(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "KEY_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "public static Blake3 initKeyDerivationFunction(byte[])",
            "parameters": [
              {
                "variable_name": "kdfContext",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a fresh Blake3 key derivation function using the provided key derivation context byte string.\n     * The instance returned functions as a key-derivation function which can further absorb additional context data\n     * before squeezing derived key data.\n     *\n     * @param kdfContext a globally unique key-derivation context byte string to separate key derivation contexts from each other\n     * @return fresh Blake3 instance in key derivation mode\n     * @throws NullPointerException if kdfContext is null\n     "
          }
        ],
        "initKeyedHash": [
          {
            "call_methods": [
              {
                "signature": "java.util.Objects.requireNonNull(T)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "T"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.unpackInts(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "KEY_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "public static Blake3 initKeyedHash(byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Constructs a fresh Blake3 keyed hash function. The instance returned functions as a pseudorandom function (PRF) or as a\n     * message authentication code (MAC).\n     *\n     * @param key 32-byte secret key\n     * @return fresh Blake3 instance in keyed mode using the provided key\n     * @throws NullPointerException     if key is null\n     * @throws IllegalArgumentException if key is not 32 bytes\n     "
          }
        ],
        "keyedHash": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.doFinalize(int)",
                "arguments": [
                  {
                    "variable_name": "OUT_LEN",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.initKeyedHash(byte[])",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              }
            ],
            "signature": "public static byte[] keyedHash(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the Blake3 keyed hash (MAC) of the provided data.\n     *\n     * @param key  32-byte secret key\n     * @param data source array to absorb data from\n     * @return 32-byte mac squeezed from the provided data\n     * @throws NullPointerException if key or data are null\n     "
          }
        ],
        "packInt": [
          {
            "call_methods": [],
            "signature": "private static void packInt(int, byte[], int, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "int"
              },
              {
                "variable_name": "dst",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "off",
                "variable_type": "int"
              },
              {
                "variable_name": "len",
                "variable_type": "int"
              }
            ]
          }
        ],
        "parentChainingValue": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.parentOutput(int[], int[], int[], int)",
                "arguments": [
                  {
                    "variable_name": "leftChildCV",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "rightChildCV",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "flags",
                    "variable_type": "int"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3.Output"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.Output.chainingValue()",
                "arguments": [],
                "return_type": "int[]"
              }
            ],
            "signature": "private static int[] parentChainingValue(int[], int[], int[], int)",
            "parameters": [
              {
                "variable_name": "leftChildCV",
                "variable_type": "int[]"
              },
              {
                "variable_name": "rightChildCV",
                "variable_type": "int[]"
              },
              {
                "variable_name": "key",
                "variable_type": "int[]"
              },
              {
                "variable_name": "flags",
                "variable_type": "int"
              }
            ]
          }
        ],
        "parentOutput": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "rightChildCV",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "blockWords",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CHAINING_VALUE_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Object.clone()",
                "arguments": [],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.util.Arrays.copyOf(int[], int)",
                "arguments": [
                  {
                    "variable_name": "leftChildCV",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "BLOCK_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "private static Output parentOutput(int[], int[], int[], int)",
            "parameters": [
              {
                "variable_name": "leftChildCV",
                "variable_type": "int[]"
              },
              {
                "variable_name": "rightChildCV",
                "variable_type": "int[]"
              },
              {
                "variable_name": "key",
                "variable_type": "int[]"
              },
              {
                "variable_name": "flags",
                "variable_type": "int"
              }
            ]
          }
        ],
        "round": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.g(int[], int, int, int, int, int, int)",
                "arguments": [
                  {
                    "variable_name": "state",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "12",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "msg[schedule[0]]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "msg[schedule[1]]",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static void round(int[], int[], byte[])",
            "parameters": [
              {
                "variable_name": "state",
                "variable_type": "int[]"
              },
              {
                "variable_name": "msg",
                "variable_type": "int[]"
              },
              {
                "variable_name": "schedule",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "unpackInt": [
          {
            "call_methods": [],
            "signature": "private static int unpackInt(byte[], int)",
            "parameters": [
              {
                "variable_name": "buf",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "off",
                "variable_type": "int"
              }
            ]
          }
        ],
        "unpackInts": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.unpackInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "off",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private static int[] unpackInts(byte[], int)",
            "parameters": [
              {
                "variable_name": "buf",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "nrInts",
                "variable_type": "int"
              }
            ]
          }
        ],
        "doFinalize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.doFinalize(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "out.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              }
            ],
            "signature": "public Blake3 doFinalize(byte[])",
            "parameters": [
              {
                "variable_name": "out",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Finalizes hash output data that depends on the sequence of updated bytes preceding this invocation and any\n     * previously finalized bytes. Note that this can finalize up to 2<sup>64</sup> bytes per instance.\n     *\n     * @param out destination array to finalize bytes into\n     * @return this\n     * @throws NullPointerException if out is null\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.outputHash(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public Blake3 doFinalize(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "out",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Finalizes an arbitrary number of bytes into the provided output array that depends on the sequence of previously\n     * updated and finalized bytes. Note that this can finalize up to 2<sup>64</sup> bytes per instance.\n     *\n     * @param out    destination array to finalize bytes into\n     * @param offset where in the array to begin writing bytes to\n     * @param length number of bytes to finalize\n     * @return this\n     * @throws NullPointerException      if out is null\n     * @throws IndexOutOfBoundsException if offset or length are negative or if offset + length is greater than the\n     *                                   length of the provided array\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.doFinalize(byte[])",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              }
            ],
            "signature": "public byte[] doFinalize(int)",
            "parameters": [
              {
                "variable_name": "nrBytes",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Squeezes and returns an arbitrary number of bytes dependent on the sequence of previously absorbed and squeezed bytes.\n     *\n     * @param nrBytes number of bytes to finalize\n     * @return requested number of finalized bytes\n     * @throws IllegalArgumentException if nrBytes is negative\n     "
          }
        ],
        "reset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.reset()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public Blake3 reset()",
            "parameters": [],
            "javadoc": "\n     * Resets this instance back to its initial state when it was first constructed.\n     * @return this\n     "
          }
        ],
        "update": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              }
            ],
            "signature": "public Blake3 update(byte[])",
            "parameters": [
              {
                "variable_name": "in",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Updates this hash state using the provided bytes.\n     *\n     * @param in source array to update data from\n     * @return this\n     * @throws NullPointerException if in is null\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.inputData(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.checkBufferArgs(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public Blake3 update(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "in",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Updates this hash state using the provided bytes at an offset.\n     *\n     * @param in     source array to update data from\n     * @param offset where in the array to begin reading bytes\n     * @param length number of bytes to update\n     * @return this\n     * @throws NullPointerException      if in is null\n     * @throws IndexOutOfBoundsException if offset or length are negative or if offset + length is greater than the\n     *                                   length of the provided array\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a\n * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a\n * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level\n * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.\n * <h2>Hashing</h2>\n * <p>Hash mode calculates the same output hash given the same input bytes and can be used as both a message digest and\n * and extensible output function.</p>\n * <pre>{@code\n *      Blake3 hasher = Blake3.initHash();\n *      hasher.update(\"Hello, world!\".getBytes(StandardCharsets.UTF_8));\n *      byte[] hash = new byte[32];\n *      hasher.doFinalize(hash);\n * }</pre>\n * <h2>Keyed Hashing</h2>\n * <p>Keyed hashes take a 32-byte secret key and calculates a message authentication code on some input bytes. These\n * also work as pseudo-random functions (PRFs) with extensible output similar to the extensible hash output. Note that\n * Blake3 keyed hashes have the same performance as plain hashes; the key is used in initialization in place of a\n * standard initialization vector used for plain hashing.</p>\n * <pre>{@code\n *      SecureRandom random = SecureRandom.getInstanceStrong();\n *      byte[] key = new byte[32];\n *      random.nextBytes(key);\n *      Blake3 hasher = Blake3.initKeyedHash(key);\n *      hasher.update(\"Hello, Alice!\".getBytes(StandardCharsets.UTF_8));\n *      byte[] mac = new byte[32];\n *      hasher.doFinalize(mac);\n * }</pre>\n * <h2>Key Derivation</h2>\n * <p>A specific hash mode for deriving session keys and other derived keys in a unique key derivation context\n * identified by some sequence of bytes. These context strings should be unique but do not need to be kept secret.\n * Additional input data is hashed for key material which can be finalized to derive subkeys.</p>\n * <pre>{@code\n *      String context = \"org.apache.commons.codec.digest.Blake3Example\";\n *      byte[] sharedSecret = ...;\n *      byte[] senderId = ...;\n *      byte[] recipientId = ...;\n *      Blake3 kdf = Blake3.initKeyDerivationFunction(context.getBytes(StandardCharsets.UTF_8));\n *      kdf.update(sharedSecret);\n *      kdf.update(senderId);\n *      kdf.update(recipientId);\n *      byte[] txKey = new byte[32];\n *      byte[] rxKey = new byte[32];\n *      kdf.doFinalize(txKey);\n *      kdf.doFinalize(rxKey);\n * }</pre>\n * <p>\n * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain\n * implementation by Jack O'Connor.\n * </p>\n *\n * @see <a href=\"https://github.com/BLAKE3-team/BLAKE3\">BLAKE3 hash function</a>\n * @since 1.16\n "
    },
    "org.apache.commons.codec.digest.Blake3.ChunkState": {
      "fields": [
        {
          "variable_name": "chainingValue",
          "variable_type": "int"
        },
        {
          "variable_name": "chunkCounter",
          "variable_type": "long"
        },
        {
          "variable_name": "flags",
          "variable_type": "int"
        },
        {
          "variable_name": "block",
          "variable_type": "byte"
        },
        {
          "variable_name": "blockLength",
          "variable_type": "int"
        },
        {
          "variable_name": "blocksCompressed",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "private ChunkState(final int[] key, final long chunkCounter, final int flags)\n{\r\n    chainingValue = key;\r\n    this.chunkCounter = chunkCounter;\r\n    this.flags = flags;\r\n}",
          "signature": "ChunkState(int[], long, int)",
          "parameters": [
            {
              "variable_name": "key",
              "variable_type": "int[]"
            },
            {
              "variable_name": "chunkCounter",
              "variable_type": "long"
            },
            {
              "variable_name": "flags",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "length": [
          {
            "call_methods": [],
            "signature": "private int length()",
            "parameters": []
          }
        ],
        "output": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.ChunkState.startFlag()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.unpackInts(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "block",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BLOCK_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "private Output output()",
            "parameters": []
          }
        ],
        "startFlag": [
          {
            "call_methods": [],
            "signature": "private int startFlag()",
            "parameters": []
          }
        ],
        "update": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.compress(int[], int[], int, long, int)",
                "arguments": [
                  {
                    "variable_name": "chainingValue",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "blockWords",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "BLOCK_LEN",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "chunkCounter",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "flags | startFlag()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "block",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "blockLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "take",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "block",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.ChunkState.startFlag()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.util.Arrays.copyOf(int[], int)",
                "arguments": [
                  {
                    "variable_name": "compress(chainingValue, blockWords, BLOCK_LEN, chunkCounter, flags | startFlag())",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "CHAINING_VALUE_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.unpackInts(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "block",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BLOCK_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "want",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private void update(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.Blake3.EngineState": {
      "fields": [
        {
          "variable_name": "key",
          "variable_type": "int"
        },
        {
          "variable_name": "flags",
          "variable_type": "int"
        },
        {
          "variable_name": "cvStack",
          "variable_type": "int"
        },
        {
          "variable_name": "stackLen",
          "variable_type": "int"
        },
        {
          "variable_name": "state",
          "variable_type": "org.apache.commons.codec.digest.Blake3.ChunkState"
        }
      ],
      "constructors": [
        {
          "body": "private EngineState(final int[] key, final int flags)\n{\r\n    this.key = key;\r\n    this.flags = flags;\r\n    state = new ChunkState(key, 0, flags);\r\n}",
          "signature": "EngineState(int[], int)",
          "parameters": [
            {
              "variable_name": "key",
              "variable_type": "int[]"
            },
            {
              "variable_name": "flags",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "addChunkCV": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.popCV()",
                "arguments": [],
                "return_type": "int[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.parentChainingValue(int[], int[], int[], int)",
                "arguments": [
                  {
                    "variable_name": "popCV()",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "newCV",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "flags",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.pushCV(int[])",
                "arguments": [
                  {
                    "variable_name": "newCV",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void addChunkCV(int[], long)",
            "parameters": [
              {
                "variable_name": "firstCV",
                "variable_type": "int[]"
              },
              {
                "variable_name": "totalChunks",
                "variable_type": "long"
              }
            ]
          }
        ],
        "inputData": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.ChunkState.output()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.digest.Blake3.Output"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.Output.chainingValue()",
                "arguments": [],
                "return_type": "int[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.ChunkState.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "take",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.ChunkState.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.EngineState.addChunkCV(int[], long)",
                "arguments": [
                  {
                    "variable_name": "chunkCV",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "totalChunks",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "want",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private void inputData(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "in",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ],
        "outputHash": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.ChunkState.output()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.digest.Blake3.Output"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.parentOutput(int[], int[], int[], int)",
                "arguments": [
                  {
                    "variable_name": "parentCV",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "output.chainingValue()",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "flags",
                    "variable_type": "int"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3.Output"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.Output.chainingValue()",
                "arguments": [],
                "return_type": "int[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.Output.rootOutputBytes(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void outputHash(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "out",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ],
        "popCV": [
          {
            "call_methods": [],
            "signature": "private int[] popCV()",
            "parameters": []
          }
        ],
        "pushCV": [
          {
            "call_methods": [],
            "signature": "private void pushCV(int[])",
            "parameters": [
              {
                "variable_name": "cv",
                "variable_type": "int[]"
              }
            ]
          }
        ],
        "reset": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.fill(java.lang.Object[], java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "cvStack",
                    "variable_type": "java.lang.Object[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void reset()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.Blake3.Output": {
      "fields": [
        {
          "variable_name": "inputChainingValue",
          "variable_type": "int"
        },
        {
          "variable_name": "blockWords",
          "variable_type": "int"
        },
        {
          "variable_name": "counter",
          "variable_type": "long"
        },
        {
          "variable_name": "blockLength",
          "variable_type": "int"
        },
        {
          "variable_name": "flags",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "private Output(final int[] inputChainingValue, final int[] blockWords, final long counter, final int blockLength, final int flags)\n{\r\n    this.inputChainingValue = inputChainingValue;\r\n    this.blockWords = blockWords;\r\n    this.counter = counter;\r\n    this.blockLength = blockLength;\r\n    this.flags = flags;\r\n}",
          "signature": "Output(int[], int[], long, int, int)",
          "parameters": [
            {
              "variable_name": "inputChainingValue",
              "variable_type": "int[]"
            },
            {
              "variable_name": "blockWords",
              "variable_type": "int[]"
            },
            {
              "variable_name": "counter",
              "variable_type": "long"
            },
            {
              "variable_name": "blockLength",
              "variable_type": "int"
            },
            {
              "variable_name": "flags",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "chainingValue": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.compress(int[], int[], int, long, int)",
                "arguments": [
                  {
                    "variable_name": "inputChainingValue",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "blockWords",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "blockLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "counter",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "flags",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "java.util.Arrays.copyOf(int[], int)",
                "arguments": [
                  {
                    "variable_name": "compress(inputChainingValue, blockWords, blockLength, counter, flags)",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "CHAINING_VALUE_INTS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "private int[] chainingValue()",
            "parameters": []
          }
        ],
        "rootOutputBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.compress(int[], int[], int, long, int)",
                "arguments": [
                  {
                    "variable_name": "inputChainingValue",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "blockWords",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "blockLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "outputBlockCounter++",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "flags | ROOT",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.packInt(int, byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "words[wordCounter++]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "wordLength",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "OUT_LEN * 2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private void rootOutputBytes(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "out",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Represents the state just prior to either producing an eight word chaining value or any number of output bytes\n     * when the ROOT flag is set.\n     "
    },
    "org.apache.commons.codec.digest.Crypt": {
      "fields": [],
      "constructors": [
        {
          "body": "public Crypt()\n{\r\n    // empty\r\n}",
          "signature": "Crypt()",
          "parameters": [],
          "javadoc": "\n     * TODO Make private in 2.0.\n     *\n     * @deprecated TODO Make private in 2.0.\n     "
        }
      ],
      "methods": {
        "crypt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String crypt(byte[])",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * A random salt and the default algorithm (currently SHA-512) are used. See {@link #crypt(String, String)} for\n     * details.\n     * </p>\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext password\n     * @return hash value\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Sha2Crypt.SHA512_PREFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String crypt(byte[], String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * If no salt is provided, a random salt and the default algorithm (currently SHA-512) will be used. See\n     * {@link #crypt(String, String)} for details.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext password\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null,\n     *            in which case a salt is generated for you using {@link SecureRandom}.\n     * @return hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String crypt(String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the digest using the strongest crypt(3) algorithm.\n     * <p>\n     * A random salt and the default algorithm (currently SHA-512) are used.\n     * </p>\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}.\n     * </p>\n     *\n     * @see #crypt(String, String)\n     * @param key\n     *            plaintext password\n     * @return hash value\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "key.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String crypt(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * The exact algorithm depends on the format of the salt string:\n     * </p>\n     * <ul>\n     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.\n     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long\n     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long\n     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars\n     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\n     * </ul>\n     * <p>\n     * The magic strings {@code \"$apr1$\"} and {@code \"$2a$\"} are not recognized by this method as its output should be\n     * identical with that of the libc implementation.\n     * </p>\n     * <p>\n     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length of if a\n     * {@code \"$\"} sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a\n     * password with:\n     * </p>\n     * <pre>\n     * storedPwd.equals(crypt(enteredPwd, storedPwd))\n     * </pre>\n     * <p>\n     * The resulting string starts with the marker string ({@code $n$}), where n is the same as the input salt.\n     * The salt is then appended, followed by a {@code \"$\"} sign.\n     * This is followed by the actual hash value.\n     * For DES the string only contains the salt and actual hash.\n     * The total length is dependent on the algorithm used:\n     * </p>\n     * <ul>\n     * <li>SHA-512: 106 chars\n     * <li>SHA-256: 63 chars\n     * <li>MD5: 34 chars\n     * <li>DES: 13 chars\n     * </ul>\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     *      crypt(\"secret\", \"$1$xxxx\") =&gt; \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n     *      crypt(\"secret\", \"xx\") =&gt; \"xxWAum7tHdIUw\"\n     * </pre>\n     * <p>\n     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\n     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\n     * </p>\n     *\n     * @see \"The man page of the libc crypt (3) function.\"\n     * @param key\n     *            plaintext password as entered by the used\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a\n     *            salt is generated for you using {@link SecureRandom}\n     * @return hash value, i.e. encrypted password including the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * GNU libc crypt(3) compatible hash method.\n * <p>\n * See {@link #crypt(String, String)} for further details.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n "
    },
    "org.apache.commons.codec.digest.DigestUtils": {
      "fields": [
        {
          "variable_name": "BUFFER_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "messageDigest",
          "variable_type": "java.security.MessageDigest"
        }
      ],
      "constructors": [
        {
          "body": "public DigestUtils()\n{\r\n    this.messageDigest = null;\r\n}",
          "signature": "DigestUtils()",
          "parameters": [],
          "javadoc": "\n     * Preserves binary compatibility only. As for previous versions does not provide useful behavior\n     *\n     * @deprecated since 1.11; only useful to preserve binary compatibility\n     "
        },
        {
          "body": "public DigestUtils(final MessageDigest digest)\n{\r\n    this.messageDigest = digest;\r\n}",
          "signature": "DigestUtils(MessageDigest)",
          "parameters": [
            {
              "variable_name": "digest",
              "variable_type": "java.security.MessageDigest"
            }
          ],
          "javadoc": "\n     * Creates an instance using the provided {@link MessageDigest} parameter.\n     *\n     * This can then be used to create digests using methods such as {@link #digest(byte[])} and {@link #digestAsHex(File)}.\n     *\n     * @param digest the {@link MessageDigest} to use\n     * @since 1.11\n     "
        },
        {
          "body": "public DigestUtils(final String name)\n{\r\n    this(getDigest(name));\r\n}",
          "signature": "DigestUtils(String)",
          "parameters": [
            {
              "variable_name": "name",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Creates an instance using the provided {@link MessageDigest} parameter.\n     *\n     * This can then be used to create digests using methods such as {@link #digest(byte[])} and {@link #digestAsHex(File)}.\n     *\n     * @param name the name of the {@link MessageDigest} to use\n     * @see #getDigest(String)\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     * @since 1.11\n     "
        }
      ],
      "methods": {
        "digest": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] digest(MessageDigest, byte[])",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Reads through a byte array and returns the digest for the data. Provided for symmetry with other methods.\n     *\n     * @param messageDigest The MessageDigest to use (e.g. MD5)\n     * @param data          Data to digest\n     * @return the digest\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] digest(MessageDigest, ByteBuffer)",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Reads through a ByteBuffer and returns the digest for the data\n     *\n     * @param messageDigest The MessageDigest to use (e.g. MD5)\n     * @param data          Data to digest\n     * @return the digest\n     *\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.File)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] digest(MessageDigest, File)",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.io.File"
              }
            ],
            "javadoc": "\n     * Reads through a File and returns the digest for the data\n     *\n     * @param messageDigest The MessageDigest to use (e.g. MD5)\n     * @param data          Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] digest(MessageDigest, InputStream)",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Reads through an InputStream and returns the digest for the data\n     *\n     * @param messageDigest The MessageDigest to use (e.g. MD5)\n     * @param data          Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.11 (was private)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.nio.file.Path, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.file.Path"
                  },
                  {
                    "variable_name": "options",
                    "variable_type": "java.nio.file.OpenOption..."
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] digest(MessageDigest, Path, OpenOption...)",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.nio.file.Path"
              },
              {
                "variable_name": "options",
                "variable_type": "java.nio.file.OpenOption"
              }
            ],
            "javadoc": "\n     * Reads through a File and returns the digest for the data\n     *\n     * @param messageDigest The MessageDigest to use (e.g. MD5)\n     * @param data          Data to digest\n     * @param options       options How to open the file\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.RandomAccessFile)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.RandomAccessFile"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] digest(MessageDigest, RandomAccessFile)",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.io.RandomAccessFile"
              }
            ],
            "javadoc": "\n     * Reads through a RandomAccessFile using non-blocking-io (NIO) and returns the digest for the data\n     *\n     * @param messageDigest The MessageDigest to use (e.g. MD5)\n     * @param data          Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] digest(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Reads through a byte array and returns the digest for the data.\n     *\n     * @param data Data to digest\n     * @return the digest\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] digest(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Reads through a ByteBuffer and returns the digest for the data\n     *\n     * @param data Data to digest\n     * @return the digest\n     *\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.File)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public byte[] digest(File)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.File"
              }
            ],
            "javadoc": "\n     * Reads through a File and returns the digest for the data\n     *\n     * @param data Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] digest(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Reads through an InputStream and returns the digest for the data\n     *\n     * @param data Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.nio.file.Path, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.file.Path"
                  },
                  {
                    "variable_name": "options",
                    "variable_type": "java.nio.file.OpenOption..."
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] digest(Path, OpenOption...)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.file.Path"
              },
              {
                "variable_name": "options",
                "variable_type": "java.nio.file.OpenOption"
              }
            ],
            "javadoc": "\n     * Reads through a File and returns the digest for the data\n     *\n     * @param data    Data to digest\n     * @param options options How to open the file\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] digest(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Reads through a byte array and returns the digest for the data.\n     *\n     * @param data Data to digest treated as UTF-8 string\n     * @return the digest\n     * @since 1.11\n     "
          }
        ],
        "getDigest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMessageDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getDigest(String)",
            "parameters": [
              {
                "variable_name": "algorithm",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Gets a {@code MessageDigest} for the given {@code algorithm}.\n     *\n     * @param algorithm the name of the algorithm requested. See\n     *                  <a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" >Appendix A in the Java\n     *                  Cryptography Architecture Reference Guide</a> for information about standard algorithm names.\n     * @return A digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMessageDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getDigest(String, MessageDigest)",
            "parameters": [
              {
                "variable_name": "algorithm",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "defaultMessageDigest",
                "variable_type": "java.security.MessageDigest"
              }
            ],
            "javadoc": "\n     * Gets a {@code MessageDigest} for the given {@code algorithm} or a default if there is a problem getting the algorithm.\n     *\n     * @param algorithm            the name of the algorithm requested. See\n     *                             <a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" > Appendix A in the Java\n     *                             Cryptography Architecture Reference Guide</a> for information about standard algorithm names.\n     * @param defaultMessageDigest The default MessageDigest.\n     * @return A digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     * @since 1.11\n     "
          }
        ],
        "getMd2Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.MD2",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getMd2Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an MD2 MessageDigest.\n     *\n     * @return An MD2 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a built-in algorithm\n     * @see MessageDigestAlgorithms#MD2\n     * @since 1.7\n     "
          }
        ],
        "getMd5Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.MD5",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getMd5Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an MD5 MessageDigest.\n     *\n     * @return An MD5 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a built-in algorithm\n     * @see MessageDigestAlgorithms#MD5\n     "
          }
        ],
        "getMessageDigest": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.getInstance(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "private static MessageDigest getMessageDigest(String)",
            "parameters": [
              {
                "variable_name": "algorithm",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Gets a {@code MessageDigest} for the given {@code algorithm}.\n     *\n     * @param algorithm the name of the algorithm requested. See\n     *                  <a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" > Appendix A in the Java\n     *                  Cryptography Architecture Reference Guide</a> for information about standard algorithm names.\n     * @return A digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws NoSuchAlgorithmException if no Provider supports a MessageDigestSpi implementation for the specified algorithm.\n     "
          },
          {
            "call_methods": [],
            "signature": "public MessageDigest getMessageDigest()",
            "parameters": [],
            "javadoc": "\n     * Returns the message digest instance.\n     *\n     * @return the message digest instance\n     * @since 1.11\n     "
          }
        ],
        "getSha1Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha1Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_1\n     * @since 1.7\n     "
          }
        ],
        "getSha256Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_256",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha256Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA-256 digest.\n     *\n     * @return An SHA-256 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_256\n     "
          }
        ],
        "getSha3_224Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA3_224",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha3_224Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA3-224 digest.\n     *\n     * @return An SHA3-224 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_224\n     * @since 1.12\n     "
          }
        ],
        "getSha3_256Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA3_256",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha3_256Digest()",
            "parameters": [],
            "javadoc": "\n     * Returns an SHA3-256 digest.\n     *\n     * @return An SHA3-256 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_256\n     * @since 1.12\n     "
          }
        ],
        "getSha3_384Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA3_384",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha3_384Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA3-384 digest.\n     *\n     * @return An SHA3-384 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_384\n     * @since 1.12\n     "
          }
        ],
        "getSha3_512Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA3_512",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha3_512Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA3-512 digest.\n     *\n     * @return An SHA3-512 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_512\n     * @since 1.12\n     "
          }
        ],
        "getSha384Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_384",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha384Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA-384 digest.\n     *\n     * @return An SHA-384 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_384\n     "
          }
        ],
        "getSha512_224Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_512_224",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha512_224Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA-512/224 digest.\n     *\n     * @return An SHA-512/224 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     * @see MessageDigestAlgorithms#SHA_512_224\n     "
          }
        ],
        "getSha512_256Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_512_256",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha512_256Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA-512/256 digest.\n     *\n     * @return An SHA-512/256 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     * @see MessageDigestAlgorithms#SHA_512_224\n     "
          }
        ],
        "getSha512Digest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_512",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getSha512Digest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA-512 digest.\n     *\n     * @return An SHA-512 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_512\n     "
          }
        ],
        "getShaDigest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha1Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest getShaDigest()",
            "parameters": [],
            "javadoc": "\n     * Gets an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught\n     * @deprecated (1.11) Use {@link #getSha1Digest()}\n     "
          }
        ],
        "isAvailable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String, java.security.MessageDigest)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.security.MessageDigest"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static boolean isAvailable(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Test whether the algorithm is supported.\n     *\n     * @param messageDigestAlgorithm the algorithm name\n     * @return {@code true} if the algorithm can be found\n     * @since 1.11\n     "
          }
        ],
        "md2": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMd2Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] md2(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the MD2 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return MD2 digest\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getMd2Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMd2Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] md2(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the MD2 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return MD2 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] md2(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the MD2 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD2 digest\n     * @since 1.7\n     "
          }
        ],
        "md2Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "md2(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md2Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the MD2 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD2 digest as a hexadecimal string\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "md2(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String md2Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the MD2 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD2 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "md2(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md2Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the MD2 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD2 digest as a hexadecimal string\n     * @since 1.7\n     "
          }
        ],
        "md5": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMd5Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] md5(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the MD5 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return MD5 digest\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMd5Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getMd5Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] md5(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the MD5 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return MD5 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] md5(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the MD5 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD5 digest\n     "
          }
        ],
        "md5Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "md5(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md5Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the MD5 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD5 digest as a hexadecimal string\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "md5(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String md5Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the MD5 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD5 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "md5(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md5Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the MD5 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD5 digest as a hexadecimal string\n     "
          }
        ],
        "sha": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest\n     * @deprecated (1.11) Use {@link #sha1(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     * @deprecated (1.11) Use {@link #sha1(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest\n     * @deprecated (1.11) Use {@link #sha1(String)}\n     "
          }
        ],
        "sha1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha1Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha1(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha1Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha1Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha1(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha1(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-1 digest\n     "
          }
        ],
        "sha1Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha1(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha1Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha1(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha1Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha1(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha1Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @since 1.7\n     "
          }
        ],
        "sha256": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha256Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha256(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-256 digest\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha256Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha256Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha256(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-256 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha256(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-256 digest\n     * @since 1.4\n     "
          }
        ],
        "sha256Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha256Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-256 digest as a hexadecimal string\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha256Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-256 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha256Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-256 digest as a hexadecimal string\n     * @since 1.4\n     "
          }
        ],
        "sha3_224": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_224Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha3_224(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-224 digest\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha3_224Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_224Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha3_224(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-224 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_224(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha3_224(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-224 digest\n     * @since 1.12\n     "
          }
        ],
        "sha3_224Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_224(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_224(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha3_224Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-224 digest as a hexadecimal string\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_224(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_224(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha3_224Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-224 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_224(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_224(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha3_224Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-224 digest as a hexadecimal string\n     * @since 1.12\n     "
          }
        ],
        "sha3_256": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_256Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha3_256(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-256 digest\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha3_256Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_256Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha3_256(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-256 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_256(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha3_256(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-256 digest\n     * @since 1.12\n     "
          }
        ],
        "sha3_256Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_256(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha3_256Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-256 digest as a hexadecimal string\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_256(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha3_256Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-256 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_256(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha3_256Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-256 digest as a hexadecimal string\n     * @since 1.12\n     "
          }
        ],
        "sha3_384": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_384Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha3_384(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-384 digest\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_384Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha3_384Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha3_384(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-384 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_384(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha3_384(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-384 digest\n     * @since 1.12\n     "
          }
        ],
        "sha3_384Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_384(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_384(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha3_384Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-384 digest as a hexadecimal string\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_384(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_384(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha3_384Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-384 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_384(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_384(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha3_384Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-384 digest as a hexadecimal string\n     * @since 1.12\n     "
          }
        ],
        "sha3_512": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_512Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha3_512(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-512 digest\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha3_512Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha3_512Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha3_512(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA3-512 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_512(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha3_512(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-512 digest\n     * @since 1.12\n     "
          }
        ],
        "sha3_512Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_512(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_512(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha3_512Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-512 digest as a hexadecimal string\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_512(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_512(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha3_512Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-512 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_512(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha3_512(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha3_512Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA3-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-512 digest as a hexadecimal string\n     * @since 1.12\n     "
          }
        ],
        "sha384": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha384Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha384(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-384 digest\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha384Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha384Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha384(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-384 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha384(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-384 digest\n     * @since 1.4\n     "
          }
        ],
        "sha384Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha384(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha384Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-384 digest as a hexadecimal string\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha384(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha384Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-384 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha384(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha384Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-384 digest as a hexadecimal string\n     * @since 1.4\n     "
          }
        ],
        "sha512": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha512(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-512 digest\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha512Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha512(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-512 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha512(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512 digest\n     * @since 1.4\n     "
          }
        ],
        "sha512_224": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512_224Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha512_224(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-512/224 digest\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512_224Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha512_224Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha512_224(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-512/224 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha512_224(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512/224 digest\n     * @since 1.14\n     "
          }
        ],
        "sha512_224Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512_224(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha512_224Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/224 digest as a hexadecimal string\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512_224(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512_224Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/224 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512_224(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String sha512_224Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/224 digest as a hexadecimal string\n     * @since 1.14\n     "
          }
        ],
        "sha512_256": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512_256Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha512_256(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-512/256 digest\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "getSha512_256Digest()",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha512_256Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static byte[] sha512_256(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-512/256 digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] sha512_256(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512/224 digest\n     * @since 1.14\n     "
          }
        ],
        "sha512_256Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512_256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512_256Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/256 digest as a hexadecimal string\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512_256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512_256Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/256 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512_256(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512_256Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512/256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/256 digest as a hexadecimal string\n     * @since 1.14\n     "
          }
        ],
        "sha512Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512Hex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512 digest as a hexadecimal string\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512Hex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sha512(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512Hex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512 digest as a hexadecimal string\n     * @since 1.4\n     "
          }
        ],
        "shaHex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String shaHex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @deprecated (1.11) Use {@link #sha1Hex(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String shaHex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.4\n     * @deprecated (1.11) Use {@link #sha1Hex(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String shaHex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @deprecated (1.11) Use {@link #sha1Hex(String)}\n     "
          }
        ],
        "updateDigest": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static MessageDigest updateDigest(MessageDigest, byte[])",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest the {@link MessageDigest} to update\n     * @param valueToDigest the value to update the {@link MessageDigest} with\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static MessageDigest updateDigest(MessageDigest, ByteBuffer)",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Updates the given {@link MessageDigest}.\n     *\n     * @param messageDigest the {@link MessageDigest} to update\n     * @param valueToDigest the value to update the {@link MessageDigest} with\n     * @return the updated {@link MessageDigest}\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "digest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "inputStream",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public static MessageDigest updateDigest(MessageDigest, File)",
            "parameters": [
              {
                "variable_name": "digest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.io.File"
              }
            ],
            "javadoc": "\n     * Reads through a File and updates the digest for the data\n     *\n     * @param digest The MessageDigest to use (e.g. MD5)\n     * @param data   Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.channels.FileChannel.read(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.clear()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.security.MessageDigest.update(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "BUFFER_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "private static MessageDigest updateDigest(MessageDigest, FileChannel)",
            "parameters": [
              {
                "variable_name": "digest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.nio.channels.FileChannel"
              }
            ],
            "javadoc": "\n     * Reads through a RandomAccessFile and updates the digest for the data using non-blocking-io (NIO).\n     *\n     * TODO Decide if this should be public.\n     *\n     * @param digest The MessageDigest to use (e.g. MD5)\n     * @param data   Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "read",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "BUFFER_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static MessageDigest updateDigest(MessageDigest, InputStream)",
            "parameters": [
              {
                "variable_name": "digest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "inputStream",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Reads through an InputStream and updates the digest for the data\n     *\n     * @param digest      The MessageDigest to use (e.g. MD5)\n     * @param inputStream Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.8\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "digest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "inputStream",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.nio.file.Files.newInputStream(java.nio.file.Path, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "path",
                    "variable_type": "java.nio.file.Path"
                  },
                  {
                    "variable_name": "options",
                    "variable_type": "java.nio.file.OpenOption..."
                  }
                ],
                "return_type": "java.io.InputStream"
              }
            ],
            "signature": "public static MessageDigest updateDigest(MessageDigest, Path, OpenOption...)",
            "parameters": [
              {
                "variable_name": "digest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "path",
                "variable_type": "java.nio.file.Path"
              },
              {
                "variable_name": "options",
                "variable_type": "java.nio.file.OpenOption"
              }
            ],
            "javadoc": "\n     * Reads through a Path and updates the digest for the data\n     *\n     * @param digest  The MessageDigest to use (e.g. MD5)\n     * @param path    Data to digest\n     * @param options options How to open the file\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.nio.channels.FileChannel)",
                "arguments": [
                  {
                    "variable_name": "digest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "data.getChannel()",
                    "variable_type": "java.nio.channels.FileChannel"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.io.RandomAccessFile.getChannel()",
                "arguments": [],
                "return_type": "java.nio.channels.FileChannel"
              }
            ],
            "signature": "public static MessageDigest updateDigest(MessageDigest, RandomAccessFile)",
            "parameters": [
              {
                "variable_name": "digest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "data",
                "variable_type": "java.io.RandomAccessFile"
              }
            ],
            "javadoc": "\n     * Reads through a RandomAccessFile and updates the digest for the data using non-blocking-io (NIO)\n     *\n     * @param digest The MessageDigest to use (e.g. MD5)\n     * @param data   Data to digest\n     * @return the digest\n     * @throws IOException On error reading from the stream\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static MessageDigest updateDigest(MessageDigest, String)",
            "parameters": [
              {
                "variable_name": "messageDigest",
                "variable_type": "java.security.MessageDigest"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Updates the given {@link MessageDigest} from a String (converted to bytes using UTF-8).\n     * <p>\n     * To update the digest using a different charset for the conversion, convert the String to a byte array using\n     * {@link String#getBytes(java.nio.charset.Charset)} and pass that to the {@link DigestUtils#updateDigest(MessageDigest, byte[])} method\n     *\n     * @param messageDigest the {@link MessageDigest} to update\n     * @param valueToDigest the value to update the {@link MessageDigest} with; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return the updated {@link MessageDigest}\n     * @since 1.7\n     "
          }
        ],
        "digestAsHex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "digest(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String digestAsHex(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Reads through a byte array and returns the digest for the data.\n     *\n     * @param data Data to digest\n     * @return the digest as a hexadecimal string\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "digest(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String digestAsHex(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Reads through a ByteBuffer and returns the digest for the data\n     *\n     * @param data Data to digest\n     * @return the digest as a hexadecimal string\n     *\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "digest(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.io.File)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String digestAsHex(File)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.File"
              }
            ],
            "javadoc": "\n     * Reads through a File and returns the digest for the data\n     *\n     * @param data Data to digest\n     * @return the digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "digest(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String digestAsHex(InputStream)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Reads through an InputStream and returns the digest for the data\n     *\n     * @param data Data to digest\n     * @return the digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.nio.file.Path, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.file.Path"
                  },
                  {
                    "variable_name": "options",
                    "variable_type": "java.nio.file.OpenOption..."
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "digest(data, options)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String digestAsHex(Path, OpenOption...)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.file.Path"
              },
              {
                "variable_name": "options",
                "variable_type": "java.nio.file.OpenOption"
              }
            ],
            "javadoc": "\n     * Reads through a File and returns the digest for the data\n     *\n     * @param data    Data to digest\n     * @param options options How to open the file\n     * @return the digest as a hexadecimal string\n     * @throws IOException On error reading from the stream\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "digest(data)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String digestAsHex(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Reads through a byte array and returns the digest for the data.\n     *\n     * @param data Data to digest treated as UTF-8 string\n     * @return the digest as a hexadecimal string\n     * @since 1.11\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Operations to simplify common {@link java.security.MessageDigest} tasks. This class is immutable and thread-safe. However the MessageDigest instances it\n * creates generally won't be.\n * <p>\n * The {@link MessageDigestAlgorithms} class provides constants for standard digest algorithms that can be used with the {@link #getDigest(String)} method and\n * other methods that require the Digest algorithm name.\n * </p>\n * <p>\n * Note: the class has shorthand methods for all the algorithms present as standard in Java 6. This approach requires lots of methods for each algorithm, and\n * quickly becomes unwieldy. The following code works with all algorithms:\n * </p>\n *\n * <pre>\n * import static org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224;\n * ...\n * byte [] digest = new DigestUtils(SHA_224).digest(dataToDigest);\n * String hdigest = new DigestUtils(SHA_224).digestAsHex(new File(\"pom.xml\"));\n * </pre>\n *\n * @see MessageDigestAlgorithms\n "
    },
    "org.apache.commons.codec.digest.HmacUtils": {
      "fields": [
        {
          "variable_name": "STREAM_BUFFER_LENGTH",
          "variable_type": "int"
        },
        {
          "variable_name": "mac",
          "variable_type": "javax.crypto.Mac"
        }
      ],
      "constructors": [
        {
          "body": "public HmacUtils()\n{\r\n    this(null);\r\n}",
          "signature": "HmacUtils()",
          "parameters": [],
          "javadoc": "\n     * Preserves binary compatibility only.\n     * As for previous versions does not provide useful behavior\n     * @deprecated since 1.11; only useful to preserve binary compatibility\n     "
        },
        {
          "body": "public HmacUtils(final HmacAlgorithms algorithm, final byte[] key)\n{\r\n    this(algorithm.getName(), key);\r\n}",
          "signature": "HmacUtils(HmacAlgorithms, byte[])",
          "parameters": [
            {
              "variable_name": "algorithm",
              "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
            },
            {
              "variable_name": "key",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Creates an instance using the provided algorithm type.\n     *\n     * @param algorithm to use.\n     * @param key the key to use\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @since 1.11\n     "
        },
        {
          "body": "public HmacUtils(final HmacAlgorithms algorithm, final String key)\n{\r\n    this(algorithm.getName(), StringUtils.getBytesUtf8(key));\r\n}",
          "signature": "HmacUtils(HmacAlgorithms, String)",
          "parameters": [
            {
              "variable_name": "algorithm",
              "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
            },
            {
              "variable_name": "key",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Creates an instance using the provided algorithm type.\n     *\n     * @param algorithm to use\n     * @param  key the key to use\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @since 1.11\n     "
        },
        {
          "body": "private HmacUtils(final Mac mac)\n{\r\n    this.mac = mac;\r\n}",
          "signature": "HmacUtils(Mac)",
          "parameters": [
            {
              "variable_name": "mac",
              "variable_type": "javax.crypto.Mac"
            }
          ]
        },
        {
          "body": "public HmacUtils(final String algorithm, final byte[] key)\n{\r\n    this(getInitializedMac(algorithm, key));\r\n}",
          "signature": "HmacUtils(String, byte[])",
          "parameters": [
            {
              "variable_name": "algorithm",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "key",
              "variable_type": "byte[]"
            }
          ],
          "javadoc": "\n     * Creates an instance using the provided algorithm type.\n     *\n     * @param algorithm to use\n     * @param  key the key to use\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @since 1.11\n     "
        },
        {
          "body": "public HmacUtils(final String algorithm, final String key)\n{\r\n    this(algorithm, StringUtils.getBytesUtf8(key));\r\n}",
          "signature": "HmacUtils(String, String)",
          "parameters": [
            {
              "variable_name": "algorithm",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "key",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Creates an instance using the provided algorithm type.\n     *\n     * @param algorithm to use\n     * @param  key the key to use\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @since 1.11\n     "
        }
      ],
      "methods": {
        "getHmacMd5": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_MD5",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static Mac getHmacMd5(byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns an initialized {@code Mac} for the HmacMD5 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_MD5, byte[])}\n     "
          }
        ],
        "getHmacSha1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_SHA_1",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static Mac getHmacSha1(byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns an initialized {@code Mac} for the HmacSHA1 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_1, byte[])}\n     "
          }
        ],
        "getHmacSha256": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_SHA_256",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static Mac getHmacSha256(byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns an initialized {@code Mac} for the HmacSHA256 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_256, byte[])}\n     "
          }
        ],
        "getHmacSha384": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_SHA_384",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static Mac getHmacSha384(byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns an initialized {@code Mac} for the HmacSHA384 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_384, byte[])}\n     "
          }
        ],
        "getHmacSha512": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_SHA_512",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static Mac getHmacSha512(byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns an initialized {@code Mac} for the HmacSHA512 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_512, byte[])}\n     "
          }
        ],
        "getInitializedMac": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(java.lang.String, byte[])",
                "arguments": [
                  {
                    "variable_name": "algorithm.getName()",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacAlgorithms.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static Mac getInitializedMac(HmacAlgorithms, byte[])",
            "parameters": [
              {
                "variable_name": "algorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns an initialized {@code Mac} for the given {@code algorithm}.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See\n     *            <a href= \"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\"\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\n     *            algorithm names.\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.init(java.security.Key)",
                "arguments": [
                  {
                    "variable_name": "keySpec",
                    "variable_type": "java.security.Key"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "javax.crypto.Mac.getInstance(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static Mac getInitializedMac(String, byte[])",
            "parameters": [
              {
                "variable_name": "algorithm",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns an initialized {@code Mac} for the given {@code algorithm}.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See\n     *            <a href= \"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\"\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\n     *            algorithm names.\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     "
          }
        ],
        "hmacMd5": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacMd5(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacMd5(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacMD5 MAC for the given key and value\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacMd5(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmac(String)}\n     "
          }
        ],
        "hmacMd5Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacMd5Hex(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value as a hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacMd5Hex(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacMD5 MAC for the given key and value as a hexadecimal string (lowercase)\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacMd5Hex(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value as a hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmacHex(String)}\n     "
          }
        ],
        "hmacSha1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha1(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha1(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA1 MAC for the given key and value\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha1(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmac(String)}\n     "
          }
        ],
        "hmacSha1Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha1Hex(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha1Hex(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA1 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha1Hex(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmacHex(String)}\n     "
          }
        ],
        "hmacSha256": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha256(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha256(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA256 MAC for the given key and value\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha256(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmac(String)}\n     "
          }
        ],
        "hmacSha256Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha256Hex(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha256Hex(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA256 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha256Hex(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmacHex(String)}\n     "
          }
        ],
        "hmacSha384": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha384(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha384(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA384 MAC for the given key and value\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha384(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmac(String)}\n     "
          }
        ],
        "hmacSha384Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha384Hex(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha384Hex(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA384 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha384Hex(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmacHex(String)}\n     "
          }
        ],
        "hmacSha512": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha512(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha512(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA512 MAC for the given key and value\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static byte[] hmacSha512(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmac(String)}\n     "
          }
        ],
        "hmacSha512Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha512Hex(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(byte[])}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha512Hex(byte[], InputStream)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return HmacSHA512 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(InputStream)}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String hmacSha512Hex(String, String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmacHex(String)}\n     "
          }
        ],
        "isAvailable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacAlgorithms.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "javax.crypto.Mac.getInstance(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name.getName()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static boolean isAvailable(HmacAlgorithms)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              }
            ],
            "javadoc": "\n     * Returns whether this algorithm is available\n     *\n     * @param name the name to check\n     * @return whether this algorithm is available\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.getInstance(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public static boolean isAvailable(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns whether this algorithm is available\n     *\n     * @param name the name to check\n     * @return whether this algorithm is available\n     * @since 1.11\n     "
          }
        ],
        "updateHmac": [
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "javax.crypto.Mac.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static Mac updateHmac(Mac, byte[])",
            "parameters": [
              {
                "variable_name": "mac",
                "variable_type": "javax.crypto.Mac"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Resets and then updates the given {@link Mac} with the value.\n     *\n     * @param mac\n     *            the initialized {@link Mac} to update\n     * @param valueToDigest\n     *            the value to update the {@link Mac} with (maybe null or empty)\n     * @return the updated {@link Mac}\n     * @throws IllegalStateException\n     *             if the Mac was not initialized\n     "
          },
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "javax.crypto.Mac.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "read",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "STREAM_BUFFER_LENGTH",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static Mac updateHmac(Mac, InputStream)",
            "parameters": [
              {
                "variable_name": "mac",
                "variable_type": "javax.crypto.Mac"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Resets and then updates the given {@link Mac} with the value.\n     *\n     * @param mac\n     *            the initialized {@link Mac} to update\n     * @param valueToDigest\n     *            the value to update the {@link Mac} with\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return the updated {@link Mac}\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @throws IllegalStateException\n     *             If the Mac was not initialized\n     "
          },
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "javax.crypto.Mac.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static Mac updateHmac(Mac, String)",
            "parameters": [
              {
                "variable_name": "mac",
                "variable_type": "javax.crypto.Mac"
              },
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Resets and then updates the given {@link Mac} with the value.\n     *\n     * @param mac\n     *            the initialized {@link Mac} to update\n     * @param valueToDigest\n     *            the value to update the {@link Mac} with (maybe null or empty)\n     * @return the updated {@link Mac}\n     * @throws IllegalStateException\n     *             if the Mac was not initialized\n     "
          }
        ],
        "hmac": [
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.doFinal(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] hmac(byte[])",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use\n     * @return the digest as a byte[]\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.doFinal()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "javax.crypto.Mac.update(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public byte[] hmac(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use\n     * @return the digest as a byte[]\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "stream",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] hmac(File)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.File"
              }
            ],
            "javadoc": "\n     * Returns the digest for the file.\n     *\n     * @param valueToDigest the file to use\n     * @return the digest\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "read",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "javax.crypto.Mac.doFinal()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.InputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "STREAM_BUFFER_LENGTH",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public byte[] hmac(InputStream)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns the digest for the stream.\n     *\n     * @param valueToDigest\n     *            the data to use\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return the digest\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "javax.crypto.Mac.doFinal(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] hmac(String)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use, treated as UTF-8\n     * @return the digest as a byte[]\n     * @since 1.11\n     "
          }
        ],
        "hmacHex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "hmac(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String hmacHex(byte[])",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use\n     * @return the digest as a hexadecimal String\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "hmac(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String hmacHex(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.nio.ByteBuffer"
              }
            ],
            "javadoc": "\n     * Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use\n     * @return the digest as a hexadecimal String\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.File)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "hmac(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String hmacHex(File)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.File"
              }
            ],
            "javadoc": "\n     * Returns the digest for the file.\n     *\n     * @param valueToDigest the file to use\n     * @return the digest as a hexadecimal String\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "hmac(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String hmacHex(InputStream)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Returns the digest for the stream.\n     *\n     * @param valueToDigest\n     *            the data to use\n     *            <p>\n     *            The InputStream must not be null and will not be closed\n     *            </p>\n     * @return the digest as a hexadecimal String\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.11\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "valueToDigest",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "hmac(valueToDigest)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String hmacHex(String)",
            "parameters": [
              {
                "variable_name": "valueToDigest",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use, treated as UTF-8\n     * @return the digest as a hexadecimal String\n     * @since 1.11\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Simplifies common {@link javax.crypto.Mac} tasks. This class is immutable and thread-safe.\n * However the Mac may not be.\n * <p>\n * <strong>Note: Not all JCE implementations support all algorithms. If not supported, an IllegalArgumentException is\n * thrown.</strong>\n * </p>\n * <p>\n * Sample usage:\n * </p>\n * <pre>\n * import static HmacAlgorithms.*;\n * byte[] key = {1,2,3,4}; // don't use this actual key!\n * String valueToDigest = \"The quick brown fox jumps over the lazy dog\";\n * byte[] hmac = new HmacUtils(HMAC_SHA_224, key).hmac(valueToDigest);\n * // Mac re-use\n * HmacUtils hm1 = new HmacUtils(\"HmacAlgoName\", key); // use a valid name here!\n * String hexPom = hm1.hmacHex(new File(\"pom.xml\"));\n * String hexNot = hm1.hmacHex(new File(\"NOTICE.txt\"));\n * </pre>\n * @since 1.10\n "
    },
    "org.apache.commons.codec.digest.Md5Crypt": {
      "fields": [
        {
          "variable_name": "APR1_PREFIX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BLOCKSIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "MD5_PREFIX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ROUNDS",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public Md5Crypt()\n{\r\n    // empty\r\n}",
          "signature": "Md5Crypt()",
          "parameters": [],
          "javadoc": "\n     * TODO Make private in 2.0.\n     *\n     * @deprecated TODO Make private in 2.0.\n     "
        }
      ],
      "methods": {
        "apr1Crypt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "APR1_PREFIX + B64.getRandomSalt(8)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String apr1Crypt(byte[])",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * See {@link #apr1Crypt(byte[], String)} for details.\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}; your own {@link Random} in\n     * {@link #apr1Crypt(byte[], Random)}.\n     * </p>\n     *\n     * @param keyBytes plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @return the hash value\n     * @throws IllegalArgumentException when a {@link java.security.NoSuchAlgorithmException} is caught. *\n     * @see #apr1Crypt(byte[], String)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "random",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "APR1_PREFIX + B64.getRandomSalt(8, random)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String apr1Crypt(byte[], Random)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "random",
                "variable_type": "java.util.Random"
              }
            ],
            "javadoc": "\n     * See {@link #apr1Crypt(byte[], String)} for details.\n     * <p>\n     * A salt is generated for you using the user provided {@link Random}.\n     * </p>\n     *\n     * @param keyBytes plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param random the instance of {@link Random} to use for generating the salt.\n     *              Consider using {@link SecureRandom} for more secure salts.\n     * @return the hash value\n     * @throws IllegalArgumentException when a {@link java.security.NoSuchAlgorithmException} is caught. *\n     * @see #apr1Crypt(byte[], String)\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "APR1_PREFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "APR1_PREFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String apr1Crypt(byte[], String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * See {@link #apr1Crypt(String, String)} for details.\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            An APR1 salt. The salt may be null, in which case a salt is generated for you using\n     *            {@link SecureRandom}\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "keyBytes.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String apr1Crypt(String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * See {@link #apr1Crypt(String, String)} for details.\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @see #apr1Crypt(byte[], String)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String apr1Crypt(String, String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates an Apache htpasswd compatible \"$apr1$\" MD5 based hash value.\n     * <p>\n     * The algorithm is identical to the crypt(3) \"$1$\" one but produces different outputs due to the different salt\n     * prefix.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            salt string including the prefix and optionally garbage at the end. The salt may be null, in which\n     *            case a salt is generated for you using {@link SecureRandom}.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          }
        ],
        "md5Crypt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "MD5_PREFIX + B64.getRandomSalt(8)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md5Crypt(byte[])",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() compatible \"$1$\" hash value.\n     * <p>\n     * See {@link #md5Crypt(byte[], String)} for details.\n     * </p>\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}.\n     * </p>\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @see #md5Crypt(byte[], String)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "random",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "MD5_PREFIX + B64.getRandomSalt(8, random)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md5Crypt(byte[], Random)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "random",
                "variable_type": "java.util.Random"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() compatible \"$1$\" hash value.\n     * <p>\n     * See {@link #md5Crypt(byte[], String)} for details.\n     * </p>\n     * <p>\n     * A salt is generated for you using the instance of {@link Random} you supply.\n     * </p>\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param random\n     *            the instance of {@link Random} to use for generating the salt.\n     *            Consider using {@link SecureRandom} for more secure salts.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @see #md5Crypt(byte[], String)\n     * @since 1.12\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "MD5_PREFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md5Crypt(byte[], String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a libc crypt() compatible \"$1$\" MD5 based hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details. We use {@link SecureRandom} for seed generation by\n     * default.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            salt string including the prefix and optionally garbage at the end. The salt may be null, in which\n     *            case a salt is generated for you using {@link SecureRandom}.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String, java.lang.String, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "prefix",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new SecureRandom()",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String md5Crypt(byte[], String, String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details. We use\n     * {@link SecureRandom by default}.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a salt\n     *            is generated for you using {@link SecureRandom}.\n     * @param prefix\n     *            salt prefix\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.regex.Pattern.matcher(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.regex.Matcher"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMd5Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "finalb",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.update(byte)",
                "arguments": [
                  {
                    "variable_name": "finalb[j]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.regex.Matcher.group(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"$\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"\\\\$\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.regex.Pattern.compile(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\" + prefix.replace(\"$\", \"\\\\$\") + \"([\\\\.\\\\/a-zA-Z0-9]{1,8}).*\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.regex.Pattern"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "ii",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "16",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "random",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.regex.Matcher.find()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.B64.b64from24bit(byte, byte, byte, int, java.lang.StringBuilder)",
                "arguments": [
                  {
                    "variable_name": "finalb[0]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "finalb[6]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "finalb[12]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "passwd",
                    "variable_type": "java.lang.StringBuilder"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "finalb",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "Math.min(ii, 16)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.reset()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public static String md5Crypt(byte[], String, String, Random)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "random",
                "variable_type": "java.util.Random"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a salt\n     *            is generated for you using {@link SecureRandom}.\n     * @param prefix\n     *            salt prefix\n     * @param random\n     *            the instance of {@link Random} to use for generating the salt.\n     *            Consider using {@link SecureRandom} for more secure salts.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @since 1.12\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * The libc crypt() \"$1$\" and Apache \"$apr1$\" MD5-based hash algorithm.\n * <p>\n * Based on the public domain (\"beer-ware\") C implementation from Poul-Henning Kamp which was found at: <a\n * href=\"http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain\">\n * crypt-md5.c @ freebsd.org</a>\n * </p>\n * <p>\n * Source:\n * </p>\n * <pre>\n * $FreeBSD: src/lib/libcrypt/crypt-md5.c,v 1.1 1999/01/21 13:50:09 brandon Exp $\n * </pre>\n * <p>\n * Conversion to Kotlin and from there to Java in 2012.\n * </p>\n * <p>\n * The C style comments are from the original C code, the ones with \"//\" from the port.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n "
    },
    "org.apache.commons.codec.digest.MessageDigestAlgorithms": {
      "fields": [
        {
          "variable_name": "MD2",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "MD5",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA_1",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA_224",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA_256",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA_384",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA_512",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA_512_224",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA_512_256",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA3_224",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA3_256",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA3_384",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA3_512",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [
        {
          "body": "private MessageDigestAlgorithms()\n{\r\n    // cannot be instantiated.\r\n}",
          "signature": "MessageDigestAlgorithms()",
          "parameters": []
        }
      ],
      "methods": {
        "values": [
          {
            "call_methods": [],
            "signature": "public static String[] values()",
            "parameters": [],
            "javadoc": "\n     * Gets all constant values defined in this class.\n     *\n     * @return all constant values defined in this class.\n     * @since 1.11\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Standard {@link MessageDigest} algorithm names from the <cite>Java Cryptography Architecture Standard Algorithm Name\n * Documentation</cite>.\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n * <ul>\n * <li>Java 8 and up: SHA-224.</li>\n * <li>Java 9 and up: SHA3-224, SHA3-256, SHA3-384, SHA3-512.</li>\n * </ul>\n *\n * @see <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest\">\n *      Java 8 Cryptography Architecture Standard Algorithm Name Documentation</a>\n * @see <a href=\"https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#messagedigest-algorithms\">\n *      Java 11 Cryptography Architecture Standard Algorithm Name Documentation</a>\n * @see <a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#messagedigest-algorithms\">\n *      Java 17 Cryptography Architecture Standard Algorithm Name Documentation</a>\n * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/specs/security/standard-names.html#messagedigest-algorithms\">\n *      Java 21 Cryptography Architecture Standard Algorithm Name Documentation</a>\n *\n * @see <a href=\"https://dx.doi.org/10.6028/NIST.FIPS.180-4\">FIPS PUB 180-4</a>\n * @see <a href=\"https://dx.doi.org/10.6028/NIST.FIPS.202\">FIPS PUB 202</a>\n * @since 1.7\n "
    },
    "org.apache.commons.codec.digest.MurmurHash2": {
      "fields": [
        {
          "variable_name": "M32",
          "variable_type": "int"
        },
        {
          "variable_name": "R32",
          "variable_type": "int"
        },
        {
          "variable_name": "M64",
          "variable_type": "long"
        },
        {
          "variable_name": "R64",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "private MurmurHash2()\n{\r\n}",
          "signature": "MurmurHash2()",
          "parameters": [],
          "javadoc": " No instance methods. "
        }
      ],
      "methods": {
        "getLittleEndianInt": [
          {
            "call_methods": [],
            "signature": "private static int getLittleEndianInt(byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Gets the little-endian int from 4 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian int\n     "
          }
        ],
        "getLittleEndianLong": [
          {
            "call_methods": [],
            "signature": "private static long getLittleEndianLong(byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Gets the little-endian long from 8 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian long\n     "
          }
        ],
        "hash32": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash32(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0x9747b28c",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates a 32-bit hash from byte array with the given length and a default seed value.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int seed = 0x9747b28c;\n     * int hash = MurmurHash2.hash32(data, length, seed);\n     * </pre>\n     *\n     * @param data The input byte array\n     * @param length The length of the array\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.getLittleEndianInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates a 32-bit hash from byte array with the given length and seed.\n     *\n     * @param data The input byte array\n     * @param length The length of the array\n     * @param seed The initial seed value\n     * @return The 32-bit hash\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash32(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static int hash32(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a 32-bit hash from a string with a default seed.\n     * <p>\n     * Before 1.14 the string was converted using default encoding.\n     * Since 1.14 the string is converted to bytes using UTF-8 encoding.\n     * </p>\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int seed = 0x9747b28c;\n     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash2.hash32(bytes, bytes.length, seed);\n     * </pre>\n     *\n     * @param text The input string\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash32(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text.substring(from, from + length)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "from",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "from + length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static int hash32(String, int, int)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "from",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates a 32-bit hash from a substring with a default seed value.\n     * The string is converted to bytes using the default encoding.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int seed = 0x9747b28c;\n     * byte[] bytes = text.substring(from, from + length).getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash2.hash32(bytes, bytes.length, seed);\n     * </pre>\n     *\n     * @param text The input string\n     * @param from The starting index\n     * @param length The length of the substring\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int)\n     "
          }
        ],
        "hash64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash64(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0xe17a1465",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates a 64-bit hash from byte array with given length and a default seed value.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int seed = 0xe17a1465;\n     * int hash = MurmurHash2.hash64(data, length, seed);\n     * </pre>\n     *\n     * @param data The input byte array\n     * @param length The length of the array\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.getLittleEndianLong(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates a 64-bit hash from byte array of the given length and seed.\n     *\n     * @param data The input byte array\n     * @param length The length of the array\n     * @param seed The initial seed value\n     * @return The 64-bit hash of the given array\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash64(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a 64-bit hash from a string with a default seed.\n     * <p>\n     * Before 1.14 the string was converted using default encoding.\n     * Since 1.14 the string is converted to bytes using UTF-8 encoding.\n     * </p>\n     * <p>\n     * This is a helper method that will produce the same result as:\n     * </p>\n     *\n     * <pre>\n     * int seed = 0xe17a1465;\n     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash2.hash64(bytes, bytes.length, seed);\n     * </pre>\n     *\n     * @param text The input string\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text.substring(from, from + length)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "from",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "from + length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static long hash64(String, int, int)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "from",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates a 64-bit hash from a substring with a default seed value.\n     * The string is converted to bytes using the default encoding.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int seed = 0xe17a1465;\n     * byte[] bytes = text.substring(from, from + length).getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash2.hash64(bytes, bytes.length, seed);\n     * </pre>\n     *\n     * @param text The input string\n     * @param from The starting index\n     * @param length The length of the substring\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int)\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Implementation of the MurmurHash2 32-bit and 64-bit hash functions.\n *\n * <p>MurmurHash is a non-cryptographic hash function suitable for general\n * hash-based lookup. The name comes from two basic operations, multiply (MU)\n * and rotate (R), used in its inner loop. Unlike cryptographic hash functions,\n * it is not specifically designed to be difficult to reverse by an adversary,\n * making it unsuitable for cryptographic purposes.</p>\n *\n * <p>This contains a Java port of the 32-bit hash function {@code MurmurHash2}\n * and the 64-bit hash function {@code MurmurHash64A} from Austin Appleby's\n * original {@code c++} code in SMHasher.</p>\n *\n * <p>This is a re-implementation of the original C code plus some additional\n * features.</p>\n *\n * <p>This is public domain code with no copyrights. From home page of\n * <a href=\"https://github.com/aappleby/smhasher\">SMHasher</a>:</p>\n *\n * <blockquote>\n * \"All MurmurHash versions are public domain software, and the author\n * disclaims all copyright to their code.\"\n * </blockquote>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/MurmurHash\">MurmurHash</a>\n * @see <a href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash2.cpp\">\n *   Original MurmurHash2 c++ code</a>\n * @since 1.13\n "
    },
    "org.apache.commons.codec.digest.MurmurHash3": {
      "fields": [
        {
          "variable_name": "NULL_HASHCODE",
          "variable_type": "long"
        },
        {
          "variable_name": "DEFAULT_SEED",
          "variable_type": "int"
        },
        {
          "variable_name": "C1_32",
          "variable_type": "int"
        },
        {
          "variable_name": "C2_32",
          "variable_type": "int"
        },
        {
          "variable_name": "R1_32",
          "variable_type": "int"
        },
        {
          "variable_name": "R2_32",
          "variable_type": "int"
        },
        {
          "variable_name": "M_32",
          "variable_type": "int"
        },
        {
          "variable_name": "N_32",
          "variable_type": "int"
        },
        {
          "variable_name": "C1",
          "variable_type": "long"
        },
        {
          "variable_name": "C2",
          "variable_type": "long"
        },
        {
          "variable_name": "R1",
          "variable_type": "int"
        },
        {
          "variable_name": "R2",
          "variable_type": "int"
        },
        {
          "variable_name": "R3",
          "variable_type": "int"
        },
        {
          "variable_name": "M",
          "variable_type": "int"
        },
        {
          "variable_name": "N1",
          "variable_type": "int"
        },
        {
          "variable_name": "N2",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "private MurmurHash3()\n{\r\n}",
          "signature": "MurmurHash3()",
          "parameters": [],
          "javadoc": " No instance methods. "
        }
      ],
      "methods": {
        "fmix32": [
          {
            "call_methods": [],
            "signature": "private static int fmix32(int)",
            "parameters": [
              {
                "variable_name": "hash",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Performs the final avalanche mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.\n     *\n     * @param hash The current hash\n     * @return The final hash\n     "
          }
        ],
        "fmix64": [
          {
            "call_methods": [],
            "signature": "private static long fmix64(long)",
            "parameters": [
              {
                "variable_name": "hash",
                "variable_type": "long"
              }
            ],
            "javadoc": "\n     * Performs the final avalanche mix step of the 64-bit hash function {@code MurmurHash3_x64_128}.\n     *\n     * @param hash The current hash\n     * @return The final hash\n     "
          }
        ],
        "getLittleEndianInt": [
          {
            "call_methods": [],
            "signature": "private static int getLittleEndianInt(byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Gets the little-endian int from 4 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian int\n     "
          }
        ],
        "getLittleEndianLong": [
          {
            "call_methods": [],
            "signature": "private static long getLittleEndianLong(byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Gets the little-endian long from 8 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian long\n     "
          }
        ],
        "hash128": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              }
            ],
            "signature": "public static long[] hash128(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates 128-bit hash from the byte array with a default seed.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * int hash = MurmurHash3.hash128(data, offset, data.length, seed);\n     * </pre>\n     *\n     * <p>Note: The sign extension bug in {@link #hash128(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * @param data The input byte array\n     * @return The 128-bit hash (2 longs)\n     * @see #hash128(byte[], int, int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[], int, int, long)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long[]"
              }
            ],
            "signature": "public static long[] hash128(byte[], int, int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 128-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * <p>This implementation contains a sign-extension bug in the seed initialization.\n     * This manifests if the seed is negative.</p>\n     *\n     * @param data The input byte array\n     * @param offset The first element of array\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 128-bit hash (2 longs)\n     * @deprecated Use {@link #hash128x64(byte[], int, int, int)}. This corrects the seed initialization.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static long[] hash128(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates 128-bit hash from a string with a default seed.\n     * <p>\n     * Before 1.14 the string was converted using default encoding.\n     * Since 1.14 the string is converted to bytes using UTF-8 encoding.\n     * </p>\n     * <p>\n     * This is a helper method that will produce the same result as:\n     * </p>\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash3.hash128(bytes, offset, bytes.length, seed);\n     * </pre>\n     *\n     * <p>Note: The sign extension bug in {@link #hash128(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * @param data The input String\n     * @return The 128-bit hash (2 longs)\n     * @see #hash128(byte[], int, int, int)\n     * @deprecated Use {@link #hash128x64(byte[])} using the bytes returned from\n     * {@link String#getBytes(java.nio.charset.Charset)}.\n     "
          }
        ],
        "hash128x64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              }
            ],
            "signature": "public static long[] hash128x64(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates 128-bit hash from the byte array with a seed of zero.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 0;\n     * int hash = MurmurHash3.hash128x64(data, offset, data.length, seed);\n     * </pre>\n     *\n     * @param data The input byte array\n     * @return The 128-bit hash (2 longs)\n     * @see #hash128x64(byte[], int, int, int)\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128x64Internal(byte[], int, int, long)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed & 0xffffffffL",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long[]"
              }
            ],
            "signature": "public static long[] hash128x64(byte[], int, int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 128-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @param data The input byte array\n     * @param offset The first element of array\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 128-bit hash (2 longs)\n     * @since 1.14\n     "
          }
        ],
        "hash128x64Internal": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix64(long)",
                "arguments": [
                  {
                    "variable_name": "h1",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Long.rotateLeft(long, int)",
                "arguments": [
                  {
                    "variable_name": "k1",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "R1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.getLittleEndianLong(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "private static long[] hash128x64Internal(byte[], int, int, long)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "long"
              }
            ],
            "javadoc": "\n     * Generates 128-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @param data The input byte array\n     * @param offset The first element of array\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 128-bit hash (2 longs)\n     "
          }
        ],
        "hash32": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from the byte array with a default seed.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * int hash = MurmurHash3.hash32(data, offset, data.length, seed);\n     * </pre>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @param data The input byte array\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int, int)\n     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(byte[], int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from the byte array with the given length and a default seed.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * int hash = MurmurHash3.hash32(data, offset, length, seed);\n     * </pre>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @param data The input byte array\n     * @param length The length of array\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int, int)\n     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from the byte array with the given length and seed. This is a\n     * helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int hash = MurmurHash3.hash32(data, offset, length, seed);\n     * </pre>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @param data The input byte array\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int, int)\n     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Integer.rotateLeft(int, int)",
                "arguments": [
                  {
                    "variable_name": "k1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "R1_32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.mix32(int, int)",
                "arguments": [
                  {
                    "variable_name": "k",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix32(int)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(byte[], int, int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @param data The input byte array\n     * @param offset The offset of data\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 32-bit hash\n     * @deprecated Use {@link #hash32x86(byte[], int, int, int)}. This corrects the processing of trailing bytes.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(long, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(long)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "long"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from a long with a default seed value.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(8)\n     *                                            .putLong(data)\n     *                                            .array(), offset, 8, seed);\n     * </pre>\n     *\n     * @param data The long to hash\n     * @return The 32-bit hash\n     * @see #hash32x86(byte[], int, int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.mix32(int, int)",
                "arguments": [
                  {
                    "variable_name": "(int) r0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix32(int)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.Long.reverseBytes(long)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static int hash32(long, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "long"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from a long with the given seed.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(8)\n     *                                            .putLong(data)\n     *                                            .array(), offset, 8, seed);\n     * </pre>\n     *\n     * @param data The long to hash\n     * @param seed The initial seed value\n     * @return The 32-bit hash\n     * @see #hash32x86(byte[], int, int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(long, long, int)",
                "arguments": [
                  {
                    "variable_name": "data1",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "data2",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32(long, long)",
            "parameters": [
              {
                "variable_name": "data1",
                "variable_type": "long"
              },
              {
                "variable_name": "data2",
                "variable_type": "long"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from two longs with a default seed value.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(16)\n     *                                            .putLong(data1)\n     *                                            .putLong(data2)\n     *                                            .array(), offset, 16, seed);\n     * </pre>\n     *\n     * @param data1 The first long to hash\n     * @param data2 The second long to hash\n     * @return The 32-bit hash\n     * @see #hash32x86(byte[], int, int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.mix32(int, int)",
                "arguments": [
                  {
                    "variable_name": "(int) r0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix32(int)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.Long.reverseBytes(long)",
                "arguments": [
                  {
                    "variable_name": "data1",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static int hash32(long, long, int)",
            "parameters": [
              {
                "variable_name": "data1",
                "variable_type": "long"
              },
              {
                "variable_name": "data2",
                "variable_type": "long"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from two longs with the given seed.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int hash = MurmurHash3.hash32x86(ByteBuffer.allocate(16)\n     *                                            .putLong(data1)\n     *                                            .putLong(data2)\n     *                                            .array(), offset, 16, seed);\n     * </pre>\n     *\n     * @param data1 The first long to hash\n     * @param data2 The second long to hash\n     * @param seed The initial seed value\n     * @return The 32-bit hash\n     * @see #hash32x86(byte[], int, int, int)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static int hash32(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from a string with a default seed.\n     * <p>\n     * Before 1.14 the string was converted using default encoding.\n     * Since 1.14 the string is converted to bytes using UTF-8 encoding.\n     * </p>\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash3.hash32(bytes, offset, bytes.length, seed);\n     * </pre>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @param data The input string\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int, int)\n     * @deprecated Use {@link #hash32x86(byte[], int, int, int)} with the bytes returned from\n     * {@link String#getBytes(java.nio.charset.Charset)}. This corrects the processing of trailing bytes.\n     "
          }
        ],
        "hash32x86": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32x86(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from the byte array with a seed of zero.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 0;\n     * int hash = MurmurHash3.hash32x86(data, offset, data.length, seed);\n     * </pre>\n     *\n     * @param data The input byte array\n     * @return The 32-bit hash\n     * @see #hash32x86(byte[], int, int, int)\n     * @since 1.14\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Integer.rotateLeft(int, int)",
                "arguments": [
                  {
                    "variable_name": "k1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "R1_32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.mix32(int, int)",
                "arguments": [
                  {
                    "variable_name": "k",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix32(int)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static int hash32x86(byte[], int, int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 32-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @param data The input byte array\n     * @param offset The offset of data\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 32-bit hash\n     * @since 1.14\n     "
          }
        ],
        "hash64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates 64-bit hash from a byte array with a default seed.\n     *\n     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>\n     *\n     * <p>This is a Murmur3-like 64-bit variant.\n     * The method does not produce the same result as either half of the hash bytes from\n     * {@linkplain #hash128x64(byte[])} with the same byte data.\n     * This method will be removed in a future release.</p>\n     *\n     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * <p>This is a helper method that will produce the same result as:</p>\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * long hash = MurmurHash3.hash64(data, offset, data.length, seed);\n     * </pre>\n     *\n     * @param data The input byte array\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int, int)\n     * @deprecated Not part of the MurmurHash3 implementation.\n     * Use half of the hash bytes from {@link #hash128x64(byte[])}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "DEFAULT_SEED",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 64-bit hash from a byte array with the given offset and length and a default seed.\n     *\n     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>\n     *\n     * <p>This is a Murmur3-like 64-bit variant.\n     * The method does not produce the same result as either half of the hash bytes from\n     * {@linkplain #hash128x64(byte[])} with the same byte data.\n     * This method will be removed in a future release.</p>\n     *\n     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * <p>This is a helper method that will produce the same result as:</p>\n     *\n     * <pre>\n     * int seed = 104729;\n     * long hash = MurmurHash3.hash64(data, offset, length, seed);\n     * </pre>\n     *\n     * @param data The input byte array\n     * @param offset The offset of data\n     * @param length The length of array\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int, int)\n     * @deprecated Not part of the MurmurHash3 implementation.\n     * Use half of the hash bytes from {@link #hash128x64(byte[], int, int, int)}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix64(long)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Long.rotateLeft(long, int)",
                "arguments": [
                  {
                    "variable_name": "k",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "R1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.getLittleEndianLong(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(byte[], int, int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 64-bit hash from a byte array with the given offset, length and seed.\n     *\n     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>\n     *\n     * <p>This is a Murmur3-like 64-bit variant.\n     * This method will be removed in a future release.</p>\n     *\n     * <p>This implementation contains a sign-extension bug in the seed initialization.\n     * This manifests if the seed is negative.</p>\n     *\n     * <p>This algorithm processes 8 bytes chunks of data in a manner similar to the 16 byte chunks\n     * of data processed in the MurmurHash3 {@code MurmurHash3_x64_128} method. However the hash\n     * is not mixed with a hash chunk from the next 8 bytes of data. The method will not return\n     * the same value as the first or second 64-bits of the function\n     * {@link #hash128(byte[], int, int, int)}.</p>\n     *\n     * <p>Use of this method is not advised. Use the first long returned from\n     * {@link #hash128x64(byte[], int, int, int)}.</p>\n     *\n     * @param data The input byte array\n     * @param offset The offset of data\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 64-bit hash\n     * @deprecated Not part of the MurmurHash3 implementation.\n     * Use half of the hash bytes from {@link #hash128x64(byte[], int, int, int)}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Integer.reverseBytes(int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix64(long)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Long.rotateLeft(long, int)",
                "arguments": [
                  {
                    "variable_name": "k1",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "R1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Generates 64-bit hash from an int with a default seed.\n     *\n     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>\n     *\n     * <p>This is a Murmur3-like 64-bit variant.\n     * The method does not produce the same result as either half of the hash bytes from\n     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code int}.\n     * This method will be removed in a future release.</p>\n     *\n     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * <p>This is a helper method that will produce the same result as:</p>\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(4)\n     *                                          .putInt(data)\n     *                                          .array(), offset, 4, seed);\n     * </pre>\n     *\n     * @param data The int to hash\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int, int)\n     * @deprecated Not part of the MurmurHash3 implementation.\n     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code int}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix64(long)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Long.rotateLeft(long, int)",
                "arguments": [
                  {
                    "variable_name": "k",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "R1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Long.reverseBytes(long)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(long)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "long"
              }
            ],
            "javadoc": "\n     * Generates 64-bit hash from a long with a default seed.\n     *\n     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>\n     *\n     * <p>This is a Murmur3-like 64-bit variant.\n     * The method does not produce the same result as either half of the hash bytes from\n     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code long}.\n     * This method will be removed in a future release.</p>\n     *\n     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * <p>This is a helper method that will produce the same result as:</p>\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(8)\n     *                                          .putLong(data)\n     *                                          .array(), offset, 8, seed);\n     * </pre>\n     *\n     * @param data The long to hash\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int, int)\n     * @deprecated Not part of the MurmurHash3 implementation.\n     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code long}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix64(long)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Long.rotateLeft(long, int)",
                "arguments": [
                  {
                    "variable_name": "k1",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "R1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public static long hash64(short)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "short"
              }
            ],
            "javadoc": "\n     * Generates 64-bit hash from a short with a default seed.\n     *\n     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>\n     *\n     * <p>This is a Murmur3-like 64-bit variant.\n     * The method does not produce the same result as either half of the hash bytes from\n     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code short}.\n     * This method will be removed in a future release.</p>\n     *\n     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * <p>This is a helper method that will produce the same result as:</p>\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(2)\n     *                                          .putShort(data)\n     *                                          .array(), offset, 2, seed);\n     * </pre>\n     *\n     * @param data The short to hash\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int, int)\n     * @deprecated Not part of the MurmurHash3 implementation.\n     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code short}.\n     "
          }
        ],
        "mix32": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Integer.rotateLeft(int, int)",
                "arguments": [
                  {
                    "variable_name": "k",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "R1_32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private static int mix32(int, int)",
            "parameters": [
              {
                "variable_name": "k",
                "variable_type": "int"
              },
              {
                "variable_name": "hash",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Performs the intermediate mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.\n     *\n     * @param k The data to add to the hash\n     * @param hash The current hash\n     * @return The new hash\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Implementation of the MurmurHash3 32-bit and 128-bit hash functions.\n *\n * <p>\n * MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic\n * operations, multiply (MU) and rotate (R), used in its inner loop. Unlike cryptographic hash functions, it is not\n * specifically designed to be difficult to reverse by an adversary, making it unsuitable for cryptographic purposes.\n * </p>\n *\n * <p>\n * This contains a Java port of the 32-bit hash function {@code MurmurHash3_x86_32} and the 128-bit hash function\n * {@code MurmurHash3_x64_128} from Austin Appleby's original {@code c++} code in SMHasher.\n * </p>\n *\n * <p>\n * This is public domain code with no copyrights. From home page of\n * <a href=\"https://github.com/aappleby/smhasher\">SMHasher</a>:\n * </p>\n *\n * <blockquote> \"All MurmurHash versions are public domain software, and the author disclaims all copyright to their\n * code.\" </blockquote>\n *\n * <p>\n * Original adaption from Apache Hive. That adaption contains a {@code hash64} method that is not part of the original\n * MurmurHash3 code. It is not recommended to use these methods. They will be removed in a future release. To obtain a\n * 64-bit hash use half of the bits from the {@code hash128x64} methods using the input data converted to bytes.\n * </p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/MurmurHash\">MurmurHash</a>\n * @see <a href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\"> Original MurmurHash3 c++\n *      code</a>\n * @see <a href=\n *      \"https://github.com/apache/hive/blob/master/storage-api/src/java/org/apache/hive/common/util/Murmur3.java\">\n *      Apache Hive Murmer3</a>\n * @since 1.13\n "
    },
    "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32": {
      "fields": [],
      "constructors": [],
      "methods": {
        "finalise": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Integer.rotateLeft(int, int)",
                "arguments": [
                  {
                    "variable_name": "k1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "R1_32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix32(int)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": " int finalise(int, int, byte[], int)",
            "parameters": [
              {
                "variable_name": "hash",
                "variable_type": "int"
              },
              {
                "variable_name": "unprocessedLength",
                "variable_type": "int"
              },
              {
                "variable_name": "unprocessed",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "totalLen",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n         * {@inheritDoc}\n         *\n         * <p>This implementation contains a sign-extension bug in the finalization step of\n         * any bytes left over from dividing the length by 4. This manifests if any of these\n         * bytes are negative.<p>\n         *\n         * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.\n         "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new\n     * hash computed.\n     *\n     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.\n     "
    },
    "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86": {
      "fields": [
        {
          "variable_name": "BLOCK_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "unprocessed",
          "variable_type": "byte"
        },
        {
          "variable_name": "unprocessedLength",
          "variable_type": "int"
        },
        {
          "variable_name": "totalLen",
          "variable_type": "int"
        },
        {
          "variable_name": "hash",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "orBytes": [
          {
            "call_methods": [],
            "signature": "private static int orBytes(byte, byte, byte, byte)",
            "parameters": [
              {
                "variable_name": "b1",
                "variable_type": "byte"
              },
              {
                "variable_name": "b2",
                "variable_type": "byte"
              },
              {
                "variable_name": "b3",
                "variable_type": "byte"
              },
              {
                "variable_name": "b4",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n         * Combines the bytes using an Or operation ({@code | } in a little-endian representation\n         * of a 32-bit integer; byte 1 will be the least significant byte, byte 4 the most\n         * significant.\n         *\n         * @param b1 The first byte\n         * @param b2 The second byte\n         * @param b3 The third byte\n         * @param b4 The fourth byte\n         * @return The 32-bit integer\n         "
          }
        ],
        "add": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "unprocessed",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "unprocessedLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.orBytes(byte, byte, byte, byte)",
                "arguments": [
                  {
                    "variable_name": "unprocessed[0]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "data[offset]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "data[offset + 1]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "data[offset + 2]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.mix32(int, int)",
                "arguments": [
                  {
                    "variable_name": "k",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.getLittleEndianInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public final void add(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n         * Adds the byte array to the current incremental hash.\n         *\n         * @param data The input byte array\n         * @param offset The offset of data\n         * @param length The length of array\n         "
          }
        ],
        "end": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.finalise(int, int, byte[], int)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "unprocessedLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "unprocessed",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "totalLen",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public final int end()",
            "parameters": [],
            "javadoc": "\n         * Generates the 32-bit hash value. Repeat calls to this method with no additional data\n         * will generate the same hash value.\n         *\n         * @return The 32-bit hash\n         "
          }
        ],
        "finalise": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Integer.rotateLeft(int, int)",
                "arguments": [
                  {
                    "variable_name": "k1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "R1_32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.fmix32(int)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": " int finalise(int, int, byte[], int)",
            "parameters": [
              {
                "variable_name": "hash",
                "variable_type": "int"
              },
              {
                "variable_name": "unprocessedLength",
                "variable_type": "int"
              },
              {
                "variable_name": "unprocessed",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "totalLen",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n         * Finalizes the running hash to the output 32-bit hash by processing remaining bytes\n         * and performing final mixing.\n         *\n         * @param hash The running hash\n         * @param unprocessedLength The number of unprocessed bytes in the tail data.\n         * @param unprocessed Up to 3 unprocessed bytes from input data.\n         * @param totalLen The total number of input bytes added since the start.\n         * @return The 32-bit hash\n         "
          }
        ],
        "start": [
          {
            "call_methods": [],
            "signature": "public final void start(int)",
            "parameters": [
              {
                "variable_name": "seed",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n         * Starts a new incremental hash.\n         *\n         * @param seed The initial seed value\n         "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new\n     * hash computed.\n     *\n     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @since 1.14\n     "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32": {
      "fields": [
        {
          "variable_name": "T",
          "variable_type": "int"
        },
        {
          "variable_name": "crc",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public PureJavaCrc32()\n{\r\n    resetCrc();\r\n}",
          "signature": "PureJavaCrc32()",
          "parameters": [],
          "javadoc": " Create a new PureJavaCrc32 object. "
        }
      ],
      "methods": {
        "getValue": [
          {
            "call_methods": [],
            "signature": "public long getValue()",
            "parameters": []
          }
        ],
        "reset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32.resetCrc()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void reset()",
            "parameters": []
          }
        ],
        "resetCrc": [
          {
            "call_methods": [],
            "signature": "private void resetCrc()",
            "parameters": []
          }
        ],
        "update": [
          {
            "call_methods": [],
            "signature": "public void update(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "len",
                "variable_type": "int"
              }
            ]
          },
          {
            "call_methods": [],
            "signature": "public final void update(int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * A pure-Java implementation of the CRC32 checksum that uses\n * the same polynomial as the built-in native CRC32.\n * <p>\n * This is to avoid the JNI overhead for certain uses of checksumming\n * where many small pieces of data are checksummed in succession.\n * </p>\n * <p>\n * The current version is ~10x to 1.8x as fast as Sun's native\n * java.util.zip.CRC32 in Java 1.6\n * </p>\n * <p>\n * Copied from Apache Hadoop 2.6.3.\n * The code agrees with the following file in the 2.6.3 tag:\n * https://gitbox.apache.org/repos/asf?p=hadoop.git;a=blob_plain;\n * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32.java;\n * hb=2120de588b92b9f22b1cc4188761d6a8c61aa778\n * </p>\n * <p>\n * This class is Not ThreadSafe\n * </p>\n *\n * @see java.util.zip.CRC32\n * @since 1.11\n "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32C": {
      "fields": [
        {
          "variable_name": "T8_0_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T8_1_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T8_2_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T8_3_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T8_4_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T8_5_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T8_6_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T8_7_START",
          "variable_type": "int"
        },
        {
          "variable_name": "T",
          "variable_type": "int"
        },
        {
          "variable_name": "crc",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public PureJavaCrc32C()\n{\r\n    reset();\r\n}",
          "signature": "PureJavaCrc32C()",
          "parameters": [],
          "javadoc": " Create a new PureJavaCrc32 object. "
        }
      ],
      "methods": {
        "getValue": [
          {
            "call_methods": [],
            "signature": "public long getValue()",
            "parameters": []
          }
        ],
        "reset": [
          {
            "call_methods": [],
            "signature": "public void reset()",
            "parameters": []
          }
        ],
        "update": [
          {
            "call_methods": [],
            "signature": "public void update(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "off",
                "variable_type": "int"
              },
              {
                "variable_name": "len",
                "variable_type": "int"
              }
            ]
          },
          {
            "call_methods": [],
            "signature": "public final void update(int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * A pure-Java implementation of the CRC32 checksum that uses the CRC32-C polynomial, the same polynomial used by iSCSI and implemented on many Intel chipsets\n * supporting SSE 4.2.\n *\n * <p>\n * Copied from Apache Hadoop 2.3.6: https://gitbox.apache.org/repos/asf?p=hadoop.git;a=blob_plain;\n * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32C.java; hb=2120de588b92b9f22b1cc4188761d6a8c61aa778\n * </p>\n * <p>\n * This class is Not ThreadSafe\n * </p>\n *\n * @since 1.11\n "
    },
    "org.apache.commons.codec.digest.Sha2Crypt": {
      "fields": [
        {
          "variable_name": "ROUNDS_DEFAULT",
          "variable_type": "int"
        },
        {
          "variable_name": "ROUNDS_MAX",
          "variable_type": "int"
        },
        {
          "variable_name": "ROUNDS_MIN",
          "variable_type": "int"
        },
        {
          "variable_name": "ROUNDS_PREFIX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA256_BLOCKSIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "SHA256_PREFIX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SHA512_BLOCKSIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "SHA512_PREFIX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SALT_PATTERN",
          "variable_type": "java.util.regex.Pattern"
        }
      ],
      "constructors": [],
      "methods": {
        "sha256Crypt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha256Crypt(byte[])",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates a libc crypt() compatible \"$5$\" hash value with random salt.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @return complete hash value\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[], java.lang.String, java.lang.String, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA256_PREFIX",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA256_BLOCKSIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_256",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha256Crypt(byte[], String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() compatible \"$5$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a salt\n     *            is generated for you using {@link SecureRandom}. If one does not want to use {@link SecureRandom},\n     *            you can pass your own {@link Random} in {@link #sha256Crypt(byte[], String, Random)}.\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "random",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[], java.lang.String, java.lang.String, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA256_PREFIX",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA256_BLOCKSIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_256",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha256Crypt(byte[], String, Random)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "random",
                "variable_type": "java.util.Random"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() compatible \"$5$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\".\n     * @param random\n     *            the instance of {@link Random} to use for generating the salt.\n     *            Consider using {@link SecureRandom} for more secure salts.\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @since 1.12\n     "
          }
        ],
        "sha2Crypt": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.util.regex.Pattern.matcher(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.regex.Matcher"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "tempResult",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.regex.Matcher.group(int)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ROUNDS_PREFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "ROUNDS_MAX",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "rounds",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "tempResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "pBytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "cp",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "blocksize",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.StringBuilder.append(int)",
                "arguments": [
                  {
                    "variable_name": "rounds",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.util.regex.Matcher.find()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.B64.b64from24bit(byte, byte, byte, int, java.lang.StringBuilder)",
                "arguments": [
                  {
                    "variable_name": "altResult[0]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "altResult[10]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "altResult[20]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.lang.StringBuilder"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "altResult",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "blocksize",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Math.max(int, int)",
                "arguments": [
                  {
                    "variable_name": "ROUNDS_MIN",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "Math.min(ROUNDS_MAX, rounds)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.Integer.parseInt(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "m.group(3)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.security.MessageDigest.reset()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "private static String sha2Crypt(byte[], String, String, int, String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "saltPrefix",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "blocksize",
                "variable_type": "int"
              },
              {
                "variable_name": "algorithm",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() compatible \"$5$\" or \"$6$\" SHA2 based hash value.\n     * <p>\n     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\n     * description, the short C-style ones from the original C code and the ones with \"Remark\" from me.\n     * </p>\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"; may not be null\n     * @param saltPrefix\n     *            either $5$ or $6$\n     * @param blocksize\n     *            a value that differs between $5$ and $6$\n     * @param algorithm\n     *            {@link MessageDigest} algorithm identifier string\n     * @return complete hash value including prefix and salt\n     * @throws IllegalArgumentException\n     *             if the given salt is {@code null} or does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught\n     * @see MessageDigestAlgorithms\n     "
          }
        ],
        "sha512Crypt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512Crypt(byte[])",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates a libc crypt() compatible \"$6$\" hash value with random salt.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @return complete hash value\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[], java.lang.String, java.lang.String, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA512_PREFIX",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA512_BLOCKSIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_512",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512Crypt(byte[], String)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() compatible \"$6$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a salt is generated\n     *            for you using {@link SecureRandom}; if you want to use a {@link Random} object other than\n     *            {@link SecureRandom} then we suggest you provide it using\n     *            {@link #sha512Crypt(byte[], String, Random)}.\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.getRandomSalt(int, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "random",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha2Crypt(byte[], java.lang.String, java.lang.String, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA512_PREFIX",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SHA512_BLOCKSIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MessageDigestAlgorithms.SHA_512",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String sha512Crypt(byte[], String, Random)",
            "parameters": [
              {
                "variable_name": "keyBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "random",
                "variable_type": "java.util.Random"
              }
            ],
            "javadoc": "\n     * Generates a libc6 crypt() compatible \"$6$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a salt\n     *            is generated for you using {@link SecureRandom}.\n     * @param random\n     *            the instance of {@link Random} to use for generating the salt.\n     *            Consider using {@link SecureRandom} for more secure salts.\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @since 1.12\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * SHA2-based UNIX crypt implementation.\n * <p>\n * Based on the C implementation released into the Public Domain by Ulrich Drepper &lt;drepper@redhat.com&gt;\n * http://www.akkadia.org/drepper/SHA-crypt.txt\n * </p>\n * <p>\n * Conversion to Kotlin and from there to Java in 2012 by Christian Hammers &lt;ch@lathspell.de&gt; and likewise put\n * into the Public Domain.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n "
    },
    "org.apache.commons.codec.digest.UnixCrypt": {
      "fields": [
        {
          "variable_name": "CRYPT_SALT_REGEX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "CRYPT_SALT_PATTERN",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "CON_SALT",
          "variable_type": "int"
        },
        {
          "variable_name": "COV2CHAR",
          "variable_type": "int"
        },
        {
          "variable_name": "SALT_CHARS",
          "variable_type": "char"
        },
        {
          "variable_name": "SHIFT2",
          "variable_type": "boolean"
        },
        {
          "variable_name": "SKB",
          "variable_type": "int"
        },
        {
          "variable_name": "SPTRANS",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public UnixCrypt()\n{\r\n    // empty\r\n}",
          "signature": "UnixCrypt()",
          "parameters": [],
          "javadoc": "\n     * TODO Make private in 2.0.\n     *\n     * @deprecated TODO Make private in 2.0.\n     "
        }
      ],
      "methods": {
        "body": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.dEncrypt(int, int, int, int, int, int[])",
                "arguments": [
                  {
                    "variable_name": "left",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "right",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "eSwap0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "eSwap1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "schedule",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.permOp(int, int, int, int, int[])",
                "arguments": [
                  {
                    "variable_name": "right",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "left",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0x55555555",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "results",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static int[] body(int[], int, int)",
            "parameters": [
              {
                "variable_name": "schedule",
                "variable_type": "int[]"
              },
              {
                "variable_name": "eSwap0",
                "variable_type": "int"
              },
              {
                "variable_name": "eSwap1",
                "variable_type": "int"
              }
            ]
          }
        ],
        "byteToUnsigned": [
          {
            "call_methods": [],
            "signature": "private static int byteToUnsigned(byte)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte"
              }
            ]
          }
        ],
        "crypt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "original",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String crypt(byte[])",
            "parameters": [
              {
                "variable_name": "original",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}.\n     * </p>\n     *\n     * @param original\n     *            plaintext password\n     * @return a 13 character string starting with the salt string\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.util.regex.Pattern.matcher(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.regex.Matcher"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.desSetKey(byte[])",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.regex.Matcher.matches()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Random.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "numSaltChars",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.intToFourBytes(int, byte[], int)",
                "arguments": [
                  {
                    "variable_name": "out[0]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.body(int[], int, int)",
                "arguments": [
                  {
                    "variable_name": "schedule",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "eSwap0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "eSwap1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.setCharAt(int, char)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "charZero",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static String crypt(byte[], String)",
            "parameters": [
              {
                "variable_name": "original",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     * <p>\n     * Using unspecified characters as salt results incompatible hash values.\n     * </p>\n     *\n     * @param original\n     *            plaintext password\n     * @param salt\n     *            a two character string drawn from [a-zA-Z0-9./]. The salt may be null, in which case a salt is\n     *            generated for you using {@link SecureRandom}.\n     * @return a 13 character string starting with the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "original.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static String crypt(String)",
            "parameters": [
              {
                "variable_name": "original",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     * <p>\n     * A salt is generated for you using {@link SecureRandom}.\n     * </p>\n     *\n     * @param original\n     *            plaintext password\n     * @return a 13 character string starting with the salt string\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "original.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "salt",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static String crypt(String, String)",
            "parameters": [
              {
                "variable_name": "original",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "salt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Generates a crypt(3) compatible hash using the DES algorithm.\n     *\n     * @param original\n     *            plaintext password\n     * @param salt\n     *            a two character string drawn from [a-zA-Z0-9./]. The salt may be null, in which case a salt is\n     *            generated for you using {@link SecureRandom}.\n     * @return a 13 character string starting with the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     "
          }
        ],
        "dEncrypt": [
          {
            "call_methods": [],
            "signature": "private static int dEncrypt(int, int, int, int, int, int[])",
            "parameters": [
              {
                "variable_name": "el",
                "variable_type": "int"
              },
              {
                "variable_name": "r",
                "variable_type": "int"
              },
              {
                "variable_name": "s",
                "variable_type": "int"
              },
              {
                "variable_name": "e0",
                "variable_type": "int"
              },
              {
                "variable_name": "e1",
                "variable_type": "int"
              },
              {
                "variable_name": "sArr",
                "variable_type": "int[]"
              }
            ]
          }
        ],
        "desSetKey": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.fourBytesToInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.hPermOp(int, int, int)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "-2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0xcccc0000",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.permOp(int, int, int, int, int[])",
                "arguments": [
                  {
                    "variable_name": "d",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0xf0f0f0f",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "results",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static int[] desSetKey(byte[])",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "fourBytesToInt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.byteToUnsigned(byte)",
                "arguments": [
                  {
                    "variable_name": "b[offset++]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private static int fourBytesToInt(byte[], int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              }
            ]
          }
        ],
        "hPermOp": [
          {
            "call_methods": [],
            "signature": "private static int hPermOp(int, int, int)",
            "parameters": [
              {
                "variable_name": "a",
                "variable_type": "int"
              },
              {
                "variable_name": "n",
                "variable_type": "int"
              },
              {
                "variable_name": "m",
                "variable_type": "int"
              }
            ]
          }
        ],
        "intToFourBytes": [
          {
            "call_methods": [],
            "signature": "private static void intToFourBytes(int, byte[], int)",
            "parameters": [
              {
                "variable_name": "iValue",
                "variable_type": "int"
              },
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              }
            ]
          }
        ],
        "permOp": [
          {
            "call_methods": [],
            "signature": "private static void permOp(int, int, int, int, int[])",
            "parameters": [
              {
                "variable_name": "a",
                "variable_type": "int"
              },
              {
                "variable_name": "b",
                "variable_type": "int"
              },
              {
                "variable_name": "n",
                "variable_type": "int"
              },
              {
                "variable_name": "m",
                "variable_type": "int"
              },
              {
                "variable_name": "results",
                "variable_type": "int[]"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * UNIX crypt(3) algorithm implementation.\n * <p>\n * This class only implements the traditional 56 bit DES based algorithm. Please use DigestUtils.crypt() for a method\n * that distinguishes between all the algorithms supported in the current glibc's crypt().\n * </p>\n * <p>\n * The Java implementation was taken from the JetSpeed Portal project (see\n * org.apache.jetspeed.services.security.ldap.UnixCrypt).\n * </p>\n * <p>\n * This class is slightly incompatible if the given salt contains characters that are not part of the allowed range\n * [a-zA-Z0-9./].\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n "
    },
    "org.apache.commons.codec.digest.XXHash32": {
      "fields": [
        {
          "variable_name": "BUF_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "ROTATE_BITS",
          "variable_type": "int"
        },
        {
          "variable_name": "PRIME1",
          "variable_type": "int"
        },
        {
          "variable_name": "PRIME2",
          "variable_type": "int"
        },
        {
          "variable_name": "PRIME3",
          "variable_type": "int"
        },
        {
          "variable_name": "PRIME4",
          "variable_type": "int"
        },
        {
          "variable_name": "PRIME5",
          "variable_type": "int"
        },
        {
          "variable_name": "oneByte",
          "variable_type": "byte"
        },
        {
          "variable_name": "state",
          "variable_type": "int"
        },
        {
          "variable_name": "buffer",
          "variable_type": "byte"
        },
        {
          "variable_name": "seed",
          "variable_type": "int"
        },
        {
          "variable_name": "totalLen",
          "variable_type": "int"
        },
        {
          "variable_name": "pos",
          "variable_type": "int"
        },
        {
          "variable_name": "stateUpdated",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public XXHash32()\n{\r\n    this(0);\r\n}",
          "signature": "XXHash32()",
          "parameters": [],
          "javadoc": "\n     * Creates an XXHash32 instance with a seed of 0.\n     "
        },
        {
          "body": "public XXHash32(final int seed)\n{\r\n    this.seed = seed;\r\n    initializeState();\r\n}",
          "signature": "XXHash32(int)",
          "parameters": [
            {
              "variable_name": "seed",
              "variable_type": "int"
            }
          ],
          "javadoc": "\n     * Creates an XXHash32 instance.\n     * @param seed the seed to use\n     "
        }
      ],
      "methods": {
        "getInt": [
          {
            "call_methods": [],
            "signature": "private static int getInt(byte[], int)",
            "parameters": [
              {
                "variable_name": "buffer",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "idx",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Gets the little-endian int from 4 bytes starting at the specified index.\n     *\n     * @param buffer The data\n     * @param idx The index\n     * @return The little-endian int\n     "
          }
        ],
        "getValue": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.getInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "idx",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.Integer.rotateLeft(int, int)",
                "arguments": [
                  {
                    "variable_name": "state[0]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public long getValue()",
            "parameters": []
          }
        ],
        "initializeState": [
          {
            "call_methods": [],
            "signature": "private void initializeState()",
            "parameters": []
          }
        ],
        "process": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.getInt(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.Integer.rotateLeft(int, int)",
                "arguments": [
                  {
                    "variable_name": "s0 + getInt(b, offset) * PRIME2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "ROTATE_BITS",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private void process(byte[], int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              }
            ]
          }
        ],
        "reset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.initializeState()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void reset()",
            "parameters": []
          }
        ],
        "update": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "off",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "pos",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "len",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.process(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void update(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "off",
                "variable_type": "int"
              },
              {
                "variable_name": "len",
                "variable_type": "int"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "oneByte",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void update(int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Implementation of the xxHash32 hash algorithm.\n *\n * <p>\n * Copied from Commons Compress 1.14 <a href=\n * \"https://gitbox.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD\">https://gitbox.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD</a>\n * </p>\n * <p>\n * NotThreadSafe\n * </p>\n *\n * @see <a href=\"https://cyan4973.github.io/xxHash/\">xxHash</a>\n * @since 1.11\n "
    },
    "org.apache.commons.codec.Encoder": {
      "fields": [],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [],
            "signature": " abstract Object encode(Object)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an \"Object\" and returns the encoded content as an Object. The Objects here may just be\n     * {@code byte[]} or {@code String}s depending on the implementation used.\n     *\n     * @param source\n     *            An object to encode\n     * @return An \"encoded\" Object\n     * @throws EncoderException\n     *             An encoder exception is thrown if the encoder experiences a failure condition during the encoding\n     *             process.\n     "
          }
        ]
      },
      "is_interface": true,
      "javadoc": "\n * Provides the highest level of abstraction for Encoders.\n * <p>\n * This is the sister interface of {@link Decoder}.  Every implementation of Encoder provides this\n * common generic interface which allows a user to pass a generic Object to any Encoder implementation\n * in the codec package.\n * </p>\n "
    },
    "org.apache.commons.codec.EncoderException": {
      "fields": [
        {
          "variable_name": "serialVersionUID",
          "variable_type": "long"
        }
      ],
      "constructors": [
        {
          "body": "public EncoderException()\n{\r\n}",
          "signature": "EncoderException()",
          "parameters": [],
          "javadoc": "\n     * Constructs a new exception with {@code null} as its detail message. The cause is not initialized, and may\n     * subsequently be initialized by a call to {@link #initCause}.\n     *\n     * @since 1.4\n     "
        },
        {
          "body": "public EncoderException(final String message)\n{\r\n    super(message);\r\n}",
          "signature": "EncoderException(String)",
          "parameters": [
            {
              "variable_name": "message",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\n     * be initialized by a call to {@link #initCause}.\n     *\n     * @param message\n     *            a useful message relating to the encoder specific error.\n     "
        },
        {
          "body": "public EncoderException(final String message, final Throwable cause)\n{\r\n    super(message, cause);\r\n}",
          "signature": "EncoderException(String, Throwable)",
          "parameters": [
            {
              "variable_name": "message",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "cause",
              "variable_type": "java.lang.Throwable"
            }
          ],
          "javadoc": "\n     * Constructs a new exception with the specified detail message and cause.\n     *\n     * <p>\n     * Note that the detail message associated with {@code cause} is not automatically incorporated into this\n     * exception's detail message.\n     * </p>\n     *\n     * @param message\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     "
        },
        {
          "body": "public EncoderException(final Throwable cause)\n{\r\n    super(cause);\r\n}",
          "signature": "EncoderException(Throwable)",
          "parameters": [
            {
              "variable_name": "cause",
              "variable_type": "java.lang.Throwable"
            }
          ],
          "javadoc": "\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\n     * null : cause.toString())</code> (which typically contains the class and detail message of {@code cause}).\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\n     *\n     * @param cause\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A {@code null}\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\n     * @since 1.4\n     "
        }
      ],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Thrown when there is a failure condition during the encoding process. This exception is thrown when an\n * {@link Encoder} encounters an encoding specific exception such as invalid data, inability to calculate a checksum,\n * characters outside of the expected range.\n "
    },
    "org.apache.commons.codec.language.AbstractCaverphone": {
      "fields": [],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type {@link String}.\n     *\n     * @param source\n     *            Object to encode\n     * @return An object (or type {@link String}) containing the caverphone code which corresponds to the String\n     *         supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type {@link String}.\n     "
          }
        ],
        "isEncodeEqual": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.encode(str2)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isEncodeEqual(String, String)",
            "parameters": [
              {
                "variable_name": "str1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "str2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Tests if the encodings of two strings are equal.\n     *\n     * This method might be promoted to a new AbstractStringEncoder superclass.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return {@code true} if the encodings of these strings are identical, {@code false} otherwise.\n     * @throws EncoderException\n     *             thrown if there is an error condition during the encoding process.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Caverphone value.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @since 1.5\n "
    },
    "org.apache.commons.codec.language.bm.BeiderMorseEncoder": {
      "fields": [
        {
          "variable_name": "engine",
          "variable_type": "org.apache.commons.codec.language.bm.PhoneticEngine"
        }
      ],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.Object"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getNameType": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getNameType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.NameType"
              }
            ],
            "signature": "public NameType getNameType()",
            "parameters": [],
            "javadoc": "\n     * Gets the name type currently in operation.\n     *\n     * @return the NameType currently being used\n     "
          }
        ],
        "getRuleType": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getRuleType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.RuleType"
              }
            ],
            "signature": "public RuleType getRuleType()",
            "parameters": [],
            "javadoc": "\n     * Gets the rule type currently in operation.\n     *\n     * @return the RuleType currently being used\n     "
          }
        ],
        "isConcat": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.isConcat()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isConcat()",
            "parameters": [],
            "javadoc": "\n     * Discovers if multiple possible encodings are concatenated.\n     *\n     * @return true if multiple encodings are concatenated, false if just the first one is returned\n     "
          }
        ],
        "setConcat": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getRuleType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getNameType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getMaxPhonemes()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void setConcat(boolean)",
            "parameters": [
              {
                "variable_name": "concat",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Sets how multiple possible phonetic encodings are combined.\n     *\n     * @param concat\n     *            true if multiple encodings are to be combined with a '|', false if just the first one is\n     *            to be considered\n     "
          }
        ],
        "setMaxPhonemes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getRuleType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.isConcat()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getNameType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.NameType"
              }
            ],
            "signature": "public void setMaxPhonemes(int)",
            "parameters": [
              {
                "variable_name": "maxPhonemes",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Sets the number of maximum of phonemes that shall be considered by the engine.\n     *\n     * @param maxPhonemes\n     *            the maximum number of phonemes returned by the engine\n     * @since 1.7\n     "
          }
        ],
        "setNameType": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getRuleType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.isConcat()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getMaxPhonemes()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void setNameType(NameType)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              }
            ],
            "javadoc": "\n     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\n     * optimized for Ashkenazi or Sephardic Jewish family names.\n     *\n     * @param nameType\n     *            the NameType in use\n     "
          }
        ],
        "setRuleType": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.isConcat()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getNameType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.getMaxPhonemes()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void setRuleType(RuleType)",
            "parameters": [
              {
                "variable_name": "ruleType",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              }
            ],
            "javadoc": "\n     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n     *\n     * @param ruleType\n     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes strings into their Beider-Morse phonetic encoding.\n * <p>\n * Beider-Morse phonetic encodings are optimized for family names. However, they may be useful for a wide range of\n * words.\n * </p>\n * <p>\n * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable,\n * and may not be thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine}\n * directly.\n * </p>\n * <h2>Encoding overview</h2>\n * <p>\n * Beider-Morse phonetic encodings is a multi-step process. Firstly, a table of rules is consulted to guess what\n * language the word comes from. For example, if it ends in \"{@code ault}\" then it infers that the word is French.\n * Next, the word is translated into a phonetic representation using a language-specific phonetics table. Some runs of\n * letters can be pronounced in multiple ways, and a single run of letters may be potentially broken up into phonemes at\n * different places, so this stage results in a set of possible language-specific phonetic representations. Lastly, this\n * language-specific phonetic representation is processed by a table of rules that re-writes it phonetically taking into\n * account systematic pronunciation differences between languages, to move it towards a pan-indo-european phonetic\n * representation. Again, sometimes there are multiple ways this could be done and sometimes things that can be\n * pronounced in several ways in the source language have only one way to represent them in this average phonetic\n * language, so the result is again a set of phonetic spellings.\n * </p>\n * <p>\n * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated. In\n * this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final encoding.\n * Secondly, some names have standard prefixes, for example, \"{@code Mac/Mc}\" in Scottish (English) names. As\n * sometimes it is ambiguous whether the prefix is intended or is an accident of the spelling, the word is encoded once\n * with the prefix and once without it. The resulting encoding contains one and then the other result.\n * </p>\n * <h2>Encoding format</h2>\n * <p>\n * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where there\n * are multiple possible phonetic representations, these are joined with a pipe ({@code |}) character. If multiple\n * hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed in ellipses and\n * these blocks are then joined with hyphens. For example, \"{@code d'ortley}\" has a possible prefix. The form\n * without prefix encodes to \"{@code ortlaj|ortlej}\", while the form with prefix encodes to \"\n * {@code dortlaj|dortlej}\". Thus, the full, combined encoding is \"{@code (ortlaj|ortlej)-(dortlaj|dortlej)}\".\n * </p>\n * <p>\n * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many\n * potential phonetic interpretations. For example, \"{@code Renault}\" encodes to \"\n * {@code rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult}\". The {@code APPROX} rules will tend to produce larger\n * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.\n * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by\n * splitting on pipe ({@code |}) and indexing under each of these alternatives.\n * </p>\n * <p>\n * <b>Note</b>: this version of the Beider-Morse encoding is equivalent with v3.4 of the reference implementation.\n * </p>\n * @see <a href=\"https://stevemorse.org/phonetics/bmpm.htm\">Beider-Morse Phonetic Matching</a>\n * @see <a href=\"https://stevemorse.org/phoneticinfo.htm\">Reference implementation</a>\n *\n * <p>\n * This class is Not ThreadSafe\n * </p>\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.Lang": {
      "fields": [
        {
          "variable_name": "LANGS",
          "variable_type": "java.util.Map<org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.Lang>"
        },
        {
          "variable_name": "LANGUAGE_RULES_RN",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "languages",
          "variable_type": "org.apache.commons.codec.language.bm.Languages"
        },
        {
          "variable_name": "rules",
          "variable_type": "java.util.List<org.apache.commons.codec.language.bm.Lang.LangRule>"
        }
      ],
      "constructors": [
        {
          "body": "private Lang(final List<LangRule> rules, final Languages languages)\n{\r\n    this.rules = Collections.unmodifiableList(rules);\r\n    this.languages = languages;\r\n}",
          "signature": "Lang(List, Languages)",
          "parameters": [
            {
              "variable_name": "rules",
              "variable_type": "java.util.List<org.apache.commons.codec.language.bm.Lang.LangRule>"
            },
            {
              "variable_name": "languages",
              "variable_type": "org.apache.commons.codec.language.bm.Languages"
            }
          ]
        }
      ],
      "methods": {
        "instance": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "nameType",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public static Lang instance(NameType)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              }
            ],
            "javadoc": "\n     * Gets a Lang instance for one of the supported NameTypes.\n     *\n     * @param nameType\n     *            the NameType to look up\n     * @return a Lang encapsulating the language guessing rules for that name type\n     "
          }
        ],
        "loadFromResource": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\\\s+\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.EXT_CMT_START",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.nextLine()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept)",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.EXT_CMT_END",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.regex.Pattern.compile(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "parts[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.regex.Pattern"
              },
              {
                "signature": "java.lang.String.trim()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.Resources.getInputStream(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "languageRulesResourceName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.io.InputStream"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "langs",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "cmtI",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"true\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.indexOf(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.CMT",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.hasNextLine()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public static Lang loadFromResource(String, Languages)",
            "parameters": [
              {
                "variable_name": "languageRulesResourceName",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "languages",
                "variable_type": "org.apache.commons.codec.language.bm.Languages"
              }
            ],
            "javadoc": "\n     * Loads language rules from a resource.\n     * <p>\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n     * You will only need to call this yourself if you are developing custom language mapping rules.\n     * </p>\n     *\n     * @param languageRulesResourceName\n     *            the fully-qualified resource name to load\n     * @param languages\n     *            the languages that these rules will support\n     * @return a Lang encapsulating the loaded language-guessing rules.\n     "
          }
        ],
        "guessLanguage": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.isSingleton()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.getAny()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Lang.guessLanguages(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "signature": "public String guessLanguage(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Guesses the language of a word.\n     *\n     * @param text\n     *            the word\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\n     "
          }
        ],
        "guessLanguages": [
          {
            "call_methods": [
              {
                "signature": "java.util.Set.removeAll(java.util.Collection<?>)",
                "arguments": [
                  {
                    "variable_name": "rule.languages",
                    "variable_type": "java.util.Collection<?>"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Set.retainAll(java.util.Collection<?>)",
                "arguments": [
                  {
                    "variable_name": "rule.languages",
                    "variable_type": "java.util.Collection<?>"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Object.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Languages.NO_LANGUAGES",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)",
                "arguments": [
                  {
                    "variable_name": "rule -> {\r\n    if (rule.matches(text)) {\r\n        if (rule.acceptOnMatch) {\r\n            langs.retainAll(rule.languages);\r\n        } else {\r\n            langs.removeAll(rule.languages);\r\n        }\r\n    }\r\n}",
                    "variable_type": "java.util.function.Consumer<? super T>"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Lang.LangRule.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.getLanguages()",
                "arguments": [],
                "return_type": "java.util.Set<java.lang.String>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.from(java.util.Set<java.lang.String>)",
                "arguments": [
                  {
                    "variable_name": "langs",
                    "variable_type": "java.util.Set<java.lang.String>"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "java.lang.String.toLowerCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Languages.LanguageSet guessLanguages(String)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Language guessing utility.\n * <p>\n * This class encapsulates rules used to guess the possible languages that a word originates from. This is\n * done by reference to a whole series of rules distributed in resource files.\n * </p>\n * <p>\n * Instances of this class are typically managed through the static factory method instance().\n * Unless you are developing your own language guessing rules, you will not need to interact with this class directly.\n * </p>\n * <p>\n * This class is intended to be immutable and thread-safe.\n * </p>\n * <h2>Lang resources</h2>\n * <p>\n * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files.\n * They are systematically named following the pattern:\n * </p>\n * <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * </p>\n * <ul>\n * <li><b>Rules:</b> whitespace separated strings.\n * There should be 3 columns to each row, and these will be interpreted as:\n * <ol>\n * <li>pattern: a regular expression.</li>\n * <li>languages: a '+'-separated list of languages.</li>\n * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\n * discarded as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\n * This will skip all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n * <p>\n * Port of lang.php\n * </p>\n *\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.Lang.LangRule": {
      "fields": [
        {
          "variable_name": "acceptOnMatch",
          "variable_type": "boolean"
        },
        {
          "variable_name": "languages",
          "variable_type": "java.util.Set<java.lang.String>"
        },
        {
          "variable_name": "pattern",
          "variable_type": "java.util.regex.Pattern"
        }
      ],
      "constructors": [
        {
          "body": "private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch)\n{\r\n    this.pattern = pattern;\r\n    this.languages = languages;\r\n    this.acceptOnMatch = acceptOnMatch;\r\n}",
          "signature": "LangRule(Pattern, Set, boolean)",
          "parameters": [
            {
              "variable_name": "pattern",
              "variable_type": "java.util.regex.Pattern"
            },
            {
              "variable_name": "languages",
              "variable_type": "java.util.Set<java.lang.String>"
            },
            {
              "variable_name": "acceptOnMatch",
              "variable_type": "boolean"
            }
          ]
        }
      ],
      "methods": {
        "matches": [
          {
            "call_methods": [
              {
                "signature": "java.util.regex.Pattern.matcher(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "txt",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.regex.Matcher"
              },
              {
                "signature": "java.util.regex.Matcher.find()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean matches(String)",
            "parameters": [
              {
                "variable_name": "txt",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.language.bm.Languages": {
      "fields": [
        {
          "variable_name": "ANY",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "LANGUAGES",
          "variable_type": "java.util.Map<org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.Languages>"
        },
        {
          "variable_name": "NO_LANGUAGES",
          "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
        },
        {
          "variable_name": "ANY_LANGUAGE",
          "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
        },
        {
          "variable_name": "languages",
          "variable_type": "java.util.Set<java.lang.String>"
        }
      ],
      "constructors": [
        {
          "body": "private Languages(final Set<String> languages)\n{\r\n    this.languages = languages;\r\n}",
          "signature": "Languages(Set)",
          "parameters": [
            {
              "variable_name": "languages",
              "variable_type": "java.util.Set<java.lang.String>"
            }
          ]
        }
      ],
      "methods": {
        "getInstance": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "nameType",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public static Languages getInstance(NameType)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.trim()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.Resources.getInputStream(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "languagesResourceName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.io.InputStream"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.EXT_CMT_START",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.nextLine()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.EXT_CMT_END",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Set.add(E)",
                "arguments": [
                  {
                    "variable_name": "line",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.hasNextLine()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Collections.unmodifiableSet(java.util.Set<? extends T>)",
                "arguments": [
                  {
                    "variable_name": "ls",
                    "variable_type": "java.util.Set<? extends T>"
                  }
                ],
                "return_type": "java.util.Set<T>"
              }
            ],
            "signature": "public static Languages getInstance(String)",
            "parameters": [
              {
                "variable_name": "languagesResourceName",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "langResourceName": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"org/apache/commons/codec/language/bm/%s_languages.txt\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "nameType.getName()",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.NameType.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private static String langResourceName(NameType)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              }
            ]
          }
        ],
        "getLanguages": [
          {
            "call_methods": [],
            "signature": "public Set<String> getLanguages()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Language codes.\n * <p>\n * Language codes are typically loaded from resource files. These are UTF-8\n * encoded text files. They are systematically named following the pattern:\n * </p>\n * <blockquote>org/apache/commons/codec/language/bm/${{@link NameType#getName()}\n * languages.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * </p>\n * <ul>\n * <li><b>Language:</b> a single string containing no whitespace</li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text\n * following on that line to be discarded as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start\n * multi-line commenting mode. This will skip all content until a line ending in\n * '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n * <p>\n * Ported from language.php\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.Languages.LanguageSet": {
      "fields": [],
      "constructors": [],
      "methods": {
        "from": [
          {
            "call_methods": [
              {
                "signature": "java.util.Set.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public static LanguageSet from(Set<String>)",
            "parameters": [
              {
                "variable_name": "langs",
                "variable_type": "java.util.Set<java.lang.String>"
              }
            ]
          }
        ],
        "contains": [
          {
            "call_methods": [],
            "signature": "public abstract boolean contains(String)",
            "parameters": [
              {
                "variable_name": "language",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getAny": [
          {
            "call_methods": [],
            "signature": "public abstract String getAny()",
            "parameters": []
          }
        ],
        "isEmpty": [
          {
            "call_methods": [],
            "signature": "public abstract boolean isEmpty()",
            "parameters": []
          }
        ],
        "isSingleton": [
          {
            "call_methods": [],
            "signature": "public abstract boolean isSingleton()",
            "parameters": []
          }
        ],
        "merge": [
          {
            "call_methods": [],
            "signature": " abstract LanguageSet merge(LanguageSet)",
            "parameters": [
              {
                "variable_name": "other",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ]
          }
        ],
        "restrictTo": [
          {
            "call_methods": [],
            "signature": "public abstract LanguageSet restrictTo(LanguageSet)",
            "parameters": [
              {
                "variable_name": "other",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * A set of languages.\n     "
    },
    "org.apache.commons.codec.language.bm.Languages.SomeLanguages": {
      "fields": [
        {
          "variable_name": "languages",
          "variable_type": "java.util.Set<java.lang.String>"
        }
      ],
      "constructors": [
        {
          "body": "private SomeLanguages(final Set<String> languages)\n{\r\n    this.languages = Collections.unmodifiableSet(languages);\r\n}",
          "signature": "SomeLanguages(Set)",
          "parameters": [
            {
              "variable_name": "languages",
              "variable_type": "java.util.Set<java.lang.String>"
            }
          ]
        }
      ],
      "methods": {
        "contains": [
          {
            "call_methods": [
              {
                "signature": "java.util.Set.contains(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "language",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean contains(String)",
            "parameters": [
              {
                "variable_name": "language",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getAny": [
          {
            "call_methods": [
              {
                "signature": "java.util.Iterator.next()",
                "arguments": [],
                "return_type": "E"
              },
              {
                "signature": "java.util.Set.iterator()",
                "arguments": [],
                "return_type": "java.util.Iterator<E>"
              }
            ],
            "signature": "public String getAny()",
            "parameters": []
          }
        ],
        "getLanguages": [
          {
            "call_methods": [],
            "signature": "public Set<String> getLanguages()",
            "parameters": []
          }
        ],
        "isEmpty": [
          {
            "call_methods": [
              {
                "signature": "java.util.Set.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isEmpty()",
            "parameters": []
          }
        ],
        "isSingleton": [
          {
            "call_methods": [
              {
                "signature": "java.util.Set.size()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public boolean isSingleton()",
            "parameters": []
          }
        ],
        "merge": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.from(java.util.Set<java.lang.String>)",
                "arguments": [
                  {
                    "variable_name": "set",
                    "variable_type": "java.util.Set<java.lang.String>"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "java.util.Set.addAll(java.util.Collection<? extends E>)",
                "arguments": [
                  {
                    "variable_name": "someLanguages.languages",
                    "variable_type": "java.util.Collection<? extends E>"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public LanguageSet merge(LanguageSet)",
            "parameters": [
              {
                "variable_name": "other",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ]
          }
        ],
        "restrictTo": [
          {
            "call_methods": [
              {
                "signature": "java.util.Collection.stream()",
                "arguments": [],
                "return_type": "java.util.stream.Stream<E>"
              },
              {
                "signature": "java.util.stream.Stream.filter(java.util.function.Predicate<? super T>)",
                "arguments": [
                  {
                    "variable_name": "lang -> someLanguages.languages.contains(lang)",
                    "variable_type": "java.util.function.Predicate<? super T>"
                  }
                ],
                "return_type": "java.util.stream.Stream<T>"
              },
              {
                "signature": "java.util.Set.contains(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "lang",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.stream.Collectors.toSet()",
                "arguments": [],
                "return_type": "java.util.stream.Collector<T, ?, java.util.Set<T>>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.from(java.util.Set<java.lang.String>)",
                "arguments": [
                  {
                    "variable_name": "languages.stream().filter(lang -> someLanguages.languages.contains(lang)).collect(Collectors.toSet())",
                    "variable_type": "java.util.Set<java.lang.String>"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)",
                "arguments": [
                  {
                    "variable_name": "Collectors.toSet()",
                    "variable_type": "java.util.stream.Collector<? super T, A, R>"
                  }
                ],
                "return_type": "R"
              }
            ],
            "signature": "public LanguageSet restrictTo(LanguageSet)",
            "parameters": [
              {
                "variable_name": "other",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ]
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Some languages, explicitly enumerated.\n     "
    },
    "org.apache.commons.codec.language.bm.PhoneticEngine": {
      "fields": [
        {
          "variable_name": "DEFAULT_MAX_PHONEMES",
          "variable_type": "int"
        },
        {
          "variable_name": "NAME_PREFIXES",
          "variable_type": "java.util.Map<org.apache.commons.codec.language.bm.NameType, java.util.Set<java.lang.String>>"
        },
        {
          "variable_name": "lang",
          "variable_type": "org.apache.commons.codec.language.bm.Lang"
        },
        {
          "variable_name": "nameType",
          "variable_type": "org.apache.commons.codec.language.bm.NameType"
        },
        {
          "variable_name": "ruleType",
          "variable_type": "org.apache.commons.codec.language.bm.RuleType"
        },
        {
          "variable_name": "concat",
          "variable_type": "boolean"
        },
        {
          "variable_name": "maxPhonemes",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concatenate)\n{\r\n    this(nameType, ruleType, concatenate, DEFAULT_MAX_PHONEMES);\r\n}",
          "signature": "PhoneticEngine(NameType, RuleType, boolean)",
          "parameters": [
            {
              "variable_name": "nameType",
              "variable_type": "org.apache.commons.codec.language.bm.NameType"
            },
            {
              "variable_name": "ruleType",
              "variable_type": "org.apache.commons.codec.language.bm.RuleType"
            },
            {
              "variable_name": "concatenate",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concatenate\n     *            if it will concatenate multiple encodings\n     "
        },
        {
          "body": "public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concatenate, final int maxPhonemes)\n{\r\n    if (ruleType == RuleType.RULES) {\r\n        throw new IllegalArgumentException(\"ruleType must not be \" + RuleType.RULES);\r\n    }\r\n    this.nameType = nameType;\r\n    this.ruleType = ruleType;\r\n    this.concat = concatenate;\r\n    this.lang = Lang.instance(nameType);\r\n    this.maxPhonemes = maxPhonemes;\r\n}",
          "signature": "PhoneticEngine(NameType, RuleType, boolean, int)",
          "parameters": [
            {
              "variable_name": "nameType",
              "variable_type": "org.apache.commons.codec.language.bm.NameType"
            },
            {
              "variable_name": "ruleType",
              "variable_type": "org.apache.commons.codec.language.bm.RuleType"
            },
            {
              "variable_name": "concatenate",
              "variable_type": "boolean"
            },
            {
              "variable_name": "maxPhonemes",
              "variable_type": "int"
            }
          ],
          "javadoc": "\n     * Generates a new, fully-configured phonetic engine.\n     *\n     * @param nameType\n     *            the type of names it will use\n     * @param ruleType\n     *            the type of rules it will apply\n     * @param concatenate\n     *            if it will concatenate multiple encodings\n     * @param maxPhonemes\n     *            the maximum number of phonemes that will be handled\n     * @since 1.7\n     "
        }
      ],
      "methods": {
        "join": [
          {
            "call_methods": [
              {
                "signature": "java.util.Collection.stream()",
                "arguments": [],
                "return_type": "java.util.stream.Stream<E>"
              },
              {
                "signature": "java.util.stream.Collectors.joining(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "sep",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.stream.Collector<java.lang.CharSequence, ?, java.lang.String>"
              },
              {
                "signature": "java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)",
                "arguments": [
                  {
                    "variable_name": "Collectors.joining(sep)",
                    "variable_type": "java.util.stream.Collector<? super T, A, R>"
                  }
                ],
                "return_type": "R"
              }
            ],
            "signature": "private static String join(List<String>, String)",
            "parameters": [
              {
                "variable_name": "strings",
                "variable_type": "java.util.List<java.lang.String>"
              },
              {
                "variable_name": "sep",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Joins some strings with an internal separator.\n     *\n     * @param strings   Strings to join\n     * @param sep       String to separate them with\n     * @return a single String consisting of each element of {@code strings} interleaved by {@code sep}\n     "
          }
        ],
        "applyFinalRules": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.put(K, V)",
                "arguments": [
                  {
                    "variable_name": "mergedPhoneme",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "mergedPhoneme",
                    "variable_type": "V"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.isFound()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)",
                "arguments": [
                  {
                    "variable_name": "phoneme -> {\r\n    PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\r\n    final String phonemeText = phoneme.getPhonemeText().toString();\r\n    for (int i = 0; i < phonemeText.length(); ) {\r\n        final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\r\n        final boolean found = rulesApplication.isFound();\r\n        subBuilder = rulesApplication.getPhonemeBuilder();\r\n        if (!found) {\r\n            // not found, appending as-is\r\n            subBuilder.append(phonemeText.subSequence(i, i + 1));\r\n        }\r\n        i = rulesApplication.getI();\r\n    }\r\n    // the phonemes map orders the phonemes only based on their text, but ignores the language set\r\n    // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\r\n    // phonemes with the same text but different language set get lost\r\n    subBuilder.getPhonemes().forEach(newPhoneme -> {\r\n        if (phonemes.containsKey(newPhoneme)) {\r\n            final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\r\n            final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\r\n            phonemes.put(mergedPhoneme, mergedPhoneme);\r\n        } else {\r\n            phonemes.put(newPhoneme, newPhoneme);\r\n        }\r\n    });\r\n}",
                    "variable_type": "java.util.function.Consumer<? super T>"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.CharSequence.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.append(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "phonemeText.subSequence(i, i + 1)",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getPhonemeBuilder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
              },
              {
                "signature": "java.util.Objects.requireNonNull(T, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "finalRules",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "\"finalRules\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.getPhonemes()",
                "arguments": [],
                "return_type": "java.util.Set<org.apache.commons.codec.language.bm.Rule.Phoneme>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getI()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.util.Map.keySet()",
                "arguments": [],
                "return_type": "java.util.Set<K>"
              },
              {
                "signature": "java.util.Map.remove(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "newPhoneme",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.empty(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "phoneme.getLanguages()",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getLanguages()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "java.util.Map.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemeText()",
                "arguments": [],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.invoke()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication"
              },
              {
                "signature": "java.lang.String.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "java.util.Map.containsKey(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "newPhoneme",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.mergeWithLanguage(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "newPhoneme.getLanguages()",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
              }
            ],
            "signature": "private PhonemeBuilder applyFinalRules(PhonemeBuilder, Map<String, List<Rule>>)",
            "parameters": [
              {
                "variable_name": "phonemeBuilder",
                "variable_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
              },
              {
                "variable_name": "finalRules",
                "variable_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
              }
            ],
            "javadoc": "\n     * Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Lang.guessLanguages(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "languageSet",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string to its phonetic representation.\n     *\n     * @param input\n     *            the String to encode\n     * @return the encoding of the input\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\\\s+\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.util.List.removeAll(java.util.Collection<?>)",
                "arguments": [
                  {
                    "variable_name": "NAME_PREFIXES.get(this.nameType)",
                    "variable_type": "java.util.Collection<?>"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "remainder",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encode(word)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getPhonemeBuilder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.substring(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.getI()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.makeString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.trim()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.List.iterator()",
                "arguments": [],
                "return_type": "java.util.Iterator<E>"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.nameType",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.util.Iterator.next()",
                "arguments": [],
                "return_type": "E"
              },
              {
                "signature": "java.util.List.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"d'\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.List.addAll(java.util.Collection<? extends E>)",
                "arguments": [
                  {
                    "variable_name": "words",
                    "variable_type": "java.util.Collection<? extends E>"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getInstanceMap(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "this.nameType",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  },
                  {
                    "variable_name": "this.ruleType",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  },
                  {
                    "variable_name": "\"common\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "parts[parts.length - 1]",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getInstanceMap(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "this.nameType",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  },
                  {
                    "variable_name": "RuleType.RULES",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  },
                  {
                    "variable_name": "languageSet",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
              },
              {
                "signature": "java.lang.String.replace(char, char)",
                "arguments": [
                  {
                    "variable_name": "'-'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "' '",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)",
                "arguments": [
                  {
                    "variable_name": "aWord -> {\r\n    final String[] parts = aWord.split(\"'\", -1);\r\n    words2.add(parts[parts.length - 1]);\r\n}",
                    "variable_type": "java.util.function.Consumer<? super T>"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.empty(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "languageSet",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
              },
              {
                "signature": "java.lang.String.split(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "\"'\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.util.List.size()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "input.split(\"\\\\s+\")",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication.invoke()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.applyFinalRules(org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder, java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>)",
                "arguments": [
                  {
                    "variable_name": "phonemeBuilder",
                    "variable_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
                  },
                  {
                    "variable_name": "finalRules1",
                    "variable_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.join(java.util.List<java.lang.String>, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "words2",
                    "variable_type": "java.util.List<java.lang.String>"
                  },
                  {
                    "variable_name": "\" \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.toLowerCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String, Languages.LanguageSet)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "languageSet",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "javadoc": "\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n     *\n     * @param input\n     *            String to phoneticise; a String with dashes or spaces separating each word\n     * @param languageSet\n     *            set of possible origin languages\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the\n     *         input\n     "
          }
        ],
        "getLang": [
          {
            "call_methods": [],
            "signature": "public Lang getLang()",
            "parameters": [],
            "javadoc": "\n     * Gets the Lang language guessing rules being used.\n     *\n     * @return the Lang in use\n     "
          }
        ],
        "getMaxPhonemes": [
          {
            "call_methods": [],
            "signature": "public int getMaxPhonemes()",
            "parameters": [],
            "javadoc": "\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\n     *\n     * @return the maximum number of phonemes\n     * @since 1.7\n     "
          }
        ],
        "getNameType": [
          {
            "call_methods": [],
            "signature": "public NameType getNameType()",
            "parameters": [],
            "javadoc": "\n     * Gets the NameType being used.\n     *\n     * @return the NameType in use\n     "
          }
        ],
        "getRuleType": [
          {
            "call_methods": [],
            "signature": "public RuleType getRuleType()",
            "parameters": [],
            "javadoc": "\n     * Gets the RuleType being used.\n     *\n     * @return the RuleType in use\n     "
          }
        ],
        "isConcat": [
          {
            "call_methods": [],
            "signature": "public boolean isConcat()",
            "parameters": [],
            "javadoc": "\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n     *\n     * @return true if multiple phonetic encodings are returned, false if just the first is\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Converts words into potential phonetic representations.\n * <p>\n * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes\n * into account the likely source language. Next, this phonetic representation is converted into a\n * pan-European 'average' representation, allowing comparison between different versions of essentially\n * the same word from different languages.\n * </p>\n * <p>\n * This class is intentionally immutable and thread-safe.\n * If you wish to alter the settings for a PhoneticEngine, you\n * must make a new one with the updated settings.\n * </p>\n * <p>\n * Ported from phoneticengine.php\n * </p>\n *\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder": {
      "fields": [
        {
          "variable_name": "phonemes",
          "variable_type": "java.util.Set<org.apache.commons.codec.language.bm.Rule.Phoneme>"
        }
      ],
      "constructors": [
        {
          "body": "private PhonemeBuilder(final Rule.Phoneme phoneme)\n{\r\n    this.phonemes = new LinkedHashSet<>();\r\n    this.phonemes.add(phoneme);\r\n}",
          "signature": "PhonemeBuilder(Rule.Phoneme)",
          "parameters": [
            {
              "variable_name": "phoneme",
              "variable_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
            }
          ]
        },
        {
          "body": "private PhonemeBuilder(final Set<Rule.Phoneme> phonemes)\n{\r\n    this.phonemes = phonemes;\r\n}",
          "signature": "PhonemeBuilder(Set)",
          "parameters": [
            {
              "variable_name": "phonemes",
              "variable_type": "java.util.Set<org.apache.commons.codec.language.bm.Rule.Phoneme>"
            }
          ]
        }
      ],
      "methods": {
        "empty": [
          {
            "call_methods": [],
            "signature": "public static PhonemeBuilder empty(Languages.LanguageSet)",
            "parameters": [
              {
                "variable_name": "languages",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "javadoc": "\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n         * phoneme from scratch.\n         *\n         * @param languages the set of languages\n         * @return  a new, empty phoneme builder\n         "
          }
        ],
        "append": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.append(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
              },
              {
                "signature": "java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)",
                "arguments": [
                  {
                    "variable_name": "ph -> ph.append(str)",
                    "variable_type": "java.util.function.Consumer<? super T>"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void append(CharSequence)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.CharSequence"
              }
            ],
            "javadoc": "\n         * Creates a new phoneme builder containing all phonemes in this one extended by {@code str}.\n         *\n         * @param str   the characters to append to the phonemes\n         "
          }
        ],
        "apply": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr.getPhonemes()",
                "arguments": [],
                "return_type": "java.lang.Iterable<org.apache.commons.codec.language.bm.Rule.Phoneme>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr.size()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.util.Set.clear()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getLanguages()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Set.add(E)",
                "arguments": [
                  {
                    "variable_name": "join",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Set.size()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.restrictTo(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "right.getLanguages()",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "java.util.Set.addAll(java.util.Collection<? extends E>)",
                "arguments": [
                  {
                    "variable_name": "newPhonemes",
                    "variable_type": "java.util.Collection<? extends E>"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "phonemes.size() * phonemeExpr.size()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "maxPhonemes",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void apply(Rule.PhonemeExpr, int)",
            "parameters": [
              {
                "variable_name": "phonemeExpr",
                "variable_type": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
              },
              {
                "variable_name": "maxPhonemes",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\n         * <p>\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n         * incompatible.\n         * </p>\n         *\n         * @param phonemeExpr   the expression to apply\n         * @param maxPhonemes   the maximum number of phonemes to build up\n         "
          }
        ],
        "getPhonemes": [
          {
            "call_methods": [],
            "signature": "public Set<Rule.Phoneme> getPhonemes()",
            "parameters": [],
            "javadoc": "\n         * Gets underlying phoneme set. Please don't mutate.\n         *\n         * @return  the phoneme set\n         "
          }
        ],
        "makeString": [
          {
            "call_methods": [
              {
                "signature": "java.util.Collection.stream()",
                "arguments": [],
                "return_type": "java.util.stream.Stream<E>"
              },
              {
                "signature": "java.util.stream.Collectors.joining(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"|\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.stream.Collector<java.lang.CharSequence, ?, java.lang.String>"
              },
              {
                "signature": "java.util.stream.Stream.map(java.util.function.Function<? super T, ? extends R>)",
                "arguments": [
                  {
                    "variable_name": "Rule.Phoneme::getPhonemeText",
                    "variable_type": "java.util.function.Function<? super T, ? extends R>"
                  }
                ],
                "return_type": "java.util.stream.Stream<R>"
              },
              {
                "signature": "java.util.stream.Stream.collect(java.util.stream.Collector<? super T, A, R>)",
                "arguments": [
                  {
                    "variable_name": "Collectors.joining(\"|\")",
                    "variable_type": "java.util.stream.Collector<? super T, A, R>"
                  }
                ],
                "return_type": "R"
              }
            ],
            "signature": "public String makeString()",
            "parameters": [],
            "javadoc": "\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n         * expensive operation, which should be avoided when debugging.\n         *\n         * @return  the stringified phoneme set\n         "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside\n     * this package, and probably not outside the {@link PhoneticEngine} class.\n     *\n     * @since 1.6\n     "
    },
    "org.apache.commons.codec.language.bm.PhoneticEngine.RulesApplication": {
      "fields": [
        {
          "variable_name": "finalRules",
          "variable_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
        },
        {
          "variable_name": "input",
          "variable_type": "java.lang.CharSequence"
        },
        {
          "variable_name": "phonemeBuilder",
          "variable_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
        },
        {
          "variable_name": "i",
          "variable_type": "int"
        },
        {
          "variable_name": "maxPhonemes",
          "variable_type": "int"
        },
        {
          "variable_name": "found",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input, final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes)\n{\r\n    Objects.requireNonNull(finalRules, \"finalRules\");\r\n    this.finalRules = finalRules;\r\n    this.phonemeBuilder = phonemeBuilder;\r\n    this.input = input;\r\n    this.i = i;\r\n    this.maxPhonemes = maxPhonemes;\r\n}",
          "signature": "RulesApplication(Map, CharSequence, PhonemeBuilder, int, int)",
          "parameters": [
            {
              "variable_name": "finalRules",
              "variable_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
            },
            {
              "variable_name": "input",
              "variable_type": "java.lang.CharSequence"
            },
            {
              "variable_name": "phonemeBuilder",
              "variable_type": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder"
            },
            {
              "variable_name": "i",
              "variable_type": "int"
            },
            {
              "variable_name": "maxPhonemes",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "getI": [
          {
            "call_methods": [],
            "signature": "public int getI()",
            "parameters": []
          }
        ],
        "getPhonemeBuilder": [
          {
            "call_methods": [],
            "signature": "public PhonemeBuilder getPhonemeBuilder()",
            "parameters": []
          }
        ],
        "invoke": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "input.subSequence(i, i + patternLength)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getPhoneme()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getPattern()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.PhonemeBuilder.apply(org.apache.commons.codec.language.bm.Rule.PhonemeExpr, int)",
                "arguments": [
                  {
                    "variable_name": "rule.getPhoneme()",
                    "variable_type": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
                  },
                  {
                    "variable_name": "maxPhonemes",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.CharSequence.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i + patternLength",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(java.lang.CharSequence, int)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public RulesApplication invoke()",
            "parameters": [],
            "javadoc": "\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n         * match, {@code i} is advanced one and the character is silently dropped from the phonetic spelling.\n         *\n         * @return {@code this}\n         "
          }
        ],
        "isFound": [
          {
            "call_methods": [],
            "signature": "public boolean isFound()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.\n     * After invocation, the values {@code i} and {@code found} are updated. {@code i} points to the\n     * index of the next char in {@code input} that must be processed next (the input up to that index having been\n     * processed already), and {@code found} indicates if a matching rule was found or not. In the case where a\n     * matching rule was found, {@code phonemeBuilder} is replaced with a new builder containing the phonemes\n     * updated by the matching rule.\n     * <p>\n     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads\n     * as it is constructed as needed by the calling methods.\n     * </p>\n     *\n     * @since 1.6\n     "
    },
    "org.apache.commons.codec.language.bm.ResourceConstants": {
      "fields": [
        {
          "variable_name": "CMT",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ENCODING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "EXT_CMT_END",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "EXT_CMT_START",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * Constants used to process resource files.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.Rule": {
      "fields": [
        {
          "variable_name": "ALL_STRINGS_RMATCHER",
          "variable_type": "org.apache.commons.codec.language.bm.Rule.RPattern"
        },
        {
          "variable_name": "ALL",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "DOUBLE_QUOTE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "HASH_INCLUDE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "HASH_INCLUDE_LENGTH",
          "variable_type": "int"
        },
        {
          "variable_name": "RULES",
          "variable_type": "java.util.Map<org.apache.commons.codec.language.bm.NameType, java.util.Map<org.apache.commons.codec.language.bm.RuleType, java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>>>>"
        },
        {
          "variable_name": "lContext",
          "variable_type": "org.apache.commons.codec.language.bm.Rule.RPattern"
        },
        {
          "variable_name": "pattern",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "phoneme",
          "variable_type": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
        },
        {
          "variable_name": "rContext",
          "variable_type": "org.apache.commons.codec.language.bm.Rule.RPattern"
        }
      ],
      "constructors": [
        {
          "body": "public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme)\n{\r\n    this.pattern = pattern;\r\n    this.lContext = pattern(lContext + \"$\");\r\n    this.rContext = pattern(\"^\" + rContext);\r\n    this.phoneme = phoneme;\r\n}",
          "signature": "Rule(String, String, String, PhonemeExpr)",
          "parameters": [
            {
              "variable_name": "pattern",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "lContext",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "rContext",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "phoneme",
              "variable_type": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
            }
          ],
          "javadoc": "\n     * Creates a new rule.\n     *\n     * @param pattern\n     *            the pattern\n     * @param lContext\n     *            the left context\n     * @param rContext\n     *            the right context\n     * @param phoneme\n     *            the resulting phoneme\n     "
        }
      ],
      "methods": {
        "contains": [
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.chars()",
                "arguments": [],
                "return_type": "java.util.stream.IntStream"
              },
              {
                "signature": "java.util.stream.IntStream.anyMatch(java.util.function.IntPredicate)",
                "arguments": [
                  {
                    "variable_name": "c -> c == input",
                    "variable_type": "java.util.function.IntPredicate"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private static boolean contains(CharSequence, char)",
            "parameters": [
              {
                "variable_name": "chars",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "input",
                "variable_type": "char"
              }
            ]
          }
        ],
        "createResourceName": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "nameType.getName()",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "rt.getName()",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "lang",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.NameType.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.RuleType.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private static String createResourceName(NameType, RuleType, String)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "rt",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "lang",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "createScanner": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.Resources.getInputStream(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "resName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.io.InputStream"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.createResourceName(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "nameType",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  },
                  {
                    "variable_name": "rt",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  },
                  {
                    "variable_name": "lang",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private static Scanner createScanner(NameType, RuleType, String)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "rt",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "lang",
                "variable_type": "java.lang.String"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"org/apache/commons/codec/language/bm/%s.txt\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "lang",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.Resources.getInputStream(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "resName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.io.InputStream"
              }
            ],
            "signature": "private static Scanner createScanner(String)",
            "parameters": [
              {
                "variable_name": "lang",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "endsWith": [
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static boolean endsWith(CharSequence, CharSequence)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "suffix",
                "variable_type": "java.lang.CharSequence"
              }
            ]
          }
        ],
        "getInstance": [
          {
            "call_methods": [
              {
                "signature": "addAll",
                "arguments": [
                  {
                    "variable_name": "rules",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getInstanceMap(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "nameType",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  },
                  {
                    "variable_name": "rt",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  },
                  {
                    "variable_name": "langs",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
              },
              {
                "signature": "java.lang.Iterable.forEach(java.util.function.Consumer<? super T>)",
                "arguments": [
                  {
                    "variable_name": "rules -> allRules.addAll(rules)",
                    "variable_type": "java.util.function.Consumer<? super T>"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Map.values()",
                "arguments": [],
                "return_type": "java.util.Collection<V>"
              }
            ],
            "signature": "public static List<Rule> getInstance(NameType, RuleType, Languages.LanguageSet)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "rt",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "langs",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "javadoc": "\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a list of Rules that apply\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getInstance(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "nameType",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  },
                  {
                    "variable_name": "rt",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  },
                  {
                    "variable_name": "LanguageSet.from(new HashSet<>(Arrays.asList(lang)))",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "java.util.List<org.apache.commons.codec.language.bm.Rule>"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "lang",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.from(java.util.Set<java.lang.String>)",
                "arguments": [
                  {
                    "variable_name": "new HashSet<>(Arrays.asList(lang))",
                    "variable_type": "java.util.Set<java.lang.String>"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "signature": "public static List<Rule> getInstance(NameType, RuleType, String)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "rt",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "lang",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a list of Rules that apply\n     "
          }
        ],
        "getInstanceMap": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.isSingleton()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getInstanceMap(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "nameType",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  },
                  {
                    "variable_name": "rt",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  },
                  {
                    "variable_name": "langs.getAny()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.getAny()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static Map<String, List<Rule>> getInstanceMap(NameType, RuleType, Languages.LanguageSet)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "rt",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "langs",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "javadoc": "\n     * Gets rules for a combination of name type, rule type and languages.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param langs\n     *            the set of languages to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "lang",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"No rules found for %s, %s, %s.\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "nameType.getName()",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "rt.getName()",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "lang",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.NameType.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.RuleType.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static Map<String, List<Rule>> getInstanceMap(NameType, RuleType, String)",
            "parameters": [
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "rt",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "lang",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9\n     "
          }
        ],
        "parsePhoneme": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"[+]\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"]\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "in.split(\"[+]\")",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "open",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.indexOf(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"[\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.from(java.util.Set<java.lang.String>)",
                "arguments": [
                  {
                    "variable_name": "langs",
                    "variable_type": "java.util.Set<java.lang.String>"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static Phoneme parsePhoneme(String)",
            "parameters": [
              {
                "variable_name": "ph",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "parsePhonemeExpr": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"[|]\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"(\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "parsePhoneme(part)",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\")\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "ph.length() - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.parsePhoneme(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "part",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static PhonemeExpr parsePhonemeExpr(String)",
            "parameters": [
              {
                "variable_name": "ph",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "parseRules": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "HASH_INCLUDE_LENGTH",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\\\s+\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.parsePhonemeExpr(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stripQuotes(parts[3])",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.EXT_CMT_START",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.nextLine()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.parseRules(java.util.Scanner, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "hashIncludeScanner",
                    "variable_type": "java.util.Scanner"
                  },
                  {
                    "variable_name": "location + \"->\" + incl",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.Map<java.lang.String, java.util.List<org.apache.commons.codec.language.bm.Rule>>"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "r",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.EXT_CMT_END",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Rule\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\" \"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.stripQuotes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "parts[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.createScanner(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "incl",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.Scanner"
              },
              {
                "signature": "java.util.Map.computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)",
                "arguments": [
                  {
                    "variable_name": "patternKey",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "k -> new ArrayList<>()",
                    "variable_type": "java.util.function.Function<? super K, ? extends V>"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.String.trim()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(int)",
                "arguments": [
                  {
                    "variable_name": "myLine",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "cmtI",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Map.putAll(java.util.Map<? extends K, ? extends V>)",
                "arguments": [
                  {
                    "variable_name": "parseRules(hashIncludeScanner, location + \"->\" + incl)",
                    "variable_type": "java.util.Map<? extends K, ? extends V>"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "'\\''",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.indexOf(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ResourceConstants.CMT",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.hasNextLine()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "private static Map<String, List<Rule>> parseRules(Scanner, String)",
            "parameters": [
              {
                "variable_name": "scanner",
                "variable_type": "java.util.Scanner"
              },
              {
                "variable_name": "location",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "pattern": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.regex.Pattern.matcher(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.regex.Matcher"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Object.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"[\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.regex.Pattern.compile(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "regex",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.regex.Pattern"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.contains(java.lang.CharSequence, char)",
                "arguments": [
                  {
                    "variable_name": "bContent",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "input.charAt(0)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.CharSequence.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.startsWith(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.endsWith(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.regex.Matcher.find()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "startsWith ? 1 : 0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "endsWith ? regex.length() - 1 : regex.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static RPattern pattern(String)",
            "parameters": [
              {
                "variable_name": "regex",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n     *\n     * @param regex\n     *            the regular expression to compile\n     * @return an RPattern that will match this regex\n     "
          }
        ],
        "startsWith": [
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static boolean startsWith(CharSequence, CharSequence)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "prefix",
                "variable_type": "java.lang.CharSequence"
              }
            ]
          }
        ],
        "stripQuotes": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DOUBLE_QUOTE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DOUBLE_QUOTE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "str.length() - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static String stripQuotes(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getLContext": [
          {
            "call_methods": [],
            "signature": "public RPattern getLContext()",
            "parameters": [],
            "javadoc": "\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\n     *\n     * @return the left context Pattern\n     "
          }
        ],
        "getPattern": [
          {
            "call_methods": [],
            "signature": "public String getPattern()",
            "parameters": [],
            "javadoc": "\n     * Gets the pattern. This is a string-literal that must exactly match.\n     *\n     * @return the pattern\n     "
          }
        ],
        "getPhoneme": [
          {
            "call_methods": [],
            "signature": "public PhonemeExpr getPhoneme()",
            "parameters": [],
            "javadoc": "\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n     *\n     * @return the phoneme\n     "
          }
        ],
        "getRContext": [
          {
            "call_methods": [],
            "signature": "public RPattern getRContext()",
            "parameters": [],
            "javadoc": "\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\n     *\n     * @return the right context Pattern\n     "
          }
        ],
        "patternAndContextMatches": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.pattern",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.RPattern.isMatch(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "input.subSequence(ipl, input.length())",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.CharSequence.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "ipl",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public boolean patternAndContextMatches(CharSequence, int)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "i",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\n     * {@code lContext} matches {@code input} up to {@code i}, {@code pattern} matches at i and\n     * {@code rContext} matches from the end of the match of {@code pattern} to the end of {@code input}.\n     *\n     * @param input\n     *            the input String\n     * @param i\n     *            the int position within the input\n     * @return true if the pattern and left/right context match, false otherwise\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * A phoneme rule.\n * <p>\n * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply\n * and a logical flag indicating if all languages must be in play. A rule matches if:\n * </p>\n * <ul>\n * <li>the pattern matches at the current position</li>\n * <li>the string up until the beginning of the pattern matches the left context</li>\n * <li>the string from the end of the pattern matches the right context</li>\n * <li>logical is ALL and all languages are in scope; or</li>\n * <li>logical is any other value and at least one language is in scope</li>\n * </ul>\n * <p>\n * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user\n * to explicitly construct their own.\n * </p>\n * <p>\n * Rules are immutable and thread-safe.\n * </p>\n * <h2>Rules resources</h2>\n * <p>\n * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically\n * named following the pattern:\n * </p>\n * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * </p>\n * <ul>\n * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these\n * will be interpreted as:\n * <ol>\n * <li>pattern</li>\n * <li>left context</li>\n * <li>right context</li>\n * <li>phoneme</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be discarded\n * as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip\n * all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n *\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.Rule.Phoneme": {
      "fields": [
        {
          "variable_name": "COMPARATOR",
          "variable_type": "java.util.Comparator<org.apache.commons.codec.language.bm.Rule.Phoneme>"
        },
        {
          "variable_name": "phonemeText",
          "variable_type": "java.lang.StringBuilder"
        },
        {
          "variable_name": "languages",
          "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
        }
      ],
      "constructors": [
        {
          "body": "public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages)\n{\r\n    this.phonemeText = new StringBuilder(phonemeText);\r\n    this.languages = languages;\r\n}",
          "signature": "Phoneme(CharSequence, Languages.LanguageSet)",
          "parameters": [
            {
              "variable_name": "phonemeText",
              "variable_type": "java.lang.CharSequence"
            },
            {
              "variable_name": "languages",
              "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
            }
          ]
        },
        {
          "body": "public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight)\n{\r\n    this(phonemeLeft.phonemeText, phonemeLeft.languages);\r\n    this.phonemeText.append(phonemeRight.phonemeText);\r\n}",
          "signature": "Phoneme(Phoneme, Phoneme)",
          "parameters": [
            {
              "variable_name": "phonemeLeft",
              "variable_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
            },
            {
              "variable_name": "phonemeRight",
              "variable_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
            }
          ]
        },
        {
          "body": "public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages)\n{\r\n    this(phonemeLeft.phonemeText, languages);\r\n    this.phonemeText.append(phonemeRight.phonemeText);\r\n}",
          "signature": "Phoneme(Phoneme, Phoneme, Languages.LanguageSet)",
          "parameters": [
            {
              "variable_name": "phonemeLeft",
              "variable_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
            },
            {
              "variable_name": "phonemeRight",
              "variable_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
            },
            {
              "variable_name": "languages",
              "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
            }
          ]
        }
      ],
      "methods": {
        "append": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "public Phoneme append(CharSequence)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.CharSequence"
              }
            ]
          }
        ],
        "getLanguages": [
          {
            "call_methods": [],
            "signature": "public Languages.LanguageSet getLanguages()",
            "parameters": []
          }
        ],
        "getPhonemes": [
          {
            "call_methods": [
              {
                "signature": "java.util.Collections.singleton(T)",
                "arguments": [
                  {
                    "variable_name": "this",
                    "variable_type": "T"
                  }
                ],
                "return_type": "java.util.Set<T>"
              }
            ],
            "signature": "public Iterable<Phoneme> getPhonemes()",
            "parameters": []
          }
        ],
        "getPhonemeText": [
          {
            "call_methods": [],
            "signature": "public CharSequence getPhonemeText()",
            "parameters": []
          }
        ],
        "join": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.restrictTo(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "right.languages",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "signature": "public Phoneme join(Phoneme)",
            "parameters": [
              {
                "variable_name": "right",
                "variable_type": "org.apache.commons.codec.language.bm.Rule.Phoneme"
              }
            ],
            "javadoc": "\n         * Deprecated since 1.9.\n         *\n         * @param right the Phoneme to join\n         * @return a new Phoneme\n         * @deprecated since 1.9\n         "
          }
        ],
        "mergeWithLanguage": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.merge(org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "lang",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "signature": "public Phoneme mergeWithLanguage(LanguageSet)",
            "parameters": [
              {
                "variable_name": "lang",
                "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "javadoc": "\n         * Returns a new Phoneme with the same text but a union of its\n         * current language set and the given one.\n         *\n         * @param lang the language set to merge\n         * @return a new Phoneme\n         "
          }
        ],
        "size": [
          {
            "call_methods": [],
            "signature": "public int size()",
            "parameters": []
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.language.bm.Rule.PhonemeExpr": {
      "fields": [],
      "constructors": [],
      "methods": {
        "getPhonemes": [
          {
            "call_methods": [],
            "signature": " abstract Iterable<Phoneme> getPhonemes()",
            "parameters": []
          }
        ],
        "size": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.PhonemeExpr.getPhonemes()",
                "arguments": [],
                "return_type": "java.lang.Iterable<org.apache.commons.codec.language.bm.Rule.Phoneme>"
              },
              {
                "signature": "java.util.Spliterator.getExactSizeIfKnown()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Math.min(long, long)",
                "arguments": [
                  {
                    "variable_name": "getPhonemes().spliterator().getExactSizeIfKnown()",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "Integer.MAX_VALUE",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Iterable.spliterator()",
                "arguments": [],
                "return_type": "java.util.Spliterator<T>"
              }
            ],
            "signature": " int size()",
            "parameters": [],
            "javadoc": "\n         * Gets the expression size in phonemes.\n         *\n         * @return the expression size in phonemes.\n         * @since 1.17.0\n         "
          }
        ]
      },
      "is_interface": true
    },
    "org.apache.commons.codec.language.bm.Rule.PhonemeList": {
      "fields": [
        {
          "variable_name": "phonemeList",
          "variable_type": "java.util.List<org.apache.commons.codec.language.bm.Rule.Phoneme>"
        }
      ],
      "constructors": [
        {
          "body": "public PhonemeList(final List<Phoneme> phonemes)\n{\r\n    this.phonemeList = phonemes;\r\n}",
          "signature": "PhonemeList(List)",
          "parameters": [
            {
              "variable_name": "phonemes",
              "variable_type": "java.util.List<org.apache.commons.codec.language.bm.Rule.Phoneme>"
            }
          ]
        }
      ],
      "methods": {
        "getPhonemes": [
          {
            "call_methods": [],
            "signature": "public List<Phoneme> getPhonemes()",
            "parameters": []
          }
        ],
        "size": [
          {
            "call_methods": [
              {
                "signature": "java.util.List.size()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public int size()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.language.bm.Rule.RPattern": {
      "fields": [],
      "constructors": [],
      "methods": {
        "isMatch": [
          {
            "call_methods": [],
            "signature": " abstract boolean isMatch(CharSequence)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.CharSequence"
              }
            ]
          }
        ]
      },
      "is_interface": true,
      "javadoc": "\n     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n     "
    },
    "org.apache.commons.codec.language.Caverphone": {
      "fields": [
        {
          "variable_name": "encoder",
          "variable_type": "org.apache.commons.codec.language.Caverphone2"
        }
      ],
      "constructors": [],
      "methods": {
        "caverphone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Caverphone2.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String caverphone(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Caverphone.caverphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type {@link String}.\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (or type {@link String}) containing the caverphone code which corresponds to the String\n     *         supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type {@link String}.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Caverphone.caverphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the Caverphone algorithm.\n     *\n     * @param str\n     *            String object to encode\n     * @return The caverphone code corresponding to the String supplied\n     "
          }
        ],
        "isCaverphoneEqual": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.caverphone(str2)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.Caverphone.caverphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public boolean isCaverphoneEqual(String, String)",
            "parameters": [
              {
                "variable_name": "str1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "str2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Tests if the caverphones of two strings are identical.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return {@code true} if the caverphones of these strings are identical, {@code false} otherwise.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Caverphone 2.0 value. Delegate to a {@link Caverphone2} instance.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"https://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n * @since 1.4\n * @deprecated 1.5 Replaced by {@link Caverphone2}, will be removed in 2.0.\n "
    },
    "org.apache.commons.codec.language.Caverphone1": {
      "fields": [
        {
          "variable_name": "SIX_1",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.replaceAll(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"[^a-z]\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "SIX_1.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"cq\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"2q\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.toLowerCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "java.util.Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Caverphone 1.0 value.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 1.0\n * algorithm:\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"https://caversham.otago.ac.nz/files/working/ctp060902.pdf\">Caverphone 1.0 specification</a>\n * @since 1.5\n *\n * <p>This class is immutable and thread-safe.</p>\n "
    },
    "org.apache.commons.codec.language.Caverphone2": {
      "fields": [
        {
          "variable_name": "TEN_1",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.isEmpty(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "txt",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.replaceAll(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"[^a-z]\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "TEN_1.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"cq\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"2q\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.toLowerCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "java.util.Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given String into a Caverphone 2.0 value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Caverphone 2.0 value.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"https://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n * @since 1.5\n *\n * <p>This class is immutable and thread-safe.</p>\n "
    },
    "org.apache.commons.codec.language.ColognePhonetic": {
      "fields": [
        {
          "variable_name": "AEIJOUY",
          "variable_type": "char"
        },
        {
          "variable_name": "CSZ",
          "variable_type": "char"
        },
        {
          "variable_name": "FPVW",
          "variable_type": "char"
        },
        {
          "variable_name": "GKQ",
          "variable_type": "char"
        },
        {
          "variable_name": "CKQ",
          "variable_type": "char"
        },
        {
          "variable_name": "AHKLOQRUX",
          "variable_type": "char"
        },
        {
          "variable_name": "SZ",
          "variable_type": "char"
        },
        {
          "variable_name": "AHKOQUX",
          "variable_type": "char"
        },
        {
          "variable_name": "DTX",
          "variable_type": "char"
        },
        {
          "variable_name": "CHAR_IGNORE",
          "variable_type": "char"
        }
      ],
      "constructors": [],
      "methods": {
        "arrayContains": [
          {
            "call_methods": [],
            "signature": "private static boolean arrayContains(char[], char)",
            "parameters": [
              {
                "variable_name": "arr",
                "variable_type": "char[]"
              },
              {
                "variable_name": "key",
                "variable_type": "char"
              }
            ]
          }
        ],
        "colognePhonetic": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.arrayContains(char[], char)",
                "arguments": [
                  {
                    "variable_name": "AEIJOUY",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "chr",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.getNextChar()",
                "arguments": [],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.preprocess(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer.put(char)",
                "arguments": [
                  {
                    "variable_name": "'0'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.removeNext()",
                "arguments": [],
                "return_type": "char"
              }
            ],
            "signature": "public String colognePhonetic(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * <p>\n     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\n     * </p>\n     * <p>\n     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\n     * </p>\n     *\n     * @param text The source text to encode\n     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) object",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "object",
                "variable_type": "java.lang.Object"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.colognePhonetic(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "isEncodeEqual": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.colognePhonetic(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "colognePhonetic(text2)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isEncodeEqual(String, String)",
            "parameters": [
              {
                "variable_name": "text1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "text2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Compares the first encoded string to the second encoded string.\n     *\n     * @param text1 source text to encode before testing for equality.\n     * @param text2 source text to encode before testing for equality.\n     * @return {@code true} if the encoding the first string equals the encoding of the second string, {@code false}\n     *         otherwise\n     "
          }
        ],
        "preprocess": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.GERMAN",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "private char[] preprocess(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Converts the string to upper case and replaces Germanic umlaut characters\n     * The following characters are mapped:\n     * <ul>\n     * <li>capital A, umlaut mark</li>\n     * <li>capital U, umlaut mark</li>\n     * <li>capital O, umlaut mark</li>\n     * <li>small sharp s, German</li>\n     * </ul>\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Cologne Phonetic value.\n * <p>\n * Implements the <a href=\"https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">K&ouml;lner Phonetik</a> (Cologne\n * Phonetic) algorithm issued by Hans Joachim Postel in 1969.\n * </p>\n * <p>\n * The <i>K&ouml;lner Phonetik</i> is a phonetic algorithm which is optimized for the German language. It is related to\n * the well-known soundex algorithm.\n * </p>\n *\n * <h2>Algorithm</h2>\n *\n * <ul>\n *\n * <li>\n * <h3>Step 1:</h3>\n * After preprocessing (conversion to upper case, transcription of <a\n * href=\"https://en.wikipedia.org/wiki/Germanic_umlaut\">germanic umlauts</a>, removal of non alphabetical characters) the\n * letters of the supplied text are replaced by their phonetic code according to the following table.\n * <table border=\"1\">\n * <caption style=\"caption-side: bottom\"><small><i>(Source: <a\n * href=\"https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes\">Wikipedia (de): K&ouml;lner Phonetik --\n * Buchstabencodes</a>)</i></small></caption> <tbody>\n * <tr>\n * <th>Letter</th>\n * <th>Context</th>\n * <th>Code</th>\n * </tr>\n * <tr>\n * <td>A, E, I, J, O, U, Y</td>\n * <td></td>\n * <td>0</td>\n * </tr>\n * <tr>\n *\n * <td>H</td>\n * <td></td>\n * <td>-</td>\n * </tr>\n * <tr>\n * <td>B</td>\n * <td></td>\n * <td rowspan=\"2\">1</td>\n * </tr>\n * <tr>\n * <td>P</td>\n * <td>not before H</td>\n *\n * </tr>\n * <tr>\n * <td>D, T</td>\n * <td>not before C, S, Z</td>\n * <td>2</td>\n * </tr>\n * <tr>\n * <td>F, V, W</td>\n * <td></td>\n * <td rowspan=\"2\">3</td>\n * </tr>\n * <tr>\n *\n * <td>P</td>\n * <td>before H</td>\n * </tr>\n * <tr>\n * <td>G, K, Q</td>\n * <td></td>\n * <td rowspan=\"3\">4</td>\n * </tr>\n * <tr>\n * <td rowspan=\"2\">C</td>\n * <td>at onset before A, H, K, L, O, Q, R, U, X</td>\n *\n * </tr>\n * <tr>\n * <td>before A, H, K, O, Q, U, X except after S, Z</td>\n * </tr>\n * <tr>\n * <td>X</td>\n * <td>not after C, K, Q</td>\n * <td>48</td>\n * </tr>\n * <tr>\n * <td>L</td>\n * <td></td>\n *\n * <td>5</td>\n * </tr>\n * <tr>\n * <td>M, N</td>\n * <td></td>\n * <td>6</td>\n * </tr>\n * <tr>\n * <td>R</td>\n * <td></td>\n * <td>7</td>\n * </tr>\n *\n * <tr>\n * <td>S, Z</td>\n * <td></td>\n * <td rowspan=\"6\">8</td>\n * </tr>\n * <tr>\n * <td rowspan=\"3\">C</td>\n * <td>after S, Z</td>\n * </tr>\n * <tr>\n * <td>at onset except before A, H, K, L, O, Q, R, U, X</td>\n * </tr>\n *\n * <tr>\n * <td>not before A, H, K, O, Q, U, X</td>\n * </tr>\n * <tr>\n * <td>D, T</td>\n * <td>before C, S, Z</td>\n * </tr>\n * <tr>\n * <td>X</td>\n * <td>after C, K, Q</td>\n * </tr>\n * </tbody>\n * </table>\n *\n * <h4>Example:</h4>\n *\n * {@code \"M}&uuml;{@code ller-L}&uuml;<code>denscheidt\"\n * =&gt; \"MULLERLUDENSCHEIDT\" =&gt; \"6005507500206880022\"</code>\n *\n * </li>\n *\n * <li>\n * <h3>Step 2:</h3>\n * Collapse of all multiple consecutive code digits.\n * <h4>Example:</h4>\n * {@code \"6005507500206880022\" =&gt; \"6050750206802\"}</li>\n *\n * <li>\n * <h3>Step 3:</h3>\n * Removal of all codes \"0\" except at the beginning. This means that two or more identical consecutive digits can occur\n * if they occur after removing the \"0\" digits.\n *\n * <h4>Example:</h4>\n * {@code \"6050750206802\" =&gt; \"65752682\"}</li>\n *\n * </ul>\n *\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see <a href=\"https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">Wikipedia (de): K&ouml;lner Phonetik (in German)</a>\n * @since 1.5\n "
    },
    "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer": {
      "fields": [
        {
          "variable_name": "data",
          "variable_type": "char"
        },
        {
          "variable_name": "length",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public CologneBuffer(final char[] data)\n{\r\n    this.data = data;\r\n    this.length = data.length;\r\n}",
          "signature": "CologneBuffer(char[])",
          "parameters": [
            {
              "variable_name": "data",
              "variable_type": "char[]"
            }
          ]
        },
        {
          "body": "public CologneBuffer(final int buffSize)\n{\r\n    this.data = new char[buffSize];\r\n    this.length = 0;\r\n}",
          "signature": "CologneBuffer(int)",
          "parameters": [
            {
              "variable_name": "buffSize",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "copyData": [
          {
            "call_methods": [],
            "signature": "protected abstract char[] copyData(int, int)",
            "parameters": [
              {
                "variable_name": "start",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ],
        "isEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public boolean isEmpty()",
            "parameters": []
          }
        ],
        "length": [
          {
            "call_methods": [],
            "signature": "public int length()",
            "parameters": []
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneBuffer.copyData(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * This class is not thread-safe; the field {@link #length} is mutable.\n     * However, it is not shared between threads, as it is constructed on demand\n     * by the method {@link ColognePhonetic#colognePhonetic(String)}\n     "
    },
    "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer": {
      "fields": [],
      "constructors": [
        {
          "body": "public CologneInputBuffer(final char[] data)\n{\r\n    super(data);\r\n}",
          "signature": "CologneInputBuffer(char[])",
          "parameters": [
            {
              "variable_name": "data",
              "variable_type": "char[]"
            }
          ]
        }
      ],
      "methods": {
        "copyData": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "data.length - this.length + start",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "newData",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "protected char[] copyData(int, int)",
            "parameters": [
              {
                "variable_name": "start",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ],
        "getNextChar": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.getNextPos()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public char getNextChar()",
            "parameters": []
          }
        ],
        "getNextPos": [
          {
            "call_methods": [],
            "signature": "protected int getNextPos()",
            "parameters": []
          }
        ],
        "removeNext": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.CologneInputBuffer.getNextChar()",
                "arguments": [],
                "return_type": "char"
              }
            ],
            "signature": "public char removeNext()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.language.ColognePhonetic.CologneOutputBuffer": {
      "fields": [
        {
          "variable_name": "lastCode",
          "variable_type": "char"
        }
      ],
      "constructors": [
        {
          "body": "public CologneOutputBuffer(final int buffSize)\n{\r\n    super(buffSize);\r\n    // impossible value\r\n    lastCode = '/';\r\n}",
          "signature": "CologneOutputBuffer(int)",
          "parameters": [
            {
              "variable_name": "buffSize",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "copyData": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.copyOfRange(char[], int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "start",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "protected char[] copyData(int, int)",
            "parameters": [
              {
                "variable_name": "start",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ]
          }
        ],
        "put": [
          {
            "call_methods": [],
            "signature": "public void put(char)",
            "parameters": [
              {
                "variable_name": "code",
                "variable_type": "char"
              }
            ],
            "javadoc": "\n         * Stores the next code in the output buffer, keeping track of the previous code.\n         * '0' is only stored if it is the first entry.\n         * Ignored chars are never stored.\n         * If the code is the same as the last code (whether stored or not) it is not stored.\n         *\n         * @param code the code to store.\n         "
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.language.DaitchMokotoffSoundex": {
      "fields": [
        {
          "variable_name": "COMMENT",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "DOUBLE_QUOTE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "MULTILINE_COMMENT_END",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "MULTILINE_COMMENT_START",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "RESOURCE_FILE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "MAX_LENGTH",
          "variable_type": "int"
        },
        {
          "variable_name": "RULES",
          "variable_type": "java.util.Map<java.lang.Character, java.util.List<org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule>>"
        },
        {
          "variable_name": "FOLDINGS",
          "variable_type": "java.util.Map<java.lang.Character, java.lang.Character>"
        },
        {
          "variable_name": "folding",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public DaitchMokotoffSoundex()\n{\r\n    this(true);\r\n}",
          "signature": "DaitchMokotoffSoundex()",
          "parameters": [],
          "javadoc": "\n     * Creates a new instance with ASCII-folding enabled.\n     "
        },
        {
          "body": "public DaitchMokotoffSoundex(final boolean folding)\n{\r\n    this.folding = folding;\r\n}",
          "signature": "DaitchMokotoffSoundex(boolean)",
          "parameters": [
            {
              "variable_name": "folding",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Creates a new instance.\n     * <p>\n     * With ASCII-folding enabled, certain accented characters will be transformed to equivalent ASCII characters, e.g.\n     *  -&gt; e.\n     * </p>\n     *\n     * @param folding\n     *            if ASCII-folding shall be performed before encoding\n     "
        }
      ],
      "methods": {
        "parseRules": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.put(K, V)",
                "arguments": [
                  {
                    "variable_name": "leftCharacter.charAt(0)",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "rightCharacter.charAt(0)",
                    "variable_type": "V"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.stripQuotes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "parts[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MULTILINE_COMMENT_START",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.nextLine()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "r",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MULTILINE_COMMENT_END",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"=\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.util.Map.computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)",
                "arguments": [
                  {
                    "variable_name": "patternKey",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "k -> new ArrayList<>()",
                    "variable_type": "java.util.function.Function<? super K, ? extends V>"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.String.trim()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "cmtI",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.indexOf(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "COMMENT",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Scanner.hasNextLine()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static void parseRules(Scanner, String, Map<Character, List<Rule>>, Map<Character, Character>)",
            "parameters": [
              {
                "variable_name": "scanner",
                "variable_type": "java.util.Scanner"
              },
              {
                "variable_name": "location",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "ruleMapping",
                "variable_type": "java.util.Map<java.lang.Character, java.util.List<org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule>>"
              },
              {
                "variable_name": "asciiFoldings",
                "variable_type": "java.util.Map<java.lang.Character, java.lang.Character>"
              }
            ]
          }
        ],
        "stripQuotes": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DOUBLE_QUOTE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DOUBLE_QUOTE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "str.length() - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static String stripQuotes(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "cleanup": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.Character.isWhitespace(char)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Character.toLowerCase(char)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "private String cleanup(String)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Performs a cleanup of the input string before the actual soundex transformation.\n     * <p>\n     * Removes all whitespace characters and performs ASCII folding if enabled.\n     * </p>\n     *\n     * @param input\n     *            the input string to clean up\n     * @return a cleaned up string\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the Daitch-Mokotoff soundex algorithm without branching.\n     * <p>\n     * This method is provided in order to satisfy the requirements of the Encoder interface, and will throw an\n     * EncoderException if the supplied object is not of type {@link String}.\n     * </p>\n     *\n     * @see #soundex(String)\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (of type {@link String}) containing the DM soundex code, which corresponds to the String\n     *         supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type {@link String}\n     * @throws IllegalArgumentException\n     *             if a character is not mapped\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String[]"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the Daitch-Mokotoff soundex algorithm without branching.\n     *\n     * @see #soundex(String)\n     *\n     * @param source\n     *            A String object to encode\n     * @return A DM Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *             if a character is not mapped\n     "
          }
        ],
        "soundex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "branch",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "'|'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "public String soundex(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the Daitch-Mokotoff soundex algorithm with branching.\n     * <p>\n     * In case a string is encoded into multiple codes (see branching rules), the result will contain all codes,\n     * separated by '|'.\n     * </p>\n     * <p>\n     * Example: the name \"AUERBACH\" is encoded as both\n     * </p>\n     * <ul>\n     * <li>097400</li>\n     * <li>097500</li>\n     * </ul>\n     * <p>\n     * Thus the result will be \"097400|097500\".\n     * </p>\n     *\n     * @param source\n     *            A String object to encode\n     * @return A string containing a set of DM Soundex codes corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *             if a character is not mapped\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "inputContext",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getPatternLength()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.util.List.clear()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.cleanup(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Set.clear()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "nextBranch",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Set.add(E)",
                "arguments": [
                  {
                    "variable_name": "new Branch()",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Set.size()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.util.Set.addAll(java.util.Collection<? extends E>)",
                "arguments": [
                  {
                    "variable_name": "nextBranches",
                    "variable_type": "java.util.Collection<? extends E>"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.createBranch()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch"
              },
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.processNextReplacement(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "nextReplacement",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "force",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Collections.emptyList()",
                "arguments": [],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getReplacements(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "inputContext",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "lastChar == '\\0'",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Character.isWhitespace(char)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.finish()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private String[] soundex(String, boolean)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "branching",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Perform the actual DM Soundex algorithm on the input string.\n     *\n     * @param source\n     *            A String object to encode\n     * @param branching\n     *            If branching shall be performed\n     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the\n     *         selected branching mode\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Daitch-Mokotoff Soundex value.\n * <p>\n * The Daitch-Mokotoff Soundex algorithm is a refinement of the Russel and American Soundex algorithms, yielding greater\n * accuracy in matching especially Slavish and Yiddish surnames with similar pronunciation but differences in spelling.\n * </p>\n * <p>\n * The main differences compared to the other soundex variants are:\n * </p>\n * <ul>\n * <li>coded names are 6 digits long\n * <li>the initial character of the name is coded\n * <li>rules to encoded multi-character n-grams\n * <li>multiple possible encodings for the same name (branching)\n * </ul>\n * <p>\n * This implementation supports branching, depending on the used method:\n * <ul>\n * <li>{@link #encode(String)} - branching disabled, only the first code will be returned\n * <li>{@link #soundex(String)} - branching enabled, all codes will be returned, separated by '|'\n * </ul>\n * <p>\n * Note: this implementation has additional branching rules compared to the original description of the algorithm. The\n * rules can be customized by overriding the default rules contained in the resource file\n * {@code org/apache/commons/codec/language/dmrules.txt}.\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see Soundex\n * @see <a href=\"https://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex\"> Wikipedia - Daitch-Mokotoff Soundex</a>\n * @see <a href=\"http://www.avotaynu.com/soundex.htm\">Avotaynu - Soundexing and Genealogy</a>\n *\n * @since 1.10\n "
    },
    "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch": {
      "fields": [
        {
          "variable_name": "builder",
          "variable_type": "java.lang.StringBuilder"
        },
        {
          "variable_name": "cachedString",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "lastReplacement",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [
        {
          "body": "private Branch()\n{\r\n    builder = new StringBuilder();\r\n    lastReplacement = null;\r\n    cachedString = null;\r\n}",
          "signature": "Branch()",
          "parameters": []
        }
      ],
      "methods": {
        "createBranch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "toString()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "public Branch createBranch()",
            "parameters": [],
            "javadoc": "\n         * Creates a new branch, identical to this branch.\n         *\n         * @return a new, identical branch\n         "
          }
        ],
        "equals": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "((Branch) other).toString()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean equals(Object)",
            "parameters": [
              {
                "variable_name": "other",
                "variable_type": "java.lang.Object"
              }
            ]
          }
        ],
        "finish": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "'0'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void finish()",
            "parameters": [],
            "javadoc": "\n         * Finish this branch by appending '0's until the maximum code length has been reached.\n         "
          }
        ],
        "hashCode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.hashCode()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Branch.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public int hashCode()",
            "parameters": []
          }
        ],
        "processNextReplacement": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.delete(int, int)",
                "arguments": [
                  {
                    "variable_name": "MAX_LENGTH",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "builder.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "replacement",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "replacement",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void processNextReplacement(String, boolean)",
            "parameters": [
              {
                "variable_name": "replacement",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "forceAppend",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n         * Process the next replacement to be added to this branch.\n         *\n         * @param replacement\n         *            the next replacement to append\n         * @param forceAppend\n         *            indicates if the default processing shall be overridden\n         "
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Inner class representing a branch during DM soundex encoding.\n     "
    },
    "org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule": {
      "fields": [
        {
          "variable_name": "pattern",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "replacementAtStart",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "replacementBeforeVowel",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "replacementDefault",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [
        {
          "body": "protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel, final String replacementDefault)\n{\r\n    this.pattern = pattern;\r\n    this.replacementAtStart = replacementAtStart.split(\"\\\\|\");\r\n    this.replacementBeforeVowel = replacementBeforeVowel.split(\"\\\\|\");\r\n    this.replacementDefault = replacementDefault.split(\"\\\\|\");\r\n}",
          "signature": "Rule(String, String, String, String)",
          "parameters": [
            {
              "variable_name": "pattern",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "replacementAtStart",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "replacementBeforeVowel",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "replacementDefault",
              "variable_type": "java.lang.String"
            }
          ]
        }
      ],
      "methods": {
        "getPatternLength": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public int getPatternLength()",
            "parameters": []
          }
        ],
        "getReplacements": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "nextIndex",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.getPatternLength()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.Rule.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "context.charAt(nextIndex)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public String[] getReplacements(String, boolean)",
            "parameters": [
              {
                "variable_name": "context",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "atStart",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "isVowel": [
          {
            "call_methods": [],
            "signature": "private boolean isVowel(char)",
            "parameters": [
              {
                "variable_name": "ch",
                "variable_type": "char"
              }
            ]
          }
        ],
        "matches": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "pattern",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean matches(String)",
            "parameters": [
              {
                "variable_name": "context",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"%s=(%s,%s,%s)\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "pattern",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "Arrays.asList(replacementAtStart)",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "Arrays.asList(replacementBeforeVowel)",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "Arrays.asList(replacementDefault)",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "replacementAtStart",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Inner class for storing rules.\n     "
    },
    "org.apache.commons.codec.language.DoubleMetaphone": {
      "fields": [
        {
          "variable_name": "VOWELS",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SILENT_START",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "L_R_N_M_B_H_F_V_W_SPACE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "L_T_K_S_N_M_B_Z",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "maxCodeLen",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "contains": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "start",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "start + length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "protected static boolean contains(String, int, int, String...)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "start",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "criteria",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "charAt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "protected char charAt(String, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ]
          }
        ],
        "cleanInput": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.trim()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "java.util.Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "private String cleanInput(String)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Cleans the input.\n     "
          }
        ],
        "conditionC0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"CHIA\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "charAt(value, index - 2)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private boolean conditionC0(String, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Complex condition 0 for 'C'.\n     "
          }
        ],
        "conditionCH0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"HARAC\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"HARIS\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private boolean conditionCH0(String, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Complex condition 0 for 'CH'.\n     "
          }
        ],
        "conditionCH1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"VAN \"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"VON \"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private boolean conditionCH1(String, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Complex condition 1 for 'CH'.\n     "
          }
        ],
        "conditionL0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"ILLO\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"ILLA\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"ALLE\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private boolean conditionL0(String, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Complex condition 0 for 'L'.\n     "
          }
        ],
        "conditionM0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"UMB\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private boolean conditionM0(String, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Complex condition 0 for 'M'.\n     "
          }
        ],
        "doubleMetaphone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String doubleMetaphone(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encode a value with Double Metaphone.\n     *\n     * @param value String to encode\n     * @return an encoded string\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleR(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "slavoGermanic",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleAEIOUY(org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'P'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleP(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleS(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "slavoGermanic",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionM0(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleZ(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "slavoGermanic",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleX(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.isComplete()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleJ(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "slavoGermanic",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isSlavoGermanic(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleW(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getAlternate()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.cleanInput(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.getMaxCodeLen()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleT(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.getPrimary()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleG(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "slavoGermanic",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleL(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleD(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isSilentStart(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public String doubleMetaphone(String, boolean)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "alternate",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encode the value using DoubleMetaphone.  It will only work if\n     * {@code obj} is a {@code String} (like {@code Metaphone}).\n     *\n     * @param obj Object to encode (should be of type String)\n     * @return An encoded Object (will be of type String)\n     * @throws EncoderException encode parameter is not of type String\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String\n     "
          }
        ],
        "getMaxCodeLen": [
          {
            "call_methods": [],
            "signature": "public int getMaxCodeLen()",
            "parameters": [],
            "javadoc": "\n     * Returns the maxCodeLen.\n     * @return int\n     "
          }
        ],
        "handleAEIOUY": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'A'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleAEIOUY(DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\n     "
          }
        ],
        "handleC": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "6",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"CAESAR\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'S'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'X'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionC0(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleCC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'K'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleCH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private int handleC(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'C' cases.\n     "
          }
        ],
        "handleCC": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"I\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"E\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"H\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'X'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"KS\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleCC(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'CC' cases.\n     "
          }
        ],
        "handleCH": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"CHAE\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'K'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'X'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionCH0(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'K'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionCH1(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private int handleCH(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'CH' cases.\n     "
          }
        ],
        "handleD": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"DG\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'J'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"TK\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleD(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'D' cases.\n     "
          }
        ],
        "handleG": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"EY\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'K'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'J'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleGH(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "charAt(value, 0)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"KN\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"N\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'K'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"KN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleG(String, DoubleMetaphoneResult, int, boolean)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "slavoGermanic",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Handles 'G' cases.\n     "
          }
        ],
        "handleGH": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"B\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"H\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"D\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "charAt(value, index - 1)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'K'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleGH(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'GH' cases.\n     "
          }
        ],
        "handleH": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "charAt(value, index - 1)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'H'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleH(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'H' cases.\n     "
          }
        ],
        "handleJ": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"JOSE\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'J'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'H'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "charAt(value, index - 1)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'H'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private int handleJ(String, DoubleMetaphoneResult, int, boolean)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "slavoGermanic",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Handles 'J' cases.\n     "
          }
        ],
        "handleL": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char)",
                "arguments": [
                  {
                    "variable_name": "'L'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.conditionL0(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'L'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleL(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'L' cases.\n     "
          }
        ],
        "handleP": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"P\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"B\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'F'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleP(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'P' cases.\n     "
          }
        ],
        "handleR": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)",
                "arguments": [
                  {
                    "variable_name": "'R'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"IE\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'R'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private int handleR(String, DoubleMetaphoneResult, int, boolean)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "slavoGermanic",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Handles 'R' cases.\n     "
          }
        ],
        "handleS": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)",
                "arguments": [
                  {
                    "variable_name": "'S'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"ISL\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"YSL\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'X'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'S'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'S'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.handleSC(java.lang.String, org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private int handleS(String, DoubleMetaphoneResult, int, boolean)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "slavoGermanic",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Handles 'S' cases.\n     "
          }
        ],
        "handleSC": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"OO\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"ER\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"EN\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"UY\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"ED\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"EM\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'X'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'S'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"X\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"SK\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "charAt(value, 3)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'X'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SK\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleSC(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'SC' cases.\n     "
          }
        ],
        "handleT": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"TION\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'0'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'T'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'X'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleT(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'T' cases.\n     "
          }
        ],
        "handleW": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)",
                "arguments": [
                  {
                    "variable_name": "'F'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"WR\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char, char)",
                "arguments": [
                  {
                    "variable_name": "'A'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'F'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "charAt(value, index + 1)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"TS\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"FX\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'R'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private int handleW(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'W' cases.\n     "
          }
        ],
        "handleX": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index - 3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"IAU\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"EAU\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'S'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"KS\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private int handleX(String, DoubleMetaphoneResult, int)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Handles 'X' cases.\n     "
          }
        ],
        "handleZ": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.contains(java.lang.String, int, int, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"ZO\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"ZI\"",
                    "variable_type": "java.lang.String..."
                  },
                  {
                    "variable_name": "\"ZA\"",
                    "variable_type": "java.lang.String..."
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.charAt(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"S\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"TS\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.append(char)",
                "arguments": [
                  {
                    "variable_name": "'J'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private int handleZ(String, DoubleMetaphoneResult, int, boolean)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "result",
                "variable_type": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "slavoGermanic",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Handles 'Z' cases.\n     "
          }
        ],
        "isDoubleMetaphoneEqual": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "value1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "value2",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isDoubleMetaphoneEqual(String, String)",
            "parameters": [
              {
                "variable_name": "value1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "value2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Check if the Double Metaphone values of two {@code String} values\n     * are equal.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @return {@code true} if the encoded {@code String}s are equal;\n     *          {@code false} otherwise.\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.equals(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "doubleMetaphone(value1, alternate)",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "doubleMetaphone(value2, alternate)",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "value1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "alternate",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public boolean isDoubleMetaphoneEqual(String, String, boolean)",
            "parameters": [
              {
                "variable_name": "value1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "value2",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "alternate",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Check if the Double Metaphone values of two {@code String} values\n     * are equal, optionally using the alternate value.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if {@code true}.\n     * @return {@code true} if the encoded {@code String}s are equal;\n     *          {@code false} otherwise.\n     "
          }
        ],
        "isSilentStart": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private boolean isSilentStart(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Determines whether or not the value starts with a silent letter.  It will\n     * return {@code true} if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'.\n     "
          }
        ],
        "isSlavoGermanic": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.indexOf(int)",
                "arguments": [
                  {
                    "variable_name": "'W'",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"CZ\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private boolean isSlavoGermanic(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Determines whether or not a value is of slavo-germanic origin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n     "
          }
        ],
        "isVowel": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.indexOf(int)",
                "arguments": [
                  {
                    "variable_name": "ch",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private boolean isVowel(char)",
            "parameters": [
              {
                "variable_name": "ch",
                "variable_type": "char"
              }
            ],
            "javadoc": "\n     * Determines whether or not a character is a vowel or not\n     "
          }
        ],
        "setMaxCodeLen": [
          {
            "call_methods": [],
            "signature": "public void setMaxCodeLen(int)",
            "parameters": [
              {
                "variable_name": "maxCodeLen",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence\n * Philips</CITE>.\n * <p>\n * This class is conditionally thread-safe. The instance field for the maximum code length is mutable\n * {@link #setMaxCodeLen(int)} but is not volatile, and accesses are not synchronized. If an instance of the class is\n * shared between threads, the caller needs to ensure that suitable synchronization is used to ensure safe publication\n * of the value between threads, and must not invoke {@link #setMaxCodeLen(int)} after initial setup.\n * </p>\n *\n * @see <a href=\"https://drdobbs.com/the-double-metaphone-search-algorithm/184401251?pgno=2\">Dr. Dobbs Original Article</a>\n * @see <a href=\"https://en.wikipedia.org/wiki/Metaphone\">Wikipedia Metaphone</a>\n "
    },
    "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult": {
      "fields": [
        {
          "variable_name": "primary",
          "variable_type": "java.lang.StringBuilder"
        },
        {
          "variable_name": "alternate",
          "variable_type": "java.lang.StringBuilder"
        },
        {
          "variable_name": "maxLength",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public DoubleMetaphoneResult(final int maxLength)\n{\r\n    this.maxLength = maxLength;\r\n}",
          "signature": "DoubleMetaphoneResult(int)",
          "parameters": [
            {
              "variable_name": "maxLength",
              "variable_type": "int"
            }
          ]
        }
      ],
      "methods": {
        "append": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void append(char)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "char"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(char)",
                "arguments": [
                  {
                    "variable_name": "alternate",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(char)",
                "arguments": [
                  {
                    "variable_name": "primary",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void append(char, char)",
            "parameters": [
              {
                "variable_name": "primary",
                "variable_type": "char"
              },
              {
                "variable_name": "alternate",
                "variable_type": "char"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void append(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendPrimary(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "primary",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.DoubleMetaphoneResult.appendAlternate(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "alternate",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void append(String, String)",
            "parameters": [
              {
                "variable_name": "primary",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "alternate",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "appendAlternate": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void appendAlternate(char)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "char"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.CharSequence, int, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "addChars",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void appendAlternate(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "appendPrimary": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void appendPrimary(char)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "char"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.CharSequence, int, int)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "addChars",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void appendPrimary(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getAlternate": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String getAlternate()",
            "parameters": []
          }
        ],
        "getPrimary": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String getPrimary()",
            "parameters": []
          }
        ],
        "isComplete": [
          {
            "call_methods": [
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public boolean isComplete()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Inner class for storing results, since there is the optional alternate encoding.\n     "
    },
    "org.apache.commons.codec.language.MatchRatingApproachEncoder": {
      "fields": [
        {
          "variable_name": "SPACE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "EMPTY",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "PLAIN_ASCII",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "UNICODE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "DOUBLE_CONSONANT",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "cleanName": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.replaceAll(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "EMPTY",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "upperName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": " String cleanName(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\n     * spaces.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to be cleaned\n     * @return The cleaned name\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) pObject",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final Object encode(Object)",
            "parameters": [
              {
                "variable_name": "pObject",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the Match Rating Approach algorithm. Method is here to satisfy the requirements of the\n     * Encoder interface Throws an EncoderException if input object is not of type {@link String}.\n     *\n     * @param pObject\n     *            Object to encode\n     * @return An object (or type {@link String}) containing the Match Rating Approach code which corresponds to the\n     *         String supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type {@link String}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.cleanName(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equalsIgnoreCase(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public final String encode(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the Match Rating Approach (MRA) algorithm.\n     *\n     * @param name\n     *            String object to encode\n     * @return The MRA code corresponding to the String supplied\n     "
          }
        ],
        "getFirst3Last3": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " String getFirst3Last3(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The string to get the substrings from\n     * @return Annexed first and last 3 letters of input word.\n     "
          }
        ],
        "getMinRating": [
          {
            "call_methods": [],
            "signature": " int getMinRating(int)",
            "parameters": [
              {
                "variable_name": "sumLength",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\n     * min rating. Values strictly from documentation.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param sumLength\n     *            The length of 2 strings sent down\n     * @return The min rating value\n     "
          }
        ],
        "isEncodeEquals": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.cleanName(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Math.abs(int)",
                "arguments": [
                  {
                    "variable_name": "name1.length() - name2.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "name2",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "sumLength",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.equalsIgnoreCase(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public boolean isEncodeEquals(String, String)",
            "parameters": [
              {
                "variable_name": "name1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "name2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\n     * strings are cleaned in the same way as {@link #encode(String)}.\n     *\n     * @param name1\n     *            First of the 2 strings (names) to compare\n     * @param name2\n     *            Second of the 2 names to compare\n     * @return {@code true} if the encodings are identical {@code false} otherwise.\n     "
          }
        ],
        "isVowel": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.equalsIgnoreCase(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"E\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": " boolean isVowel(String)",
            "parameters": [
              {
                "variable_name": "letter",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Determines if a letter is a vowel.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param letter\n     *            The letter under investigation\n     * @return True if a vowel, else false\n     "
          }
        ],
        "leftToRightThenRightToLeftProcessing": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Math.abs(int)",
                "arguments": [
                  {
                    "variable_name": "6 - strA.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.replaceAll(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\\\s+\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "EMPTY",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "name2RtLStart",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " int leftToRightThenRightToLeftProcessing(String, String)",
            "parameters": [
              {
                "variable_name": "name1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "name2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Processes the names from left to right (first) then right to left removing identical letters in same positions.\n     * Then subtracts the longer string that remains from 6 and returns this.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name1\n     *            name2\n     * @return the length as above\n     "
          }
        ],
        "removeAccents": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.String.indexOf(int)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "PLAIN_ASCII.charAt(pos)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " String removeAccents(String)",
            "parameters": [
              {
                "variable_name": "accentedWord",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Removes accented letters and replaces with non-accented ASCII equivalent Case is preserved.\n     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\n     *\n     * @param accentedWord\n     *            The word that may have accents in it.\n     * @return De-accented word\n     "
          }
        ],
        "removeDoubleConsonants": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "dc",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "singleLetter",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "dc",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": " String removeDoubleConsonants(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Replaces any double consonant pair with the single letter equivalent.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            String to have double consonants removed\n     * @return Single consonant word\n     "
          }
        ],
        "removeVowels": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "firstLetter",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.replaceAll(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\\\s{2,}\\\\b\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "SPACE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"A\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "EMPTY",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": " String removeVowels(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Deletes all vowels unless the vowel begins the word.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to have vowels removed\n     * @return De-voweled word\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Match Rating Approach Phonetic Algorithm Developed by <CITE>Western Airlines</CITE> in 1977.\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Match_rating_approach\">Wikipedia - Match Rating Approach</a>\n * @since 1.8\n "
    },
    "org.apache.commons.codec.language.Metaphone": {
      "fields": [
        {
          "variable_name": "VOWELS",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "FRONTV",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "VARSON",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "maxCodeLen",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the metaphone algorithm.  This method\n     * is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an EncoderException if the\n     * supplied object is not of type {@link String}.\n     *\n     * @param obj Object to encode\n     * @return An object (or type {@link String}) containing the\n     *         metaphone code which corresponds to the String supplied.\n     * @throws EncoderException if the parameter supplied is not\n     *                          of type {@link String}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the Metaphone algorithm.\n     *\n     * @param str String object to encode\n     * @return The metaphone code corresponding to the String supplied\n     "
          }
        ],
        "getMaxCodeLen": [
          {
            "call_methods": [],
            "signature": "public int getMaxCodeLen()",
            "parameters": [],
            "javadoc": "\n     * Returns the maxCodeLen.\n     * @return int\n     "
          }
        ],
        "isLastChar": [
          {
            "call_methods": [],
            "signature": "private boolean isLastChar(int, int)",
            "parameters": [
              {
                "variable_name": "wdsz",
                "variable_type": "int"
              },
              {
                "variable_name": "n",
                "variable_type": "int"
              }
            ]
          }
        ],
        "isMetaphoneEqual": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "metaphone(str2)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public boolean isMetaphoneEqual(String, String)",
            "parameters": [
              {
                "variable_name": "str1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "str2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return {@code true} if the metaphones of these strings are identical,\n     *        {@code false} otherwise.\n     "
          }
        ],
        "isNextChar": [
          {
            "call_methods": [
              {
                "signature": "java.lang.AbstractStringBuilder.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private boolean isNextChar(StringBuilder, int, char)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.StringBuilder"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "c",
                "variable_type": "char"
              }
            ]
          }
        ],
        "isPreviousChar": [
          {
            "call_methods": [
              {
                "signature": "java.lang.AbstractStringBuilder.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private boolean isPreviousChar(StringBuilder, int, char)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.StringBuilder"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "c",
                "variable_type": "char"
              }
            ]
          }
        ],
        "isVowel": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.indexOf(int)",
                "arguments": [
                  {
                    "variable_name": "string.charAt(index)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              }
            ],
            "signature": "private boolean isVowel(StringBuilder, int)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.StringBuilder"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              }
            ]
          }
        ],
        "metaphone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.isNextChar(java.lang.StringBuilder, int, char)",
                "arguments": [
                  {
                    "variable_name": "local",
                    "variable_type": "java.lang.StringBuilder"
                  },
                  {
                    "variable_name": "n",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "'H'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.isLastChar(int, int)",
                "arguments": [
                  {
                    "variable_name": "wdsz",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "n",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.StringBuilder.append(char[])",
                "arguments": [
                  {
                    "variable_name": "inwd",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.isVowel(java.lang.StringBuilder, int)",
                "arguments": [
                  {
                    "variable_name": "local",
                    "variable_type": "java.lang.StringBuilder"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.setCharAt(int, char)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "'W'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.regionMatch(java.lang.StringBuilder, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "local",
                    "variable_type": "java.lang.StringBuilder"
                  },
                  {
                    "variable_name": "n",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"CIA\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "n",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.String.indexOf(int)",
                "arguments": [
                  {
                    "variable_name": "local.charAt(n + 1)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.getMaxCodeLen()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "java.util.Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "symb",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.setLength(int)",
                "arguments": [
                  {
                    "variable_name": "this.getMaxCodeLen()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.StringBuilder.append(char[], int, int)",
                "arguments": [
                  {
                    "variable_name": "inwd",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "inwd.length - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.isPreviousChar(java.lang.StringBuilder, int, char)",
                "arguments": [
                  {
                    "variable_name": "local",
                    "variable_type": "java.lang.StringBuilder"
                  },
                  {
                    "variable_name": "n",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "symb",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public String metaphone(String)",
            "parameters": [
              {
                "variable_name": "txt",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied\n     "
          }
        ],
        "regionMatch": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "index + test.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private boolean regionMatch(StringBuilder, int, String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.StringBuilder"
              },
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "test",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "setMaxCodeLen": [
          {
            "call_methods": [],
            "signature": "public void setMaxCodeLen(int)",
            "parameters": [
              {
                "variable_name": "maxCodeLen",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Metaphone value.\n * <p>\n * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>.\n * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.\n * </p>\n * <p>\n * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990,\n * p 39.</CITE>\n * </p>\n * <p>\n * Note, that this does not match the algorithm that ships with PHP, or the algorithm found in the Perl implementations:\n * </p>\n * <ul>\n * <li><a href=\"https://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm\">Text:Metaphone-1.96</a>\n *  (broken link 4/30/2013) </li>\n * <li><a href=\"https://metacpan.org/source/MSCHWERN/Text-Metaphone-1.96//Metaphone.pm\">Text:Metaphone-1.96</a>\n *  (link checked 4/30/2013) </li>\n * </ul>\n * <p>\n * They have had undocumented changes from the originally published algorithm.\n * For more information, see <a href=\"https://issues.apache.org/jira/browse/CODEC-57\">CODEC-57</a>.\n * </p>\n * <p>\n * This class is conditionally thread-safe.\n * The instance field for maximum code length is mutable {@link #setMaxCodeLen(int)}\n * but is not volatile, and accesses are not synchronized.\n * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization\n * is used to ensure safe publication of the value between threads, and must not invoke {@link #setMaxCodeLen(int)}\n * after initial setup.\n * </p>\n "
    },
    "org.apache.commons.codec.language.Nysiis": {
      "fields": [
        {
          "variable_name": "CHARS_A",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_AF",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_C",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_FF",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_G",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_N",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_NN",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_S",
          "variable_type": "char"
        },
        {
          "variable_name": "CHARS_SSS",
          "variable_type": "char"
        },
        {
          "variable_name": "PAT_MAC",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "PAT_KN",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "PAT_K",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "PAT_PH_PF",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "PAT_SCH",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "PAT_EE_IE",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "PAT_DT_ETC",
          "variable_type": "java.util.regex.Pattern"
        },
        {
          "variable_name": "SPACE",
          "variable_type": "char"
        },
        {
          "variable_name": "TRUE_LENGTH",
          "variable_type": "int"
        },
        {
          "variable_name": "strict",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public Nysiis()\n{\r\n    this(true);\r\n}",
          "signature": "Nysiis()",
          "parameters": [],
          "javadoc": "\n     * Creates an instance of the {@link Nysiis} encoder with strict mode (original form),\n     * i.e. encoded strings have a maximum length of 6.\n     "
        },
        {
          "body": "public Nysiis(final boolean strict)\n{\r\n    this.strict = strict;\r\n}",
          "signature": "Nysiis(boolean)",
          "parameters": [
            {
              "variable_name": "strict",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Create an instance of the {@link Nysiis} encoder with the specified strict mode:\n     *\n     * <ul>\n     *  <li>{@code true}: encoded strings have a maximum length of 6</li>\n     *  <li>{@code false}: encoded strings may have arbitrary length</li>\n     * </ul>\n     *\n     * @param strict\n     *            the strict mode\n     "
        }
      ],
      "methods": {
        "isVowel": [
          {
            "call_methods": [],
            "signature": "private static boolean isVowel(char)",
            "parameters": [
              {
                "variable_name": "c",
                "variable_type": "char"
              }
            ],
            "javadoc": "\n     * Tests if the given character is a vowel.\n     *\n     * @param c\n     *            the character to test\n     * @return {@code true} if the character is a vowel, {@code false} otherwise\n     "
          }
        ],
        "transcodeRemaining": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Nysiis.isVowel(char)",
                "arguments": [
                  {
                    "variable_name": "curr",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private static char[] transcodeRemaining(char, char, char, char)",
            "parameters": [
              {
                "variable_name": "prev",
                "variable_type": "char"
              },
              {
                "variable_name": "curr",
                "variable_type": "char"
              },
              {
                "variable_name": "next",
                "variable_type": "char"
              },
              {
                "variable_name": "aNext",
                "variable_type": "char"
              }
            ],
            "javadoc": "\n     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\n     * a time: [i-1, i, i+1, i+2].\n     *\n     * @param prev\n     *            the previous character\n     * @param curr\n     *            the current character\n     * @param next\n     *            the next character\n     * @param aNext\n     *            the after next character\n     * @return a transcoded array of characters, starting from the current position\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Nysiis.nysiis(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the NYSIIS algorithm. This method is provided in order to satisfy the requirements of the\n     * Encoder interface, and will throw an {@link EncoderException} if the supplied object is not of type\n     * {@link String}.\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (or a {@link String}) containing the NYSIIS code which corresponds to the given String.\n     * @throws EncoderException\n     *            if the parameter supplied is not of a {@link String}\n     * @throws IllegalArgumentException\n     *            if a character is not mapped\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Nysiis.nysiis(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the NYSIIS algorithm.\n     *\n     * @param str\n     *            A String object to encode\n     * @return A Nysiis code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *            if a character is not mapped\n     "
          }
        ],
        "isStrict": [
          {
            "call_methods": [],
            "signature": "public boolean isStrict()",
            "parameters": [],
            "javadoc": "\n     * Indicates the strict mode for this {@link Nysiis} encoder.\n     *\n     * @return {@code true} if the encoder is configured for strict mode, {@code false} otherwise\n     "
          }
        ],
        "nysiis": [
          {
            "call_methods": [
              {
                "signature": "java.util.regex.Pattern.matcher(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.util.regex.Matcher"
              },
              {
                "signature": "org.apache.commons.codec.language.Nysiis.isStrict()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.regex.Matcher.replaceFirst(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"MCC\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.Nysiis.transcodeRemaining(char, char, char, char)",
                "arguments": [
                  {
                    "variable_name": "chars[i - 1]",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "chars[i]",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "next",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "aNext",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.clean(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "TRUE_LENGTH",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "string.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "transcoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "chars",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "transcoded.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "key.length() - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.StringBuilder.deleteCharAt(int)",
                "arguments": [
                  {
                    "variable_name": "key.length() - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "str.charAt(0)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "Math.min(TRUE_LENGTH, string.length())",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public String nysiis(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Retrieves the NYSIIS code for a given String object.\n     *\n     * @param str\n     *            String to encode using the NYSIIS algorithm\n     * @return A NYSIIS code for the String supplied\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a NYSIIS value. NYSIIS is an encoding used to relate similar names, but can also be used as a\n * general purpose scheme to find word with similar phonemes.\n * <p>\n * NYSIIS features an accuracy increase of 2.7% over the traditional Soundex algorithm.\n * </p>\n * <p>\n * Algorithm description:\n * </p>\n * <pre>\n * 1. Transcode first characters of name\n *   1a. MAC -&gt;   MCC\n *   1b. KN  -&gt;   NN\n *   1c. K   -&gt;   C\n *   1d. PH  -&gt;   FF\n *   1e. PF  -&gt;   FF\n *   1f. SCH -&gt;   SSS\n * 2. Transcode last characters of name\n *   2a. EE, IE          -&gt;   Y\n *   2b. DT,RT,RD,NT,ND  -&gt;   D\n * 3. First character of key = first character of name\n * 4. Transcode remaining characters by following these rules, incrementing by one character each time\n *   4a. EV  -&gt;   AF  else A,E,I,O,U -&gt; A\n *   4b. Q   -&gt;   G\n *   4c. Z   -&gt;   S\n *   4d. M   -&gt;   N\n *   4e. KN  -&gt;   N   else K -&gt; C\n *   4f. SCH -&gt;   SSS\n *   4g. PH  -&gt;   FF\n *   4h. H   -&gt;   If previous or next is non-vowel, previous\n *   4i. W   -&gt;   If previous is vowel, previous\n *   4j. Add current to key if current != last key character\n * 5. If last character is S, remove it\n * 6. If last characters are AY, replace with Y\n * 7. If last character is A, remove it\n * 8. Collapse all strings of repeated characters\n * 9. Add original first character of name as first character of key\n * </pre>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/NYSIIS\">NYSIIS on Wikipedia</a>\n * @see <a href=\"http://www.dropby.com/NYSIIS.html\">NYSIIS on dropby.com</a>\n * @see Soundex\n * @since 1.7\n "
    },
    "org.apache.commons.codec.language.RefinedSoundex": {
      "fields": [
        {
          "variable_name": "US_ENGLISH_MAPPING_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "US_ENGLISH_MAPPING",
          "variable_type": "char"
        },
        {
          "variable_name": "US_ENGLISH",
          "variable_type": "org.apache.commons.codec.language.RefinedSoundex"
        },
        {
          "variable_name": "soundexMapping",
          "variable_type": "char"
        }
      ],
      "constructors": [
        {
          "body": "public RefinedSoundex()\n{\r\n    this.soundexMapping = US_ENGLISH_MAPPING;\r\n}",
          "signature": "RefinedSoundex()",
          "parameters": [],
          "javadoc": "\n     * Creates an instance of the RefinedSoundex object using the default US\n     * English mapping.\n     "
        },
        {
          "body": "public RefinedSoundex(final char[] mapping)\n{\r\n    this.soundexMapping = mapping.clone();\r\n}",
          "signature": "RefinedSoundex(char[])",
          "parameters": [
            {
              "variable_name": "mapping",
              "variable_type": "char[]"
            }
          ],
          "javadoc": "\n     * Creates a refined soundex instance using a custom mapping. This\n     * constructor can be used to customize the mapping, and/or possibly\n     * provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for\n     *                  a given character\n     "
        },
        {
          "body": "public RefinedSoundex(final String mapping)\n{\r\n    this.soundexMapping = mapping.toCharArray();\r\n}",
          "signature": "RefinedSoundex(String)",
          "parameters": [
            {
              "variable_name": "mapping",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     "
        }
      ],
      "methods": {
        "difference": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.difference(org.apache.commons.codec.StringEncoder, java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "this",
                    "variable_type": "org.apache.commons.codec.StringEncoder"
                  },
                  {
                    "variable_name": "s1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "s2",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public int difference(String, String)",
            "parameters": [
              {
                "variable_name": "s1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "s2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns the number of characters in the two encoded Strings that are the\n     * same. This return value ranges from 0 to the length of the shortest\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n     * example) indicates strong similarity or identical values. For refined\n     * Soundex, the return value can be greater than 4.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the\n     *             same from 0 to the length of the shortest encoded String.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the refined soundex algorithm. This method is\n     * provided in order to satisfy the requirements of the Encoder interface,\n     * and will throw an EncoderException if the supplied object is not of type\n     * {@link String}.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type {@link String}) containing the refined\n     *             soundex code which corresponds to the String supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type {@link String}\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the refined soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     "
          }
        ],
        "getMappingCode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Character.toUpperCase(char)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.Character.isLetter(char)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": " char getMappingCode(char)",
            "parameters": [
              {
                "variable_name": "c",
                "variable_type": "char"
              }
            ],
            "javadoc": "\n     * Returns the mapping code for a given character. The mapping codes are\n     * maintained in an internal char array named soundexMapping, and the\n     * default values of these mappings are US English.\n     *\n     * @param c\n     *                  char to get mapping for\n     * @return A character (really a numeral) to return for the given char\n     "
          }
        ],
        "soundex": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.getMappingCode(char)",
                "arguments": [
                  {
                    "variable_name": "str.charAt(i)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "str.charAt(0)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.clean(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public String soundex(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Retrieves the Refined Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Refined Soundex algorithm\n     * @return A soundex code for the String supplied\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Refined Soundex value. A refined soundex code is\n * optimized for spell checking words. Soundex method originally developed by\n * <CITE>Margaret Odell</CITE> and <CITE>Robert Russell</CITE>.\n *\n * <p>This class is immutable and thread-safe.</p>\n "
    },
    "org.apache.commons.codec.language.Soundex": {
      "fields": [
        {
          "variable_name": "SILENT_MARKER",
          "variable_type": "char"
        },
        {
          "variable_name": "US_ENGLISH_MAPPING_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "US_ENGLISH_MAPPING",
          "variable_type": "char"
        },
        {
          "variable_name": "US_ENGLISH",
          "variable_type": "org.apache.commons.codec.language.Soundex"
        },
        {
          "variable_name": "US_ENGLISH_SIMPLIFIED",
          "variable_type": "org.apache.commons.codec.language.Soundex"
        },
        {
          "variable_name": "US_ENGLISH_GENEALOGY",
          "variable_type": "org.apache.commons.codec.language.Soundex"
        },
        {
          "variable_name": "maxLength",
          "variable_type": "int"
        },
        {
          "variable_name": "soundexMapping",
          "variable_type": "char"
        },
        {
          "variable_name": "specialCaseHW",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public Soundex()\n{\r\n    this.soundexMapping = US_ENGLISH_MAPPING;\r\n    this.specialCaseHW = true;\r\n}",
          "signature": "Soundex()",
          "parameters": [],
          "javadoc": "\n     * Creates an instance using US_ENGLISH_MAPPING\n     *\n     * @see Soundex#Soundex(char[])\n     * @see Soundex#US_ENGLISH_MAPPING_STRING\n     "
        },
        {
          "body": "public Soundex(final char[] mapping)\n{\r\n    this.soundexMapping = mapping.clone();\r\n    this.specialCaseHW = !hasMarker(this.soundexMapping);\r\n}",
          "signature": "Soundex(char[])",
          "parameters": [
            {
              "variable_name": "mapping",
              "variable_type": "char[]"
            }
          ],
          "javadoc": "\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\n     * mapping for a non-Western character set.\n     * <p>\n     * Every letter of the alphabet is \"mapped\" to a numerical value. This char array holds the values to which each\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\n     * </p>\n     * <p>\n     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment\n     * </p>\n     *\n     * @param mapping\n     *                  Mapping array to use when finding the corresponding code for a given character\n     "
        },
        {
          "body": "public Soundex(final String mapping)\n{\r\n    this.soundexMapping = mapping.toCharArray();\r\n    this.specialCaseHW = !hasMarker(this.soundexMapping);\r\n}",
          "signature": "Soundex(String)",
          "parameters": [
            {
              "variable_name": "mapping",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     * <p>\n     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment\n     * </p>\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @since 1.4\n     "
        },
        {
          "body": "public Soundex(final String mapping, final boolean specialCaseHW)\n{\r\n    this.soundexMapping = mapping.toCharArray();\r\n    this.specialCaseHW = specialCaseHW;\r\n}",
          "signature": "Soundex(String, boolean)",
          "parameters": [
            {
              "variable_name": "mapping",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "specialCaseHW",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\n     *\n     * @param mapping\n     *            Mapping string to use when finding the corresponding code for a given character\n     * @param specialCaseHW if true, then\n     * @since 1.11\n     "
        }
      ],
      "methods": {
        "difference": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.difference(org.apache.commons.codec.StringEncoder, java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "this",
                    "variable_type": "org.apache.commons.codec.StringEncoder"
                  },
                  {
                    "variable_name": "s1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "s2",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public int difference(String, String)",
            "parameters": [
              {
                "variable_name": "s1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "s2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type {@link String}.\n     *\n     * @param obj\n     *                  Object to encode\n     * @return An object (or type {@link String}) containing the soundex code which corresponds to the String\n     *             supplied.\n     * @throws EncoderException\n     *                  if the parameter supplied is not of type {@link String}\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String using the soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     "
          }
        ],
        "getMaxLength": [
          {
            "call_methods": [],
            "signature": "public int getMaxLength()",
            "parameters": [],
            "javadoc": "\n     * Returns the maxLength. Standard Soundex\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int\n     "
          }
        ],
        "hasMarker": [
          {
            "call_methods": [],
            "signature": "private boolean hasMarker(char[])",
            "parameters": [
              {
                "variable_name": "mapping",
                "variable_type": "char[]"
              }
            ]
          }
        ],
        "map": [
          {
            "call_methods": [],
            "signature": "private char map(char)",
            "parameters": [
              {
                "variable_name": "ch",
                "variable_type": "char"
              }
            ],
            "javadoc": "\n     * Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if {@code ch} is not mapped.\n     "
          }
        ],
        "setMaxLength": [
          {
            "call_methods": [],
            "signature": "public void setMaxLength(int)",
            "parameters": [
              {
                "variable_name": "maxLength",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Sets the maxLength.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set\n     "
          }
        ],
        "soundex": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.Soundex.map(char)",
                "arguments": [
                  {
                    "variable_name": "first",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.clean(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public String soundex(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a\n * general purpose scheme to find word with similar phonemes.\n *\n * <p>This class is thread-safe.\n * Although not strictly immutable, the mutable fields are not actually used.</p>\n "
    },
    "org.apache.commons.codec.language.SoundexUtils": {
      "fields": [],
      "constructors": [],
      "methods": {
        "clean": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.isEmpty(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "java.util.Locale.ENGLISH",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Character.isLetter(char)",
                "arguments": [
                  {
                    "variable_name": "str.charAt(i)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " static String clean(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Cleans up the input string before Soundex processing by only returning\n     * upper case letters.\n     *\n     * @param str\n     *                  The String to clean.\n     * @return A clean String.\n     "
          }
        ],
        "difference": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.differenceEncoded(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoder.encode(s1)",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "encoder.encode(s2)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": " static int difference(StringEncoder, String, String)",
            "parameters": [
              {
                "variable_name": "encoder",
                "variable_type": "org.apache.commons.codec.StringEncoder"
              },
              {
                "variable_name": "s1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "s2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the Strings and returns the number of characters in the two\n     * encoded Strings that are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param encoder\n     *                  The encoder to use to encode the Strings.\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see #differenceEncoded(String,String)\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     "
          }
        ],
        "differenceEncoded": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.Math.min(int, int)",
                "arguments": [
                  {
                    "variable_name": "es1.length()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "es2.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " static int differenceEncoded(String, String)",
            "parameters": [
              {
                "variable_name": "es1",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "es2",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Returns the number of characters in the two Soundex encoded Strings that\n     * are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param es1\n     *                  An encoded String.\n     * @param es2\n     *                  An encoded String.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     "
          }
        ],
        "isEmpty": [
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": " static boolean isEmpty(CharSequence)",
            "parameters": [
              {
                "variable_name": "cs",
                "variable_type": "java.lang.CharSequence"
              }
            ],
            "javadoc": "\n     * <p>Checks if a CharSequence is empty (\"\") or null.</p>\n     *\n     * <pre>\n     * StringUtils.isEmpty(null)      = true\n     * StringUtils.isEmpty(\"\")        = true\n     * StringUtils.isEmpty(\" \")       = false\n     * StringUtils.isEmpty(\"bob\")     = false\n     * StringUtils.isEmpty(\"  bob  \") = false\n     * </pre>\n     *\n     * @param cs  the CharSequence to check, may be null\n     * @return {@code true} if the CharSequence is empty or null\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @since 1.3\n "
    },
    "org.apache.commons.codec.net.BCodec": {
      "fields": [
        {
          "variable_name": "DECODING_POLICY_DEFAULT",
          "variable_type": "org.apache.commons.codec.CodecPolicy"
        },
        {
          "variable_name": "decodingPolicy",
          "variable_type": "org.apache.commons.codec.CodecPolicy"
        }
      ],
      "constructors": [
        {
          "body": "public BCodec()\n{\r\n    this(StandardCharsets.UTF_8);\r\n}",
          "signature": "BCodec()",
          "parameters": [],
          "javadoc": "\n     * Default constructor.\n     "
        },
        {
          "body": "public BCodec(final Charset charset)\n{\r\n    this(charset, DECODING_POLICY_DEFAULT);\r\n}",
          "signature": "BCodec(Charset)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.nio.charset.Charset"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset\n     *\n     * @param charset\n     *            the default string Charset to use.\n     *\n     * @see Charset\n     * @since 1.7\n     "
        },
        {
          "body": "public BCodec(final Charset charset, final CodecPolicy decodingPolicy)\n{\r\n    super(charset);\r\n    this.decodingPolicy = decodingPolicy;\r\n}",
          "signature": "BCodec(Charset, CodecPolicy)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.nio.charset.Charset"
            },
            {
              "variable_name": "decodingPolicy",
              "variable_type": "org.apache.commons.codec.CodecPolicy"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset.\n     *\n     * @param charset\n     *            the default string Charset to use.\n     * @param decodingPolicy The decoding policy.\n     *\n     * @see Charset\n     * @since 1.15\n     "
        },
        {
          "body": "public BCodec(final String charsetName)\n{\r\n    this(Charset.forName(charsetName));\r\n}",
          "signature": "BCodec(String)",
          "parameters": [
            {
              "variable_name": "charsetName",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset\n     *\n     * @param charsetName\n     *            the default Charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named Charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named Charset is unavailable\n     * @see Charset\n     "
        }
      ],
      "methods": {
        "decode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes a Base64 object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param value\n     *            Base64 object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a {@code String}. Thrown if a failure condition is encountered\n     *             during the decode process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.decodeText(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String decode(String)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a Base64 string into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param value\n     *            Base64 string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n     "
          }
        ],
        "doDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getChunkSeparator()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "protected byte[] doDecoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "doEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "protected byte[] doEncoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an object into its Base64 form using the default Charset. Unsafe characters are escaped.\n     *\n     * @param value\n     *            object to convert to Base64 form\n     * @return Base64 object\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "strSource",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "getCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "strSource",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its Base64 form using the default Charset. Unsafe characters are escaped.\n     *\n     * @param strSource\n     *            string to convert to Base64 form\n     * @return Base64 string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "strSource",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "sourceCharset",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String, Charset)",
            "parameters": [
              {
                "variable_name": "strSource",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Encodes a string into its Base64 form using the specified Charset. Unsafe characters are escaped.\n     *\n     * @param strSource\n     *            string to convert to Base64 form\n     * @param sourceCharset\n     *            the Charset for {@code value}\n     * @return Base64 string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "strSource",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "sourceCharset",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String, String)",
            "parameters": [
              {
                "variable_name": "strSource",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its Base64 form using the specified Charset. Unsafe characters are escaped.\n     *\n     * @param strSource\n     *            string to convert to Base64 form\n     * @param sourceCharset\n     *            the Charset for {@code value}\n     * @return Base64 string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     "
          }
        ],
        "getEncoding": [
          {
            "call_methods": [],
            "signature": "protected String getEncoding()",
            "parameters": []
          }
        ],
        "isStrictDecoding": [
          {
            "call_methods": [],
            "signature": "public boolean isStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Returns true if decoding behavior is strict. Decoding will raise a\n     * {@link DecoderException} if trailing bits are not part of a valid Base64 encoding.\n     *\n     * <p>The default is false for lenient encoding. Decoding will compose trailing bits\n     * into 8-bit bytes and discard the remainder.\n     *\n     * @return true if using strict decoding\n     * @since 1.15\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Identical to the Base64 encoding defined by <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a>\n * and allows a character set to be specified.\n * <p>\n * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\n * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\n * handling software.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\n *          Header Extensions for Non-ASCII Text</a>\n *\n * @since 1.3\n "
    },
    "org.apache.commons.codec.net.PercentCodec": {
      "fields": [
        {
          "variable_name": "ESCAPE_CHAR",
          "variable_type": "byte"
        },
        {
          "variable_name": "alwaysEncodeChars",
          "variable_type": "java.util.BitSet"
        },
        {
          "variable_name": "plusForSpace",
          "variable_type": "boolean"
        },
        {
          "variable_name": "alwaysEncodeCharsMin",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "public PercentCodec()\n{\r\n    this.plusForSpace = false;\r\n    insertAlwaysEncodeChar(ESCAPE_CHAR);\r\n}",
          "signature": "PercentCodec()",
          "parameters": [],
          "javadoc": "\n     * Constructs a Percent coded that will encode all the non US-ASCII characters using the Percent-Encoding\n     * while it will not encode all the US-ASCII characters, except for character '%' that is used as escape\n     * character for Percent-Encoding.\n     "
        },
        {
          "body": "public PercentCodec(final byte[] alwaysEncodeChars, final boolean plusForSpace)\n{\r\n    this.plusForSpace = plusForSpace;\r\n    insertAlwaysEncodeChars(alwaysEncodeChars);\r\n}",
          "signature": "PercentCodec(byte[], boolean)",
          "parameters": [
            {
              "variable_name": "alwaysEncodeChars",
              "variable_type": "byte[]"
            },
            {
              "variable_name": "plusForSpace",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructs a Percent codec by specifying the characters that belong to US-ASCII that should\n     * always be encoded. The rest US-ASCII characters will not be encoded, except for character '%' that\n     * is used as escape character for Percent-Encoding.\n     *\n     * @param alwaysEncodeChars the unsafe characters that should always be encoded\n     * @param plusForSpace      the flag defining if the space character should be encoded as '+'\n     "
        }
      ],
      "methods": {
        "canEncode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.inAlwaysEncodeCharsRange(byte)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.BitSet.get(int)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.isAsciiChar(byte)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private boolean canEncode(byte)",
            "parameters": [
              {
                "variable_name": "c",
                "variable_type": "byte"
              }
            ]
          }
        ],
        "containsSpace": [
          {
            "call_methods": [],
            "signature": "private boolean containsSpace(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.put(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) ((u << 4) + l)",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.expectedDecodingBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.Utils.digit16(byte)",
                "arguments": [
                  {
                    "variable_name": "bytes[++i]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "expectedDecodingBytes(bytes)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public byte[] decode(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes bytes encoded with Percent-Encoding based on RFC 3986. The reverse process is performed in order to\n     * decode the encoded characters to Unicode.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes a byte[] Object, whose bytes are encoded with Percent-Encoding.\n     *\n     * @param obj the object to decode\n     * @return the decoding result byte[] as Object\n     * @throws DecoderException if the object is not a byte array\n     "
          }
        ],
        "doEncode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.Utils.hexDigit(int)",
                "arguments": [
                  {
                    "variable_name": "bb >> 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.nio.ByteBuffer.put(byte)",
                "arguments": [
                  {
                    "variable_name": "ESCAPE_CHAR",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.canEncode(byte)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "expectedLength",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "private byte[] doEncode(byte[], int, boolean)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "expectedLength",
                "variable_type": "int"
              },
              {
                "variable_name": "willEncode",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.expectedEncodingBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.doEncode(byte[], int, boolean)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "expectedEncodingBytes",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "willEncode",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.containsSpace(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public byte[] encode(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Percent-Encoding based on RFC 3986. The non US-ASCII characters are encoded, as well as the\n     * US-ASCII characters that are configured to be always encoded.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an object into using the Percent-Encoding. Only byte[] objects are accepted.\n     *\n     * @param obj the object to encode\n     * @return the encoding result byte[] as Object\n     * @throws EncoderException if the object is not a byte array\n     "
          }
        ],
        "expectedDecodingBytes": [
          {
            "call_methods": [],
            "signature": "private int expectedDecodingBytes(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "expectedEncodingBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.canEncode(byte)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private int expectedEncodingBytes(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "inAlwaysEncodeCharsRange": [
          {
            "call_methods": [],
            "signature": "private boolean inAlwaysEncodeCharsRange(byte)",
            "parameters": [
              {
                "variable_name": "c",
                "variable_type": "byte"
              }
            ]
          }
        ],
        "insertAlwaysEncodeChar": [
          {
            "call_methods": [
              {
                "signature": "java.util.BitSet.set(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void insertAlwaysEncodeChar(byte)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Inserts a single character into a BitSet and maintains the min and max of the characters of the\n     * {@code BitSet alwaysEncodeChars} in order to avoid look-ups when a byte is out of this range.\n     *\n     * @param b the byte that is candidate for min and max limit\n     "
          }
        ],
        "insertAlwaysEncodeChars": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.insertAlwaysEncodeChar(byte)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void insertAlwaysEncodeChars(byte[])",
            "parameters": [
              {
                "variable_name": "alwaysEncodeCharsArray",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Inserts the byte array into a BitSet for faster lookup.\n     *\n     * @param alwaysEncodeCharsArray\n     "
          }
        ],
        "isAsciiChar": [
          {
            "call_methods": [],
            "signature": "private boolean isAsciiChar(byte)",
            "parameters": [
              {
                "variable_name": "c",
                "variable_type": "byte"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Implements the Percent-Encoding scheme, as described in HTTP 1.1 specification. For extensibility, an array of\n * special US-ASCII characters can be specified in order to perform proper URI encoding for the different parts\n * of the URI.\n * <p>\n * This class is immutable. It is also thread-safe besides using BitSet which is not thread-safe, but its public\n * interface only call the access\n * </p>\n *\n * @see <a href=\"https://tools.ietf.org/html/rfc3986#section-2.1\">Percent-Encoding</a>\n * @since 1.12\n "
    },
    "org.apache.commons.codec.net.QCodec": {
      "fields": [
        {
          "variable_name": "PRINTABLE_CHARS",
          "variable_type": "java.util.BitSet"
        },
        {
          "variable_name": "SPACE",
          "variable_type": "byte"
        },
        {
          "variable_name": "UNDERSCORE",
          "variable_type": "byte"
        },
        {
          "variable_name": "encodeBlanks",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public QCodec()\n{\r\n    this(StandardCharsets.UTF_8);\r\n}",
          "signature": "QCodec()",
          "parameters": [],
          "javadoc": "\n     * Default constructor.\n     "
        },
        {
          "body": "public QCodec(final Charset charset)\n{\r\n    super(charset);\r\n}",
          "signature": "QCodec(Charset)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.nio.charset.Charset"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset.\n     *\n     * @param charset\n     *            the default string Charset to use.\n     *\n     * @see Charset\n     * @since 1.7\n     "
        },
        {
          "body": "public QCodec(final String charsetName)\n{\r\n    this(Charset.forName(charsetName));\r\n}",
          "signature": "QCodec(String)",
          "parameters": [
            {
              "variable_name": "charsetName",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset.\n     *\n     * @param charsetName\n     *            the Charset to use.\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named Charset is unavailable\n     * @since 1.7 throws UnsupportedCharsetException if the named Charset is unavailable\n     * @see Charset\n     "
        }
      ],
      "methods": {
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param obj\n     *            quoted-printable object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a {@code String}. Thrown if a failure condition is encountered\n     *             during the decode process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.decodeText(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String decode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param str\n     *            quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\n     "
          }
        ],
        "doDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[])",
                "arguments": [
                  {
                    "variable_name": "tmp",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "protected byte[] doDecoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "doEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(java.util.BitSet, byte[])",
                "arguments": [
                  {
                    "variable_name": "PRINTABLE_CHARS",
                    "variable_type": "java.util.BitSet"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "protected byte[] doEncoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an object into its quoted-printable form using the default Charset. Unsafe characters are escaped.\n     *\n     * @param obj\n     *            object to convert to quoted-printable form\n     * @return quoted-printable object\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "sourceStr",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "getCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its quoted-printable form using the default Charset. Unsafe characters are escaped.\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "sourceStr",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "sourceCharset",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String, Charset)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @param sourceCharset\n     *            the Charset for sourceStr\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "sourceStr",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "sourceCharset",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String, String)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @param sourceCharset\n     *            the Charset for sourceStr\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process.\n     "
          }
        ],
        "getEncoding": [
          {
            "call_methods": [],
            "signature": "protected String getEncoding()",
            "parameters": []
          }
        ],
        "isEncodeBlanks": [
          {
            "call_methods": [],
            "signature": "public boolean isEncodeBlanks()",
            "parameters": [],
            "javadoc": "\n     * Tests if optional transformation of SPACE characters is to be used\n     *\n     * @return {@code true} if SPACE characters are to be transformed, {@code false} otherwise\n     "
          }
        ],
        "setEncodeBlanks": [
          {
            "call_methods": [],
            "signature": "public void setEncodeBlanks(boolean)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Defines whether optional transformation of SPACE characters is to be used\n     *\n     * @param b\n     *            {@code true} if SPACE characters are to be transformed, {@code false} otherwise\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Similar to the Quoted-Printable content-transfer-encoding defined in\n * <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a> and designed to allow text containing mostly ASCII\n * characters to be decipherable on an ASCII terminal without decoding.\n * <p>\n * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\n * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\n * handling software.\n * </p>\n * <p>\n * This class is conditionally thread-safe.\n * The instance field for encoding blanks is mutable {@link #setEncodeBlanks(boolean)}\n * but is not volatile, and accesses are not synchronized.\n * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization\n * is used to ensure safe publication of the value between threads, and must not invoke\n * {@link #setEncodeBlanks(boolean)} after initial setup.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\n *          Header Extensions for Non-ASCII Text</a>\n *\n * @since 1.3\n "
    },
    "org.apache.commons.codec.net.QuotedPrintableCodec": {
      "fields": [
        {
          "variable_name": "PRINTABLE_CHARS",
          "variable_type": "java.util.BitSet"
        },
        {
          "variable_name": "ESCAPE_CHAR",
          "variable_type": "byte"
        },
        {
          "variable_name": "TAB",
          "variable_type": "byte"
        },
        {
          "variable_name": "SPACE",
          "variable_type": "byte"
        },
        {
          "variable_name": "CR",
          "variable_type": "byte"
        },
        {
          "variable_name": "LF",
          "variable_type": "byte"
        },
        {
          "variable_name": "MIN_BYTES",
          "variable_type": "int"
        },
        {
          "variable_name": "SAFE_LENGTH",
          "variable_type": "int"
        },
        {
          "variable_name": "charset",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "strict",
          "variable_type": "boolean"
        }
      ],
      "constructors": [
        {
          "body": "public QuotedPrintableCodec()\n{\r\n    this(StandardCharsets.UTF_8, false);\r\n}",
          "signature": "QuotedPrintableCodec()",
          "parameters": [],
          "javadoc": "\n     * Default constructor, assumes default Charset of {@link StandardCharsets#UTF_8}\n     "
        },
        {
          "body": "public QuotedPrintableCodec(final boolean strict)\n{\r\n    this(StandardCharsets.UTF_8, strict);\r\n}",
          "signature": "QuotedPrintableCodec(boolean)",
          "parameters": [
            {
              "variable_name": "strict",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of the strict mode.\n     *\n     * @param strict\n     *            if {@code true}, soft line breaks will be used\n     * @since 1.10\n     "
        },
        {
          "body": "public QuotedPrintableCodec(final Charset charset)\n{\r\n    this(charset, false);\r\n}",
          "signature": "QuotedPrintableCodec(Charset)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.nio.charset.Charset"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset.\n     *\n     * @param charset\n     *            the default string Charset to use.\n     * @since 1.7\n     "
        },
        {
          "body": "public QuotedPrintableCodec(final Charset charset, final boolean strict)\n{\r\n    this.charset = charset;\r\n    this.strict = strict;\r\n}",
          "signature": "QuotedPrintableCodec(Charset, boolean)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.nio.charset.Charset"
            },
            {
              "variable_name": "strict",
              "variable_type": "boolean"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset and strict mode.\n     *\n     * @param charset\n     *            the default string Charset to use.\n     * @param strict\n     *            if {@code true}, soft line breaks will be used\n     * @since 1.10\n     "
        },
        {
          "body": "public QuotedPrintableCodec(final String charsetName) throws IllegalCharsetNameException, IllegalArgumentException, UnsupportedCharsetException\n{\r\n    this(Charset.forName(charsetName), false);\r\n}",
          "signature": "QuotedPrintableCodec(String)",
          "parameters": [
            {
              "variable_name": "charsetName",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default Charset.\n     *\n     * @param charsetName\n     *            the default string Charset to use.\n     * @throws UnsupportedCharsetException\n     *             If no support for the named Charset is available\n     *             in this instance of the Java virtual machine\n     * @throws IllegalArgumentException\n     *             If the given charsetName is null\n     * @throws IllegalCharsetNameException\n     *             If the given Charset name is illegal\n     *\n     * @since 1.7 throws UnsupportedCharsetException if the named Charset is unavailable\n     "
        }
      ],
      "methods": {
        "decodeQuotedPrintable": [
          {
            "call_methods": [
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "(char) ((u << 4) + l)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.Utils.digit16(byte)",
                "arguments": [
                  {
                    "variable_name": "bytes[i]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static final byte[] decodeQuotedPrintable(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *            array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     "
          }
        ],
        "encodeByte": [
          {
            "call_methods": [
              {
                "signature": "java.io.ByteArrayOutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int, java.io.ByteArrayOutputStream)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.io.ByteArrayOutputStream"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private static int encodeByte(int, boolean, ByteArrayOutputStream)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "int"
              },
              {
                "variable_name": "encode",
                "variable_type": "boolean"
              },
              {
                "variable_name": "buffer",
                "variable_type": "java.io.ByteArrayOutputStream"
              }
            ],
            "javadoc": "\n     * Encodes a byte in the buffer.\n     *\n     * @param b\n     *            byte to write\n     * @param encode\n     *            indicates whether the octet shall be encoded\n     * @param buffer\n     *            the buffer to write to\n     * @return the number of bytes that have been written to the buffer\n     "
          }
        ],
        "encodeQuotedPrintable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(java.util.BitSet, byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "printable",
                    "variable_type": "java.util.BitSet"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public static final byte[] encodeQuotedPrintable(BitSet, byte[])",
            "parameters": [
              {
                "variable_name": "printable",
                "variable_type": "java.util.BitSet"
              },
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * <p>\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param printable\n     *            bitset of characters deemed quoted-printable\n     * @param bytes\n     *            array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.BitSet.get(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "ESCAPE_CHAR",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.getUnsignedOctet(int, byte[])",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.isWhitespace(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeByte(int, boolean, java.io.ByteArrayOutputStream)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "!printable.get(b)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.io.ByteArrayOutputStream"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(int, java.io.ByteArrayOutputStream)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.io.ByteArrayOutputStream"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static final byte[] encodeQuotedPrintable(BitSet, byte[], boolean)",
            "parameters": [
              {
                "variable_name": "printable",
                "variable_type": "java.util.BitSet"
              },
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "strict",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param printable\n     *            bitset of characters deemed quoted-printable\n     * @param bytes\n     *            array of bytes to be encoded\n     * @param strict\n     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2\n     * @return array of bytes containing quoted-printable data\n     * @since 1.10\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.Utils.hexDigit(int)",
                "arguments": [
                  {
                    "variable_name": "b >> 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "ESCAPE_CHAR",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static final int encodeQuotedPrintable(int, ByteArrayOutputStream)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "int"
              },
              {
                "variable_name": "buffer",
                "variable_type": "java.io.ByteArrayOutputStream"
              }
            ],
            "javadoc": "\n     * Encodes byte into its quoted-printable representation.\n     *\n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     * @return The number of bytes written to the {@code buffer}\n     "
          }
        ],
        "getUnsignedOctet": [
          {
            "call_methods": [],
            "signature": "private static int getUnsignedOctet(int, byte[])",
            "parameters": [
              {
                "variable_name": "index",
                "variable_type": "int"
              },
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Gets the byte at position {@code index} of the byte array and\n     * make sure it is unsigned.\n     *\n     * @param index\n     *            position in the array\n     * @param bytes\n     *            the byte array\n     * @return the unsigned octet at position {@code index} from the array\n     "
          }
        ],
        "isWhitespace": [
          {
            "call_methods": [],
            "signature": "private static boolean isWhitespace(int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Checks whether the given byte is whitespace.\n     *\n     * @param b\n     *            byte to be checked\n     * @return {@code true} if the byte is either a space or tab character\n     "
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] decode(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *            array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param obj\n     *            quoted-printable object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a {@code String} or {@code byte[]}. Thrown if a failure\n     *             condition is encountered during the decode process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "sourceStr",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "this.getCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String decode(String)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a quoted-printable string into its original form using the default string Charset. Escaped characters are\n     * converted back to their original representation.\n     *\n     * @param sourceStr\n     *            quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful. Thrown if Charset is not supported.\n     * @see #getCharset()\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUsAscii(sourceStr)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "sourceStr",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String decode(String, Charset)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Decodes a quoted-printable string into its original form using the specified string Charset. Escaped characters\n     * are converted back to their original representation.\n     *\n     * @param sourceStr\n     *            quoted-printable string to convert into its original form\n     * @param sourceCharset\n     *            the original string Charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUsAscii(sourceStr)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "sourceStr",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String decode(String, String)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a quoted-printable string into its original form using the specified string Charset. Escaped characters\n     * are converted back to their original representation.\n     *\n     * @param sourceStr\n     *            quoted-printable string to convert into its original form\n     * @param sourceCharset\n     *            the original string Charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *             Thrown if Charset is not supported\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(java.util.BitSet, byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "PRINTABLE_CHARS",
                    "variable_type": "java.util.BitSet"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "strict",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] encode(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param bytes\n     *            array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\n     *\n     * @param obj\n     *            string to convert to a quoted-printable form\n     * @return quoted-printable object\n     * @throws EncoderException\n     *             Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\n     *             unsuccessful\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "sourceStr",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "getCharset()",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its quoted-printable form using the default string Charset. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             Thrown if quoted-printable encoding is unsuccessful\n     *\n     * @see #getCharset()\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "sourceCharset",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "this.encode(sourceStr.getBytes(sourceCharset))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "sourceStr.getBytes(sourceCharset)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String encode(String, Charset)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @param sourceCharset\n     *            the Charset for sourceStr\n     * @return quoted-printable string\n     * @since 1.7\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "encode(sourceStr.getBytes(sourceCharset))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "sourceCharset",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "sourceStr.getBytes(sourceCharset)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String encode(String, String)",
            "parameters": [
              {
                "variable_name": "sourceStr",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "sourceCharset",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @param sourceCharset\n     *            the Charset for sourceStr\n     * @return quoted-printable string\n     * @throws UnsupportedEncodingException\n     *             Thrown if the Charset is not supported\n     "
          }
        ],
        "getCharset": [
          {
            "call_methods": [],
            "signature": "public Charset getCharset()",
            "parameters": [],
            "javadoc": "\n     * Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name\n     * @since 1.7\n     "
          }
        ],
        "getDefaultCharset": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String getDefaultCharset()",
            "parameters": [],
            "javadoc": "\n     * Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Codec for the Quoted-Printable section of <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a>.\n * <p>\n * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to\n * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are\n * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the\n * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable\n * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping\n * gateway.\n * </p>\n * <p>\n * Note:\n * </p>\n * <p>\n * Depending on the selected {@code strict} parameter, this class will implement a different set of rules of the\n * quoted-printable spec:\n * </p>\n * <ul>\n *   <li>{@code strict=false}: only rules #1 and #2 are implemented</li>\n *   <li>{@code strict=true}: all rules #1 through #5 are implemented</li>\n * </ul>\n * <p>\n * Originally, this class only supported the non-strict mode, but the codec in this partial form could already be used\n * for certain applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance\n * Q codec. The strict mode has been added in 1.10.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\n *\n * @since 1.3\n "
    },
    "org.apache.commons.codec.net.RFC1522Codec": {
      "fields": [
        {
          "variable_name": "SEP",
          "variable_type": "char"
        },
        {
          "variable_name": "POSTFIX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "PREFIX",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "charset",
          "variable_type": "java.nio.charset.Charset"
        }
      ],
      "constructors": [
        {
          "body": " RFC1522Codec(final Charset charset)\n{\r\n    this.charset = Objects.requireNonNull(charset, \"charset\");\r\n}",
          "signature": "RFC1522Codec(Charset)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.nio.charset.Charset"
            }
          ]
        }
      ],
      "methods": {
        "decodeText": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.getEncoding()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "PREFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.indexOf(int, int)",
                "arguments": [
                  {
                    "variable_name": "SEP",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "from",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text.substring(from, to)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.doDecoding(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.endsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "POSTFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "from",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "to",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equalsIgnoreCase(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoding",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "protected String decodeText(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Applies an RFC 1522 compliant decoding scheme to the given string of text.\n     * <p>\n     * This method processes the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doDecoding(byte[])}  method of a concrete class to perform the specific decoding.\n     * </p>\n     *\n     * @param text\n     *            a string to decode\n     * @return A new decoded String or {@code null} if the input is {@code null}.\n     * @throws DecoderException\n     *             thrown if there is an error condition during the decoding process.\n     * @throws UnsupportedEncodingException\n     *             thrown if charset specified in the \"encoded-word\" header is not supported\n     "
          }
        ],
        "doDecoding": [
          {
            "call_methods": [],
            "signature": "protected abstract byte[] doDecoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes an array of bytes using the defined encoding scheme.\n     *\n     * @param bytes\n     *            Data to be decoded\n     * @return a byte array that contains decoded data\n     * @throws DecoderException\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\n     "
          }
        ],
        "doEncoding": [
          {
            "call_methods": [],
            "signature": "protected abstract byte[] doEncoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes an array of bytes using the defined encoding scheme.\n     *\n     * @param bytes\n     *            Data to be encoded\n     * @return A byte array containing the encoded data\n     * @throws EncoderException\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\n     "
          }
        ],
        "encodeText": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.getEncoding()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "charset",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "charset",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.doEncoding(byte[])",
                "arguments": [
                  {
                    "variable_name": "text.getBytes(charset)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "this.doEncoding(text.getBytes(charset))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "PREFIX",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "SEP",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "protected String encodeText(String, Charset)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charset",
                "variable_type": "java.nio.charset.Charset"
              }
            ],
            "javadoc": "\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\n     * <p>\n     * This method constructs the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte[])}  method of a concrete class to perform the specific encoding.\n     * </p>\n     *\n     * @param text\n     *            a string to encode\n     * @param charset\n     *            a charset to be used\n     * @return RFC 1522 compliant \"encoded-word\"\n     * @throws EncoderException\n     *             thrown if there is an error condition during the Encoding process.\n     * @see Charset\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.forName(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "Charset.forName(charsetName)",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "protected String encodeText(String, String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\n     * <p>\n     * This method constructs the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte[])}  method of a concrete class to perform the specific encoding.\n     * </p>\n     *\n     * @param text\n     *            a string to encode\n     * @param charsetName\n     *            the charset to use\n     * @return RFC 1522 compliant \"encoded-word\"\n     * @throws EncoderException\n     *             thrown if there is an error condition during the Encoding process.\n     * @throws UnsupportedCharsetException\n     *             if charset is not available\n     * @see Charset\n     "
          }
        ],
        "getCharset": [
          {
            "call_methods": [],
            "signature": "public Charset getCharset()",
            "parameters": [],
            "javadoc": "\n     * Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name\n     * @since 1.7\n     "
          }
        ],
        "getDefaultCharset": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String getDefaultCharset()",
            "parameters": [],
            "javadoc": "\n     * Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name\n     "
          }
        ],
        "getEncoding": [
          {
            "call_methods": [],
            "signature": "protected abstract String getEncoding()",
            "parameters": [],
            "javadoc": "\n     * Returns the codec name (referred to as encoding in the RFC 1522).\n     *\n     * @return name of the codec.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Implements methods common to all codecs defined in RFC 1522.\n * <p>\n * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the\n * encoding of non-ASCII text in various portions of a RFC 822 [2] message header, in a manner which\n * is unlikely to confuse existing message handling software.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two:\n *          Message Header Extensions for Non-ASCII Text</a>\n * @since 1.3\n "
    },
    "org.apache.commons.codec.net.URLCodec": {
      "fields": [
        {
          "variable_name": "ESCAPE_CHAR",
          "variable_type": "byte"
        },
        {
          "variable_name": "WWW_FORM_URL",
          "variable_type": "java.util.BitSet"
        },
        {
          "variable_name": "WWW_FORM_URL_SAFE",
          "variable_type": "java.util.BitSet"
        },
        {
          "variable_name": "charset",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [
        {
          "body": "public URLCodec()\n{\r\n    this(CharEncoding.UTF_8);\r\n}",
          "signature": "URLCodec()",
          "parameters": [],
          "javadoc": "\n     * Default constructor.\n     "
        },
        {
          "body": "public URLCodec(final String charset)\n{\r\n    this.charset = charset;\r\n}",
          "signature": "URLCodec(String)",
          "parameters": [
            {
              "variable_name": "charset",
              "variable_type": "java.lang.String"
            }
          ],
          "javadoc": "\n     * Constructor which allows for the selection of a default charset.\n     *\n     * @param charset the default string charset to use.\n     "
        }
      ],
      "methods": {
        "decodeUrl": [
          {
            "call_methods": [
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "' '",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.Utils.digit16(byte)",
                "arguments": [
                  {
                    "variable_name": "bytes[++i]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public static final byte[] decodeUrl(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     "
          }
        ],
        "encodeUrl": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.Utils.hexDigit(int)",
                "arguments": [
                  {
                    "variable_name": "b >> 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.BitSet.get(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static final byte[] encodeUrl(BitSet, byte[])",
            "parameters": [
              {
                "variable_name": "urlsafe",
                "variable_type": "java.util.BitSet"
              },
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     "
          }
        ],
        "decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decodeUrl(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] decode(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public Object decode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Decodes a URL safe object into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param obj\n     *            URL safe object to convert into its original form\n     * @return original object\n     * @throws DecoderException\n     *             Thrown if the argument is not a {@code String} or {@code byte[]}. Thrown if a failure\n     *             condition is encountered during the decode process.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodec.getDefaultCharset()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "getDefaultCharset()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String decode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a URL safe string into its original form using the default string charset. Escaped characters are\n     * converted back to their original representation.\n     *\n     * @param str\n     *            URL safe string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     * @see #getDefaultCharset()\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUsAscii(str)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String decode(String, String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a URL safe string into its original form using the specified encoding. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param str\n     *            URL safe string to convert into its original form\n     * @param charsetName\n     *            the original string charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported\n     "
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encodeUrl(java.util.BitSet, byte[])",
                "arguments": [
                  {
                    "variable_name": "WWW_FORM_URL_SAFE",
                    "variable_type": "java.util.BitSet"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public byte[] encode(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) obj",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) obj",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public Object encode(Object)",
            "parameters": [
              {
                "variable_name": "obj",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Encodes an object into its URL safe form. Unsafe characters are escaped.\n     *\n     * @param obj\n     *            string to convert to a URL safe form\n     * @return URL safe object\n     * @throws EncoderException\n     *             Thrown if URL encoding is not applicable to objects of this type or if encoding is unsuccessful\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodec.getDefaultCharset()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "getDefaultCharset()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String encode(String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its URL safe form using the default string charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to a URL safe form\n     * @return URL safe string\n     * @throws EncoderException\n     *             Thrown if URL encoding is unsuccessful\n     *\n     * @see #getDefaultCharset()\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "encode(str.getBytes(charsetName))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "str.getBytes(charsetName)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public String encode(String, String)",
            "parameters": [
              {
                "variable_name": "str",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to a URL safe form\n     * @param charsetName\n     *            the charset for str\n     * @return URL safe string\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported\n     "
          }
        ],
        "getDefaultCharset": [
          {
            "call_methods": [],
            "signature": "public String getDefaultCharset()",
            "parameters": [],
            "javadoc": "\n     * The default charset used for string decoding and encoding.\n     *\n     * @return the default string charset.\n     "
          }
        ],
        "getEncoding": [
          {
            "call_methods": [],
            "signature": "public String getEncoding()",
            "parameters": [],
            "javadoc": "\n     * The {@code String} encoding used for decoding and encoding.\n     *\n     * @return Returns the encoding.\n     *\n     * @deprecated Use {@link #getDefaultCharset()}, will be removed in 2.0.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Implements the 'www-form-urlencoded' encoding scheme, also misleadingly known as URL encoding.\n * <p>\n * This codec is meant to be a replacement for standard Java classes {@link java.net.URLEncoder} and\n * {@link java.net.URLDecoder} on older Java platforms, as these classes in Java versions below\n * 1.4 rely on the platform's default charset encoding.\n * </p>\n * <p>\n * This class is thread-safe as of 1.11\n * </p>\n *\n * @see <a href=\"http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1\">Chapter 17.13.4 Form content types</a>\n *           of the <a href=\"http://www.w3.org/TR/html4/\">HTML 4.01 Specification</a>\n *\n * @since 1.2\n "
    },
    "org.apache.commons.codec.net.Utils": {
      "fields": [
        {
          "variable_name": "RADIX",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "digit16": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Character.digit(char, int)",
                "arguments": [
                  {
                    "variable_name": "(char) b",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "RADIX",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": " static int digit16(byte)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Returns the numeric value of the character {@code b} in radix 16.\n     *\n     * @param b\n     *            The byte to be converted.\n     * @return The numeric value represented by the character in radix 16.\n     *\n     * @throws DecoderException\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\n     "
          }
        ],
        "hexDigit": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Character.toUpperCase(char)",
                "arguments": [
                  {
                    "variable_name": "Character.forDigit(b & 0xF, RADIX)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.Character.forDigit(int, int)",
                "arguments": [
                  {
                    "variable_name": "b & 0xF",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "RADIX",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              }
            ],
            "signature": " static char hexDigit(int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Returns the upper case hexadecimal digit of the lower 4 bits of the int.\n     *\n     * @param b the input int\n     * @return the upper case hexadecimal digit of the lower 4 bits of the int.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Utility methods for this package.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @since 1.4\n "
    },
    "org.apache.commons.codec.Resources": {
      "fields": [],
      "constructors": [
        {
          "body": "public Resources()\n{\r\n    // empty\r\n}",
          "signature": "Resources()",
          "parameters": [],
          "javadoc": "\n     * TODO Make private in 2.0.\n     *\n     * @deprecated TODO Make private in 2.0.\n     "
        }
      ],
      "methods": {
        "getInputStream": [
          {
            "call_methods": [
              {
                "signature": "java.lang.ClassLoader.getResourceAsStream(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.io.InputStream"
              },
              {
                "signature": "java.lang.Class.getClassLoader()",
                "arguments": [],
                "return_type": "java.lang.ClassLoader"
              }
            ],
            "signature": "public static InputStream getInputStream(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Opens the given named resource from the given class.\n     *\n     * @param name The resource name.\n     * @return An input stream.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Consider this class package private. Helps load resources.\n *\n * @since 1.12\n "
    },
    "org.apache.commons.codec.StringDecoder": {
      "fields": [],
      "constructors": [],
      "methods": {
        "decode": [
          {
            "call_methods": [],
            "signature": " abstract String decode(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Decodes a String and returns a String.\n     *\n     * @param source\n     *            the String to decode\n     * @return the encoded String\n     * @throws DecoderException\n     *             thrown if there is an error condition during the Encoding process.\n     "
          }
        ]
      },
      "is_interface": true,
      "javadoc": "\n * Defines common decoding methods for String decoders.\n "
    },
    "org.apache.commons.codec.StringEncoder": {
      "fields": [],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [],
            "signature": " abstract String encode(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes a String and returns a String.\n     *\n     * @param source\n     *            the String to encode\n     * @return the encoded String\n     * @throws EncoderException\n     *             thrown if there is an error condition during the encoding process.\n     "
          }
        ]
      },
      "is_interface": true,
      "javadoc": "\n * Defines common encoding methods for String encoders.\n "
    },
    "org.apache.commons.codec.StringEncoderComparator": {
      "fields": [
        {
          "variable_name": "stringEncoder",
          "variable_type": "org.apache.commons.codec.StringEncoder"
        }
      ],
      "constructors": [
        {
          "body": "public StringEncoderComparator()\n{\r\n    // Trying to use this will cause things to break\r\n    this.stringEncoder = null;\r\n}",
          "signature": "StringEncoderComparator()",
          "parameters": [],
          "javadoc": "\n     * Constructs a new instance.\n     *\n     * @deprecated Creating an instance without a {@link StringEncoder} leads to a {@link NullPointerException}. Will be\n     *             removed in 2.0.\n     "
        },
        {
          "body": "public StringEncoderComparator(final StringEncoder stringEncoder)\n{\r\n    this.stringEncoder = stringEncoder;\r\n}",
          "signature": "StringEncoderComparator(StringEncoder)",
          "parameters": [
            {
              "variable_name": "stringEncoder",
              "variable_type": "org.apache.commons.codec.StringEncoder"
            }
          ],
          "javadoc": "\n     * Constructs a new instance with the given algorithm.\n     *\n     * @param stringEncoder\n     *            the StringEncoder used for comparisons.\n     "
        }
      ],
      "methods": {
        "compare": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.Encoder.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "o1",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.Comparable.compareTo(T)",
                "arguments": [
                  {
                    "variable_name": "s2",
                    "variable_type": "T"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public int compare(Object, Object)",
            "parameters": [
              {
                "variable_name": "o1",
                "variable_type": "java.lang.Object"
              },
              {
                "variable_name": "o2",
                "variable_type": "java.lang.Object"
              }
            ],
            "javadoc": "\n     * Compares two strings based not on the strings themselves, but on an encoding of the two strings using the\n     * StringEncoder this Comparator was created with.\n     *\n     * If an {@link EncoderException} is encountered, return {@code 0}.\n     *\n     * @param o1\n     *            the object to compare\n     * @param o2\n     *            the object to compare to\n     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\n     * @see Comparable\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Compares Strings using a {@link StringEncoder}. This comparator is used to sort Strings by an encoding scheme such as\n * Soundex, Metaphone, etc. This class can come in handy if one need to sort Strings by an encoded form of a name such\n * as Soundex.\n *\n * <p>This class is immutable and thread-safe.</p>\n "
    }
  },
  "test": {
    "org.apache.commons.codec.AbstractStringEncoderTest": {
      "fields": [
        {
          "variable_name": "stringEncoder",
          "variable_type": "T"
        }
      ],
      "constructors": [],
      "methods": {
        "checkEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(source)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Source: \" + source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void checkEncoding(String, String)",
            "parameters": [
              {
                "variable_name": "expected",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "checkEncodings": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "element[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "protected void checkEncodings(String[][])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String[][]"
              }
            ]
          }
        ],
        "checkEncodingVariations": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "element",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "protected void checkEncodingVariations(String, String[])",
            "parameters": [
              {
                "variable_name": "expected",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "data",
                "variable_type": "java.lang.String[]"
              }
            ]
          }
        ],
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected abstract T createStringEncoder()",
            "parameters": []
          }
        ],
        "getStringEncoder": [
          {
            "call_methods": [],
            "signature": "public T getStringEncoder()",
            "parameters": []
          }
        ],
        "testEncodeEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.Encoder.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testEncodeEmpty()",
            "parameters": []
          }
        ],
        "testEncodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public void testEncodeNull()",
            "parameters": []
          }
        ],
        "testEncodeWithInvalidObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> encoder.encode(Float.valueOf(3.4f))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"An exception was not thrown when we tried to encode a Float object\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.Encoder.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Float.valueOf(3.4f)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.Float.valueOf(float)",
                "arguments": [
                  {
                    "variable_name": "3.4f",
                    "variable_type": "float"
                  }
                ],
                "return_type": "java.lang.Float"
              }
            ],
            "signature": "public void testEncodeWithInvalidObject()",
            "parameters": []
          }
        ],
        "testLocaleIndependence": [
          {
            "call_methods": [
              {
                "signature": "java.util.Locale.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.StringEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Locale.getDefault().toString() + \": \" + e.getMessage()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "java.util.Locale.setDefault(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "locales[j]",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ref",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "cur",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Locale.getDefault().toString() + \": \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Locale.getDefault()",
                "arguments": [],
                "return_type": "java.util.Locale"
              }
            ],
            "signature": "public void testLocaleIndependence()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n "
    },
    "org.apache.commons.codec.binary.AllocateDirectHexTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "allocate": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.allocateDirect(int)",
                "arguments": [
                  {
                    "variable_name": "capacity",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "protected ByteBuffer allocate(int)",
            "parameters": [
              {
                "variable_name": "capacity",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.binary.Base16InputStreamTest": {
      "fields": [
        {
          "variable_name": "ENCODED_B16",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STRING_FIXTURE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "testAvailable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B16",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b16Stream.available()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b16Stream.skip(10)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.available()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testAvailable()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping past the end of a stream.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testBase16EmptyInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByChunk(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByteByByte(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase16EmptyInputStream()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base16InputStream implementation against empty input.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testBase16InputStreamByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByChunk(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByChunk(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              }
            ],
            "signature": "public void testBase16InputStreamByChunk()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base16InputStream implementation.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testBase16InputStreamByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByteByByte(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByteByByte(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase16InputStreamByteByByte()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base16InputStream implementation.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByChunk(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16InputStream wraps itself in encode and decode mode over and over again.\n     *\n     * @param encoded Base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming Base16 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in.read()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"EOF\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[], boolean)",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "lowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16InputStream wraps itself in encode and decode mode over and over again.\n     *\n     * @param encoded   Base16 encoded data\n     * @param decoded   the data from above, but decoded\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          }
        ],
        "testByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16InputStreamTest.testByteByByte(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16InputStream wraps itself in encode and decode mode over and over again.\n     *\n     * @param encoded Base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming Base16 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in.read()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"EOF\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[], boolean)",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "lowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16InputStream wraps itself in encode and decode mode over and over again.\n     *\n     * @param encoded   Base16 encoded data\n     * @param decoded   the data from above, but decoded\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          }
        ],
        "testMarkSupported": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "in.markSupported()",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Base16InputStream.markSupported() is false\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.markSupported()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testMarkSupported()",
            "parameters": [],
            "javadoc": "\n     * Tests markSupported.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testRead0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytesRead",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Base16InputStream.read(buf, 0, 0) returns 0\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRead0()",
            "parameters": [],
            "javadoc": "\n     * Tests read returning 0\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testReadNull": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> in.read(null, 0, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base16InputStream.read(null, 0, 0)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testReadNull()",
            "parameters": [],
            "javadoc": "\n     * Tests read with null.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testReadOutOfBounds": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> in.read(buf, -1, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base16InputStream.read(buf, -1, 0)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testReadOutOfBounds()",
            "parameters": [],
            "javadoc": "\n     * Tests read throwing IndexOutOfBoundsException\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testSkipBig": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B16",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "Integer.MAX_VALUE",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b16Stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b16Stream.skip(Integer.MAX_VALUE)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipBig()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping number of characters larger than the internal buffer.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testSkipNone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B16",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "actualBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new byte[] { (byte) 202, (byte) 254, (byte) 186, (byte) 190, (byte) 255, (byte) 255 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b16Stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b16Stream.skip(0)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "actualBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "actualBytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipNone()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping as a noop\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testSkipPastEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B16",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b16Stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b16Stream.skip(10)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipPastEnd()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping past the end of a stream.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testSkipToEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B16",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b16Stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b16Stream.skip(6)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipToEnd()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping to the end of a stream.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testSkipWrongArgument": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B16",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> b16Stream.skip(-10)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "-10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testSkipWrongArgument()",
            "parameters": [],
            "javadoc": "\n     * Tests if negative arguments to skip are handled correctly.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n "
    },
    "org.apache.commons.codec.binary.Base16OutputStreamTest": {
      "fields": [
        {
          "variable_name": "STRING_FIXTURE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "testBase16EmptyOutputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByteByByte(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByChunk(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase16EmptyOutputStream()",
            "parameters": [],
            "javadoc": "\n     * Test the Base16OutputStream implementation against empty input.\n     *\n     * @throws IOException for some failure scenarios..\n     "
          }
        ],
        "testBase16OutputStreamByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByChunk(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByChunk(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              }
            ],
            "signature": "public void testBase16OutputStreamByChunk()",
            "parameters": [],
            "javadoc": "\n     * Test the Base16OutputStream implementation\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testBase16OutputStreamByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByteByByte(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByteByByte(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              }
            ],
            "signature": "public void testBase16OutputStreamByteByByte()",
            "parameters": [],
            "javadoc": "\n     * Test the Base16OutputStream implementation\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByChunk(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming chunked base16 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.OutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[], boolean)",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "lowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          }
        ],
        "testByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16OutputStreamTest.testByteByByte(byte[], byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          },
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming byte-by-byte base16 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.OutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.OutputStream.flush()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[], boolean)",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "lowerCase",
                "variable_type": "boolean"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation.\n     "
          }
        ],
        "testWriteOutOfBounds": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> out.write(buf, -1, 1)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base16InputStream.write(buf, -1, 0)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWriteOutOfBounds()",
            "parameters": [],
            "javadoc": "\n     * Tests Base16OutputStream.write for expected IndexOutOfBoundsException conditions.\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ],
        "testWriteToNullCoverage": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> out.write(null, 0, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWriteToNullCoverage()",
            "parameters": [],
            "javadoc": "\n     * Tests Base16OutputStream.write(null).\n     *\n     * @throws IOException for some failure scenarios.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n "
    },
    "org.apache.commons.codec.binary.Base16Test": {
      "fields": [
        {
          "variable_name": "CHARSET_UTF8",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "random",
          "variable_type": "java.util.Random"
        }
      ],
      "constructors": [],
      "methods": {
        "getRandom": [
          {
            "call_methods": [],
            "signature": "public Random getRandom()",
            "parameters": [],
            "javadoc": "\n     * @return Returns the random.\n     "
          }
        ],
        "testBase16": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(content)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedContent",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"encoding hello world\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testBase16()",
            "parameters": [],
            "javadoc": "\n     * Test the Base16 implementation\n     "
          }
        ],
        "testBase16AtBufferEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16Test.testBase16InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase16AtBufferEnd()",
            "parameters": []
          }
        ],
        "testBase16AtBufferMiddle": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16Test.testBase16InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase16AtBufferMiddle()",
            "parameters": []
          }
        ],
        "testBase16AtBufferStart": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base16Test.testBase16InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase16AtBufferStart()",
            "parameters": []
          }
        ],
        "testBase16InBuffer": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "startPasSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytesUtf8.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.lang3.ArrayUtils.addAll(byte[], byte...)",
                "arguments": [
                  {
                    "variable_name": "bytesUtf8",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new byte[endPadSize]",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedContent",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"encoding hello world\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testBase16InBuffer(int, int)",
            "parameters": [
              {
                "variable_name": "startPasSize",
                "variable_type": "int"
              },
              {
                "variable_name": "endPadSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testByteToStringVariations": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base16.encodeToString(b3)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"byteToString null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])",
                "arguments": [
                  {
                    "variable_name": "b1",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "base16.encodeToString(b1)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"byteToString Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "new Base16().encode(b1)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "b1",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testByteToStringVariations()",
            "parameters": []
          }
        ],
        "testCheckEncodeLengthBounds": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "new byte[10]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1 << 30",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> base16.encode(new byte[10], 0, 1 << 30)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testCheckEncodeLengthBounds()",
            "parameters": []
          }
        ],
        "testCodec68": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "RuntimeException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> b16.decode(x)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "x",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testCodec68()",
            "parameters": [],
            "javadoc": "\n     * isBase16 throws RuntimeException on some non-Base16 bytes\n     "
          }
        ],
        "testConstructor_LowerCase": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNTestData.DECODED",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"new Base16(true)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructor_LowerCase()",
            "parameters": []
          }
        ],
        "testConstructor_LowerCase_DecodingPolicy": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNTestData.DECODED",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"new base16(false, CodecPolicy.STRICT)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructor_LowerCase_DecodingPolicy()",
            "parameters": []
          }
        ],
        "testConstructors": [
          {
            "call_methods": [],
            "signature": "public void testConstructors()",
            "parameters": []
          }
        ],
        "testDecodeSingleBytes": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "context.buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "context.readPos",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "decodedBytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"Until next time!\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "encocdedBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeSingleBytes()",
            "parameters": []
          }
        ],
        "testDecodeSingleBytesOptimisation": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context.ibitWorkArea",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "context.buffer",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(byte, byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) 0xEF",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "context.buffer[0]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeSingleBytesOptimisation()",
            "parameters": []
          }
        ],
        "testEmptyBase16": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new Base16().encode(null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"empty Base16 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "result.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"empty Base16 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEmptyBase16()",
            "parameters": [],
            "javadoc": "\n     * Test encode and decode of empty byte array.\n     "
          }
        ],
        "testEncodeDecodeRandom": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "data2",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Random.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "10000",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16Test.getRandom()",
                "arguments": [],
                "return_type": "java.util.Random"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "enc",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeDecodeRandom()",
            "parameters": []
          }
        ],
        "testEncodeDecodeSmall": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "data2",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "toString(data) + \" equals \" + toString(data2)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16Test.toString(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16Test.getRandom()",
                "arguments": [],
                "return_type": "java.util.Random"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "enc",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeDecodeSmall()",
            "parameters": []
          }
        ],
        "testIsInAlphabet": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "b16.isInAlphabet((byte) 0)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16.isInAlphabet(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "b16.isInAlphabet((byte) c)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsInAlphabet()",
            "parameters": []
          }
        ],
        "testKnownDecodings": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"The quick brown fox jumped over the lazy dogs.\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(new Base16(true).decode(\"54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testKnownDecodings()",
            "parameters": []
          }
        ],
        "testKnownEncodings": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(new Base16(true).encode(\"The quick brown fox jumped over the lazy dogs.\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"The quick brown fox jumped over the lazy dogs.\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testKnownEncodings()",
            "parameters": []
          }
        ],
        "testLenientDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd }",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.LENIENT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "b16.getCodecPolicy()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getCodecPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(encoded)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testLenientDecoding()",
            "parameters": []
          }
        ],
        "testNonBase16Test": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Base16().decode(encoded)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Invalid Base16 char: \" + (char) invalidEncodedChar",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testNonBase16Test()",
            "parameters": []
          }
        ],
        "testObjectDecodeWithInvalidParameter": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Base16().decode(Integer.valueOf(5))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Integer.valueOf(5)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.Integer.valueOf(int)",
                "arguments": [
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.Integer"
              }
            ],
            "signature": "public void testObjectDecodeWithInvalidParameter()",
            "parameters": []
          }
        ],
        "testObjectDecodeWithValidParameter": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "o",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "original.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "original",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "dest",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"dest string does not equal original\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testObjectDecodeWithValidParameter()",
            "parameters": []
          }
        ],
        "testObjectEncode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new String(b16.encode(\"Hello World\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"48656C6C6F20576F726C64\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testObjectEncode()",
            "parameters": []
          }
        ],
        "testObjectEncodeWithInvalidParameter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"Yadayadayada\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Base16().encode(\"Yadayadayada\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testObjectEncodeWithInvalidParameter()",
            "parameters": []
          }
        ],
        "testObjectEncodeWithValidParameter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "origObj",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "original",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "dest",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"dest string does not equal original\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) oEncoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testObjectEncodeWithValidParameter()",
            "parameters": []
          }
        ],
        "testOddEvenDecoding": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "context.buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "context.readPos",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "decodedBytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ABCDE\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base16.decode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "encodedBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testOddEvenDecoding()",
            "parameters": []
          }
        ],
        "testPairs": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Base16().decode(new Base16().encode(test))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0, (byte) 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new Base16().encode(test)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testPairs()",
            "parameters": []
          }
        ],
        "testSingletons": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Base16().decode(new Base16().encode(test))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"00\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(new Base16().encode(new byte[] { (byte) 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new Base16().encode(test)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSingletons()",
            "parameters": []
          }
        ],
        "testStrictDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> b16.decode(StringUtils.getBytesUtf8(encoded))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.STRICT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "b16.getCodecPolicy()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getCodecPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(encoded)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testStrictDecoding()",
            "parameters": []
          }
        ],
        "testStringToByteVariations": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.newStringUtf8(new Base16().decode(s3))",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"StringToByte null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) s1",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "StringUtils.newStringUtf8(base16.decode(s1))",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"StringToByte Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "base16.decode(s1)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testStringToByteVariations()",
            "parameters": []
          }
        ],
        "testTriplets": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(new Base16().encode(new byte[] { (byte) 0, (byte) 0, (byte) 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0, (byte) 0, (byte) 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testTriplets()",
            "parameters": []
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(int)",
                "arguments": [
                  {
                    "variable_name": "data[i]",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\",\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private String toString(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Test cases for Base16 class.\n "
    },
    "org.apache.commons.codec.binary.Base16TestData": {
      "fields": [
        {
          "variable_name": "ENCODED_UTF8_LOWERCASE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ENCODED_UTF8_UPPERCASE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n * Commons-Codec and OpenSSL.\n "
    },
    "org.apache.commons.codec.binary.Base32InputStreamTest": {
      "fields": [
        {
          "variable_name": "ENCODED_FOO",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "CRLF",
          "variable_type": "byte"
        },
        {
          "variable_name": "LF",
          "variable_type": "byte"
        },
        {
          "variable_name": "STRING_FIXTURE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "testAvailable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_FOO",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b32stream.available()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b32stream.skip(10)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.available()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testAvailable()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase32EmptyInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32InputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chuckSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32InputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chuckSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testBase32EmptyInputStream(int)",
            "parameters": [
              {
                "variable_name": "chuckSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testBase32EmptyInputStreamMimeChuckSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32InputStreamTest.testBase32EmptyInputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32EmptyInputStreamMimeChuckSize()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base32InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase32EmptyInputStreamPemChuckSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32InputStreamTest.testBase32EmptyInputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.PEM_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32EmptyInputStreamPemChuckSize()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base32InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase32InputStreamByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32InputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.BASE32_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              }
            ],
            "signature": "public void testBase32InputStreamByChunk()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base32InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase32InputStreamByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.BASE32_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32InputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32InputStreamByteByByte()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base32InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming base32 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.io.InputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in.read()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"EOF\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base32 encoded data.\n     * @param separator\n     *            Line separator in the base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation.\n     "
          }
        ],
        "testByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming base32 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.io.InputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in.read()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"EOF\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base32 encoded data.\n     * @param separator\n     *            Line separator in the base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation.\n     "
          }
        ],
        "testCodec105": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testCodec105()",
            "parameters": [],
            "javadoc": "\n     * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.\n     "
          }
        ],
        "testCodec130": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.FilterOutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(STRING_FIXTURE)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE.substring(1)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream, byte[])",
                "arguments": [
                  {
                    "variable_name": "ins",
                    "variable_type": "java.io.InputStream"
                  },
                  {
                    "variable_name": "new byte[64]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testCodec130()",
            "parameters": [],
            "javadoc": "\n     * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.\n     "
          }
        ],
        "testMarkSupported": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "in.markSupported()",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Base32InputStream.markSupported() is false\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.markSupported()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testMarkSupported()",
            "parameters": [],
            "javadoc": "\n     * Tests markSupported.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testRead0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytesRead",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Base32InputStream.read(buf, 0, 0) returns 0\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRead0()",
            "parameters": [],
            "javadoc": "\n     * Tests read returning 0\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testReadNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> in.read(null, 0, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testReadNull()",
            "parameters": [],
            "javadoc": "\n     * Tests read with null.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testReadOutOfBounds": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> in.read(buf, -1, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base32InputStream.read(buf, -1, 0)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testReadOutOfBounds()",
            "parameters": [],
            "javadoc": "\n     * Tests read throwing IndexOutOfBoundsException\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipBig": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_FOO",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "1024",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b32stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b32stream.skip(1024)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipBig()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping number of characters larger than the internal buffer.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipNone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_FOO",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "actualBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new byte[] { 102, 111, 111, 0, 0, 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b32stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b32stream.skip(0)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "actualBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "actualBytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipNone()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping as a noop\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipPastEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_FOO",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b32stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b32stream.skip(10)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipPastEnd()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipToEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_FOO",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b32stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b32stream.skip(3)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipToEnd()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping to the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipWrongArgument": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_FOO",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> b32stream.skip(-10)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "-10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testSkipWrongArgument()",
            "parameters": [],
            "javadoc": "\n     * Tests if negative arguments to skip are handled correctly.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testStrictDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> BaseNTestData.streamToBytes(in2)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "in.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "in2.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.binary.Base32OutputStreamTest": {
      "fields": [
        {
          "variable_name": "CR_LF",
          "variable_type": "byte"
        },
        {
          "variable_name": "LF",
          "variable_type": "byte"
        }
      ],
      "constructors": [],
      "methods": {
        "testBase32EmptyOutputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32OutputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chunkSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32OutputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chunkSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testBase32EmptyOutputStream(int)",
            "parameters": [
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testBase32EmptyOutputStreamMimeChunkSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32OutputStreamTest.testBase32EmptyOutputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32EmptyOutputStreamMimeChunkSize()",
            "parameters": [],
            "javadoc": "\n     * Test the Base32OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase32EmptyOutputStreamPemChunkSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32OutputStreamTest.testBase32EmptyOutputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.PEM_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32EmptyOutputStreamPemChunkSize()",
            "parameters": [],
            "javadoc": "\n     * Test the Base32OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase32OutputStreamByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.BASE32_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32OutputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              }
            ],
            "signature": "public void testBase32OutputStreamByChunk()",
            "parameters": [],
            "javadoc": "\n     * Test the Base32OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase32OutputStreamByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base32TestData.BASE32_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32OutputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "76",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32OutputStreamByteByByte()",
            "parameters": [],
            "javadoc": "\n     * Test the Base32OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming chunked Base32 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.OutputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.OutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            Base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the Base32 encoded data.\n     * @param separator\n     *            Line separator in the Base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation.\n     "
          }
        ],
        "testByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming byte-by-byte Base32 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.OutputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.OutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.OutputStream.flush()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            Base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the Base32 encoded data.\n     * @param separator\n     *            Line separator in the Base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation.\n     "
          }
        ],
        "testStrictDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> out2.write(encoded)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.size()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "out.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.io.FilterOutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "bout.size() > 0",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testWriteOutOfBounds": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> out.write(buf, -1, 1)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base32OutputStream.write(buf, -1, 1)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWriteOutOfBounds()",
            "parameters": [],
            "javadoc": "\n     * Tests Base32OutputStream.write for expected IndexOutOfBoundsException conditions.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testWriteToNullCoverage": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> out.write(null, 0, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWriteToNullCoverage()",
            "parameters": [],
            "javadoc": "\n     * Tests Base32OutputStream.write(null).\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.binary.Base32Test": {
      "fields": [
        {
          "variable_name": "CHARSET_UTF8",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "BASE32_TEST_CASES",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BASE32_IMPOSSIBLE_CASES",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BASE32_IMPOSSIBLE_CASES_CHUNKED",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BASE32HEX_IMPOSSIBLE_CASES",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "BASE32_BINARY_TEST_CASES",
          "variable_type": "java.lang.Object"
        },
        {
          "variable_name": "BASE32HEX_TEST_CASES",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BASE32_TEST_CASES_CHUNKED",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BASE32_PAD_TEST_CASES",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "assertBase32DecodingOfTrailingBits": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.equals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "defaultCodec.encode(decoded)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "codec.encode(decoded)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], int, int, byte)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "ENCODE_TABLE[0]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "defaultCodec.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> codec.decode(encoded)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Final base-32 digit should not be allowed\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.STRICT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "codec.getCodecPolicy()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getCodecPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bitsEncoded",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "decoded[decoded.length - 1]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Invalid decoding of last character\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private static void assertBase32DecodingOfTrailingBits(int)",
            "parameters": [
              {
                "variable_name": "nbits",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Test base 32 decoding of the final trailing bits. Trailing encoded bytes\n     * cannot fit exactly into 5-bit characters so the last character has a limited\n     * alphabet where the final bits are zero. This asserts that illegal final\n     * characters throw an exception when decoding.\n     *\n     * @param nbits the number of trailing bits (must be a factor of 5 and {@code <40})\n     "
          }
        ],
        "testBase32AtBufferEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.testBase32InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32AtBufferEnd()",
            "parameters": []
          }
        ],
        "testBase32AtBufferMiddle": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.testBase32InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32AtBufferMiddle()",
            "parameters": []
          }
        ],
        "testBase32AtBufferStart": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.testBase32InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32AtBufferStart()",
            "parameters": []
          }
        ],
        "testBase32BinarySamples": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.toUpperCase()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) element[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected.toUpperCase()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "codec.encodeAsString((byte[]) element[0])",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32BinarySamples()",
            "parameters": []
          }
        ],
        "testBase32BinarySamplesReverse": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) element[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "codec.decode((String) element[1])",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) element[1]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testBase32BinarySamplesReverse()",
            "parameters": []
          }
        ],
        "testBase32Chunked": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])",
                "arguments": [
                  {
                    "variable_name": "element[0].getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "codec.encodeAsString(element[0].getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32Chunked()",
            "parameters": []
          }
        ],
        "testBase32DecodingOfTrailing10Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.assertBase32DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32DecodingOfTrailing10Bits()",
            "parameters": []
          }
        ],
        "testBase32DecodingOfTrailing15Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.assertBase32DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "15",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32DecodingOfTrailing15Bits()",
            "parameters": []
          }
        ],
        "testBase32DecodingOfTrailing20Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.assertBase32DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "20",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32DecodingOfTrailing20Bits()",
            "parameters": []
          }
        ],
        "testBase32DecodingOfTrailing25Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.assertBase32DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "25",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32DecodingOfTrailing25Bits()",
            "parameters": []
          }
        ],
        "testBase32DecodingOfTrailing30Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.assertBase32DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "30",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32DecodingOfTrailing30Bits()",
            "parameters": []
          }
        ],
        "testBase32DecodingOfTrailing35Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.assertBase32DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "35",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32DecodingOfTrailing35Bits()",
            "parameters": []
          }
        ],
        "testBase32DecodingOfTrailing5Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.assertBase32DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32DecodingOfTrailing5Bits()",
            "parameters": []
          }
        ],
        "testBase32HexImpossibleSamples": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.testImpossibleCases(org.apache.commons.codec.binary.Base32, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "new Base32(0, null, true, BaseNCodec.PAD_DEFAULT, CodecPolicy.STRICT)",
                    "variable_type": "org.apache.commons.codec.binary.Base32"
                  },
                  {
                    "variable_name": "BASE32HEX_IMPOSSIBLE_CASES",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32HexImpossibleSamples()",
            "parameters": []
          }
        ],
        "testBase32HexSamples": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])",
                "arguments": [
                  {
                    "variable_name": "element[0].getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "codec.encodeAsString(element[0].getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32HexSamples()",
            "parameters": []
          }
        ],
        "testBase32HexSamplesReverse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element[0]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(codec.decode(element[1]), CHARSET_UTF8)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32HexSamplesReverse()",
            "parameters": []
          }
        ],
        "testBase32HexSamplesReverseLowercase": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "element[1].toLowerCase()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element[0]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(codec.decode(element[1].toLowerCase()), CHARSET_UTF8)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toLowerCase()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBase32HexSamplesReverseLowercase()",
            "parameters": []
          }
        ],
        "testBase32ImpossibleChunked": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.testImpossibleCases(org.apache.commons.codec.binary.Base32, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "new Base32(20, BaseNCodec.CHUNK_SEPARATOR, false, BaseNCodec.PAD_DEFAULT, CodecPolicy.STRICT)",
                    "variable_type": "org.apache.commons.codec.binary.Base32"
                  },
                  {
                    "variable_name": "BASE32_IMPOSSIBLE_CASES_CHUNKED",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32ImpossibleChunked()",
            "parameters": []
          }
        ],
        "testBase32ImpossibleSamples": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32Test.testImpossibleCases(org.apache.commons.codec.binary.Base32, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "new Base32(0, null, false, BaseNCodec.PAD_DEFAULT, CodecPolicy.STRICT)",
                    "variable_type": "org.apache.commons.codec.binary.Base32"
                  },
                  {
                    "variable_name": "BASE32_IMPOSSIBLE_CASES",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32ImpossibleSamples()",
            "parameters": []
          }
        ],
        "testBase32InBuffer": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "startPasSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.lang3.ArrayUtils.addAll(byte[], byte...)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new byte[endPadSize]",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "StringUtils.newStringUtf8(codec.encode(buffer, startPasSize, bytes.length))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "codec.encode(buffer, startPasSize, bytes.length)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private void testBase32InBuffer(int, int)",
            "parameters": [
              {
                "variable_name": "startPasSize",
                "variable_type": "int"
              },
              {
                "variable_name": "endPadSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testBase32Samples": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])",
                "arguments": [
                  {
                    "variable_name": "element[0].getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "codec.encodeAsString(element[0].getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32Samples()",
            "parameters": []
          }
        ],
        "testBase32SamplesNonDefaultPadding": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeAsString(byte[])",
                "arguments": [
                  {
                    "variable_name": "element[0].getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "codec.encodeAsString(element[0].getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase32SamplesNonDefaultPadding()",
            "parameters": []
          }
        ],
        "testBuilderCodecPolicy": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setDecodingPolicy(org.apache.commons.codec.CodecPolicy)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.LENIENT",
                    "variable_type": "org.apache.commons.codec.CodecPolicy"
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base32"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.LENIENT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Base32.builder().get().getCodecPolicy()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getCodecPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base32.Builder"
              }
            ],
            "signature": "public void testBuilderCodecPolicy()",
            "parameters": []
          }
        ],
        "testBuilderLineAttributes": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base32.builder().setLineLength(4).setLineSeparator(BaseNCodec.CHUNK_SEPARATOR).get().getLineSeparator()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineLength(int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "getLineSeparator",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base32.Builder"
              },
              {
                "signature": "assertArrayEquals",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "Base32.builder().setLineLength(4).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base32"
              },
              {
                "signature": "assertNull",
                "arguments": [
                  {
                    "variable_name": "Base32.builder().setLineLength(-1).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.getLineSeparator()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineSeparator(byte...)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "get",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Base32.builder().get().getLineSeparator()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"MZXXQ===\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Base32.builder().setLineLength(4).get().encodeToString(\"fox\".getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "setLineSeparator",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"fox\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBuilderLineAttributes()",
            "parameters": []
          }
        ],
        "testBuilderPadingByte": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base32.builder().setLineLength(4).setLineSeparator(BaseNCodec.CHUNK_SEPARATOR).get().getLineSeparator()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineLength(int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "getLineSeparator",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base32.Builder"
              },
              {
                "signature": "assertArrayEquals",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "Base32.builder().setLineLength(4).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base32"
              },
              {
                "signature": "assertNull",
                "arguments": [
                  {
                    "variable_name": "Base32.builder().setLineLength(-1).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.getLineSeparator()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineSeparator(byte...)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "get",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Base32.builder().get().getLineSeparator()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"MZXXQ___\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Base32.builder().setLineLength(4).setPadding((byte) '_').get().encodeToString(\"fox\".getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "setLineSeparator",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"fox\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setPadding(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) '_'",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "B"
              }
            ],
            "signature": "public void testBuilderPadingByte()",
            "parameters": []
          }
        ],
        "testCodec200": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodec200()",
            "parameters": []
          }
        ],
        "testConstructors": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "base32",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Base32(32, null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"null line separator\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testConstructors()",
            "parameters": []
          }
        ],
        "testEmptyBase32": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new Base32().encode(null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"empty Base32 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "result.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"empty Base32 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEmptyBase32()",
            "parameters": [],
            "javadoc": "\n     * Test encode and decode of empty byte array.\n     "
          }
        ],
        "testImpossibleCases": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> codec.decode(impossible)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "impossible",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private void testImpossibleCases(Base32, String[])",
            "parameters": [
              {
                "variable_name": "codec",
                "variable_type": "org.apache.commons.codec.binary.Base32"
              },
              {
                "variable_name": "impossible_cases",
                "variable_type": "java.lang.String[]"
              }
            ]
          }
        ],
        "testIsInAlphabet": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base32.isInAlphabet(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "b32.isInAlphabet((byte) 0)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "b32.isInAlphabet((byte) c)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsInAlphabet()",
            "parameters": []
          }
        ],
        "testRandomBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "b[1].length",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "codec.getEncodedLength(b[0])",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "i + \" \" + codec.lineLength",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[])",
                "arguments": [
                  {
                    "variable_name": "b[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testRandomBytes()",
            "parameters": []
          }
        ],
        "testRandomBytesChunked": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "b[1].length",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "codec.getEncodedLength(b[0])",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "i + \" \" + codec.lineLength",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[])",
                "arguments": [
                  {
                    "variable_name": "b[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testRandomBytesChunked()",
            "parameters": []
          }
        ],
        "testRandomBytesHex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "b[1].length",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "codec.getEncodedLength(b[0])",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "i + \" \" + codec.lineLength",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getEncodedLength(byte[])",
                "arguments": [
                  {
                    "variable_name": "b[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testRandomBytesHex()",
            "parameters": []
          }
        ],
        "testSingleCharEncoding": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.equals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "allInOne",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "singly",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.readResults(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "singly",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail()",
                "arguments": [],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base32.encode(byte[], int, int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "unencoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "j",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "unencoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSingleCharEncoding()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.binary.Base32TestData": {
      "fields": [
        {
          "variable_name": "STRING_FIXTURE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BASE32_FIXTURE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n "
    },
    "org.apache.commons.codec.binary.Base64Codec13Test": {
      "fields": [
        {
          "variable_name": "STRINGS",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "CHUNKED_STRINGS",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "BYTES",
          "variable_type": "byte"
        }
      ],
      "constructors": [],
      "methods": {
        "initBYTES": [
          {
            "call_methods": [],
            "signature": "private static void initBYTES()",
            "parameters": []
          }
        ],
        "initCHUNKED_STRINGS": [
          {
            "call_methods": [],
            "signature": "private static void initCHUNKED_STRINGS()",
            "parameters": []
          }
        ],
        "initSTRINGS": [
          {
            "call_methods": [],
            "signature": "private static void initSTRINGS()",
            "parameters": []
          }
        ],
        "utf8": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private static byte[] utf8(String)",
            "parameters": [
              {
                "variable_name": "s",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testBinaryDecoder": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "dec.decode(base64)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"BinaryDecoder test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.BinaryDecoder.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testBinaryDecoder()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryDecoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws DecoderException problem\n     "
          }
        ],
        "testBinaryEncoder": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "enc.encode(binary)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"BinaryEncoder test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.BinaryEncoder.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testBinaryEncoder()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryEncoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws EncoderException problem\n     "
          }
        ],
        "testDecoder": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte[]) dec.decode(base64)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Decoder test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.Decoder.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecoder()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of the org.apache.commons.codec.Decoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws DecoderException problem\n     "
          }
        ],
        "testEncoder": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte[]) enc.encode(binary)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Encoder test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.Encoder.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testEncoder()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of the org.apache.commons.codec.Encoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws EncoderException problem\n     "
          }
        ],
        "testStaticDecode": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.decodeBase64(base64)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"static Base64.decodeBase64() test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testStaticDecode()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of Base64.decodeBase64()\n     * static method is behaving identical to commons-codec-1.3.jar.\n     "
          }
        ],
        "testStaticDecodeChunked": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.decodeBase64(base64Chunked)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"static Base64.decodeBase64Chunked() test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "CHUNKED_STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "base64Chunked",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testStaticDecodeChunked()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of Base64.decodeBase64()\n     * static method is behaving identical to commons-codec-1.3.jar when\n     * supplied with chunked input.\n     "
          }
        ],
        "testStaticEncode": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.encodeBase64(binary)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"static Base64.encodeBase64() test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testStaticEncode()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of Base64.encodeBase64()\n     * static method is behaving identical to commons-codec-1.3.jar.\n     "
          }
        ],
        "testStaticEncodeChunked": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64Chunked",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.encodeBase64Chunked(binary)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"static Base64.encodeBase64Chunked() test-\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Codec13Test.utf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "CHUNKED_STRINGS[i]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])",
                "arguments": [
                  {
                    "variable_name": "binary",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testStaticEncodeChunked()",
            "parameters": [],
            "javadoc": "\n     * Tests to make sure Base64's implementation of Base64.encodeBase64Chunked()\n     * static method is behaving identical to commons-codec-1.3.jar.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests to make sure future versions of commons-codec.jar have identical Base64\n * behavior as commons-codec-1.3.jar.\n "
    },
    "org.apache.commons.codec.binary.Base64InputStreamTest": {
      "fields": [
        {
          "variable_name": "ENCODED_B64",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "CRLF",
          "variable_type": "byte"
        },
        {
          "variable_name": "LF",
          "variable_type": "byte"
        },
        {
          "variable_name": "STRING_FIXTURE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "testAvailable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b64stream.available()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b64stream.skip(10)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.available()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testAvailable()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase64EmptyInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chuckSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chuckSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testBase64EmptyInputStream(int)",
            "parameters": [
              {
                "variable_name": "chuckSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testBase64EmptyInputStreamMimeChuckSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64EmptyInputStreamMimeChuckSize()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base64InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase64EmptyInputStreamPemChuckSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.PEM_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64EmptyInputStreamPemChuckSize()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base64InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase64InputStreamByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\\r\\n\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"\\n\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBase64InputStreamByChunk()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base64InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase64InputStreamByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64InputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CRLF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\\r\\n\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"\\n\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBase64InputStreamByteByByte()",
            "parameters": [],
            "javadoc": "\n     * Tests the Base64InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming base64 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.io.InputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in.read()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"EOF\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation.\n     "
          }
        ],
        "testByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming base64 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.InputStream.read()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in.read()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"EOF\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation.\n     "
          }
        ],
        "testCodec101": [
          {
            "call_methods": [
              {
                "signature": "java.io.FilterInputStream.read(byte[])",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64TestData.CODEC_101_INPUT_LENGTH_IS_MULTIPLE_OF_3",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "c > 0",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Codec101: First read successful [c=\" + c + \"]\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodec101()",
            "parameters": [],
            "javadoc": "\n     * Test for the CODEC-101 bug: InputStream.read(byte[]) should never return 0 because Java's builtin InputStreamReader hates that.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testCodec105": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testCodec105()",
            "parameters": [],
            "javadoc": "\n     * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.\n     "
          }
        ],
        "testCodec130": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.substring(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.FilterOutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(STRING_FIXTURE)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE.substring(1)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream, byte[])",
                "arguments": [
                  {
                    "variable_name": "ins",
                    "variable_type": "java.io.InputStream"
                  },
                  {
                    "variable_name": "new byte[64]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testCodec130()",
            "parameters": [],
            "javadoc": "\n     * Tests the problem reported in CODEC-130. Missing / wrong implementation of skip.\n     "
          }
        ],
        "testCodec98NPE": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64TestData.CODEC_98_NPE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream, byte[])",
                "arguments": [
                  {
                    "variable_name": "stream",
                    "variable_type": "java.io.InputStream"
                  },
                  {
                    "variable_name": "new byte[1024]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64TestData.CODEC_98_NPE_DECODED",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"codec-98 NPE Base64InputStream\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodec98NPE()",
            "parameters": [],
            "javadoc": "\n     * Test the Base64InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testInputStreamReader": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64TestData.CODEC_101_INPUT_LENGTH_IS_MULTIPLE_OF_3",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.BufferedReader.readLine()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "line",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Codec101:  InputStreamReader works!\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testInputStreamReader()",
            "parameters": [],
            "javadoc": "\n     * Another test for the CODEC-101 bug: In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n     * InputStream.read(byte[]) return of 0:\n     *\n     * java.io.IOException: Underlying input stream returned zero bytes at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268) at\n     * sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158) at\n     * java.io.InputStreamReader.read(InputStreamReader.java:167) at java.io.BufferedReader.fill(BufferedReader.java:136) at\n     * java.io.BufferedReader.readLine(BufferedReader.java:299) at java.io.BufferedReader.readLine(BufferedReader.java:362) at\n     * org.apache.commons.codec.binary.Base64InputStreamTest.testInputStreamReader(Base64InputStreamTest.java:75)\n     *\n     * But in commons-codec-1.5 it's fixed. :-)\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testMarkSupported": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "in.markSupported()",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Base64InputStream.markSupported() is false\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.markSupported()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testMarkSupported()",
            "parameters": [],
            "javadoc": "\n     * Tests markSupported.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testRead0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytesRead",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Base64InputStream.read(buf, 0, 0) returns 0\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRead0()",
            "parameters": [],
            "javadoc": "\n     * Tests read returning 0\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testReadMultipleBufferSizes": [
          {
            "call_methods": [
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "out.toByteArray()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytesRead",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.FilterInputStream.read(byte[])",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "new Base64(0, null, false)",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "1024 * 64",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytesRead",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testReadMultipleBufferSizes()",
            "parameters": [],
            "javadoc": "\n     * Tests read using different buffer sizes\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testReadNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> in.read(null, 0, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testReadNull()",
            "parameters": [],
            "javadoc": "\n     * Tests read with null.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testReadOutOfBounds": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> in.read(buf, -1, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base64InputStream.read(buf, -1, 0)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testReadOutOfBounds()",
            "parameters": [],
            "javadoc": "\n     * Tests read throwing IndexOutOfBoundsException\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipBig": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "Integer.MAX_VALUE",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b64stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b64stream.skip(Integer.MAX_VALUE)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipBig()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping number of characters larger than the internal buffer.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipNone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "actualBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new byte[] { 0, 0, 0, (byte) 255, (byte) 255, (byte) 255 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b64stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b64stream.skip(0)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "actualBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "actualBytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipNone()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping as a noop\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipPastEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b64stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b64stream.skip(10)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipPastEnd()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipToEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b64stream.read()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "b64stream.skip(6)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.read()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSkipToEnd()",
            "parameters": [],
            "javadoc": "\n     * Tests skipping to the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testSkipWrongArgument": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ENCODED_B64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> b64stream.skip(-10)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.skip(long)",
                "arguments": [
                  {
                    "variable_name": "-10",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testSkipWrongArgument()",
            "parameters": [],
            "javadoc": "\n     * Tests if negative arguments to skip are handled correctly.\n     *\n     * @throws Throwable\n     *             for some failure scenarios.\n     "
          }
        ],
        "testStrictDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> BaseNTestData.streamToBytes(in2)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.streamToBytes(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecInputStream.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "in.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "in2.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n "
    },
    "org.apache.commons.codec.binary.Base64OutputStreamTest": {
      "fields": [
        {
          "variable_name": "CR_LF",
          "variable_type": "byte"
        },
        {
          "variable_name": "LF",
          "variable_type": "byte"
        },
        {
          "variable_name": "STRING_FIXTURE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "testBase64EmptyOutputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chunkSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyEncoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyDecoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "chunkSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testBase64EmptyOutputStream(int)",
            "parameters": [
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testBase64EmptyOutputStreamMimeChunkSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64EmptyOutputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64EmptyOutputStreamMimeChunkSize()",
            "parameters": [],
            "javadoc": "\n     * Test the Base64OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase64EmptyOutputStreamPemChunkSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testBase64EmptyOutputStream(int)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.PEM_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64EmptyOutputStreamPemChunkSize()",
            "parameters": [],
            "javadoc": "\n     * Test the Base64OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase64OutputStreamByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\\r\\n\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"\\n\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testByChunk(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64OutputStreamByChunk()",
            "parameters": [],
            "javadoc": "\n     * Test the Base64OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testBase64OutputStreamByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64OutputStreamTest.testByteByByte(byte[], byte[], int, byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "76",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "CR_LF",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\\r\\n\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"\\n\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBase64OutputStreamByteByByte()",
            "parameters": [],
            "javadoc": "\n     * Test the Base64OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testByChunk": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming chunked base64 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.OutputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.OutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testByChunk(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation.\n     "
          }
        ],
        "testByteByByte": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Streaming byte-by-byte base64 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.OutputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.OutputStream.write(int)",
                "arguments": [
                  {
                    "variable_name": "element",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.OutputStream.flush()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "private void testByteByByte(byte[], byte[], int, byte[])",
            "parameters": [
              {
                "variable_name": "encoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "decoded",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "chunkSize",
                "variable_type": "int"
              },
              {
                "variable_name": "separator",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation.\n     "
          }
        ],
        "testCodec98NPE": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "codec98",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "codec98_1024",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "codec98.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64TestData.CODEC_98_NPE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64TestData.CODEC_98_NPE_DECODED",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"codec-98 NPE Base64OutputStream\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "codec98_1024",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1024",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodec98NPE()",
            "parameters": [],
            "javadoc": "\n     * Test the Base64OutputStream implementation against the special NPE inducing input\n     * identified in the CODEC-98 bug.\n     *\n     * @throws Exception for some failure scenarios.\n     "
          }
        ],
        "testStrictDecoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> {\r\n    out.write(impossibleEncoded);\r\n    out.close();\r\n}",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.size()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "out.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "impossibleStr",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.io.FilterOutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "impossibleEncoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "bout.size() > 0",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testStrictDecoding()",
            "parameters": [],
            "javadoc": "\n     * Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testWriteOutOfBounds": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> out.write(buf, -1, 1)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base64OutputStream.write(buf, -1, 1)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWriteOutOfBounds()",
            "parameters": [],
            "javadoc": "\n     * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ],
        "testWriteToNullCoverage": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> out.write(null, 0, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWriteToNullCoverage()",
            "parameters": [],
            "javadoc": "\n     * Tests Base64OutputStream.write(null).\n     *\n     * @throws Exception\n     *             for some failure scenarios.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n "
    },
    "org.apache.commons.codec.binary.Base64Test": {
      "fields": [
        {
          "variable_name": "FOX_BASE64",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "FOX_TEXT",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "CHARSET_UTF8",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "BASE64_IMPOSSIBLE_CASES",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_ENCODE_TABLE",
          "variable_type": "byte"
        },
        {
          "variable_name": "random",
          "variable_type": "java.util.Random"
        }
      ],
      "constructors": [],
      "methods": {
        "assertBase64DecodingOfTrailingBits": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.equals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "defaultCodec.encode(decoded)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "codec.encode(decoded)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], int, int, byte)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "STANDARD_ENCODE_TABLE[0]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "defaultCodec.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> codec.decode(encoded)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Final base-64 digit should not be allowed\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.STRICT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "codec.getCodecPolicy()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getCodecPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bitsEncoded",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "decoded[decoded.length - 1]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Invalid decoding of last character\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private static void assertBase64DecodingOfTrailingBits(int)",
            "parameters": [
              {
                "variable_name": "nbits",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Test base 64 decoding of the final trailing bits. Trailing encoded bytes\n     * cannot fit exactly into 6-bit characters so the last character has a limited\n     * alphabet where the final bits are zero. This asserts that illegal final\n     * characters throw an exception when decoding.\n     *\n     * @param nbits the number of trailing bits (must be a factor of 6 and {@code <24})\n     "
          }
        ],
        "getRandom": [
          {
            "call_methods": [],
            "signature": "public Random getRandom()",
            "parameters": [],
            "javadoc": "\n     * @return Returns the random.\n     "
          }
        ],
        "testBase64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG{\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9\\u00e9}8gV29ybGQ=\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(content)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedContent",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"encoding hello world\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(content)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testBase64()",
            "parameters": [],
            "javadoc": "\n     * Test the Base64 implementation\n     "
          }
        ],
        "testBase64AtBufferEnd": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.testBase64InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64AtBufferEnd()",
            "parameters": []
          }
        ],
        "testBase64AtBufferMiddle": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.testBase64InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64AtBufferMiddle()",
            "parameters": []
          }
        ],
        "testBase64AtBufferStart": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.testBase64InBuffer(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "100",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64AtBufferStart()",
            "parameters": []
          }
        ],
        "testBase64DecodingOfTrailing12Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.assertBase64DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "12",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64DecodingOfTrailing12Bits()",
            "parameters": []
          }
        ],
        "testBase64DecodingOfTrailing18Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.assertBase64DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "18",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64DecodingOfTrailing18Bits()",
            "parameters": []
          }
        ],
        "testBase64DecodingOfTrailing6Bits": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.assertBase64DecodingOfTrailingBits(int)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64DecodingOfTrailing6Bits()",
            "parameters": []
          }
        ],
        "testBase64ImpossibleSamples": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> codec.decode(s)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testBase64ImpossibleSamples()",
            "parameters": []
          }
        ],
        "testBase64InBuffer": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "startPasSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytesUtf8.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.lang3.ArrayUtils.addAll(byte[], byte...)",
                "arguments": [
                  {
                    "variable_name": "bytesUtf8",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new byte[endPadSize]",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedContent",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"encoding hello world\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testBase64InBuffer(int, int)",
            "parameters": [
              {
                "variable_name": "startPasSize",
                "variable_type": "int"
              },
              {
                "variable_name": "endPadSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testBuilderCodecPolicy": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setDecodingPolicy(org.apache.commons.codec.CodecPolicy)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.LENIENT",
                    "variable_type": "org.apache.commons.codec.CodecPolicy"
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64.Builder"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "CodecPolicy.LENIENT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Base64.builder().get().getCodecPolicy()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getCodecPolicy()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.CodecPolicy"
              }
            ],
            "signature": "public void testBuilderCodecPolicy()",
            "parameters": []
          }
        ],
        "testBuilderLineAttributes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64.Builder"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.builder().setLineLength(4).setLineSeparator(BaseNCodec.CHUNK_SEPARATOR).get().getLineSeparator()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.getLineSeparator()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineLength(int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "getLineSeparator",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "assertArrayEquals",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "Base64.builder().setLineLength(4).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "assertNull",
                "arguments": [
                  {
                    "variable_name": "Base64.builder().setLineLength(-1).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineSeparator(byte...)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "get",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Base64.builder().get().getLineSeparator()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"Zm94\\r\\n\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Base64.builder().setLineLength(4).get().encodeToString(\"fox\".getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "setLineSeparator",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"fox\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBuilderLineAttributes()",
            "parameters": []
          }
        ],
        "testBuilderPadingByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64.Builder"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.builder().setLineLength(4).setLineSeparator(BaseNCodec.CHUNK_SEPARATOR).get().getLineSeparator()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.getLineSeparator()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineLength(int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "getLineSeparator",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "assertArrayEquals",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "Base64.builder().setLineLength(4).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "assertNull",
                "arguments": [
                  {
                    "variable_name": "Base64.builder().setLineLength(-1).setLineSeparator(null).get().getLineSeparator()",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setLineSeparator(byte...)",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "get",
                "arguments": [],
                "return_type": "unresolved"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Base64.builder().get().getLineSeparator()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"VGhlIGJyb3duIGZveA==\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Base64.builder().get().encodeToString(\"The brown fox\".getBytes(CHARSET_UTF8))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "setLineSeparator",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"The brown fox\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setPadding(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) '_'",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "B"
              }
            ],
            "signature": "public void testBuilderPadingByte()",
            "parameters": []
          }
        ],
        "testBuilderUrlSafe": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64.Builder"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isUrlSafe()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "Base64.builder().get().isUrlSafe()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.Builder.setUrlSafe(boolean)",
                "arguments": [
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "org.apache.commons.codec.binary.Base64.Builder"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Base64.builder().setUrlSafe(false).setUrlSafe(true).get().isUrlSafe()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBuilderUrlSafe()",
            "parameters": []
          }
        ],
        "testByteToStringVariations": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"2bf7cc2701fe4397b49ebeed5acc7090\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64.encodeToString(b3)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"byteToString null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])",
                "arguments": [
                  {
                    "variable_name": "b1",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(byte[])",
                "arguments": [
                  {
                    "variable_name": "b4",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encodeToString(byte[])",
                "arguments": [
                  {
                    "variable_name": "b1",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "base64.encodeToString(b1)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"byteToString Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testByteToStringVariations()",
            "parameters": []
          }
        ],
        "testChunkedEncodeMultipleOf76": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expectedEncode",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actualEncode",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"chunkedEncodeMultipleOf76\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "BaseNTestData.DECODED",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "actualResult",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"\\n\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"\\r\\n\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testChunkedEncodeMultipleOf76()",
            "parameters": [],
            "javadoc": "\n     * Tests Base64.encodeBase64().\n     "
          }
        ],
        "testCodec112": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean, int)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "out.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testCodec112()",
            "parameters": []
          }
        ],
        "testCodec263": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"publishMessage\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"publishMessage\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(\"publishMessage\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodec263()",
            "parameters": [],
            "javadoc": "\n     * Tests <a href=\"https://issues.apache.org/jira/browse/CODEC-263\">CODEC-263</a>.\n     "
          }
        ],
        "testCodec265": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "expectedLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "encoded.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "presumableFreeMemory > estimatedMemory",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Not enough free memory for the test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Math.ceil(double)",
                "arguments": [
                  {
                    "variable_name": "size1GiB / 3.0",
                    "variable_type": "double"
                  }
                ],
                "return_type": "double"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecTest.getPresumableFreeMemory()",
                "arguments": [],
                "return_type": "long"
              }
            ],
            "signature": "public void testCodec265()",
            "parameters": [],
            "javadoc": "\n     * Test for CODEC-265: Encode a 1GiB file.\n     *\n     * @see <a href=\"https://issues.apache.org/jira/projects/CODEC/issues/CODEC-265\">CODEC-265</a>\n     "
          }
        ],
        "testCodec68": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "x",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testCodec68()",
            "parameters": [],
            "javadoc": "\n     * CODEC-68: isBase64 throws ArrayIndexOutOfBoundsException on some\n     * non-BASE64 bytes\n     "
          }
        ],
        "testCodeInteger1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeInteger(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedInt1.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.math.BigInteger"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeInteger(java.math.BigInteger)",
                "arguments": [
                  {
                    "variable_name": "bigInt1",
                    "variable_type": "java.math.BigInteger"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encodedInt1",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeInteger(bigInt1))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodeInteger1()",
            "parameters": []
          }
        ],
        "testCodeInteger2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeInteger(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedInt2.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.math.BigInteger"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeInteger(java.math.BigInteger)",
                "arguments": [
                  {
                    "variable_name": "bigInt2",
                    "variable_type": "java.math.BigInteger"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encodedInt2",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeInteger(bigInt2))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodeInteger2()",
            "parameters": []
          }
        ],
        "testCodeInteger3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeInteger(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedInt3.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.math.BigInteger"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeInteger(java.math.BigInteger)",
                "arguments": [
                  {
                    "variable_name": "bigInt3",
                    "variable_type": "java.math.BigInteger"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encodedInt3",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeInteger(bigInt3))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodeInteger3()",
            "parameters": []
          }
        ],
        "testCodeInteger4": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeInteger(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedInt4.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.math.BigInteger"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeInteger(java.math.BigInteger)",
                "arguments": [
                  {
                    "variable_name": "bigInt4",
                    "variable_type": "java.math.BigInteger"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encodedInt4",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeInteger(bigInt4))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodeInteger4()",
            "parameters": []
          }
        ],
        "testCodeIntegerEdgeCases": [
          {
            "call_methods": [],
            "signature": "public void testCodeIntegerEdgeCases()",
            "parameters": []
          }
        ],
        "testCodeIntegerNull": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeInteger(java.math.BigInteger)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.math.BigInteger"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Base64.encodeInteger(null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Exception not thrown when passing in null to encodeInteger(BigInteger)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testCodeIntegerNull()",
            "parameters": []
          }
        ],
        "testConstructor_Int_ByteArray_Boolean": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.replace(char, char)",
                "arguments": [
                  {
                    "variable_name": "'\\n'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'\\t'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNTestData.DECODED",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"new Base64(65, \\\\t, false)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructor_Int_ByteArray_Boolean()",
            "parameters": []
          }
        ],
        "testConstructor_Int_ByteArray_Boolean_UrlSafe": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.replace(char, char)",
                "arguments": [
                  {
                    "variable_name": "'\\n'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'\\t'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"=\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNTestData.DECODED",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"new Base64(64, \\\\t, true)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructor_Int_ByteArray_Boolean_UrlSafe()",
            "parameters": []
          }
        ],
        "testConstructors": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "base64",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Base64(-1, new byte[] { 'A' })",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Should have rejected attempt to use 'A' as a line separator\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testConstructors()",
            "parameters": []
          }
        ],
        "testCustomEncodingAlphabet": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64.Builder"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setEncodeTable(byte...)",
                "arguments": [
                  {
                    "variable_name": "encodeTable",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "B"
              },
              {
                "signature": "java.lang.String.replace(char, char)",
                "arguments": [
                  {
                    "variable_name": "'B'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'-'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encodedContent.contains(\"A\") && encodedContent.contains(\"B\")",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"testing precondition not met - ecodedContent should contain parts of modified table\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "// replace alphabet adjustments\r\nencodedContent.replace('A', '.').replace('B', '-').replace(\"=\", // remove padding (not default alphabet)\r\n\"\")",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedContentCustom",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.replace(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"=\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "// remove padding (not default alphabet)\r\n\"\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(content)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"A\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedBytesCustom",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testCustomEncodingAlphabet()",
            "parameters": []
          }
        ],
        "testCustomEncodingAlphabet_illegal": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.builder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64.Builder"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Base64.builder().setEncodeTable(encodeTable).get()",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.Builder.get()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.binary.Base64"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.AbstractBuilder.setEncodeTable(byte...)",
                "arguments": [
                  {
                    "variable_name": "encodeTable",
                    "variable_type": "byte..."
                  }
                ],
                "return_type": "B"
              }
            ],
            "signature": "public void testCustomEncodingAlphabet_illegal()",
            "parameters": []
          }
        ],
        "testDecodeEncode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "Base64.decodeBase64(encodedText)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encodedText",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(decodedText)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "decodedText",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encodedText",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedText2",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testDecodeEncode(String)",
            "parameters": [
              {
                "variable_name": "encodedText",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDecodePadMarkerIndex2": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"QQ==\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"A\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.decodeBase64(\"QQ==\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodePadMarkerIndex2()",
            "parameters": [],
            "javadoc": "\n     * Tests conditional true branch for \"marker0\" test.\n     "
          }
        ],
        "testDecodePadMarkerIndex3": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"QUE=\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AA\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.decodeBase64(\"QUE=\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodePadMarkerIndex3()",
            "parameters": [],
            "javadoc": "\n     * Tests conditional branches for \"marker1\" test.\n     "
          }
        ],
        "testDecodePadOnly": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "Base64.decodeBase64(\"====\".getBytes(CHARSET_UTF8)).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"====\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.decodeBase64(\"====\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodePadOnly()",
            "parameters": []
          }
        ],
        "testDecodePadOnlyChunked": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "Base64.decodeBase64(\"====\\n\".getBytes(CHARSET_UTF8)).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"====\\n\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.decodeBase64(\"====\\n\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodePadOnlyChunked()",
            "parameters": []
          }
        ],
        "testDecodeWithInnerPad": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "shouldBe",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"decode should halt at pad (=)\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "content",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testDecodeWithInnerPad()",
            "parameters": [],
            "javadoc": "\n     * Test our decode with pad character in the middle. (Our current\n     * implementation: halt decode and return what we've got so far).\n     *\n     * The point of this test is not to say\n     * \"this is the correct way to decode base64.\" The point is simply to keep\n     * us aware of the current logic since 1.4 so we don't accidentally break it\n     * without realizing.\n     *\n     * Note for historians. The 1.3 logic would decode to:\n     * \"Hello World\\u0000Hello World\" -- null in the middle --- and 1.4\n     * unwittingly changed it to current logic.\n     "
          }
        ],
        "testDecodeWithWhitespace": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.StringBuilder.insert(int, char)",
                "arguments": [
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "' '",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedWithWS",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "orig.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "orig",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "dest",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Dest string doesn't equal the original\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeWithWhitespace()",
            "parameters": []
          }
        ],
        "testEmptyBase64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64.encodeBase64(null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"empty base64 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "empty",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "result.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"empty base64 encode\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEmptyBase64()",
            "parameters": [],
            "javadoc": "\n     * Test encode and decode of empty byte array.\n     "
          }
        ],
        "testEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "Base64.decodeBase64(encodedText)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encodedText",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(plainText)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plainText",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "plainText",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "decodedText",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testEncodeDecode(String)",
            "parameters": [
              {
                "variable_name": "plainText",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testEncodeDecodeRandom": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.getRandom()",
                "arguments": [],
                "return_type": "java.util.Random"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "data2",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "enc",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "enc",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.Random.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "10000",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(enc)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeDecodeRandom()",
            "parameters": []
          }
        ],
        "testEncodeDecodeSmall": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.getRandom()",
                "arguments": [],
                "return_type": "java.util.Random"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "data2",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "toString(data) + \" equals \" + toString(data2)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "enc",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(enc)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"\\\"\" + new String(enc) + \"\\\" is Base64 data.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.toString(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "enc",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeDecodeSmall()",
            "parameters": []
          }
        ],
        "testEncodeOverMaxSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.testEncodeOverMaxSize(int)",
                "arguments": [
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeOverMaxSize()",
            "parameters": []
          },
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Base64.encodeBase64(BaseNTestData.DECODED, true, false, maxSize)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[], boolean, boolean, int)",
                "arguments": [
                  {
                    "variable_name": "BaseNTestData.DECODED",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "maxSize",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private void testEncodeOverMaxSize(int)",
            "parameters": [
              {
                "variable_name": "maxSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testHugeLineSeparator": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "strOriginal",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(strOriginal)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "strOriginal",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "strDecoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"testDEFAULT_BUFFER_SIZE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "b64.encode(StringUtils.getBytesUtf8(strOriginal))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testHugeLineSeparator()",
            "parameters": [],
            "javadoc": "\n     * Tests a lineSeparator much bigger than DEFAULT_BUFFER_SIZE.\n     *\n     * @see \"<a href='https://mail-archives.apache.org/mod_mbox/commons-dev/201202.mbox/%3C4F3C85D7.5060706@snafu.de%3E'>dev@commons.apache.org</a>\"\n     "
          }
        ],
        "testIgnoringNonBase64InDecode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "FOX_BASE64.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "FOX_TEXT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.decodeBase64(FOX_BASE64.getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIgnoringNonBase64InDecode()",
            "parameters": []
          }
        ],
        "testIsArrayByteBase64": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(new byte[] { Byte.MIN_VALUE })",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { Byte.MIN_VALUE }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(new byte[] { 'A' })",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsArrayByteBase64()",
            "parameters": []
          }
        ],
        "testIsStringBase64": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(invalidString)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Base64.isStringBase64(invalid-string) is false\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "nullString",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(emptyString)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Base64.isStringBase64(empty-string) is true\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Base64.isBase64(nullString)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Base64.isStringBase64() should not be null-safe.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testIsStringBase64()",
            "parameters": [],
            "javadoc": "\n     * Test the isStringBase64 method.\n     "
          }
        ],
        "testIsUrlSafe": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64Standard.isUrlSafe()",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Base64.isUrlSafe=false\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isUrlSafe()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "whiteSpace",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "base64URLSafe.isUrlSafe()",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Base64.isUrlSafe=true\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsUrlSafe()",
            "parameters": [],
            "javadoc": "\n     * Tests isUrlSafe.\n     "
          }
        ],
        "testKnownDecodings": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "FOX_TEXT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.decodeBase64(\"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testKnownDecodings()",
            "parameters": []
          }
        ],
        "testKnownEncodings": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg==\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeBase64(FOX_TEXT.getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "FOX_TEXT.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testKnownEncodings()",
            "parameters": []
          }
        ],
        "testNonBase64Test": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Base64.isBase64(bArray)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Invalid Base64 array was incorrectly validated as an array of Base64 encoded data\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Exception '\" + e.getClass().getName() + \"' was thrown when trying to decode \" + \"invalid base64 encoded data - RFC 2045 requires that all \" + \"non base64 character be discarded, an exception should not have been thrown\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.isBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "bArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "result.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"The result should be empty as the test encoded content did \" + \"not contain any valid base 64 characters\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "bArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testNonBase64Test()",
            "parameters": []
          }
        ],
        "testObjectDecodeWithInvalidParameter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Integer.valueOf(5)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Base64().decode(Integer.valueOf(5))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"decode(Object) didn't throw an exception when passed an Integer object\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Integer.valueOf(int)",
                "arguments": [
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.Integer"
              }
            ],
            "signature": "public void testObjectDecodeWithInvalidParameter()",
            "parameters": []
          }
        ],
        "testObjectDecodeWithValidParameter": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "o",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "original.getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "original",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "dest",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"dest string does not equal original\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testObjectDecodeWithValidParameter()",
            "parameters": []
          }
        ],
        "testObjectEncode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"SGVsbG8gV29ybGQ=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(b64.encode(\"Hello World\".getBytes(CHARSET_UTF8)))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testObjectEncode()",
            "parameters": []
          }
        ],
        "testObjectEncodeWithInvalidParameter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"Yadayadayada\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Base64().encode(\"Yadayadayada\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"encode(Object) didn't throw an exception when passed a String object\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testObjectEncodeWithInvalidParameter()",
            "parameters": []
          }
        ],
        "testObjectEncodeWithValidParameter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "origObj",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) oEncoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "original",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "dest",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"dest string does not equal original\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testObjectEncodeWithValidParameter()",
            "parameters": []
          }
        ],
        "testPairs": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.decodeBase64(Base64.encodeBase64(test))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "Base64.encodeBase64(test)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AAA=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeBase64(new byte[] { 0, 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { 0, 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testPairs()",
            "parameters": []
          }
        ],
        "testRfc1421Section6Dot8ChunkSizeDefinition": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "64",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "BaseNCodec.PEM_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc1421Section6Dot8ChunkSizeDefinition()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 1421 section 4.3.2.4 chuck size definition.\n     "
          }
        ],
        "testRfc2045Section2Dot1CrLfDefinition": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { 13, 10 }",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc2045Section2Dot1CrLfDefinition()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 2045 section 2.1 CRLF definition.\n     "
          }
        ],
        "testRfc2045Section6Dot8ChunkSizeDefinition": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "76",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "BaseNCodec.MIME_CHUNK_SIZE",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc2045Section6Dot8ChunkSizeDefinition()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 2045 section 6.8 chuck size definition.\n     "
          }
        ],
        "testRfc4648Section10Decode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "Base64.decodeBase64(\"\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "StringUtils.newStringUsAscii(Base64.decodeBase64(\"\"))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc4648Section10Decode()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>\n     "
          }
        ],
        "testRfc4648Section10DecodeEncode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.testDecodeEncode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc4648Section10DecodeEncode()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>\n     "
          }
        ],
        "testRfc4648Section10DecodeWithCrLf": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "BaseNCodec.CHUNK_SEPARATOR",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\" + CRLF",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "StringUtils.newStringUsAscii(Base64.decodeBase64(\"\" + CRLF))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc4648Section10DecodeWithCrLf()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>\n     "
          }
        ],
        "testRfc4648Section10Encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64String(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(\"\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Base64.encodeBase64String(StringUtils.getBytesUtf8(\"\"))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc4648Section10Encode()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>\n     "
          }
        ],
        "testRfc4648Section10EncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Base64Test.testEncodeDecode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRfc4648Section10EncodeDecode()",
            "parameters": [],
            "javadoc": "\n     * Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>\n     "
          }
        ],
        "testSingletons": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Base64.decodeBase64(Base64.encodeBase64(test))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "Base64.encodeBase64(test)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AA==\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeBase64(new byte[] { (byte) 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSingletons()",
            "parameters": []
          }
        ],
        "testSingletonsChunked": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AA==\\r\\n\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeBase64Chunked(new byte[] { (byte) 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSingletonsChunked()",
            "parameters": []
          }
        ],
        "testStringToByteVariations": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "b4",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "base64.decode(s4b)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"StringToByte UUID\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"2bf7cc2701fe4397b49ebeed5acc7090\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.newStringUtf8(base64.decode(s3))",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"StringToByte null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) s1",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "StringUtils.newStringUtf8(base64.decode(s1))",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"StringToByte Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "base64.decode(s1)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testStringToByteVariations()",
            "parameters": []
          }
        ],
        "testTriplets": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AAAA\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeBase64(new byte[] { (byte) 0, (byte) 0, (byte) 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0, (byte) 0, (byte) 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testTriplets()",
            "parameters": []
          }
        ],
        "testTripletsChunked": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AAAA\\r\\n\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Base64.encodeBase64Chunked(new byte[] { (byte) 0, (byte) 0, (byte) 0 }))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64Chunked(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { (byte) 0, (byte) 0, (byte) 0 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testTripletsChunked()",
            "parameters": []
          }
        ],
        "testUrlSafe": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "result",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"url-safe i=\" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "BaseNTestData.bytesContain(encoded, (byte) '=')",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"url-safe i=\" + i + \" no '='\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.randomData(org.apache.commons.codec.binary.BaseNCodec, int)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[][]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.bytesContain(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) '='",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testUrlSafe()",
            "parameters": [],
            "javadoc": "\n     * Tests URL-safe Base64 against random data, sizes 0 to 150.\n     "
          }
        ],
        "testUUID": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encodedStandard",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "standard[i]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"standard encode uuid\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"94ed8d0319e4493399560fb67404d370\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64URLSafe(byte[])",
                "arguments": [
                  {
                    "variable_name": "ids[i]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"lO2NAxnkSTOZVg+2dATTcA==\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.decodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "standard[i]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Base64.encodeBase64(byte[])",
                "arguments": [
                  {
                    "variable_name": "ids[i]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testUUID()",
            "parameters": [],
            "javadoc": "\n     * Base64 encoding of UUID's is a common use-case, especially in URL-SAFE\n     * mode. This test case ends up being the \"URL-SAFE\" JUnit's.\n     *\n     * @throws DecoderException\n     *             if Hex.decode() fails - a serious problem since Hex comes\n     *             from our own commons-codec!\n     "
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(int)",
                "arguments": [
                  {
                    "variable_name": "data[i]",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\",\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private String toString(byte[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "byte[]"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Test cases for Base64 class.\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n "
    },
    "org.apache.commons.codec.binary.Base64TestData": {
      "fields": [
        {
          "variable_name": "CODEC_101_INPUT_LENGTH_IS_MULTIPLE_OF_3",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "CODEC_98_NPE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "CODEC_98_NPE_DECODED",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ENCODED_64_CHARS_PER_LINE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ENCODED_76_CHARS_PER_LINE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {},
      "is_interface": false,
      "javadoc": "\n * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n "
    },
    "org.apache.commons.codec.binary.BaseNCodecTest": {
      "fields": [
        {
          "variable_name": "codec",
          "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
        }
      ],
      "constructors": [],
      "methods": {
        "assertEnsureBufferSizeExpandsToMaxBufferSize": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.gc()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "extra",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "presumableFreeMemory > estimatedMemory",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Not enough free memory for the test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecTest.assumeCanAllocateBufferSize(int)",
                "arguments": [
                  {
                    "variable_name": "max + 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecTest.getPresumableFreeMemory()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "context.buffer.length >= length + extra",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static void assertEnsureBufferSizeExpandsToMaxBufferSize(boolean)",
            "parameters": [
              {
                "variable_name": "exceedMaxBufferSize",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "assumeCanAllocateBufferSize": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bytes != null",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Cannot allocate array of size: \" + size",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static void assumeCanAllocateBufferSize(int)",
            "parameters": [
              {
                "variable_name": "size",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Verify this VM can allocate the given size byte array. Otherwise skip the test.\n     "
          }
        ],
        "getPresumableFreeMemory": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.gc()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Runtime.totalMemory()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Runtime.maxMemory()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Runtime.getRuntime()",
                "arguments": [],
                "return_type": "java.lang.Runtime"
              },
              {
                "signature": "java.lang.Runtime.freeMemory()",
                "arguments": [],
                "return_type": "long"
              }
            ],
            "signature": " static long getPresumableFreeMemory()",
            "parameters": [],
            "javadoc": "\n     * Gets the presumable free memory; an estimate of the amount of memory that could be allocated.\n     *\n     * <p>This performs a garbage clean-up and the obtains the presumed amount of free memory\n     * that can be allocated in this VM. This is computed as:<p>\n     *\n     * <pre>\n     * System.gc();\n     * long allocatedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n     * long presumableFreeMemory = Runtime.getRuntime().maxMemory() - allocatedMemory;\n     * </pre>\n     *\n     * @return the presumable free memory\n     * @see <a href=\"https://stackoverflow.com/a/18366283\">\n     *     Christian Fries StackOverflow answer on Java available memory</a>\n     "
          }
        ],
        "setUp": [
          {
            "call_methods": [],
            "signature": "public void setUp()",
            "parameters": []
          }
        ],
        "testBaseNCodec": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "codec",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBaseNCodec()",
            "parameters": []
          }
        ],
        "testContainsAlphabetOrPad": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.containsAlphabetOrPad(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.containsAlphabetOrPad(null)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.containsAlphabetOrPad(\"OK\".getBytes())",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testContainsAlphabetOrPad()",
            "parameters": []
          }
        ],
        "testContextToString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.Context.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"[0, 0, 0]\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "text.contains(\"[0, 0, 0]\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testContextToString()",
            "parameters": [],
            "javadoc": "\n     * Test the Context string representation has debugging info.\n     * This is not part of the API and the test should be changed if the string\n     * format is updated.\n     "
          }
        ],
        "testEnsureBufferSize": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "context.buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Initial buffer should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "context.buffer.length >= length + extra",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"buffer should expand\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.getDefaultBufferSize()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "context.buffer",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"buffer should be initialized\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ncodec.getDefaultBufferSize()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context.buffer.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"buffer should be initialized to default size\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEnsureBufferSize()",
            "parameters": []
          }
        ],
        "testEnsureBufferSizeExpandsToBeyondMaxBufferSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecTest.assertEnsureBufferSizeExpandsToMaxBufferSize(boolean)",
                "arguments": [
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEnsureBufferSizeExpandsToBeyondMaxBufferSize()",
            "parameters": [],
            "javadoc": "\n     * Test to expand to beyond the max buffer size.\n     *\n     * <p>Note: If the buffer is required to expand to above the max buffer size it may not work\n     * on all VMs and may have to be annotated with @Ignore.</p>\n     "
          }
        ],
        "testEnsureBufferSizeExpandsToMaxBufferSize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodecTest.assertEnsureBufferSizeExpandsToMaxBufferSize(boolean)",
                "arguments": [
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEnsureBufferSizeExpandsToMaxBufferSize()",
            "parameters": [],
            "javadoc": "\n     * Test to expand to the max buffer size.\n     "
          }
        ],
        "testEnsureBufferSizeThrowsOnOverflow": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "OutOfMemoryError.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> ncodec.ensureBufferSize(extra, context)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.ensureBufferSize(int, org.apache.commons.codec.binary.BaseNCodec.Context)",
                "arguments": [
                  {
                    "variable_name": "extra",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "context",
                    "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEnsureBufferSizeThrowsOnOverflow()",
            "parameters": []
          }
        ],
        "testIsInAlphabetByte": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isInAlphabet((byte) 0)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isInAlphabet((byte) 'O')",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsInAlphabetByte()",
            "parameters": []
          }
        ],
        "testIsInAlphabetByteArrayBoolean": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "new byte[] {}",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isInAlphabet(new byte[] { 'O', ' ' }, false)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isInAlphabet(new byte[] {}, false)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsInAlphabetByteArrayBoolean()",
            "parameters": []
          }
        ],
        "testIsInAlphabetString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.isInAlphabet(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"OK\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isInAlphabet(\"OK\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsInAlphabetString()",
            "parameters": []
          }
        ],
        "testIsWhiteSpace": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Character.isWhitespace(int)",
                "arguments": [
                  {
                    "variable_name": "(byte) ' '",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Character.isWhitespace(b)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Character.isWhitespace(byteToCheck)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Character.isWhitespace((byte) ' ')",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsWhiteSpace()",
            "parameters": []
          }
        ],
        "testProvidePaddingByte": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0x25",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "actualPaddingByte",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testProvidePaddingByte()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.binary.BaseNCodecTest.NoOpBaseNCodec": {
      "fields": [],
      "constructors": [
        {
          "body": " NoOpBaseNCodec()\n{\r\n    super(0, 0, 0, 0);\r\n}",
          "signature": "NoOpBaseNCodec()",
          "parameters": []
        }
      ],
      "methods": {
        "decode": [
          {
            "call_methods": [],
            "signature": " void decode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "i",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ]
          }
        ],
        "encode": [
          {
            "call_methods": [],
            "signature": " void encode(byte[], int, int, Context)",
            "parameters": [
              {
                "variable_name": "pArray",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "i",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              },
              {
                "variable_name": "context",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec.Context"
              }
            ]
          }
        ],
        "isInAlphabet": [
          {
            "call_methods": [],
            "signature": "protected boolean isInAlphabet(byte)",
            "parameters": [
              {
                "variable_name": "value",
                "variable_type": "byte"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Extend BaseNCodec without implementation (no operations = NoOp).\n     * Used for testing the memory allocation in {@link BaseNCodec#ensureBufferSize(int, Context)}.\n     "
    },
    "org.apache.commons.codec.binary.BaseNTestData": {
      "fields": [
        {
          "variable_name": "DECODED",
          "variable_type": "byte"
        },
        {
          "variable_name": "SIZE_KEY",
          "variable_type": "int"
        },
        {
          "variable_name": "LAST_READ_KEY",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "bytesContain": [
          {
            "call_methods": [],
            "signature": " static boolean bytesContain(byte[], byte)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "c",
                "variable_type": "byte"
              }
            ],
            "javadoc": "\n     * Tests the supplied byte[] array to see if it contains the specified byte c.\n     *\n     * @param bytes byte[] array to test\n     * @param c byte to look for\n     * @return true if bytes contains c, false otherwise\n     "
          }
        ],
        "fill": [
          {
            "call_methods": [
              {
                "signature": "java.io.InputStream.read(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buf.length - offset",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "private static int[] fill(byte[], int, InputStream)",
            "parameters": [
              {
                "variable_name": "buf",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "offset",
                "variable_type": "int"
              },
              {
                "variable_name": "in",
                "variable_type": "java.io.InputStream"
              }
            ]
          }
        ],
        "randomData": [
          {
            "call_methods": [
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "decoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": " static byte[][] randomData(BaseNCodec, int)",
            "parameters": [
              {
                "variable_name": "codec",
                "variable_type": "org.apache.commons.codec.binary.BaseNCodec"
              },
              {
                "variable_name": "size",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Returns an encoded and decoded copy of the same random data.\n     *\n     * @param codec the codec to use\n     * @param size amount of random data to generate and encode\n     * @return two byte[] arrays:  [0] = decoded, [1] = encoded\n     "
          }
        ],
        "resizeArray": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "biggerBytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static byte[] resizeArray(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "streamToBytes": [
          {
            "call_methods": [
              {
                "signature": "java.io.InputStream.read(byte[])",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.ByteArrayOutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "read",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": " static byte[] streamToBytes(InputStream)",
            "parameters": [
              {
                "variable_name": "in",
                "variable_type": "java.io.InputStream"
              }
            ],
            "javadoc": "\n     * Read all bytes from an InputStream into a byte array.\n     *\n     * @param in the input stream.\n     * @return the byte array\n     *\n     * @throws IOException if an error occurs whilst reading the input stream\n     "
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "smallerBuf",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "size",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.resizeArray(byte[])",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.InputStream.close()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BaseNTestData.fill(byte[], int, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "buf",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": " static byte[] streamToBytes(InputStream, byte[])",
            "parameters": [
              {
                "variable_name": "in",
                "variable_type": "java.io.InputStream"
              },
              {
                "variable_name": "buf",
                "variable_type": "byte[]"
              }
            ],
            "javadoc": "\n     * Read all bytes from an InputStream into a byte array\n     * in chunks of {@code buf.length}.\n     *\n     * @param in the input stream.\n     * @param buf the byte array to use for chunking\n     *\n     * @return the bytes read from the input stream\n     *\n     * @throws IOException if an error occurs whilst reading the input stream\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Data and functions common to BaseN tests.\n "
    },
    "org.apache.commons.codec.binary.BinaryCodecTest": {
      "fields": [
        {
          "variable_name": "CHARSET_UTF8",
          "variable_type": "java.nio.charset.Charset"
        },
        {
          "variable_name": "BIT_0",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_1",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_2",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_3",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_4",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_5",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_6",
          "variable_type": "int"
        },
        {
          "variable_name": "BIT_7",
          "variable_type": "int"
        },
        {
          "variable_name": "instance",
          "variable_type": "org.apache.commons.codec.binary.BinaryCodec"
        }
      ],
      "constructors": [],
      "methods": {
        "assertDecodeObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encodeMe",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new String(bits)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(decoded)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": " void assertDecodeObject(byte[], String)",
            "parameters": [
              {
                "variable_name": "bits",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "encodeMe",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Utility used to assert the encoded and decoded values.\n     *\n     * @param bits\n     *            the pre-encoded data\n     * @param encodeMe\n     *            data to encode and compare\n     "
          }
        ],
        "setUp": [
          {
            "call_methods": [],
            "signature": "public void setUp()",
            "parameters": []
          }
        ],
        "tearDown": [
          {
            "call_methods": [],
            "signature": "public void tearDown()",
            "parameters": []
          }
        ],
        "testDecodeByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"00000000\".getBytes(CHARSET_UTF8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new String(bits)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(decoded)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeByteArray()",
            "parameters": []
          }
        ],
        "testDecodeObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodecTest.assertDecodeObject(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bits",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"00000000\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeObject()",
            "parameters": [],
            "javadoc": "\n     * Tests for Object decode(Object)\n     "
          }
        ],
        "testDecodeObjectException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Expected DecoderException\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new Object()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeObjectException()",
            "parameters": [],
            "javadoc": "\n     * Tests for Object decode(Object)\n     "
          }
        ],
        "testEncodeByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "bits",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "instance.encode((byte[]) null).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"00000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "l_encoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeByteArray()",
            "parameters": []
          }
        ],
        "testEncodeObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) bits",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"00000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "l_encoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeObject()",
            "parameters": []
          }
        ],
        "testEncodeObjectException": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Expected EncoderException\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public void testEncodeObjectException()",
            "parameters": []
          }
        ],
        "testEncodeObjectNull": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "obj",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "((char[]) instance.encode(obj)).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeObjectNull()",
            "parameters": []
          }
        ],
        "testFromAsciiByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "CHARSET_UTF8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "BinaryCodec.fromAscii((byte[]) null).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new String(bits)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(decoded)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testFromAsciiByteArray()",
            "parameters": []
          }
        ],
        "testFromAsciiCharArray": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "BinaryCodec.fromAscii((char[]) null).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.fromAscii(char[])",
                "arguments": [
                  {
                    "variable_name": "(char[]) null",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new String(bits)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(decoded)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testFromAsciiCharArray()",
            "parameters": []
          }
        ],
        "testToAsciiBytes": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "BinaryCodec.toAsciiBytes((byte[]) null).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "bits",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"00000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "l_encoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testToAsciiBytes()",
            "parameters": []
          }
        ],
        "testToAsciiChars": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "BinaryCodec.toAsciiChars((byte[]) null).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"00000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "l_encoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiChars(byte[])",
                "arguments": [
                  {
                    "variable_name": "bits",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testToAsciiChars()",
            "parameters": []
          }
        ],
        "testToAsciiString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.toAsciiString(byte[])",
                "arguments": [
                  {
                    "variable_name": "bits",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"00000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "l_encoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testToAsciiString()",
            "parameters": [],
            "javadoc": "\n     * Tests the toAsciiString(byte[]) method\n     "
          }
        ],
        "testToByteArrayFromString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.BinaryCodec.toByteArray(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"00000000\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "instance.toByteArray((String) null).length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new String(bits)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(decoded)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testToByteArrayFromString()",
            "parameters": [],
            "javadoc": "\n     * Tests for byte[] toByteArray(String)\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * TestCase for BinaryCodec class.\n "
    },
    "org.apache.commons.codec.binary.CharSequenceUtilsTest": {
      "fields": [
        {
          "variable_name": "TEST_DATA",
          "variable_type": "org.apache.commons.codec.binary.CharSequenceUtilsTest.TestData"
        }
      ],
      "constructors": [],
      "methods": {
        "testConstructor": [
          {
            "call_methods": [],
            "signature": "public void testConstructor()",
            "parameters": [],
            "javadoc": "\n     * Test the constructor exists. This is here for code coverage. The class ideally should\n     * be package private, marked as final and have a private constructor to prevent instances.\n     "
          }
        ],
        "testRegionMatches": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.CharSequenceUtilsTest.RunTest.run(org.apache.commons.codec.binary.CharSequenceUtilsTest.TestData, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "org.apache.commons.codec.binary.CharSequenceUtilsTest.TestData"
                  },
                  {
                    "variable_name": "\"String\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.CharSequenceUtils.regionMatches(java.lang.CharSequence, boolean, int, java.lang.CharSequence, int, int)",
                "arguments": [
                  {
                    "variable_name": "data.source",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "data.ignoreCase",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "data.toffset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.other",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "data.ooffset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.len",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)",
                "arguments": [
                  {
                    "variable_name": "data.ignoreCase",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "data.toffset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.other",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "data.ooffset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.len",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testRegionMatches()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link org.apache.commons.codec.binary.CharSequenceUtils}.\n *\n * <p>Tests copied from Apache Commons Lang 3.11. The implementation in codec is based on\n * an earlier version of Lang and some tests fail. The CharSequenceUtils class is public but\n * the method is package private. The failing tests have been commented out and the\n * implementation left unchanged.\n "
    },
    "org.apache.commons.codec.binary.CharSequenceUtilsTest.RunTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "invoke": [
          {
            "call_methods": [],
            "signature": " abstract boolean invoke()",
            "parameters": []
          }
        ],
        "run": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "msg + \" but nothing was thrown.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data.throwable.isAssignableFrom(ex.getClass())",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "msg + \" but was \" + ex.getClass().getSimpleName()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.CharSequenceUtilsTest.RunTest.invoke()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Class.getSimpleName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Class.isAssignableFrom(java.lang.Class<?>)",
                "arguments": [
                  {
                    "variable_name": "ex.getClass()",
                    "variable_type": "java.lang.Class<?>"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data.expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "stringCheck",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "id + \" Failed test \" + data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": " void run(TestData, String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "org.apache.commons.codec.binary.CharSequenceUtilsTest.TestData"
              },
              {
                "variable_name": "id",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.binary.CharSequenceUtilsTest.TestData": {
      "fields": [
        {
          "variable_name": "source",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ignoreCase",
          "variable_type": "boolean"
        },
        {
          "variable_name": "toffset",
          "variable_type": "int"
        },
        {
          "variable_name": "other",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "ooffset",
          "variable_type": "int"
        },
        {
          "variable_name": "len",
          "variable_type": "int"
        },
        {
          "variable_name": "expected",
          "variable_type": "boolean"
        },
        {
          "variable_name": "throwable",
          "variable_type": "java.lang.Class<? extends java.lang.Throwable>"
        }
      ],
      "constructors": [
        {
          "body": " TestData(final String source, final boolean ignoreCase, final int toffset, final String other, final int ooffset, final int len, final boolean expected)\n{\r\n    this.source = source;\r\n    this.ignoreCase = ignoreCase;\r\n    this.toffset = toffset;\r\n    this.other = other;\r\n    this.ooffset = ooffset;\r\n    this.len = len;\r\n    this.expected = expected;\r\n    this.throwable = null;\r\n}",
          "signature": "TestData(String, boolean, int, String, int, int, boolean)",
          "parameters": [
            {
              "variable_name": "source",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "ignoreCase",
              "variable_type": "boolean"
            },
            {
              "variable_name": "toffset",
              "variable_type": "int"
            },
            {
              "variable_name": "other",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "ooffset",
              "variable_type": "int"
            },
            {
              "variable_name": "len",
              "variable_type": "int"
            },
            {
              "variable_name": "expected",
              "variable_type": "boolean"
            }
          ]
        },
        {
          "body": " TestData(final String source, final boolean ignoreCase, final int toffset, final String other, final int ooffset, final int len, final Class<? extends Throwable> throwable)\n{\r\n    this.source = source;\r\n    this.ignoreCase = ignoreCase;\r\n    this.toffset = toffset;\r\n    this.other = other;\r\n    this.ooffset = ooffset;\r\n    this.len = len;\r\n    this.expected = false;\r\n    this.throwable = throwable;\r\n}",
          "signature": "TestData(String, boolean, int, String, int, int, Class)",
          "parameters": [
            {
              "variable_name": "source",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "ignoreCase",
              "variable_type": "boolean"
            },
            {
              "variable_name": "toffset",
              "variable_type": "int"
            },
            {
              "variable_name": "other",
              "variable_type": "java.lang.String"
            },
            {
              "variable_name": "ooffset",
              "variable_type": "int"
            },
            {
              "variable_name": "len",
              "variable_type": "int"
            },
            {
              "variable_name": "throwable",
              "variable_type": "java.lang.Class<? extends java.lang.Throwable>"
            }
          ]
        }
      ],
      "methods": {
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.append(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "throwable",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(int)",
                "arguments": [
                  {
                    "variable_name": "toffset",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(boolean)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"]\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.binary.Codec105ErrorInputStream": {
      "fields": [
        {
          "variable_name": "EOF",
          "variable_type": "int"
        },
        {
          "variable_name": "countdown",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "read": [
          {
            "call_methods": [],
            "signature": "public int read()",
            "parameters": []
          },
          {
            "call_methods": [],
            "signature": "public int read(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "b",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "pos",
                "variable_type": "int"
              },
              {
                "variable_name": "len",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Emits three line-feeds '\\n' in a row, one at a time, and then EOF.\n *\n * Recreates the bug described in CODEC-105.\n *\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.HexTest": {
      "fields": [
        {
          "variable_name": "BAD_ENCODING_NAME",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "LOG",
          "variable_type": "boolean"
        }
      ],
      "constructors": [],
      "methods": {
        "allocate": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "capacity",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "protected ByteBuffer allocate(int)",
            "parameters": [
              {
                "variable_name": "capacity",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Allocate a ByteBuffer.\n     *\n     * <p>The default implementation uses {@link ByteBuffer#allocate(int)}.\n     * The method is overridden in AllocateDirectHexTest to use\n     * {@link ByteBuffer#allocateDirect(int)}\n     *\n     * @param capacity the capacity\n     * @return the byte buffer\n     "
          }
        ],
        "charsetSanityCheck": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.HexTest.log(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"FAILED charsetSanityCheck=Interesting Java charset oddity: Roundtrip failed for \" + name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.log(java.lang.Throwable)",
                "arguments": [
                  {
                    "variable_name": "e",
                    "variable_type": "java.lang.Throwable"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "str",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private boolean charsetSanityCheck(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "checkDecodeHexByteBufferOddCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex().decode(data)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "private void checkDecodeHexByteBufferOddCharacters(ByteBuffer)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.nio.ByteBuffer"
              }
            ]
          }
        ],
        "checkDecodeHexCharArrayOddCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Hex.decodeHex(data)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "private void checkDecodeHexCharArrayOddCharacters(char[])",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "char[]"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Hex.decodeHex(data)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "private void checkDecodeHexCharArrayOddCharacters(String)",
            "parameters": [
              {
                "variable_name": "data",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getByteBufferUtf8": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "private ByteBuffer getByteBufferUtf8(String)",
            "parameters": [
              {
                "variable_name": "string",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Encodes the given string into a byte buffer using the UTF-8 charset.\n     *\n     * <p>The buffer is allocated using {@link #allocate(int)}.\n     *\n     * @param string the String to encode\n     * @return the byte buffer\n     "
          }
        ],
        "log": [
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.PrintStream.flush()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "private void log(String)",
            "parameters": [
              {
                "variable_name": "s",
                "variable_type": "java.lang.String"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.printStackTrace(java.io.PrintStream)",
                "arguments": [
                  {
                    "variable_name": "System.out",
                    "variable_type": "java.io.PrintStream"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.PrintStream.flush()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "private void log(Throwable)",
            "parameters": [
              {
                "variable_name": "t",
                "variable_type": "java.lang.Throwable"
              }
            ]
          }
        ],
        "testCharset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "sourceBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "actualEncodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expectedHexStringBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actualEncodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.log(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "parent + \"=\" + name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.charsetSanityCheck(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "sourceBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expectedHexString",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actualStringFromBytes",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expectedHexString",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "private void testCharset(String, String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "parent",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * @param name\n     * @param parent\n     * @throws UnsupportedEncodingException\n     * @throws DecoderException\n     "
          }
        ],
        "testCustomCharset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.HexTest.testCharset(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"testCustomCharset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCustomCharset(String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testCustomCharsetBadName": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "UnsupportedCharsetException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex(BAD_ENCODING_NAME)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testCustomCharsetBadName()",
            "parameters": []
          }
        ],
        "testCustomCharsetToString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "Hex.DEFAULT_CHARSET_NAME",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "new Hex().toString().contains(Hex.DEFAULT_CHARSET_NAME)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCustomCharsetToString()",
            "parameters": []
          }
        ],
        "testDecodeBadCharacterPos0": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex().decode(\"q0\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"q0\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeBadCharacterPos0()",
            "parameters": []
          }
        ],
        "testDecodeBadCharacterPos1": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex().decode(\"0q\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0q\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeBadCharacterPos1()",
            "parameters": []
          }
        ],
        "testDecodeByteArrayEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().decode(new byte[0])",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeByteArrayEmpty()",
            "parameters": []
          }
        ],
        "testDecodeByteArrayObjectEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte[]) new Hex().decode((Object) new byte[0])",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) new byte[0]",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeByteArrayObjectEmpty()",
            "parameters": []
          }
        ],
        "testDecodeByteArrayOddCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { 65 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex().decode(new byte[] { 65 })",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"odd number of characters\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testDecodeByteArrayOddCharacters()",
            "parameters": []
          }
        ],
        "testDecodeByteBufferAllocatedButEmpty": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().decode(bb)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bb.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testDecodeByteBufferAllocatedButEmpty()",
            "parameters": []
          }
        ],
        "testDecodeByteBufferEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "allocate(0)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().decode(allocate(0))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testDecodeByteBufferEmpty()",
            "parameters": []
          }
        ],
        "testDecodeByteBufferObjectEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte[]) new Hex().decode((Object) allocate(0))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) allocate(0)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeByteBufferObjectEmpty()",
            "parameters": []
          }
        ],
        "testDecodeByteBufferOddCharacters": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) 65",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.checkDecodeHexByteBufferOddCharacters(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testDecodeByteBufferOddCharacters()",
            "parameters": []
          }
        ],
        "testDecodeByteBufferWithLimit": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bb.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOfRange(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i + 2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.getByteBufferUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"000102030405060708090a0b0c0d0e0f\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new String(Arrays.copyOfRange(expected, i, i + 2))",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(new Hex().decode(bb))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.position(int)",
                "arguments": [
                  {
                    "variable_name": "i * 2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.limit(int)",
                "arguments": [
                  {
                    "variable_name": "i * 2 + 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testDecodeByteBufferWithLimit()",
            "parameters": []
          }
        ],
        "testDecodeByteBufferWithLimitOddCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.HexTest.checkDecodeHexByteBufferOddCharacters(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(int, byte)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "(byte) 65",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.position(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.limit(int)",
                "arguments": [
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testDecodeByteBufferWithLimitOddCharacters()",
            "parameters": []
          }
        ],
        "testDecodeClassCastException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex().decode(new int[] { 65 })",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"odd number of characters\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new int[] { 65 }",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeClassCastException()",
            "parameters": []
          }
        ],
        "testDecodeHexCharArrayEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "new char[0]",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Hex.decodeHex(new char[0])",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeHexCharArrayEmpty()",
            "parameters": []
          }
        ],
        "testDecodeHexCharArrayOddCharacters1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.HexTest.checkDecodeHexCharArrayOddCharacters(char[])",
                "arguments": [
                  {
                    "variable_name": "new char[] { 'A' }",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeHexCharArrayOddCharacters1()",
            "parameters": []
          }
        ],
        "testDecodeHexCharArrayOddCharacters3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.HexTest.checkDecodeHexCharArrayOddCharacters(char[])",
                "arguments": [
                  {
                    "variable_name": "new char[] { 'A', 'B', 'C' }",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeHexCharArrayOddCharacters3()",
            "parameters": []
          }
        ],
        "testDecodeHexCharArrayOddCharacters5": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.HexTest.checkDecodeHexCharArrayOddCharacters(char[])",
                "arguments": [
                  {
                    "variable_name": "new char[] { 'A', 'B', 'C', 'D', 'E' }",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeHexCharArrayOddCharacters5()",
            "parameters": []
          }
        ],
        "testDecodeHexCharArrayOutBufferUnderSized": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[], byte[], int)",
                "arguments": [
                  {
                    "variable_name": "\"aabbccddeeff\".toCharArray()",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Hex.decodeHex(\"aabbccddeeff\".toCharArray(), out, 0)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testDecodeHexCharArrayOutBufferUnderSized()",
            "parameters": []
          }
        ],
        "testDecodeHexCharArrayOutBufferUnderSizedByOffset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[], byte[], int)",
                "arguments": [
                  {
                    "variable_name": "\"aabbccddeeff\".toCharArray()",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "out",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Hex.decodeHex(\"aabbccddeeff\".toCharArray(), out, 1)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testDecodeHexCharArrayOutBufferUnderSizedByOffset()",
            "parameters": []
          }
        ],
        "testDecodeHexStringEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "Hex.decodeHex(\"\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeHexStringEmpty()",
            "parameters": []
          }
        ],
        "testDecodeHexStringOddCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex().decode(\"6\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"odd number of characters\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"6\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeHexStringOddCharacters()",
            "parameters": []
          }
        ],
        "testDecodeHexStringOddCharacters1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.HexTest.checkDecodeHexCharArrayOddCharacters(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"A\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeHexStringOddCharacters1()",
            "parameters": []
          }
        ],
        "testDecodeStringEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte[]) new Hex().decode(\"\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testDecodeStringEmpty()",
            "parameters": []
          }
        ],
        "testEncodeByteArrayEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().encode(new byte[0])",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeByteArrayEmpty()",
            "parameters": []
          }
        ],
        "testEncodeByteArrayObjectEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) new byte[0]",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(char[], char[])",
                "arguments": [
                  {
                    "variable_name": "new char[0]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "(char[]) new Hex().encode((Object) new byte[0])",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeByteArrayObjectEmpty()",
            "parameters": []
          }
        ],
        "testEncodeByteBufferAllocatedButEmpty": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().encode(bb)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bb.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeByteBufferAllocatedButEmpty()",
            "parameters": []
          }
        ],
        "testEncodeByteBufferEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().encode(allocate(0))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "allocate(0)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeByteBufferEmpty()",
            "parameters": []
          }
        ],
        "testEncodeByteBufferObjectEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) allocate(0)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(char[], char[])",
                "arguments": [
                  {
                    "variable_name": "new char[0]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "(char[]) new Hex().encode((Object) allocate(0))",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeByteBufferObjectEmpty()",
            "parameters": []
          }
        ],
        "testEncodeClassCastException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new Hex().encode(new int[] { 65 })",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new int[] { 65 }",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testEncodeClassCastException()",
            "parameters": []
          }
        ],
        "testEncodeDecodeHexCharArrayRandom": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "encodedChars",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encodedStringBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decodedBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "10000",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "dataString",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "dataString",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encodedStringChars",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testEncodeDecodeHexCharArrayRandom()",
            "parameters": []
          }
        ],
        "testEncodeDecodeHexCharArrayRandomToOutput": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], int, int, boolean, char[], int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "lowerEncodedChars",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(char[])",
                "arguments": [
                  {
                    "variable_name": "lowerEncodedChars",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "decodedLowerCaseBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "10000",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeDecodeHexCharArrayRandomToOutput()",
            "parameters": []
          }
        ],
        "testEncodeHex_ByteBufferOfZeroes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "allocate(36)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "36",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"000000000000000000000000000000000000000000000000000000000000000000000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(c)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHex_ByteBufferOfZeroes()",
            "parameters": []
          }
        ],
        "testEncodeHex_ByteBufferWithLimit": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) i",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bb.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "16",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.lang.String.substring(int, int)",
                "arguments": [
                  {
                    "variable_name": "i * 2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i * 2 + 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected.substring(i * 2, i * 2 + 4)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(Hex.encodeHex(bb))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.position(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.limit(int)",
                "arguments": [
                  {
                    "variable_name": "i + 2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testEncodeHex_ByteBufferWithLimit()",
            "parameters": []
          }
        ],
        "testEncodeHexByteArrayEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().encode(new byte[0])",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(char[], char[])",
                "arguments": [
                  {
                    "variable_name": "new char[0]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "Hex.encodeHex(new byte[0])",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteArrayEmpty()",
            "parameters": []
          }
        ],
        "testEncodeHexByteArrayHelloWorldLowerCaseHex": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(actual)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(actual)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteArrayHelloWorldLowerCaseHex()",
            "parameters": []
          }
        ],
        "testEncodeHexByteArrayHelloWorldUpperCaseHex": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(actual)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(actual)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteArrayHelloWorldUpperCaseHex()",
            "parameters": []
          }
        ],
        "testEncodeHexByteArrayZeroes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[36]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"000000000000000000000000000000000000000000000000000000000000000000000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(c)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteArrayZeroes()",
            "parameters": []
          }
        ],
        "testEncodeHexByteBufferEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "allocate(0)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new Hex().encode(allocate(0))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(char[], char[])",
                "arguments": [
                  {
                    "variable_name": "new char[0]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "Hex.encodeHex(allocate(0))",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "allocate(0)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeHexByteBufferEmpty()",
            "parameters": []
          }
        ],
        "testEncodeHexByteBufferHelloWorldLowerCaseHex": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "java.lang.String.toUpperCase()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.getByteBufferUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(actual)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteBufferHelloWorldLowerCaseHex()",
            "parameters": []
          }
        ],
        "testEncodeHexByteBufferHelloWorldUpperCaseHex": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.getByteBufferUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello World\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected.toLowerCase()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new String(actual)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toLowerCase()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeHexByteBufferHelloWorldUpperCaseHex()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteArrayBoolean_ToLowerCase": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "new byte[] { 10 }",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0a\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(new byte[] { 10 }, true)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteArrayBoolean_ToLowerCase()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteArrayBoolean_ToUpperCase": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "new byte[] { 10 }",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0A\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(new byte[] { 10 }, false)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteArrayBoolean_ToUpperCase()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteArrayOfZeroes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[36]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"000000000000000000000000000000000000000000000000000000000000000000000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteArrayOfZeroes()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteBufferBoolean_ToLowerCase": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) 10",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0a\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(bb, true)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteBufferBoolean_ToLowerCase()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteBufferBoolean_ToUpperCase": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.flip()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(byte)",
                "arguments": [
                  {
                    "variable_name": "(byte) 10",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0A\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(bb, false)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteBufferBoolean_ToUpperCase()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteBufferOfZeroes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "allocate(36)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "36",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"000000000000000000000000000000000000000000000000000000000000000000000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteBufferOfZeroes()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteBufferOfZeroesWithLimit": [
          {
            "call_methods": [
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bb.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "36",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"000000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(bb)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.position(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.limit(int)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteBufferOfZeroesWithLimit()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteBufferWithLimitBoolean_ToLowerCase": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bb.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(int, byte)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "(byte) 10",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0a\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(bb, true)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.position(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.limit(int)",
                "arguments": [
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteBufferWithLimitBoolean_ToLowerCase()",
            "parameters": []
          }
        ],
        "testEncodeHexByteString_ByteBufferWithLimitBoolean_ToUpperCase": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(java.nio.ByteBuffer, boolean)",
                "arguments": [
                  {
                    "variable_name": "bb",
                    "variable_type": "java.nio.ByteBuffer"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.nio.Buffer.remaining()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bb.remaining()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.put(int, byte)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "(byte) 10",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0A\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(bb, false)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.position(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.nio.ByteBuffer.limit(int)",
                "arguments": [
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testEncodeHexByteString_ByteBufferWithLimitBoolean_ToUpperCase()",
            "parameters": []
          }
        ],
        "testEncodeHexPartialInput": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], int, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(char[], char[])",
                "arguments": [
                  {
                    "variable_name": "new char[0]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "hex",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testEncodeHexPartialInput()",
            "parameters": []
          }
        ],
        "testEncodeHexPartialInputOverbounds": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "ArrayIndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Hex.encodeHex(data, 9, 10, true)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], int, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "9",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testEncodeHexPartialInputOverbounds()",
            "parameters": []
          }
        ],
        "testEncodeHexPartialInputUnderbounds": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "ArrayIndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Hex.encodeHex(data, -2, 10, true)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(byte[], int, int, boolean)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "-2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testEncodeHexPartialInputUnderbounds()",
            "parameters": []
          }
        ],
        "testEncodeHexReadOnlyByteBuffer": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "ByteBuffer.wrap(new byte[] { 10 }).asReadOnlyBuffer()",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "char[]"
              },
              {
                "signature": "java.nio.ByteBuffer.wrap(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] { 10 }",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0a\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "String.valueOf(chars)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.asReadOnlyBuffer()",
                "arguments": [],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "java.lang.String.valueOf(char[])",
                "arguments": [
                  {
                    "variable_name": "chars",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeHexReadOnlyByteBuffer()",
            "parameters": [],
            "javadoc": "\n     * Test encoding of a read only byte buffer.\n     * See CODEC-261.\n     "
          }
        ],
        "testEncodeStringEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(char[], char[])",
                "arguments": [
                  {
                    "variable_name": "new char[0]",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "(char[]) new Hex().encode(\"\")",
                    "variable_type": "char[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeStringEmpty()",
            "parameters": []
          }
        ],
        "testGetCharset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new Hex(StandardCharsets.UTF_8).getCharset()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetCharset()",
            "parameters": []
          }
        ],
        "testGetCharsetName": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new Hex(StandardCharsets.UTF_8).getCharsetName()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.getCharsetName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testGetCharsetName()",
            "parameters": []
          }
        ],
        "testRequiredCharset": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.HexTest.testCharset(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charset.name()",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"testRequiredCharset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testRequiredCharset(Charset)",
            "parameters": [
              {
                "variable_name": "charset",
                "variable_type": "java.nio.charset.Charset"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link org.apache.commons.codec.binary.Hex}.\n "
    },
    "org.apache.commons.codec.binary.StringUtilsTest": {
      "fields": [
        {
          "variable_name": "BYTES_FIXTURE",
          "variable_type": "byte"
        },
        {
          "variable_name": "BYTES_FIXTURE_16BE",
          "variable_type": "byte"
        },
        {
          "variable_name": "BYTES_FIXTURE_16LE",
          "variable_type": "byte"
        },
        {
          "variable_name": "STRING_FIXTURE",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "testByteBufferUtf8": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getByteBufferUtf8(null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Should be null safe\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "text.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "bb.array()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getByteBufferUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testByteBufferUtf8()",
            "parameters": []
          }
        ],
        "testConstructor": [
          {
            "call_methods": [],
            "signature": "public void testConstructor()",
            "parameters": [],
            "javadoc": "\n     * We could make the constructor private but there does not seem to be a point to jumping through extra code hoops\n     * to restrict instantiation right now.\n     "
          }
        ],
        "testEqualsCS1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.equals(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "new StringBuilder(\"abc\")",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.equals(new StringBuilder(\"abc\"), null)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abc\"))",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEqualsCS1()",
            "parameters": []
          }
        ],
        "testEqualsCS2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.equals(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "new StringBuilder(\"abc\")",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.equals(new StringBuilder(\"abc\"), \"abcd\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.equals(\"abc\", new StringBuilder(\"abc\"))",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEqualsCS2()",
            "parameters": []
          }
        ],
        "testEqualsString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.equals(java.lang.CharSequence, java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.equals(\"abc\", null)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.equals(null, null)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEqualsString()",
            "parameters": []
          }
        ],
        "testGetBytesIso8859_1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesIso8859_1(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testGetBytesUnchecked(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetBytesIso8859_1()",
            "parameters": []
          }
        ],
        "testGetBytesUnchecked": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private void testGetBytesUnchecked(String)",
            "parameters": [
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testGetBytesUncheckedBadName": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalStateException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> StringUtils.getBytesUnchecked(STRING_FIXTURE, \"UNKNOWN\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"UNKNOWN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testGetBytesUncheckedBadName()",
            "parameters": []
          }
        ],
        "testGetBytesUncheckedNullInput": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUnchecked(null, \"UNKNOWN\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUnchecked(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"UNKNOWN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testGetBytesUncheckedNullInput()",
            "parameters": []
          }
        ],
        "testGetBytesUsAscii": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUsAscii(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testGetBytesUnchecked(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetBytesUsAscii()",
            "parameters": []
          }
        ],
        "testGetBytesUtf16": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testGetBytesUnchecked(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetBytesUtf16()",
            "parameters": []
          }
        ],
        "testGetBytesUtf16Be": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testGetBytesUnchecked(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16Be(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testGetBytesUtf16Be()",
            "parameters": []
          }
        ],
        "testGetBytesUtf16Le": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf16Le(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testGetBytesUnchecked(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetBytesUtf16Le()",
            "parameters": []
          }
        ],
        "testGetBytesUtf8": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STRING_FIXTURE",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.getBytes(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testGetBytesUnchecked(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetBytesUtf8()",
            "parameters": []
          }
        ],
        "testNewString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void testNewString(String)",
            "parameters": [
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testNewStringBadEnc": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalStateException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> StringUtils.newString(BYTES_FIXTURE, \"UNKNOWN\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"UNKNOWN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testNewStringBadEnc()",
            "parameters": []
          }
        ],
        "testNewStringIso8859_1": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testNewString(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringIso8859_1(byte[])",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testNewStringIso8859_1()",
            "parameters": []
          }
        ],
        "testNewStringNullInput": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newString(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"UNKNOWN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.newString(null, \"UNKNOWN\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNewStringNullInput()",
            "parameters": []
          }
        ],
        "testNewStringNullInput_CODEC229": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Le(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StringUtils.newStringUtf8(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringIso8859_1(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Be(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testNewStringNullInput_CODEC229()",
            "parameters": []
          }
        ],
        "testNewStringUsAscii": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testNewString(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUsAscii(byte[])",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNewStringUsAscii()",
            "parameters": []
          }
        ],
        "testNewStringUtf16": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testNewString(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16(byte[])",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testNewStringUtf16()",
            "parameters": []
          }
        ],
        "testNewStringUtf16Be": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testNewString(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Be(byte[])",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE_16BE",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testNewStringUtf16Be()",
            "parameters": []
          }
        ],
        "testNewStringUtf16Le": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf16Le(byte[])",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE_16LE",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testNewString(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNewStringUtf16Le()",
            "parameters": []
          }
        ],
        "testNewStringUtf8": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtilsTest.testNewString(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.newStringUtf8(byte[])",
                "arguments": [
                  {
                    "variable_name": "BYTES_FIXTURE",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testNewStringUtf8()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link StringUtils}\n "
    },
    "org.apache.commons.codec.BinaryEncoderAbstractTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "makeEncoder": [
          {
            "call_methods": [],
            "signature": "protected abstract BinaryEncoder makeEncoder()",
            "parameters": []
          }
        ],
        "testEncodeEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.BinaryEncoderAbstractTest.makeEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.BinaryEncoder"
              },
              {
                "signature": "org.apache.commons.codec.BinaryEncoder.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeEmpty()",
            "parameters": []
          }
        ],
        "testEncodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> makeEncoder().encode(null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.BinaryEncoderAbstractTest.makeEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.BinaryEncoder"
              },
              {
                "signature": "org.apache.commons.codec.Encoder.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testEncodeNull()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n "
    },
    "org.apache.commons.codec.CharEncodingTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testConstructor": [
          {
            "call_methods": [],
            "signature": "public void testConstructor()",
            "parameters": [],
            "javadoc": "\n     * We could make the constructor private in the future, it's a matter a style.\n     "
          }
        ],
        "testIso8859_1": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "CharEncoding.ISO_8859_1",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIso8859_1()",
            "parameters": []
          }
        ],
        "testUsAscii": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.US_ASCII.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "CharEncoding.US_ASCII",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUsAscii()",
            "parameters": []
          }
        ],
        "testUtf16": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_16.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_16",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf16()",
            "parameters": []
          }
        ],
        "testUtf16Be": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_16BE.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_16BE",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf16Be()",
            "parameters": []
          }
        ],
        "testUtf16Le": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_16LE.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_16LE",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf16Le()",
            "parameters": []
          }
        ],
        "testUtf8": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_8",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf8()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Sanity checks for {@link CharEncoding}.\n "
    },
    "org.apache.commons.codec.CharsetsTest": {
      "fields": [
        {
          "variable_name": "AVAILABLE_CHARSET_NAMES",
          "variable_type": "java.util.TreeSet<java.lang.String>"
        }
      ],
      "constructors": [],
      "methods": {
        "getAvailableCharsetNames": [
          {
            "call_methods": [],
            "signature": "public static SortedSet<String> getAvailableCharsetNames()",
            "parameters": []
          }
        ],
        "getRequiredCharsets": [
          {
            "call_methods": [
              {
                "signature": "java.util.SortedMap.values()",
                "arguments": [],
                "return_type": "java.util.Collection<V>"
              },
              {
                "signature": "org.apache.commons.io.Charsets.requiredCharsets()",
                "arguments": [],
                "return_type": "java.util.SortedMap<java.lang.String, java.nio.charset.Charset>"
              }
            ],
            "signature": "public static Collection<Charset> getRequiredCharsets()",
            "parameters": []
          }
        ],
        "testIso8859_1": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ISO-8859-1\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Charsets.ISO_8859_1.name()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIso8859_1()",
            "parameters": []
          }
        ],
        "testToCharset": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.io.Charsets.toCharset(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "java.nio.charset.Charset.defaultCharset()",
                "arguments": [],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.apache.commons.io.Charsets.toCharset(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "(Charset) null",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.nio.charset.Charset"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Charset.defaultCharset()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Charsets.toCharset((String) null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testToCharset()",
            "parameters": []
          }
        ],
        "testUsAscii": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.US_ASCII.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Charsets.US_ASCII.name()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUsAscii()",
            "parameters": []
          }
        ],
        "testUtf16": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_16.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Charsets.UTF_16.name()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf16()",
            "parameters": []
          }
        ],
        "testUtf16Be": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_16BE.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Charsets.UTF_16BE.name()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf16Be()",
            "parameters": []
          }
        ],
        "testUtf16Le": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_16LE.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Charsets.UTF_16LE.name()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf16Le()",
            "parameters": []
          }
        ],
        "testUtf8": [
          {
            "call_methods": [
              {
                "signature": "java.nio.charset.Charset.name()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8.name()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Charsets.UTF_8.name()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUtf8()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Sanity checks for {@link Charsets}.\n "
    },
    "org.apache.commons.codec.cli.DigestTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testEmptyArguments": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Digest.main(new String[0])",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.main(java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "new String[0]",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEmptyArguments()",
            "parameters": [],
            "javadoc": "\n     * Tests if empty arguments are handled correctly.\n     "
          }
        ],
        "testNullArguments": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Digest.main(null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.cli.Digest.main(java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNullArguments()",
            "parameters": [],
            "javadoc": "\n     * Tests if null arguments are handled correctly.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link Digest}.\n "
    },
    "org.apache.commons.codec.DecoderExceptionTest": {
      "fields": [
        {
          "variable_name": "MSG",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "t",
          "variable_type": "java.lang.Throwable"
        }
      ],
      "constructors": [],
      "methods": {
        "testConstructor0": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructor0()",
            "parameters": []
          }
        ],
        "testConstructorString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "MSG",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "e.getCause()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructorString()",
            "parameters": []
          }
        ],
        "testConstructorStringThrowable": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "MSG",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructorStringThrowable()",
            "parameters": []
          }
        ],
        "testConstructorThrowable": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "t.getClass().getName()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testConstructorThrowable()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link DecoderException}.\n "
    },
    "org.apache.commons.codec.digest.Apr1CryptTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testApr1CryptBytes": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Md5Crypt.apr1Crypt(\"!bc.\", hash)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$apr1$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"!bc.\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testApr1CryptBytes()",
            "parameters": []
          }
        ],
        "testApr1CryptBytesWithThreadLocalRandom": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "threadLocalRandom",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Md5Crypt.apr1Crypt(\"!bc.\", hash)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$apr1$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"!bc.\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testApr1CryptBytesWithThreadLocalRandom()",
            "parameters": []
          }
        ],
        "testApr1CryptExplicitCall": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\\\\$apr1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Md5Crypt.apr1Crypt(\"secret\", \"1234\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"1234\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Md5Crypt.apr1Crypt(\"secret\".getBytes()).matches(\"^\\\\$apr1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testApr1CryptExplicitCall()",
            "parameters": []
          }
        ],
        "testApr1CryptNullData": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Md5Crypt.apr1Crypt((byte[]) null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testApr1CryptNullData()",
            "parameters": []
          }
        ],
        "testApr1CryptStrings": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$apr1$TqI9WECO$LHZB2DqRlk9nObiB6vJG9.\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Md5Crypt.apr1Crypt(\"secret\", \"$apr1$TqI9WECO\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$apr1$TqI9WECO\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testApr1CryptStrings()",
            "parameters": []
          }
        ],
        "testApr1CryptWithEmptySalt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Md5Crypt.apr1Crypt(\"secret\".getBytes(), \"\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testApr1CryptWithEmptySalt()",
            "parameters": []
          }
        ],
        "testApr1CryptWithInvalidSalt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Md5Crypt.apr1Crypt(new byte[0], \"!\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"!\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testApr1CryptWithInvalidSalt()",
            "parameters": []
          }
        ],
        "testApr1CryptWithoutSalt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\\\\$apr1\\\\$[a-zA-Z0-9\\\\./]{8}\\\\$[a-zA-Z0-9\\\\./]{22}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotSame(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "hash2",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "hash.matches(\"^\\\\$apr1\\\\$[a-zA-Z0-9\\\\./]{8}\\\\$[a-zA-Z0-9\\\\./]{22}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testApr1CryptWithoutSalt()",
            "parameters": []
          }
        ],
        "testApr1LongSalt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Md5Crypt.apr1Crypt(\"secret\", \"12345678901234567890\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.apr1Crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"12345678901234567890\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testApr1LongSalt()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.B64Test": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testB64from24bit": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.B64.b64from24bit(byte, byte, byte, int, java.lang.StringBuilder)",
                "arguments": [
                  {
                    "variable_name": "(byte) 8",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "(byte) 16",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "(byte) 64",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "java.lang.StringBuilder"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"./spo/\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "buffer.toString()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testB64from24bit()",
            "parameters": []
          }
        ],
        "testB64T": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "64",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "B64.B64T_ARRAY.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new B64()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testB64T()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.Blake3Test": {
      "fields": [],
      "constructors": [],
      "methods": {
        "assertThrowsProperExceptionWithKeySize": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Blake3.initKeyedHash(new byte[keySize])",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Blake3 keys must be 32 bytes\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.initKeyedHash(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[keySize]",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              }
            ],
            "signature": "private static void assertThrowsProperExceptionWithKeySize(int)",
            "parameters": [
              {
                "variable_name": "keySize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testShouldThrowIllegalArgumentExceptionWhenIncorrectKeySize": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3Test.assertThrowsProperExceptionWithKeySize(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testShouldThrowIllegalArgumentExceptionWhenIncorrectKeySize()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.Blake3TestVectorsTest": {
      "fields": [
        {
          "variable_name": "KEY",
          "variable_type": "byte"
        },
        {
          "variable_name": "CTX",
          "variable_type": "byte"
        },
        {
          "variable_name": "hasher",
          "variable_type": "org.apache.commons.codec.digest.Blake3"
        },
        {
          "variable_name": "keyedHasher",
          "variable_type": "org.apache.commons.codec.digest.Blake3"
        },
        {
          "variable_name": "kdfHasher",
          "variable_type": "org.apache.commons.codec.digest.Blake3"
        },
        {
          "variable_name": "inputByteArray",
          "variable_type": "byte"
        },
        {
          "variable_name": "hashByteArray",
          "variable_type": "byte"
        },
        {
          "variable_name": "keyedHashByteArray",
          "variable_type": "byte"
        },
        {
          "variable_name": "deriveKeyByteArray",
          "variable_type": "byte"
        }
      ],
      "constructors": [],
      "methods": {
        "data": [
          {
            "call_methods": [
              {
                "signature": "java.util.stream.Stream.of(T...)",
                "arguments": [
                  {
                    "variable_name": "Arguments.of(0, \"af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262e00f03e7b69af26b7faaf09fcd333050338ddfe085b8cc869ca98b206c08243a26f5487789e8f660afe6c99ef9e0c52b92e7393024a80459cf91f476f9ffdbda7001c22e159b402631f277ca96f2defdf1078282314e763699a31c5363165421cce14d\", \"92b2b75604ed3c761f9d6f62392c8a9227ad0ea3f09573e783f1498a4ed60d26b18171a2f22a4b94822c701f107153dba24918c4bae4d2945c20ece13387627d3b73cbf97b797d5e59948c7ef788f54372df45e45e4293c7dc18c1d41144a9758be58960856be1eabbe22c2653190de560ca3b2ac4aa692a9210694254c371e851bc8f\", \"2cc39783c223154fea8dfb7c1b1660f2ac2dcbd1c1de8277b0b0dd39b7e50d7d905630c8be290dfcf3e6842f13bddd573c098c3f17361f1f206b8cad9d088aa4a3f746752c6b0ce6a83b0da81d59649257cdf8eb3e9f7d4998e41021fac119deefb896224ac99f860011f73609e6e0e4540f93b273e56547dfd3aa1a035ba6689d89a0\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(1, \"2d3adedff11b61f14c886e35afa036736dcd87a74d27b5c1510225d0f592e213c3a6cb8bf623e20cdb535f8d1a5ffb86342d9c0b64aca3bce1d31f60adfa137b358ad4d79f97b47c3d5e79f179df87a3b9776ef8325f8329886ba42f07fb138bb502f4081cbcec3195c5871e6c23e2cc97d3c69a613eba131e5f1351f3f1da786545e5\", \"6d7878dfff2f485635d39013278ae14f1454b8c0a3a2d34bc1ab38228a80c95b6568c0490609413006fbd428eb3fd14e7756d90f73a4725fad147f7bf70fd61c4e0cf7074885e92b0e3f125978b4154986d4fb202a3f331a3fb6cf349a3a70e49990f98fe4289761c8602c4e6ab1138d31d3b62218078b2f3ba9a88e1d08d0dd4cea11\", \"b3e2e340a117a499c6cf2398a19ee0d29cca2bb7404c73063382693bf66cb06c5827b91bf889b6b97c5477f535361caefca0b5d8c4746441c57617111933158950670f9aa8a05d791daae10ac683cbef8faf897c84e6114a59d2173c3f417023a35d6983f2c7dfa57e7fc559ad751dbfb9ffab39c2ef8c4aafebc9ae973a64f0c76551\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(2, \"7b7015bb92cf0b318037702a6cdd81dee41224f734684c2c122cd6359cb1ee63d8386b22e2ddc05836b7c1bb693d92af006deb5ffbc4c70fb44d0195d0c6f252faac61659ef86523aa16517f87cb5f1340e723756ab65efb2f91964e14391de2a432263a6faf1d146937b35a33621c12d00be8223a7f1919cec0acd12097ff3ab00ab1\", \"5392ddae0e0a69d5f40160462cbd9bd889375082ff224ac9c758802b7a6fd20a9ffbf7efd13e989a6c246f96d3a96b9d279f2c4e63fb0bdff633957acf50ee1a5f658be144bab0f6f16500dee4aa5967fc2c586d85a04caddec90fffb7633f46a60786024353b9e5cebe277fcd9514217fee2267dcda8f7b31697b7c54fab6a939bf8f\", \"1f166565a7df0098ee65922d7fea425fb18b9943f19d6161e2d17939356168e6daa59cae19892b2d54f6fc9f475d26031fd1c22ae0a3e8ef7bdb23f452a15e0027629d2e867b1bb1e6ab21c71297377750826c404dfccc2406bd57a83775f89e0b075e59a7732326715ef912078e213944f490ad68037557518b79c0086de6d6f6cdd2\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(3, \"e1be4d7a8ab5560aa4199eea339849ba8e293d55ca0a81006726d184519e647f5b49b82f805a538c68915c1ae8035c900fd1d4b13902920fd05e1450822f36de9454b7e9996de4900c8e723512883f93f4345f8a58bfe64ee38d3ad71ab027765d25cdd0e448328a8e7a683b9a6af8b0af94fa09010d9186890b096a08471e4230a134\", \"39e67b76b5a007d4921969779fe666da67b5213b096084ab674742f0d5ec62b9b9142d0fab08e1b161efdbb28d18afc64d8f72160c958e53a950cdecf91c1a1bbab1a9c0f01def762a77e2e8545d4dec241e98a89b6db2e9a5b070fc110caae2622690bd7b76c02ab60750a3ea75426a6bb8803c370ffe465f07fb57def95df772c39f\", \"440aba35cb006b61fc17c0529255de438efc06a8c9ebf3f2ddac3b5a86705797f27e2e914574f4d87ec04c379e12789eccbfbc15892626042707802dbe4e97c3ff59dca80c1e54246b6d055154f7348a39b7d098b2b4824ebe90e104e763b2a447512132cede16243484a55a4e40a85790038bb0dcf762e8c053cabae41bbe22a5bff7\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(4, \"f30f5ab28fe047904037f77b6da4fea1e27241c5d132638d8bedce9d40494f328f603ba4564453e06cdcee6cbe728a4519bbe6f0d41e8a14b5b225174a566dbfa61b56afb1e452dc08c804f8c3143c9e2cc4a31bb738bf8c1917b55830c6e65797211701dc0b98daa1faeaa6ee9e56ab606ce03a1a881e8f14e87a4acf4646272cfd12\", \"7671dde590c95d5ac9616651ff5aa0a27bee5913a348e053b8aa9108917fe070116c0acff3f0d1fa97ab38d813fd46506089118147d83393019b068a55d646251ecf81105f798d76a10ae413f3d925787d6216a7eb444e510fd56916f1d753a5544ecf0072134a146b2615b42f50c179f56b8fae0788008e3e27c67482349e249cb86a\", \"f46085c8190d69022369ce1a18880e9b369c135eb93f3c63550d3e7630e91060fbd7d8f4258bec9da4e05044f88b91944f7cab317a2f0c18279629a3867fad0662c9ad4d42c6f27e5b124da17c8c4f3a94a025ba5d1b623686c6099d202a7317a82e3d95dae46a87de0555d727a5df55de44dab799a20dffe239594d6e99ed17950910\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(5, \"b40b44dfd97e7a84a996a91af8b85188c66c126940ba7aad2e7ae6b385402aa2ebcfdac6c5d32c31209e1f81a454751280db64942ce395104e1e4eaca62607de1c2ca748251754ea5bbe8c20150e7f47efd57012c63b3c6a6632dc1c7cd15f3e1c999904037d60fac2eb9397f2adbe458d7f264e64f1e73aa927b30988e2aed2f03620\", \"73ac69eecf286894d8102018a6fc729f4b1f4247d3703f69bdc6a5fe3e0c84616ab199d1f2f3e53bffb17f0a2209fe8b4f7d4c7bae59c2bc7d01f1ff94c67588cc6b38fa6024886f2c078bfe09b5d9e6584cd6c521c3bb52f4de7687b37117a2dbbec0d59e92fa9a8cc3240d4432f91757aabcae03e87431dac003e7d73574bfdd8218\", \"1f24eda69dbcb752847ec3ebb5dd42836d86e58500c7c98d906ecd82ed9ae47f6f48a3f67e4e43329c9a89b1ca526b9b35cbf7d25c1e353baffb590fd79be58ddb6c711f1a6b60e98620b851c688670412fcb0435657ba6b638d21f0f2a04f2f6b0bd8834837b10e438d5f4c7c2c71299cf7586ea9144ed09253d51f8f54dd6bff719d\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(6, \"06c4e8ffb6872fad96f9aaca5eee1553eb62aed0ad7198cef42e87f6a616c844611a30c4e4f37fe2fe23c0883cde5cf7059d88b657c7ed2087e3d210925ede716435d6d5d82597a1e52b9553919e804f5656278bd739880692c94bff2824d8e0b48cac1d24682699e4883389dc4f2faa2eb3b4db6e39debd5061ff3609916f3e07529a\", \"82d3199d0013035682cc7f2a399d4c212544376a839aa863a0f4c91220ca7a6dc2ffb3aa05f2631f0fa9ac19b6e97eb7e6669e5ec254799350c8b8d189e8807800842a5383c4d907c932f34490aaf00064de8cdb157357bde37c1504d2960034930887603abc5ccb9f5247f79224baff6120a3c622a46d7b1bcaee02c5025460941256\", \"be96b30b37919fe4379dfbe752ae77b4f7e2ab92f7ff27435f76f2f065f6a5f435ae01a1d14bd5a6b3b69d8cbd35f0b01ef2173ff6f9b640ca0bd4748efa398bf9a9c0acd6a66d9332fdc9b47ffe28ba7ab6090c26747b85f4fab22f936b71eb3f64613d8bd9dfabe9bb68da19de78321b481e5297df9e40ec8a3d662f3e1479c65de0\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(7, \"3f8770f387faad08faa9d8414e9f449ac68e6ff0417f673f602a646a891419fe66036ef6e6d1a8f54baa9fed1fc11c77cfb9cff65bae915045027046ebe0c01bf5a941f3bb0f73791d3fc0b84370f9f30af0cd5b0fc334dd61f70feb60dad785f070fef1f343ed933b49a5ca0d16a503f599a365a4296739248b28d1a20b0e2cc8975c\", \"af0a7ec382aedc0cfd626e49e7628bc7a353a4cb108855541a5651bf64fbb28a7c5035ba0f48a9c73dabb2be0533d02e8fd5d0d5639a18b2803ba6bf527e1d145d5fd6406c437b79bcaad6c7bdf1cf4bd56a893c3eb9510335a7a798548c6753f74617bede88bef924ba4b334f8852476d90b26c5dc4c3668a2519266a562c6c8034a6\", \"dc3b6485f9d94935329442916b0d059685ba815a1fa2a14107217453a7fc9f0e66266db2ea7c96843f9d8208e600a73f7f45b2f55b9e6d6a7ccf05daae63a3fdd10b25ac0bd2e224ce8291f88c05976d575df998477db86fb2cfbbf91725d62cb57acfeb3c2d973b89b503c2b60dde85a7802b69dc1ac2007d5623cbea8cbfb6b181f5\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(8, \"2351207d04fc16ade43ccab08600939c7c1fa70a5c0aaca76063d04c3228eaeb725d6d46ceed8f785ab9f2f9b06acfe398c6699c6129da084cb531177445a682894f9685eaf836999221d17c9a64a3a057000524cd2823986db378b074290a1a9b93a22e135ed2c14c7e20c6d045cd00b903400374126676ea78874d79f2dd7883cf5c\", \"be2f5495c61cba1bb348a34948c004045e3bd4dae8f0fe82bf44d0da245a060048eb5e68ce6dea1eb0229e144f578b3aa7e9f4f85febd135df8525e6fe40c6f0340d13dd09b255ccd5112a94238f2be3c0b5b7ecde06580426a93e0708555a265305abf86d874e34b4995b788e37a823491f25127a502fe0704baa6bfdf04e76c13276\", \"2b166978cef14d9d438046c720519d8b1cad707e199746f1562d0c87fbd32940f0e2545a96693a66654225ebbaac76d093bfa9cd8f525a53acb92a861a98c42e7d1c4ae82e68ab691d510012edd2a728f98cd4794ef757e94d6546961b4f280a51aac339cc95b64a92b83cc3f26d8af8dfb4c091c240acdb4d47728d23e7148720ef04\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(63, \"e9bc37a594daad83be9470df7f7b3798297c3d834ce80ba85d6e207627b7db7b1197012b1e7d9af4d7cb7bdd1f3bb49a90a9b5dec3ea2bbc6eaebce77f4e470cbf4687093b5352f04e4a4570fba233164e6acc36900e35d185886a827f7ea9bdc1e5c3ce88b095a200e62c10c043b3e9bc6cb9b6ac4dfa51794b02ace9f98779040755\", \"bb1eb5d4afa793c1ebdd9fb08def6c36d10096986ae0cfe148cd101170ce37aea05a63d74a840aecd514f654f080e51ac50fd617d22610d91780fe6b07a26b0847abb38291058c97474ef6ddd190d30fc318185c09ca1589d2024f0a6f16d45f11678377483fa5c005b2a107cb9943e5da634e7046855eaa888663de55d6471371d55d\", \"b6451e30b953c206e34644c6803724e9d2725e0893039cfc49584f991f451af3b89e8ff572d3da4f4022199b9563b9d70ebb616efff0763e9abec71b550f1371e233319c4c4e74da936ba8e5bbb29a598e007a0bbfa929c99738ca2cc098d59134d11ff300c39f82e2fce9f7f0fa266459503f64ab9913befc65fddc474f6dc1c67669\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(64, \"4eed7141ea4a5cd4b788606bd23f46e212af9cacebacdc7d1f4c6dc7f2511b98fc9cc56cb831ffe33ea8e7e1d1df09b26efd2767670066aa82d023b1dfe8ab1b2b7fbb5b97592d46ffe3e05a6a9b592e2949c74160e4674301bc3f97e04903f8c6cf95b863174c33228924cdef7ae47559b10b294acd660666c4538833582b43f82d74\", \"ba8ced36f327700d213f120b1a207a3b8c04330528586f414d09f2f7d9ccb7e68244c26010afc3f762615bbac552a1ca909e67c83e2fd5478cf46b9e811efccc93f77a21b17a152ebaca1695733fdb086e23cd0eb48c41c034d52523fc21236e5d8c9255306e48d52ba40b4dac24256460d56573d1312319afcf3ed39d72d0bfc69acb\", \"a5c4a7053fa86b64746d4bb688d06ad1f02a18fce9afd3e818fefaa7126bf73e9b9493a9befebe0bf0c9509fb3105cfa0e262cde141aa8e3f2c2f77890bb64a4cca96922a21ead111f6338ad5244f2c15c44cb595443ac2ac294231e31be4a4307d0a91e874d36fc9852aeb1265c09b6e0cda7c37ef686fbbcab97e8ff66718be048bb\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(65, \"de1e5fa0be70df6d2be8fffd0e99ceaa8eb6e8c93a63f2d8d1c30ecb6b263dee0e16e0a4749d6811dd1d6d1265c29729b1b75a9ac346cf93f0e1d7296dfcfd4313b3a227faaaaf7757cc95b4e87a49be3b8a270a12020233509b1c3632b3485eef309d0abc4a4a696c9decc6e90454b53b000f456a3f10079072baaf7a981653221f2c\", \"c0a4edefa2d2accb9277c371ac12fcdbb52988a86edc54f0716e1591b4326e72d5e795f46a596b02d3d4bfb43abad1e5d19211152722ec1f20fef2cd413e3c22f2fc5da3d73041275be6ede3517b3b9f0fc67ade5956a672b8b75d96cb43294b9041497de92637ed3f2439225e683910cb3ae923374449ca788fb0f9bea92731bc26ad\", \"51fd05c3c1cfbc8ed67d139ad76f5cf8236cd2acd26627a30c104dfd9d3ff8a82b02e8bd36d8498a75ad8c8e9b15eb386970283d6dd42c8ae7911cc592887fdbe26a0a5f0bf821cd92986c60b2502c9be3f98a9c133a7e8045ea867e0828c7252e739321f7c2d65daee4468eb4429efae469a42763f1f94977435d10dccae3e3dce88d\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(127, \"d81293fda863f008c09e92fc382a81f5a0b4a1251cba1634016a0f86a6bd640de3137d477156d1fde56b0cf36f8ef18b44b2d79897bece12227539ac9ae0a5119da47644d934d26e74dc316145dcb8bb69ac3f2e05c242dd6ee06484fcb0e956dc44355b452c5e2bbb5e2b66e99f5dd443d0cbcaaafd4beebaed24ae2f8bb672bcef78\", \"c64200ae7dfaf35577ac5a9521c47863fb71514a3bcad18819218b818de85818ee7a317aaccc1458f78d6f65f3427ec97d9c0adb0d6dacd4471374b621b7b5f35cd54663c64dbe0b9e2d95632f84c611313ea5bd90b71ce97b3cf645776f3adc11e27d135cbadb9875c2bf8d3ae6b02f8a0206aba0c35bfe42574011931c9a255ce6dc\", \"c91c090ceee3a3ac81902da31838012625bbcd73fcb92e7d7e56f78deba4f0c3feeb3974306966ccb3e3c69c337ef8a45660ad02526306fd685c88542ad00f759af6dd1adc2e50c2b8aac9f0c5221ff481565cf6455b772515a69463223202e5c371743e35210bbbbabd89651684107fd9fe493c937be16e39cfa7084a36207c99bea3\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(128, \"f17e570564b26578c33bb7f44643f539624b05df1a76c81f30acd548c44b45efa69faba091427f9c5c4caa873aa07828651f19c55bad85c47d1368b11c6fd99e47ecba5820a0325984d74fe3e4058494ca12e3f1d3293d0010a9722f7dee64f71246f75e9361f44cc8e214a100650db1313ff76a9f93ec6e84edb7add1cb4a95019b0c\", \"b04fe15577457267ff3b6f3c947d93be581e7e3a4b018679125eaf86f6a628ecd86bbe0001f10bda47e6077b735016fca8119da11348d93ca302bbd125bde0db2b50edbe728a620bb9d3e6f706286aedea973425c0b9eedf8a38873544cf91badf49ad92a635a93f71ddfcee1eae536c25d1b270956be16588ef1cfef2f1d15f650bd5\", \"81720f34452f58a0120a58b6b4608384b5c51d11f39ce97161a0c0e442ca022550e7cd651e312f0b4c6afb3c348ae5dd17d2b29fab3b894d9a0034c7b04fd9190cbd90043ff65d1657bbc05bfdecf2897dd894c7a1b54656d59a50b51190a9da44db426266ad6ce7c173a8c0bbe091b75e734b4dadb59b2861cd2518b4e7591e4b83c9\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(129, \"683aaae9f3c5ba37eaaf072aed0f9e30bac0865137bae68b1fde4ca2aebdcb12f96ffa7b36dd78ba321be7e842d364a62a42e3746681c8bace18a4a8a79649285c7127bf8febf125be9de39586d251f0d41da20980b70d35e3dac0eee59e468a894fa7e6a07129aaad09855f6ad4801512a116ba2b7841e6cfc99ad77594a8f2d181a7\", \"d4a64dae6cdccbac1e5287f54f17c5f985105457c1a2ec1878ebd4b57e20d38f1c9db018541eec241b748f87725665b7b1ace3e0065b29c3bcb232c90e37897fa5aaee7e1e8a2ecfcd9b51463e42238cfdd7fee1aecb3267fa7f2128079176132a412cd8aaf0791276f6b98ff67359bd8652ef3a203976d5ff1cd41885573487bcd683\", \"938d2d4435be30eafdbb2b7031f7857c98b04881227391dc40db3c7b21f41fc18d72d0f9c1de5760e1941aebf3100b51d64644cb459eb5d20258e233892805eb98b07570ef2a1787cd48e117c8d6a63a68fd8fc8e59e79dbe63129e88352865721c8d5f0cf183f85e0609860472b0d6087cefdd186d984b21542c1c780684ed6832d8d\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(1023, \"10108970eeda3eb932baac1428c7a2163b0e924c9a9e25b35bba72b28f70bd11a182d27a591b05592b15607500e1e8dd56bc6c7fc063715b7a1d737df5bad3339c56778957d870eb9717b57ea3d9fb68d1b55127bba6a906a4a24bbd5acb2d123a37b28f9e9a81bbaae360d58f85e5fc9d75f7c370a0cc09b6522d9c8d822f2f28f485\", \"c951ecdf03288d0fcc96ee3413563d8a6d3589547f2c2fb36d9786470f1b9d6e890316d2e6d8b8c25b0a5b2180f94fb1a158ef508c3cde45e2966bd796a696d3e13efd86259d756387d9becf5c8bf1ce2192b87025152907b6d8cc33d17826d8b7b9bc97e38c3c85108ef09f013e01c229c20a83d9e8efac5b37470da28575fd755a10\", \"74a16c1c3d44368a86e1ca6df64be6a2f64cce8f09220787450722d85725dea59c413264404661e9e4d955409dfe4ad3aa487871bcd454ed12abfe2c2b1eb7757588cf6cb18d2eccad49e018c0d0fec323bec82bf1644c6325717d13ea712e6840d3e6e730d35553f59eff5377a9c350bcc1556694b924b858f329c44ee64b884ef00d\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(1024, \"42214739f095a406f3fc83deb889744ac00df831c10daa55189b5d121c855af71cf8107265ecdaf8505b95d8fcec83a98a6a96ea5109d2c179c47a387ffbb404756f6eeae7883b446b70ebb144527c2075ab8ab204c0086bb22b7c93d465efc57f8d917f0b385c6df265e77003b85102967486ed57db5c5ca170ba441427ed9afa684e\", \"75c46f6f3d9eb4f55ecaaee480db732e6c2105546f1e675003687c31719c7ba4a78bc838c72852d4f49c864acb7adafe2478e824afe51c8919d06168414c265f298a8094b1ad813a9b8614acabac321f24ce61c5a5346eb519520d38ecc43e89b5000236df0597243e4d2493fd626730e2ba17ac4d8824d09d1a4a8f57b8227778e2de\", \"7356cd7720d5b66b6d0697eb3177d9f8d73a4a5c5e968896eb6a6896843027066c23b601d3ddfb391e90d5c8eccdef4ae2a264bce9e612ba15e2bc9d654af1481b2e75dbabe615974f1070bba84d56853265a34330b4766f8e75edd1f4a1650476c10802f22b64bd3919d246ba20a17558bc51c199efdec67e80a227251808d8ce5bad\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(1025, \"d00278ae47eb27b34faecf67b4fe263f82d5412916c1ffd97c8cb7fb814b8444f4c4a22b4b399155358a994e52bf255de60035742ec71bd08ac275a1b51cc6bfe332b0ef84b409108cda080e6269ed4b3e2c3f7d722aa4cdc98d16deb554e5627be8f955c98e1d5f9565a9194cad0c4285f93700062d9595adb992ae68ff12800ab67a\", \"357dc55de0c7e382c900fd6e320acc04146be01db6a8ce7210b7189bd664ea69362396b77fdc0d2634a552970843722066c3c15902ae5097e00ff53f1e116f1cd5352720113a837ab2452cafbde4d54085d9cf5d21ca613071551b25d52e69d6c81123872b6f19cd3bc1333edf0c52b94de23ba772cf82636cff4542540a7738d5b930\", \"effaa245f065fbf82ac186839a249707c3bddf6d3fdda22d1b95a3c970379bcb5d31013a167509e9066273ab6e2123bc835b408b067d88f96addb550d96b6852dad38e320b9d940f86db74d398c770f462118b35d2724efa13da97194491d96dd37c3c09cbef665953f2ee85ec83d88b88d11547a6f911c8217cca46defa2751e7f3ad\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(2048, \"e776b6028c7cd22a4d0ba182a8bf62205d2ef576467e838ed6f2529b85fba24a9a60bf80001410ec9eea6698cd537939fad4749edd484cb541aced55cd9bf54764d063f23f6f1e32e12958ba5cfeb1bf618ad094266d4fc3c968c2088f677454c288c67ba0dba337b9d91c7e1ba586dc9a5bc2d5e90c14f53a8863ac75655461cea8f9\", \"879cf1fa2ea0e79126cb1063617a05b6ad9d0b696d0d757cf053439f60a99dd10173b961cd574288194b23ece278c330fbb8585485e74967f31352a8183aa782b2b22f26cdcadb61eed1a5bc144b8198fbb0c13abbf8e3192c145d0a5c21633b0ef86054f42809df823389ee40811a5910dcbd1018af31c3b43aa55201ed4edaac74fe\", \"7b2945cb4fef70885cc5d78a87bf6f6207dd901ff239201351ffac04e1088a23e2c11a1ebffcea4d80447867b61badb1383d842d4e79645d48dd82ccba290769caa7af8eaa1bd78a2a5e6e94fbdab78d9c7b74e894879f6a515257ccf6f95056f4e25390f24f6b35ffbb74b766202569b1d797f2d4bd9d17524c720107f985f4ddc583\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(2049, \"5f4d72f40d7a5f82b15ca2b2e44b1de3c2ef86c426c95c1af0b687952256303096de31d71d74103403822a2e0bc1eb193e7aecc9643a76b7bbc0c9f9c52e8783aae98764ca468962b5c2ec92f0c74eb5448d519713e09413719431c802f948dd5d90425a4ecdadece9eb178d80f26efccae630734dff63340285adec2aed3b51073ad3\", \"9f29700902f7c86e514ddc4df1e3049f258b2472b6dd5267f61bf13983b78dd5f9a88abfefdfa1e00b418971f2b39c64ca621e8eb37fceac57fd0c8fc8e117d43b81447be22d5d8186f8f5919ba6bcc6846bd7d50726c06d245672c2ad4f61702c646499ee1173daa061ffe15bf45a631e2946d616a4c345822f1151284712f76b2b0e\", \"2ea477c5515cc3dd606512ee72bb3e0e758cfae7232826f35fb98ca1bcbdf27316d8e9e79081a80b046b60f6a263616f33ca464bd78d79fa18200d06c7fc9bffd808cc4755277a7d5e09da0f29ed150f6537ea9bed946227ff184cc66a72a5f8c1e4bd8b04e81cf40fe6dc4427ad5678311a61f4ffc39d195589bdbc670f63ae70f4b6\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(3072, \"b98cb0ff3623be03326b373de6b9095218513e64f1ee2edd2525c7ad1e5cffd29a3f6b0b978d6608335c09dc94ccf682f9951cdfc501bfe47b9c9189a6fc7b404d120258506341a6d802857322fbd20d3e5dae05b95c88793fa83db1cb08e7d8008d1599b6209d78336e24839724c191b2a52a80448306e0daa84a3fdb566661a37e11\", \"044a0e7b172a312dc02a4c9a818c036ffa2776368d7f528268d2e6b5df19177022f302d0529e4174cc507c463671217975e81dab02b8fdeb0d7ccc7568dd22574c783a76be215441b32e91b9a904be8ea81f7a0afd14bad8ee7c8efc305ace5d3dd61b996febe8da4f56ca0919359a7533216e2999fc87ff7d8f176fbecb3d6f34278b\", \"050df97f8c2ead654d9bb3ab8c9178edcd902a32f8495949feadcc1e0480c46b3604131bbd6e3ba573b6dd682fa0a63e5b165d39fc43a625d00207607a2bfeb65ff1d29292152e26b298868e3b87be95d6458f6f2ce6118437b632415abe6ad522874bcd79e4030a5e7bad2efa90a7a7c67e93f0a18fb28369d0a9329ab5c24134ccb0\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(3073, \"7124b49501012f81cc7f11ca069ec9226cecb8a2c850cfe644e327d22d3e1cd39a27ae3b79d68d89da9bf25bc27139ae65a324918a5f9b7828181e52cf373c84f35b639b7fccbb985b6f2fa56aea0c18f531203497b8bbd3a07ceb5926f1cab74d14bd66486d9a91eba99059a98bd1cd25876b2af5a76c3e9eed554ed72ea952b603bf\", \"68dede9bef00ba89e43f31a6825f4cf433389fedae75c04ee9f0cf16a427c95a96d6da3fe985054d3478865be9a092250839a697bbda74e279e8a9e69f0025e4cfddd6cfb434b1cd9543aaf97c635d1b451a4386041e4bb100f5e45407cbbc24fa53ea2de3536ccb329e4eb9466ec37093a42cf62b82903c696a93a50b702c80f3c3c5\", \"72613c9ec9ff7e40f8f5c173784c532ad852e827dba2bf85b2ab4b76f7079081576288e552647a9d86481c2cae75c2dd4e7c5195fb9ada1ef50e9c5098c249d743929191441301c69e1f48505a4305ec1778450ee48b8e69dc23a25960fe33070ea549119599760a8a2d28aeca06b8c5e9ba58bc19e11fe57b6ee98aa44b2a8e6b14a5\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(4096, \"015094013f57a5277b59d8475c0501042c0b642e531b0a1c8f58d2163229e9690289e9409ddb1b99768eafe1623da896faf7e1114bebeadc1be30829b6f8af707d85c298f4f0ff4d9438aef948335612ae921e76d411c3a9111df62d27eaf871959ae0062b5492a0feb98ef3ed4af277f5395172dbe5c311918ea0074ce0036454f620\", \"befc660aea2f1718884cd8deb9902811d332f4fc4a38cf7c7300d597a081bfc0bbb64a36edb564e01e4b4aaf3b060092a6b838bea44afebd2deb8298fa562b7b597c757b9df4c911c3ca462e2ac89e9a787357aaf74c3b56d5c07bc93ce899568a3eb17d9250c20f6c5f6c1e792ec9a2dcb715398d5a6ec6d5c54f586a00403a1af1de\", \"1e0d7f3db8c414c97c6307cbda6cd27ac3b030949da8e23be1a1a924ad2f25b9d78038f7b198596c6cc4a9ccf93223c08722d684f240ff6569075ed81591fd93f9fff1110b3a75bc67e426012e5588959cc5a4c192173a03c00731cf84544f65a2fb9378989f72e9694a6a394a8a30997c2e67f95a504e631cd2c5f55246024761b245\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(4097, \"9b4052b38f1c5fc8b1f9ff7ac7b27cd242487b3d890d15c96a1c25b8aa0fb99505f91b0b5600a11251652eacfa9497b31cd3c409ce2e45cfe6c0a016967316c426bd26f619eab5d70af9a418b845c608840390f361630bd497b1ab44019316357c61dbe091ce72fc16dc340ac3d6e009e050b3adac4b5b2c92e722cffdc46501531956\", \"00df940cd36bb9fa7cbbc3556744e0dbc8191401afe70520ba292ee3ca80abbc606db4976cfdd266ae0abf667d9481831ff12e0caa268e7d3e57260c0824115a54ce595ccc897786d9dcbf495599cfd90157186a46ec800a6763f1c59e36197e9939e900809f7077c102f888caaf864b253bc41eea812656d46742e4ea42769f89b83f\", \"aca51029626b55fda7117b42a7c211f8c6e9ba4fe5b7a8ca922f34299500ead8a897f66a400fed9198fd61dd2d58d382458e64e100128075fc54b860934e8de2e84170734b06e1d212a117100820dbc48292d148afa50567b8b84b1ec336ae10d40c8c975a624996e12de31abbe135d9d159375739c333798a80c64ae895e51e22f3ad\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(5120, \"9cadc15fed8b5d854562b26a9536d9707cadeda9b143978f319ab34230535833acc61c8fdc114a2010ce8038c853e121e1544985133fccdd0a2d507e8e615e611e9a0ba4f47915f49e53d721816a9198e8b30f12d20ec3689989175f1bf7a300eee0d9321fad8da232ece6efb8e9fd81b42ad161f6b9550a069e66b11b40487a5f5059\", \"2c493e48e9b9bf31e0553a22b23503c0a3388f035cece68eb438d22fa1943e209b4dc9209cd80ce7c1f7c9a744658e7e288465717ae6e56d5463d4f80cdb2ef56495f6a4f5487f69749af0c34c2cdfa857f3056bf8d807336a14d7b89bf62bef2fb54f9af6a546f818dc1e98b9e07f8a5834da50fa28fb5874af91bf06020d1bf0120e\", \"7a7acac8a02adcf3038d74cdd1d34527de8a0fcc0ee3399d1262397ce5817f6055d0cefd84d9d57fe792d65a278fd20384ac6c30fdb340092f1a74a92ace99c482b28f0fc0ef3b923e56ade20c6dba47e49227166251337d80a037e987ad3a7f728b5ab6dfafd6e2ab1bd583a95d9c895ba9c2422c24ea0f62961f0dca45cad47bfa0d\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(5121, \"628bd2cb2004694adaab7bbd778a25df25c47b9d4155a55f8fbd79f2fe154cff96adaab0613a6146cdaabe498c3a94e529d3fc1da2bd08edf54ed64d40dcd6777647eac51d8277d70219a9694334a68bc8f0f23e20b0ff70ada6f844542dfa32cd4204ca1846ef76d811cdb296f65e260227f477aa7aa008bac878f72257484f2b6c95\", \"6ccf1c34753e7a044db80798ecd0782a8f76f33563accaddbfbb2e0ea4b2d0240d07e63f13667a8d1490e5e04f13eb617aea16a8c8a5aaed1ef6fbde1b0515e3c81050b361af6ead126032998290b563e3caddeaebfab592e155f2e161fb7cba939092133f23f9e65245e58ec23457b78a2e8a125588aad6e07d7f11a85b88d375b72d\", \"b07f01e518e702f7ccb44a267e9e112d403a7b3f4883a47ffbed4b48339b3c341a0add0ac032ab5aaea1e4e5b004707ec5681ae0fcbe3796974c0b1cf31a194740c14519273eedaabec832e8a784b6e7cfc2c5952677e6c3f2c3914454082d7eb1ce1766ac7d75a4d3001fc89544dd46b5147382240d689bbbaefc359fb6ae30263165\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(6144, \"3e2e5b74e048f3add6d21faab3f83aa44d3b2278afb83b80b3c35164ebeca2054d742022da6fdda444ebc384b04a54c3ac5839b49da7d39f6d8a9db03deab32aade156c1c0311e9b3435cde0ddba0dce7b26a376cad121294b689193508dd63151603c6ddb866ad16c2ee41585d1633a2cea093bea714f4c5d6b903522045b20395c83\", \"3d6b6d21281d0ade5b2b016ae4034c5dec10ca7e475f90f76eac7138e9bc8f1dc35754060091dc5caf3efabe0603c60f45e415bb3407db67e6beb3d11cf8e4f7907561f05dace0c15807f4b5f389c841eb114d81a82c02a00b57206b1d11fa6e803486b048a5ce87105a686dee041207e095323dfe172df73deb8c9532066d88f9da7e\", \"2a95beae63ddce523762355cf4b9c1d8f131465780a391286a5d01abb5683a1597099e3c6488aab6c48f3c15dbe1942d21dbcdc12115d19a8b8465fb54e9053323a9178e4275647f1a9927f6439e52b7031a0b465c861a3fc531527f7758b2b888cf2f20582e9e2c593709c0a44f9c6e0f8b963994882ea4168827823eef1f64169fef\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(6145, \"f1323a8631446cc50536a9f705ee5cb619424d46887f3c376c695b70e0f0507f18a2cfdd73c6e39dd75ce7c1c6e3ef238fd54465f053b25d21044ccb2093beb015015532b108313b5829c3621ce324b8e14229091b7c93f32db2e4e63126a377d2a63a3597997d4f1cba59309cb4af240ba70cebff9a23d5e3ff0cdae2cfd54e070022\", \"9ac301e9e39e45e3250a7e3b3df701aa0fb6889fbd80eeecf28dbc6300fbc539f3c184ca2f59780e27a576c1d1fb9772e99fd17881d02ac7dfd39675aca918453283ed8c3169085ef4a466b91c1649cc341dfdee60e32231fc34c9c4e0b9a2ba87ca8f372589c744c15fd6f985eec15e98136f25beeb4b13c4e43dc84abcc79cd4646c\", \"379bcc61d0051dd489f686c13de00d5b14c505245103dc040d9e4dd1facab8e5114493d029bdbd295aaa744a59e31f35c7f52dba9c3642f773dd0b4262a9980a2aef811697e1305d37ba9d8b6d850ef07fe41108993180cf779aeece363704c76483458603bbeeb693cffbbe5588d1f3535dcad888893e53d977424bb707201569a8d2\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(7168, \"61da957ec2499a95d6b8023e2b0e604ec7f6b50e80a9678b89d2628e99ada77a5707c321c83361793b9af62a40f43b523df1c8633cecb4cd14d00bdc79c78fca5165b863893f6d38b02ff7236c5a9a8ad2dba87d24c547cab046c29fc5bc1ed142e1de4763613bb162a5a538e6ef05ed05199d751f9eb58d332791b8d73fb74e4fce95\", \"b42835e40e9d4a7f42ad8cc04f85a963a76e18198377ed84adddeaecacc6f3fca2f01d5277d69bb681c70fa8d36094f73ec06e452c80d2ff2257ed82e7ba348400989a65ee8daa7094ae0933e3d2210ac6395c4af24f91c2b590ef87d7788d7066ea3eaebca4c08a4f14b9a27644f99084c3543711b64a070b94f2c9d1d8a90d035d52\", \"11c37a112765370c94a51415d0d651190c288566e295d505defdad895dae223730d5a5175a38841693020669c7638f40b9bc1f9f39cf98bda7a5b54ae24218a800a2116b34665aa95d846d97ea988bfcb53dd9c055d588fa21ba78996776ea6c40bc428b53c62b5f3ccf200f647a5aae8067f0ea1976391fcc72af1945100e2a6dcb88\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(7169, \"a003fc7a51754a9b3c7fae0367ab3d782dccf28855a03d435f8cfe74605e781798a8b20534be1ca9eb2ae2df3fae2ea60e48c6fb0b850b1385b5de0fe460dbe9d9f9b0d8db4435da75c601156df9d047f4ede008732eb17adc05d96180f8a73548522840779e6062d643b79478a6e8dbce68927f36ebf676ffa7d72d5f68f050b119c8\", \"ed9b1a922c046fdb3d423ae34e143b05ca1bf28b710432857bf738bcedbfa5113c9e28d72fcbfc020814ce3f5d4fc867f01c8f5b6caf305b3ea8a8ba2da3ab69fabcb438f19ff11f5378ad4484d75c478de425fb8e6ee809b54eec9bdb184315dc856617c09f5340451bf42fd3270a7b0b6566169f242e533777604c118a6358250f54\", \"554b0a5efea9ef183f2f9b931b7497995d9eb26f5c5c6dad2b97d62fc5ac31d99b20652c016d88ba2a611bbd761668d5eda3e568e940faae24b0d9991c3bd25a65f770b89fdcadabcb3d1a9c1cb63e69721cacf1ae69fefdcef1e3ef41bc5312ccc17222199e47a26552c6adc460cf47a72319cb5039369d0060eaea59d6c65130f1dd\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(8192, \"aae792484c8efe4f19e2ca7d371d8c467ffb10748d8a5a1ae579948f718a2a635fe51a27db045a567c1ad51be5aa34c01c6651c4d9b5b5ac5d0fd58cf18dd61a47778566b797a8c67df7b1d60b97b19288d2d877bb2df417ace009dcb0241ca1257d62712b6a4043b4ff33f690d849da91ea3bf711ed583cb7b7a7da2839ba71309bbf\", \"dc9637c8845a770b4cbf76b8daec0eebf7dc2eac11498517f08d44c8fc00d58a4834464159dcbc12a0ba0c6d6eb41bac0ed6585cabfe0aca36a375e6c5480c22afdc40785c170f5a6b8a1107dbee282318d00d915ac9ed1143ad40765ec120042ee121cd2baa36250c618adaf9e27260fda2f94dea8fb6f08c04f8f10c78292aa46102\", \"ad01d7ae4ad059b0d33baa3c01319dcf8088094d0359e5fd45d6aeaa8b2d0c3d4c9e58958553513b67f84f8eac653aeeb02ae1d5672dcecf91cd9985a0e67f4501910ecba25555395427ccc7241d70dc21c190e2aadee875e5aae6bf1912837e53411dabf7a56cbf8e4fb780432b0d7fe6cec45024a0788cf5874616407757e9e6bef7\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(8193, \"bab6c09cb8ce8cf459261398d2e7aef35700bf488116ceb94a36d0f5f1b7bc3bb2282aa69be089359ea1154b9a9286c4a56af4de975a9aa4a5c497654914d279bea60bb6d2cf7225a2fa0ff5ef56bbe4b149f3ed15860f78b4e2ad04e158e375c1e0c0b551cd7dfc82f1b155c11b6b3ed51ec9edb30d133653bb5709d1dbd55f4e1ff6\", \"954a2a75420c8d6547e3ba5b98d963e6fa6491addc8c023189cc519821b4a1f5f03228648fd983aef045c2fa8290934b0866b615f585149587dda2299039965328835a2b18f1d63b7e300fc76ff260b571839fe44876a4eae66cbac8c67694411ed7e09df51068a22c6e67d6d3dd2cca8ff12e3275384006c80f4db68023f24eebba57\", \"af1e0346e389b17c23200270a64aa4e1ead98c61695d917de7d5b00491c9b0f12f20a01d6d622edf3de026a4db4e4526225debb93c1237934d71c7340bb5916158cbdafe9ac3225476b6ab57a12357db3abbad7a26c6e66290e44034fb08a20a8d0ec264f309994d2810c49cfba6989d7abb095897459f5425adb48aba07c5fb3c83c0\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(16384, \"f875d6646de28985646f34ee13be9a576fd515f76b5b0a26bb324735041ddde49d764c270176e53e97bdffa58d549073f2c660be0e81293767ed4e4929f9ad34bbb39a529334c57c4a381ffd2a6d4bfdbf1482651b172aa883cc13408fa67758a3e47503f93f87720a3177325f7823251b85275f64636a8f1d599c2e49722f42e93893\", \"9e9fc4eb7cf081ea7c47d1807790ed211bfec56aa25bb7037784c13c4b707b0df9e601b101e4cf63a404dfe50f2e1865bb12edc8fca166579ce0c70dba5a5c0fc960ad6f3772183416a00bd29d4c6e651ea7620bb100c9449858bf14e1ddc9ecd35725581ca5b9160de04060045993d972571c3e8f71e9d0496bfa744656861b169d65\", \"160e18b5878cd0df1c3af85eb25a0db5344d43a6fbd7a8ef4ed98d0714c3f7e160dc0b1f09caa35f2f417b9ef309dfe5ebd67f4c9507995a531374d099cf8ae317542e885ec6f589378864d3ea98716b3bbb65ef4ab5e0ab5bb298a501f19a41ec19af84a5e6b428ecd813b1a47ed91c9657c3fba11c406bc316768b58f6802c9e9b57\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(31744, \"62b6960e1a44bcc1eb1a611a8d6235b6b4b78f32e7abc4fb4c6cdcce94895c47860cc51f2b0c28a7b77304bd55fe73af663c02d3f52ea053ba43431ca5bab7bfea2f5e9d7121770d88f70ae9649ea713087d1914f7f312147e247f87eb2d4ffef0ac978bf7b6579d57d533355aa20b8b77b13fd09748728a5cc327a8ec470f4013226f\", \"efa53b389ab67c593dba624d898d0f7353ab99e4ac9d42302ee64cbf9939a4193a7258db2d9cd32a7a3ecfce46144114b15c2fcb68a618a976bd74515d47be08b628be420b5e830fade7c080e351a076fbc38641ad80c736c8a18fe3c66ce12f95c61c2462a9770d60d0f77115bbcd3782b593016a4e728d4c06cee4505cb0c08a42ec\", \"39772aef80e0ebe60596361e45b061e8f417429d529171b6764468c22928e28e9759adeb797a3fbf771b1bcea30150a020e317982bf0d6e7d14dd9f064bc11025c25f31e81bd78a921db0174f03dd481d30e93fd8e90f8b2fee209f849f2d2a52f31719a490fb0ba7aea1e09814ee912eba111a9fde9d5c274185f7bae8ba85d300a2b\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(102400, \"bc3e3d41a1146b069abffad3c0d44860cf664390afce4d9661f7902e7943e085e01c59dab908c04c3342b816941a26d69c2605ebee5ec5291cc55e15b76146e6745f0601156c3596cb75065a9c57f35585a52e1ac70f69131c23d611ce11ee4ab1ec2c009012d236648e77be9295dd0426f29b764d65de58eb7d01dd42248204f45f8e\", \"1c35d1a5811083fd7119f5d5d1ba027b4d01c0c6c49fb6ff2cf75393ea5db4a7f9dbdd3e1d81dcbca3ba241bb18760f207710b751846faaeb9dff8262710999a59b2aa1aca298a032d94eacfadf1aa192418eb54808db23b56e34213266aa08499a16b354f018fc4967d05f8b9d2ad87a7278337be9693fc638a3bfdbe314574ee6fc4\", \"4652cff7a3f385a6103b5c260fc1593e13c778dbe608efb092fe7ee69df6e9c6d83a3e041bc3a48df2879f4a0a3ed40e7c961c73eff740f3117a0504c2dff4786d44fb17f1549eb0ba585e40ec29bf7732f0b7e286ff8acddc4cb1e23b87ff5d824a986458dcc6a04ac83969b80637562953df51ed1a7e90a7926924d2763778be8560\")",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.stream.Stream<T>"
              },
              {
                "signature": "org.junit.jupiter.params.provider.Arguments.of(java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "\"af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262e00f03e7b69af26b7faaf09fcd333050338ddfe085b8cc869ca98b206c08243a26f5487789e8f660afe6c99ef9e0c52b92e7393024a80459cf91f476f9ffdbda7001c22e159b402631f277ca96f2defdf1078282314e763699a31c5363165421cce14d\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "\"92b2b75604ed3c761f9d6f62392c8a9227ad0ea3f09573e783f1498a4ed60d26b18171a2f22a4b94822c701f107153dba24918c4bae4d2945c20ece13387627d3b73cbf97b797d5e59948c7ef788f54372df45e45e4293c7dc18c1d41144a9758be58960856be1eabbe22c2653190de560ca3b2ac4aa692a9210694254c371e851bc8f\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "\"2cc39783c223154fea8dfb7c1b1660f2ac2dcbd1c1de8277b0b0dd39b7e50d7d905630c8be290dfcf3e6842f13bddd573c098c3f17361f1f206b8cad9d088aa4a3f746752c6b0ce6a83b0da81d59649257cdf8eb3e9f7d4998e41021fac119deefb896224ac99f860011f73609e6e0e4540f93b273e56547dfd3aa1a035ba6689d89a0\"",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "org.junit.jupiter.params.provider.Arguments"
              }
            ],
            "signature": "public static Stream<Arguments> data()",
            "parameters": []
          }
        ],
        "hashArbitraryOutputLength": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "inputByteArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3TestVectorsTest.initData(int, java.lang.String, java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "inputLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "keyedHash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "deriveKey",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "hashByteArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.doFinalize(int)",
                "arguments": [
                  {
                    "variable_name": "hashByteArray.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void hashArbitraryOutputLength(int, String, String, String)",
            "parameters": [
              {
                "variable_name": "inputLength",
                "variable_type": "int"
              },
              {
                "variable_name": "hash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "keyedHash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "deriveKey",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "hashTruncatedOutput": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3TestVectorsTest.initData(int, java.lang.String, java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "inputLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "keyedHash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "deriveKey",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.hash(byte[])",
                "arguments": [
                  {
                    "variable_name": "inputByteArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "Arrays.copyOf(this.hashByteArray, 32)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "this.hashByteArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void hashTruncatedOutput(int, String, String, String)",
            "parameters": [
              {
                "variable_name": "inputLength",
                "variable_type": "int"
              },
              {
                "variable_name": "hash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "keyedHash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "deriveKey",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "initData": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "private void initData(int, String, String, String)",
            "parameters": [
              {
                "variable_name": "inputLength",
                "variable_type": "int"
              },
              {
                "variable_name": "hash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "keyedHash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "deriveKey",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "keyDerivation": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "inputByteArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3TestVectorsTest.initData(int, java.lang.String, java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "inputLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "keyedHash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "deriveKey",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "deriveKeyByteArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.reset()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.doFinalize(int)",
                "arguments": [
                  {
                    "variable_name": "deriveKeyByteArray.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "deriveKeyByteArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void keyDerivation(int, String, String, String)",
            "parameters": [
              {
                "variable_name": "inputLength",
                "variable_type": "int"
              },
              {
                "variable_name": "hash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "keyedHash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "deriveKey",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "keyedHashArbitraryOutputLength": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "inputByteArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.Blake3"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3TestVectorsTest.initData(int, java.lang.String, java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "inputLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "keyedHash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "deriveKey",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "keyedHashByteArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3.doFinalize(int)",
                "arguments": [
                  {
                    "variable_name": "keyedHashByteArray.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void keyedHashArbitraryOutputLength(int, String, String, String)",
            "parameters": [
              {
                "variable_name": "inputLength",
                "variable_type": "int"
              },
              {
                "variable_name": "hash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "keyedHash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "deriveKey",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "keyedHashTruncatedOutput": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Blake3.keyedHash(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "KEY",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "inputByteArray",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Blake3TestVectorsTest.initData(int, java.lang.String, java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "inputLength",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "keyedHash",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "deriveKey",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "Arrays.copyOf(keyedHashByteArray, 32)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "actual",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "keyedHashByteArray",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "32",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void keyedHashTruncatedOutput(int, String, String, String)",
            "parameters": [
              {
                "variable_name": "inputLength",
                "variable_type": "int"
              },
              {
                "variable_name": "hash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "keyedHash",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "deriveKey",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests the standard test vectors provided by the reference Blake3 implementation. Each test uses as input data the\n * cyclic byte sequence 0, 1, 2, ..., 249, 250, 0, 1, ..., up to a specified length. For each test, the hash of this\n * message up to a specific length is calculated. Then the same hash is calculated in keyed mode using the UTF-8\n * encoding of the string \"whats the Elvish word for friend\". Finally, the same hash is calculated in key derivation\n * mode using the KDF context string with the UTF-8 encoding of \"BLAKE3 2019-12-27 16:29:52 test vectors context\".\n * For each of these hashes, both the extended hash output and the truncated 32-byte hash outputs are validated against\n * these known answer tests (KATs).\n "
    },
    "org.apache.commons.codec.digest.CryptTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testCrypt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new Crypt()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCrypt()",
            "parameters": []
          }
        ],
        "testCryptWithBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "keyBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(\"byte\", hash)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"byte\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testCryptWithBytes()",
            "parameters": []
          }
        ],
        "testCryptWithEmptySalt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Crypt.crypt(\"secret\", \"\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testCryptWithEmptySalt()",
            "parameters": [],
            "javadoc": "\n     * An empty string as salt is invalid.\n     *\n     * The C and Perl implementations return an empty string, PHP threads it\n     * as NULL. Our implementation should throw an Exception as any resulting\n     * hash would not be verifiable with other implementations of crypt().\n     "
          }
        ],
        "testDefaultCryptVariant": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.startsWith(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"$6$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Crypt.crypt(\"secret\").startsWith(\"$6$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDefaultCryptVariant()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.DigestUtilsTest": {
      "fields": [
        {
          "variable_name": "EMPTY_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "testData",
          "variable_type": "byte"
        },
        {
          "variable_name": "testFile",
          "variable_type": "java.nio.file.Path"
        },
        {
          "variable_name": "testRandomAccessFile",
          "variable_type": "java.nio.file.Path"
        },
        {
          "variable_name": "testRandomAccessFileWrapper",
          "variable_type": "java.io.RandomAccessFile"
        }
      ],
      "constructors": [],
      "methods": {
        "assumeJava8": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.lang3.SystemUtils.isJavaVersionAtLeast(org.apache.commons.lang3.JavaVersion)",
                "arguments": [
                  {
                    "variable_name": "JavaVersion.JAVA_1_8",
                    "variable_type": "org.apache.commons.lang3.JavaVersion"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private void assumeJava8()",
            "parameters": []
          }
        ],
        "assumeJava9": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.lang3.SystemUtils.isJavaVersionAtLeast(org.apache.commons.lang3.JavaVersion)",
                "arguments": [
                  {
                    "variable_name": "JavaVersion.JAVA_9",
                    "variable_type": "org.apache.commons.lang3.JavaVersion"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private void assumeJava9()",
            "parameters": []
          }
        ],
        "getTestData": [
          {
            "call_methods": [],
            "signature": " byte[] getTestData()",
            "parameters": []
          }
        ],
        "getTestPath": [
          {
            "call_methods": [],
            "signature": " Path getTestPath()",
            "parameters": []
          }
        ],
        "getTestRandomAccessFile": [
          {
            "call_methods": [],
            "signature": " RandomAccessFile getTestRandomAccessFile()",
            "parameters": []
          }
        ],
        "setUp": [
          {
            "call_methods": [
              {
                "signature": "java.nio.file.Files.createTempFile(java.lang.String, java.lang.String, java.nio.file.attribute.FileAttribute<?>...)",
                "arguments": [
                  {
                    "variable_name": "DigestUtilsTest.class.getName()",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\".dat\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.file.Path"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.nio.file.Files.newOutputStream(java.nio.file.Path, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "testFile",
                    "variable_type": "java.nio.file.Path"
                  }
                ],
                "return_type": "java.io.OutputStream"
              },
              {
                "signature": "java.io.OutputStream.write(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.io.RandomAccessFileMode.create(java.nio.file.Path)",
                "arguments": [
                  {
                    "variable_name": "testRandomAccessFile",
                    "variable_type": "java.nio.file.Path"
                  }
                ],
                "return_type": "java.io.RandomAccessFile"
              }
            ],
            "signature": "public void setUp()",
            "parameters": []
          }
        ],
        "tearDown": [
          {
            "call_methods": [
              {
                "signature": "java.nio.file.Files.deleteIfExists(java.nio.file.Path)",
                "arguments": [
                  {
                    "variable_name": "testFile",
                    "variable_type": "java.nio.file.Path"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.io.RandomAccessFile.close()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void tearDown()",
            "parameters": []
          }
        ],
        "testDigestAs": [
          {
            "call_methods": [
              {
                "signature": "java.nio.file.Files.readAllBytes(java.nio.file.Path)",
                "arguments": [
                  {
                    "variable_name": "Paths.get(pathName)",
                    "variable_type": "java.nio.file.Path"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.file.Paths.get(java.lang.String, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "pathName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.file.Path"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "ByteBuffer.wrap(allBytes)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "inputStream",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "allBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.nio.ByteBuffer.wrap(byte[])",
                "arguments": [
                  {
                    "variable_name": "allBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.io.File)",
                "arguments": [
                  {
                    "variable_name": "new File(pathName)",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new DigestUtils(algo).digestAsHex(new File(pathName))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDigestAs()",
            "parameters": []
          }
        ],
        "testGetMessageDigest": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.getAlgorithm()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getMessageDigest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "digestUtils.getMessageDigest()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.MD5",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "digestUtils.getMessageDigest().getAlgorithm()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetMessageDigest()",
            "parameters": []
          }
        ],
        "testInternalNoSuchAlgorithmException": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Bogus Bogus\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> DigestUtils.getDigest(\"Bogus Bogus\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testInternalNoSuchAlgorithmException()",
            "parameters": []
          }
        ],
        "testIsAvailable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "MessageDigestAlgorithms.MD5",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(\"FOO\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(MessageDigestAlgorithms.MD5)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsAvailable()",
            "parameters": []
          }
        ],
        "testMd2Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EMPTY_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"8350e5a3e24c153df2275c9f80692773\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.md2Hex(EMPTY_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMd2Hex()",
            "parameters": []
          }
        ],
        "testMd2HexLength": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(hashMe)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "32",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "hashMe",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testMd2HexLength()",
            "parameters": [],
            "javadoc": "\n     * An MD2 hash converted to hexadecimal should always be 32 characters.\n     "
          }
        ],
        "testMd2Length": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "16",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md2(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(hashMe)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "hashMe",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testMd2Length()",
            "parameters": [],
            "javadoc": "\n     * An MD2 hash should always be a 16 element byte[].\n     "
          }
        ],
        "testMd5Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"d41d8cd98f00b204e9800998ecf8427e\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.md5Hex(EMPTY_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EMPTY_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMd5Hex()",
            "parameters": []
          }
        ],
        "testMd5HexLengthForBytes": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "32",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash.length()",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "hashMe",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(hashMe)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testMd5HexLengthForBytes()",
            "parameters": [],
            "javadoc": "\n     * An MD5 hash converted to hexadecimal should always be 32 characters.\n     "
          }
        ],
        "testMd5LengthForBytes": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "16",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.md5(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(hashMe)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "hashMe",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testMd5LengthForBytes()",
            "parameters": [],
            "javadoc": "\n     * An MD5 hash should always be a 16 element byte[].\n     "
          }
        ],
        "testSha1Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(\"abc\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"a9993e364706816aba3e25717850c26c9cd0d89d\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha1Hex(\"abc\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha1Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha1Hex()",
            "parameters": []
          }
        ],
        "testSha1UpdateWithByteArray": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "d1.getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "d1.getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha1Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest.digest()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actualResult",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha1UpdateWithByteArray()",
            "parameters": []
          }
        ],
        "testSha1UpdateWithByteBuffer": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "d1.getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "ByteBuffer.wrap(d1.getBytes())",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha1Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.nio.ByteBuffer.wrap(byte[])",
                "arguments": [
                  {
                    "variable_name": "d1.getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest.digest()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actualResult",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha1UpdateWithByteBuffer()",
            "parameters": []
          }
        ],
        "testSha1UpdateWithString": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(d1)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getSha1Digest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "d1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest.digest()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "d1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actualResult",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha1UpdateWithString()",
            "parameters": []
          }
        ],
        "testSha224_FileAsHex": [
          {
            "call_methods": [
              {
                "signature": "java.nio.file.Files.readAllBytes(java.nio.file.Path)",
                "arguments": [
                  {
                    "variable_name": "Paths.get(pathName)",
                    "variable_type": "java.nio.file.Path"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.file.Paths.get(java.lang.String, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "pathName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.file.Path"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "ByteBuffer.wrap(allBytes)",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "inputStream",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "allBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.nio.ByteBuffer.wrap(byte[])",
                "arguments": [
                  {
                    "variable_name": "allBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.io.File)",
                "arguments": [
                  {
                    "variable_name": "new File(pathName)",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "digestUtils.digestAsHex(new File(pathName))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava8()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha224_FileAsHex()",
            "parameters": []
          }
        ],
        "testSha224_PathAsHex": [
          {
            "call_methods": [
              {
                "signature": "java.nio.file.Paths.get(java.lang.String, java.lang.String...)",
                "arguments": [
                  {
                    "variable_name": "\"src/test/resources/org/apache/commons/codec/empty.bin\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.nio.file.Path"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new DigestUtils(MessageDigestAlgorithms.SHA_224).digestAsHex(Paths.get(\"src/test/resources/org/apache/commons/codec/empty.bin\"))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava8()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.nio.file.Path, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "Paths.get(\"src/test/resources/org/apache/commons/codec/empty.bin\")",
                    "variable_type": "java.nio.file.Path"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha224_PathAsHex()",
            "parameters": []
          }
        ],
        "testSha224_StringAsHex": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new DigestUtils(MessageDigestAlgorithms.SHA_224).digestAsHex(EMPTY_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava8()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digestAsHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EMPTY_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha224_StringAsHex()",
            "parameters": []
          }
        ],
        "testSha256": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(\"abc\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha256Hex(\"abc\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha256()",
            "parameters": []
          }
        ],
        "testSha256HexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha256Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.sha256Hex(testData)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha256Hex(new ByteArrayInputStream(testData))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha256HexInputStream()",
            "parameters": []
          }
        ],
        "testSha3_224": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_224Hex(EMPTY_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EMPTY_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha3_224()",
            "parameters": []
          }
        ],
        "testSha3_224HexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.sha3_224Hex(testData)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_224Hex(new ByteArrayInputStream(testData))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha3_224HexInputStream()",
            "parameters": []
          }
        ],
        "testSha3_256": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EMPTY_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_256Hex(EMPTY_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha3_256()",
            "parameters": []
          }
        ],
        "testSha3_256HexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.sha3_256Hex(testData)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_256Hex(new ByteArrayInputStream(testData))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_256Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha3_256HexInputStream()",
            "parameters": []
          }
        ],
        "testSha3_384": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_384Hex(EMPTY_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EMPTY_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha3_384()",
            "parameters": []
          }
        ],
        "testSha3_384HexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_384Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.sha3_384Hex(testData)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_384Hex(new ByteArrayInputStream(testData))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha3_384HexInputStream()",
            "parameters": []
          }
        ],
        "testSha3_512": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EMPTY_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_512Hex(EMPTY_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha3_512()",
            "parameters": []
          }
        ],
        "testSha3_512HexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.sha3_512Hex(testData)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha3_512Hex(new ByteArrayInputStream(testData))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha3_512Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha3_512HexInputStream()",
            "parameters": []
          }
        ],
        "testSha384": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(\"abc\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed\" + \"8086072ba1e7cc2358baeca134c825a7\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha384Hex(\"abc\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha384()",
            "parameters": []
          }
        ],
        "testSha384HexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.sha384Hex(testData)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha384Hex(new ByteArrayInputStream(testData))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha384Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha384HexInputStream()",
            "parameters": []
          }
        ],
        "testSha512": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(\"abc\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\" + \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha512Hex(\"abc\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha512()",
            "parameters": []
          }
        ],
        "testSha512_224": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stringInput",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "resultString",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "resultBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.sha512_224(bytesInput)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(bytesInput)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(bytesInput)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytesInput",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytesInput",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stringInput",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_224(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stringInput",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "resultString",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha512_224Hex(bytesInput)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toLowerCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.ROOT",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha512_224()",
            "parameters": []
          }
        ],
        "testSha512_256": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.binary.Hex.decodeHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "resultString",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "resultBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.sha512_256(bytesInput)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stringInput",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stringInput",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytesInput",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(bytesInput)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stringInput",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(bytesInput)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "resultString",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha512_256Hex(bytesInput)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.assumeJava9()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512_256Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytesInput",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.toLowerCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.ROOT",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha512_256()",
            "parameters": []
          }
        ],
        "testSha512HexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.sha512Hex(byte[])",
                "arguments": [
                  {
                    "variable_name": "testData",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.sha512Hex(testData)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.sha512Hex(new ByteArrayInputStream(testData))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha512HexInputStream()",
            "parameters": []
          }
        ],
        "testShaHex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "getBytesUtf8(\"abc\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(testData)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.shaHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"a9993e364706816aba3e25717850c26c9cd0d89d\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "DigestUtils.shaHex(\"abc\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testShaHex()",
            "parameters": []
          }
        ],
        "testShaUpdateWithByteArray": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "d1.getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "d1.getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest.digest()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actualResult",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getShaDigest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testShaUpdateWithByteArray()",
            "parameters": []
          }
        ],
        "testShaUpdateWithString": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.update(byte[])",
                "arguments": [
                  {
                    "variable_name": "StringUtils.getBytesUtf8(d1)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.updateDigest(java.security.MessageDigest, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigest",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "d1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "messageDigest.digest()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "d1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expectedResult",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "actualResult",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getShaDigest()",
                "arguments": [],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "java.security.MessageDigest.digest()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testShaUpdateWithString()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link DigestUtils}.\n "
    },
    "org.apache.commons.codec.digest.HmacAlgorithmsTest": {
      "fields": [
        {
          "variable_name": "STANDARD_KEY_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_KEY_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_MD5_RESULT_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_MD5_RESULT_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_PHRASE_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_PHRASE_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_SHA1_RESULT_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_SHA1_RESULT_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_SHA224_RESULT_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_SHA224_RESULT_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_SHA256_RESULT_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_SHA256_RESULT_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_SHA384_RESULT_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_SHA384_RESULT_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "STANDARD_SHA512_RESULT_BYTES",
          "variable_type": "byte"
        },
        {
          "variable_name": "STANDARD_SHA512_RESULT_STRING",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "EMPTY_BYTE_ARRAY",
          "variable_type": "byte"
        },
        {
          "variable_name": "digestUtilsTest",
          "variable_type": "org.apache.commons.codec.digest.DigestUtilsTest"
        }
      ],
      "constructors": [],
      "methods": {
        "data": [
          {
            "call_methods": [
              {
                "signature": "java.util.Collection.stream()",
                "arguments": [],
                "return_type": "java.util.stream.Stream<E>"
              },
              {
                "signature": "org.junit.jupiter.params.provider.Arguments.of(java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_MD5",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "STANDARD_MD5_RESULT_BYTES",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "STANDARD_MD5_RESULT_STRING",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "org.junit.jupiter.params.provider.Arguments"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "Arguments.of(HmacAlgorithms.HMAC_SHA_224, STANDARD_SHA224_RESULT_BYTES, STANDARD_SHA224_RESULT_STRING)",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "// @formatter:off\r\nArguments.of(HmacAlgorithms.HMAC_MD5, STANDARD_MD5_RESULT_BYTES, STANDARD_MD5_RESULT_STRING)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(HmacAlgorithms.HMAC_SHA_1, STANDARD_SHA1_RESULT_BYTES, STANDARD_SHA1_RESULT_STRING)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(HmacAlgorithms.HMAC_SHA_256, STANDARD_SHA256_RESULT_BYTES, STANDARD_SHA256_RESULT_STRING)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(HmacAlgorithms.HMAC_SHA_384, STANDARD_SHA384_RESULT_BYTES, STANDARD_SHA384_RESULT_STRING)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(HmacAlgorithms.HMAC_SHA_512, STANDARD_SHA512_RESULT_BYTES, STANDARD_SHA512_RESULT_STRING)",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "org.apache.commons.lang3.SystemUtils.isJavaVersionAtLeast(org.apache.commons.lang3.JavaVersion)",
                "arguments": [
                  {
                    "variable_name": "JavaVersion.JAVA_1_8",
                    "variable_type": "org.apache.commons.lang3.JavaVersion"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public static Stream<Arguments> data()",
            "parameters": []
          }
        ],
        "setUp": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.setUp()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void setUp()",
            "parameters": []
          }
        ],
        "tearDown": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.tearDown()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void tearDown()",
            "parameters": []
          }
        ],
        "testAlgorithm": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacAlgorithms.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "javax.crypto.Mac.getInstance(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "algorithm.isEmpty()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testAlgorithm(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testGetHmacEmptyKey": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.getInitializedMac(hmacAlgorithm, EMPTY_BYTE_ARRAY)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "EMPTY_BYTE_ARRAY",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testGetHmacEmptyKey(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testGetHmacNullKey": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.getInitializedMac(hmacAlgorithm, null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testGetHmacNullKey(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testHmacFailByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new HmacUtils(hmacAlgorithm, (byte[]) null).hmac(STANDARD_PHRASE_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHmacFailByteArray(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testHmacFailInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new HmacUtils(hmacAlgorithm, (byte[]) null).hmac(new ByteArrayInputStream(STANDARD_PHRASE_BYTES))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHmacFailInputStream(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testHmacFailString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new HmacUtils(hmacAlgorithm, (String) null).hmac(STANDARD_PHRASE_STRING)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHmacFailString(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testHmacHexFailByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new HmacUtils(hmacAlgorithm, (byte[]) null).hmac(STANDARD_PHRASE_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHmacHexFailByteArray(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testHmacHexFailInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new HmacUtils(hmacAlgorithm, (byte[]) null).hmac(new ByteArrayInputStream(STANDARD_PHRASE_BYTES))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHmacHexFailInputStream(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testHmacHexFailString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new HmacUtils(hmacAlgorithm, (String) null).hmac(STANDARD_PHRASE_STRING)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHmacHexFailString(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testInitializedMac": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "standardResultBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.updateHmac(mac, STANDARD_PHRASE_STRING).doFinal()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(java.lang.String, byte[])",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm.getName()",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacAlgorithms.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "javax.crypto.Mac.doFinal()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.updateHmac(javax.crypto.Mac, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "mac",
                    "variable_type": "javax.crypto.Mac"
                  },
                  {
                    "variable_name": "STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testInitializedMac(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testMacByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "standardResultBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new HmacUtils(hmacAlgorithm, STANDARD_KEY_BYTES).hmac(STANDARD_PHRASE_BYTES)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(byte[])",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testMacByteArray(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testMacHexByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(byte[])",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "standardResultString",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new HmacUtils(hmacAlgorithm, STANDARD_KEY_BYTES).hmacHex(STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMacHexByteArray(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testMacHexInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "standardResultString",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new HmacUtils(hmacAlgorithm, STANDARD_KEY_BYTES).hmacHex(new ByteArrayInputStream(STANDARD_PHRASE_BYTES))",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMacHexInputStream(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testMacHexString": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "standardResultString",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new HmacUtils(hmacAlgorithm, STANDARD_KEY_BYTES).hmacHex(STANDARD_PHRASE_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacHex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMacHexString(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testMacInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "new ByteArrayInputStream(STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "standardResultBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new HmacUtils(hmacAlgorithm, STANDARD_KEY_BYTES).hmac(new ByteArrayInputStream(STANDARD_PHRASE_BYTES))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testMacInputStream(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testMacString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmac(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "standardResultBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new HmacUtils(hmacAlgorithm, STANDARD_KEY_BYTES).hmac(STANDARD_PHRASE_STRING)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "HmacUtils.isAvailable(hmacAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.isAvailable(org.apache.commons.codec.digest.HmacAlgorithms)",
                "arguments": [
                  {
                    "variable_name": "hmacAlgorithm",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testMacString(HmacAlgorithms, byte[], String)",
            "parameters": [
              {
                "variable_name": "hmacAlgorithm",
                "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
              },
              {
                "variable_name": "standardResultBytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "standardResultString",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link HmacAlgorithms}.\n "
    },
    "org.apache.commons.codec.digest.HmacUtilsTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testEmptyKey": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.getHmacMd5(new byte[] {})",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacMd5(byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[] {}",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testEmptyKey()",
            "parameters": []
          }
        ],
        "testGetHMac": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_MD5_RESULT_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.getHmacMd5(HmacAlgorithmsTest.STANDARD_KEY_BYTES).doFinal(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacMd5(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacSha1(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacSha512(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "javax.crypto.Mac.doFinal(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacSha384(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacSha256(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testGetHMac()",
            "parameters": []
          }
        ],
        "testHmacMd5Hex": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"The quick brown fox jumps over the lazy dog\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_MD5_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "HmacUtils.hmacMd5Hex(HmacAlgorithmsTest.STANDARD_KEY_STRING, \"The quick brown fox jumps over the lazy dog\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "\"Jefe\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(\"what do ya want for nothing?\".getBytes())",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testHmacMd5Hex()",
            "parameters": []
          }
        ],
        "testHmacSha1Hex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "\"Jefe\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(\"what do ya want for nothing?\".getBytes())",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA1_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha1Hex(HmacAlgorithmsTest.STANDARD_KEY_STRING, HmacAlgorithmsTest.STANDARD_PHRASE_STRING)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHmacSha1Hex()",
            "parameters": []
          }
        ],
        "testHmacSha1UpdateWithByteArray": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacSha1(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "javax.crypto.Mac.doFinal()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "mac.doFinal()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA1_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(mac.doFinal())",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.updateHmac(javax.crypto.Mac, byte[])",
                "arguments": [
                  {
                    "variable_name": "mac",
                    "variable_type": "javax.crypto.Mac"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testHmacSha1UpdateWithByteArray()",
            "parameters": []
          }
        ],
        "testHmacSha1UpdateWithInputStream": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacSha1(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.updateHmac(javax.crypto.Mac, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "mac",
                    "variable_type": "javax.crypto.Mac"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "javax.crypto.Mac.doFinal()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "mac.doFinal()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA1_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(mac.doFinal())",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHmacSha1UpdateWithInputStream()",
            "parameters": []
          }
        ],
        "testHmacSha1UpdateWithString": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacSha1(byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "javax.crypto.Mac.doFinal()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.binary.Hex.encodeHexString(byte[])",
                "arguments": [
                  {
                    "variable_name": "mac.doFinal()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA1_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Hex.encodeHexString(mac.doFinal())",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.updateHmac(javax.crypto.Mac, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "mac",
                    "variable_type": "javax.crypto.Mac"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testHmacSha1UpdateWithString()",
            "parameters": []
          }
        ],
        "testInitializedMac": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_MD5_RESULT_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.updateHmac(md5Mac, HmacAlgorithmsTest.STANDARD_PHRASE_STRING).doFinal()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(java.lang.String, byte[])",
                "arguments": [
                  {
                    "variable_name": "\"HmacMD5\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_MD5",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "javax.crypto.Mac.doFinal()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.updateHmac(javax.crypto.Mac, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "md5Mac",
                    "variable_type": "javax.crypto.Mac"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testInitializedMac()",
            "parameters": []
          }
        ],
        "testInitializedMacNullAlgo": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.getInitializedMac((String) null, HmacAlgorithmsTest.STANDARD_KEY_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(java.lang.String, byte[])",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testInitializedMacNullAlgo()",
            "parameters": []
          }
        ],
        "testInitializedMacNullKey": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.getInitializedMac(HmacAlgorithms.HMAC_MD5, null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(org.apache.commons.codec.digest.HmacAlgorithms, byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithms.HMAC_MD5",
                    "variable_type": "org.apache.commons.codec.digest.HmacAlgorithms"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testInitializedMacNullKey()",
            "parameters": []
          }
        ],
        "testInternalNoSuchAlgorithmException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.getInitializedMac(\"Bogus Bogus\", StringUtils.getBytesUtf8(\"akey\"))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getInitializedMac(java.lang.String, byte[])",
                "arguments": [
                  {
                    "variable_name": "\"Bogus Bogus\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StringUtils.getBytesUtf8(\"akey\")",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"akey\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testInternalNoSuchAlgorithmException()",
            "parameters": []
          }
        ],
        "testMd5HMac": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_MD5_RESULT_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.hmacMd5(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_MD5_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "HmacUtils.hmacMd5Hex(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5Hex(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMd5HMac()",
            "parameters": []
          }
        ],
        "testMd5HMacFail": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.hmacMd5((byte[]) null, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacMd5(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testMd5HMacFail()",
            "parameters": []
          }
        ],
        "testNullKey": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.getHmacMd5(null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.getHmacMd5(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "javax.crypto.Mac"
              }
            ],
            "signature": "public void testNullKey()",
            "parameters": []
          }
        ],
        "testSecretKeySpecAllowsEmptyKeys": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new SecretKeySpec(new byte[] {}, \"HmacMD5\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testSecretKeySpecAllowsEmptyKeys()",
            "parameters": []
          }
        ],
        "testSha1HMac": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA1_RESULT_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha1(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1Hex(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA1_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha1Hex(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha1HMac()",
            "parameters": []
          }
        ],
        "testSha1HMacFail": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.hmacSha1((byte[]) null, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha1(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha1HMacFail()",
            "parameters": []
          }
        ],
        "testSha256HMac": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA256_RESULT_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha256(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA256_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha256Hex(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha256(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha256HMac()",
            "parameters": []
          }
        ],
        "testSha256HMacFail": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.hmacSha256((byte[]) null, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha256(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha256HMacFail()",
            "parameters": []
          }
        ],
        "testSha384HMac": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA384_RESULT_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha384(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha384(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA384_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha384Hex(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha384Hex(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha384HMac()",
            "parameters": []
          }
        ],
        "testSha384HMacFail": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.hmacSha384((byte[]) null, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha384(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha384HMacFail()",
            "parameters": []
          }
        ],
        "testSha512HMac": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha512(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_STRING",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_STRING",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA512_RESULT_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha512(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_SHA512_RESULT_STRING",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "HmacUtils.hmacSha512Hex(HmacAlgorithmsTest.STANDARD_KEY_BYTES, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha512Hex(byte[], java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_KEY_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha512HMac()",
            "parameters": []
          }
        ],
        "testSha512HMacFail": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> HmacUtils.hmacSha512((byte[]) null, HmacAlgorithmsTest.STANDARD_PHRASE_BYTES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.HmacUtils.hmacSha512(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "HmacAlgorithmsTest.STANDARD_PHRASE_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testSha512HMacFail()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link HmacUtils}.\n "
    },
    "org.apache.commons.codec.digest.Md5CryptTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testCtor": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new Md5Crypt()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCtor()",
            "parameters": []
          }
        ],
        "testMd5CryptBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$1$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$1$foo$9mS5ExwgIECGE5YKlD5o91\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(new byte[0], \"$1$foo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"t\\u00e4st\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$1$./$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMd5CryptBytes()",
            "parameters": []
          }
        ],
        "testMd5CryptExplicitCall": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Md5Crypt.md5Crypt(\"secret\".getBytes()).matches(\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMd5CryptExplicitCall()",
            "parameters": []
          }
        ],
        "testMd5CryptExplicitCallWithThreadLocalRandom": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "threadLocalRandom",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Md5Crypt.md5Crypt(\"secret\".getBytes(), threadLocalRandom).matches(\"^\\\\$1\\\\$[a-zA-Z0-9./]{0,8}\\\\$.{1,}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMd5CryptExplicitCallWithThreadLocalRandom()",
            "parameters": []
          }
        ],
        "testMd5CryptLongInput": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$1$1234$MoxekaNNUgfPRVqoeYjCD/\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(\"12345678901234567890\", \"$1$1234\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"12345678901234567890\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$1$1234\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMd5CryptLongInput()",
            "parameters": []
          }
        ],
        "testMd5CryptNullData": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Md5Crypt.md5Crypt((byte[]) null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMd5CryptNullData()",
            "parameters": []
          }
        ],
        "testMd5CryptStrings": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$1$foo$9mS5ExwgIECGE5YKlD5o91\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(\"\", \"$1$foo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$1$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMd5CryptStrings()",
            "parameters": []
          }
        ],
        "testMd5CryptWithEmptySalt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Md5Crypt.md5Crypt(\"secret\".getBytes(), \"\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testMd5CryptWithEmptySalt()",
            "parameters": []
          }
        ],
        "testZeroOutInput": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[buffer.length]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Md5Crypt.md5Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 'A'",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testZeroOutInput()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest": {
      "fields": [
        {
          "variable_name": "digestUtilsTest",
          "variable_type": "org.apache.commons.codec.digest.DigestUtilsTest"
        }
      ],
      "constructors": [],
      "methods": {
        "checkValues": [
          {
            "call_methods": [
              {
                "signature": "java.lang.reflect.Modifier.isFinal(int)",
                "arguments": [
                  {
                    "variable_name": "modifiers",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Not found in MessageDigestAlgorithms.values(): \" + f.getName()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.reflect.Field.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithms.values()",
                "arguments": [],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"One or more entries are missing from the MessageDigestAlgorithms.values() array\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.lang.reflect.Modifier.isPublic(int)",
                "arguments": [
                  {
                    "variable_name": "modifiers",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.reflect.Field.getModifiers()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.lang.reflect.Field.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.Class.getDeclaredFields()",
                "arguments": [],
                "return_type": "java.lang.reflect.Field[]"
              },
              {
                "signature": "java.lang.reflect.Modifier.isStatic(int)",
                "arguments": [
                  {
                    "variable_name": "modifiers",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.String.contains(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"cobertura\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.contains(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) f.get(null)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public static void checkValues()",
            "parameters": []
          }
        ],
        "contains": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithms.values()",
                "arguments": [],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "key",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private static boolean contains(String)",
            "parameters": [
              {
                "variable_name": "key",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "data": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithms.values()",
                "arguments": [],
                "return_type": "java.lang.String[]"
              }
            ],
            "signature": "public static String[] data()",
            "parameters": []
          }
        ],
        "digestTestData": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, byte[])",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "getTestData()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.getTestData()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "private byte[] digestTestData(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getTestData": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.getTestData()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "private byte[] getTestData()",
            "parameters": []
          }
        ],
        "getTestFile": [
          {
            "call_methods": [
              {
                "signature": "java.nio.file.Path.toFile()",
                "arguments": [],
                "return_type": "java.io.File"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.getTestPath()",
                "arguments": [],
                "return_type": "java.nio.file.Path"
              }
            ],
            "signature": "private File getTestFile()",
            "parameters": []
          }
        ],
        "getTestPath": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.getTestPath()",
                "arguments": [],
                "return_type": "java.nio.file.Path"
              }
            ],
            "signature": "private Path getTestPath()",
            "parameters": []
          }
        ],
        "getTestRandomAccessFile": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.getTestRandomAccessFile()",
                "arguments": [],
                "return_type": "java.io.RandomAccessFile"
              }
            ],
            "signature": "private RandomAccessFile getTestRandomAccessFile()",
            "parameters": []
          }
        ],
        "setUp": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.setUp()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void setUp()",
            "parameters": []
          }
        ],
        "tearDown": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtilsTest.tearDown()",
                "arguments": [],
                "return_type": "void"
              }
            ],
            "signature": "public void tearDown()",
            "parameters": []
          }
        ],
        "testAlgorithm": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "algorithm.isEmpty()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "java.security.MessageDigest.getInstance(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "algorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              }
            ],
            "signature": "public void testAlgorithm(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDigestByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "digestTestData(messageDigestAlgorithm)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), getTestData())",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, byte[])",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "getTestData()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.digestTestData(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.getTestData()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testDigestByteArray(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDigestByteBuffer": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "digestTestData(messageDigestAlgorithm)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), ByteBuffer.wrap(getTestData()))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.nio.ByteBuffer)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "ByteBuffer.wrap(getTestData())",
                    "variable_type": "java.nio.ByteBuffer"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.wrap(byte[])",
                "arguments": [
                  {
                    "variable_name": "getTestData()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.digestTestData(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.getTestData()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testDigestByteBuffer(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDigestFile": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.File)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "getTestFile()",
                    "variable_type": "java.io.File"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "digestTestData(messageDigestAlgorithm)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), getTestFile())",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.getTestFile()",
                "arguments": [],
                "return_type": "java.io.File"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.digestTestData(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testDigestFile(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDigestInputStream": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "digestTestData(messageDigestAlgorithm)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), new ByteArrayInputStream(getTestData()))",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "new ByteArrayInputStream(getTestData())",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.digestTestData(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.getTestData()",
                "arguments": [],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testDigestInputStream(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDigestPath": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "digestTestData(messageDigestAlgorithm)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), getTestPath(), options)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.nio.file.Path, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "getTestPath()",
                    "variable_type": "java.nio.file.Path"
                  },
                  {
                    "variable_name": "options",
                    "variable_type": "java.nio.file.OpenOption..."
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.digestTestData(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.getTestPath()",
                "arguments": [],
                "return_type": "java.nio.file.Path"
              }
            ],
            "signature": "private void testDigestPath(String, OpenOption...)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "options",
                "variable_type": "java.nio.file.OpenOption"
              }
            ]
          }
        ],
        "testDigestPathOpenOptionsEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.testDigestPath(java.lang.String, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDigestPathOpenOptionsEmpty(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDigestPathStandardOpenOptionRead": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.testDigestPath(java.lang.String, java.nio.file.OpenOption...)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "StandardOpenOption.READ",
                    "variable_type": "java.nio.file.OpenOption..."
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDigestPathStandardOpenOptionRead(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testGetMessageDigest": [
          {
            "call_methods": [
              {
                "signature": "java.security.MessageDigest.getAlgorithm()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "messageDigest.getAlgorithm()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetMessageDigest(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testNonBlockingDigestRandomAccessFile": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.digest(java.security.MessageDigest, java.io.RandomAccessFile)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.getDigest(messageDigestAlgorithm)",
                    "variable_type": "java.security.MessageDigest"
                  },
                  {
                    "variable_name": "randomAccessFile",
                    "variable_type": "java.io.RandomAccessFile"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.getDigest(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.security.MessageDigest"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), randomAccessFile)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.DigestUtils.isAvailable(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.getTestRandomAccessFile()",
                "arguments": [],
                "return_type": "java.io.RandomAccessFile"
              },
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DigestUtils.isAvailable(messageDigestAlgorithm)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest.digestTestData(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "messageDigestAlgorithm",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.io.RandomAccessFile.seek(long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNonBlockingDigestRandomAccessFile(String)",
            "parameters": [
              {
                "variable_name": "messageDigestAlgorithm",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link MessageDigestAlgorithms}.\n "
    },
    "org.apache.commons.codec.digest.MurmurHash2Test": {
      "fields": [
        {
          "variable_name": "input",
          "variable_type": "byte"
        },
        {
          "variable_name": "results32_standard",
          "variable_type": "int"
        },
        {
          "variable_name": "results32_seed",
          "variable_type": "int"
        },
        {
          "variable_name": "results64_standard",
          "variable_type": "long"
        },
        {
          "variable_name": "results64_seed",
          "variable_type": "long"
        },
        {
          "variable_name": "text",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "testHash32ByteArrayInt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"Unexpected hash32 result for example %d: 0x%08x instead of 0x%08x\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "results32_standard[i]",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash32(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "input[i]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "input[i].length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "String.format(\"Unexpected hash32 result for example %d: 0x%08x instead of 0x%08x\", i, hash, results32_standard[i])",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public void testHash32ByteArrayInt()",
            "parameters": []
          }
        ],
        "testHash32ByteArrayIntInt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"Unexpected hash32 result for example %d: 0x%08x instead of 0x%08x\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "results32_seed[i]",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash32(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "input[i]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "input[i].length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0x71b4954d",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "String.format(\"Unexpected hash32 result for example %d: 0x%08x instead of 0x%08x\", i, hash, results32_seed[i])",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public void testHash32ByteArrayIntInt()",
            "parameters": []
          }
        ],
        "testHash32String": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0xb3bf597e",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash32(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testHash32String()",
            "parameters": []
          }
        ],
        "testHash32StringIntInt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0x4d666d90",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash32(java.lang.String, int, int)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "text.length() - 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testHash32StringIntInt()",
            "parameters": []
          }
        ],
        "testHash64ByteArrayInt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"Unexpected hash64 result for example %d: 0x%016x instead of 0x%016x\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "results64_standard[i]",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "String.format(\"Unexpected hash64 result for example %d: 0x%016x instead of 0x%016x\", i, hash, results64_standard[i])",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash64(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "input[i]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "input[i].length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testHash64ByteArrayInt()",
            "parameters": []
          }
        ],
        "testHash64ByteArrayIntInt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"Unexpected hash64 result for example %d: 0x%016x instead of 0x%016x\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "results64_seed[i]",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash64(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "input[i]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "input[i].length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0x344d1f5c",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "String.format(\"Unexpected hash64 result for example %d: 0x%016x instead of 0x%016x\", i, hash, results64_seed[i])",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public void testHash64ByteArrayIntInt()",
            "parameters": []
          }
        ],
        "testHash64String": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash64(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "0x0920e0c1b7eeb261L",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHash64String()",
            "parameters": []
          }
        ],
        "testHash64StringIntInt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash2.hash64(java.lang.String, int, int)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "text.length() - 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "0xa8b33145194985a2L",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testHash64StringIntInt()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.MurmurHash3Test": {
      "fields": [
        {
          "variable_name": "TEST_HASH64",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "RANDOM_INTS",
          "variable_type": "int"
        },
        {
          "variable_name": "RANDOM_BYTES",
          "variable_type": "byte"
        }
      ],
      "constructors": [],
      "methods": {
        "assertIncrementalHash32": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "total",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "h1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "h2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Hashes differ\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "block",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.end()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.start(int)",
                "arguments": [
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static void assertIncrementalHash32(byte[], int, int...)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              },
              {
                "variable_name": "blocks",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Assert {@link IncrementalHash32} returns the same values as\n     * {@link MurmurHash3#hash32(byte[], int, int, int)}.\n     *\n     * <p>The bytes are added to the incremental hash in the given blocks.</p>\n     *\n     * @param bytes the bytes\n     * @param seed the seed\n     * @param blocks the blocks\n     "
          }
        ],
        "assertIncrementalHash32x86": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "total",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "h1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "h2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Hashes differ\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "block",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.end()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.start(int)",
                "arguments": [
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static void assertIncrementalHash32x86(byte[], int, int...)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "seed",
                "variable_type": "int"
              },
              {
                "variable_name": "blocks",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Assert {@link IncrementalHash32x86} returns the same values as\n     * {@link MurmurHash3#hash32x86(byte[], int, int, int)}.\n     *\n     * <p>The bytes are added to the incremental hash in the given blocks.</p>\n     *\n     * @param bytes the bytes\n     * @param seed the seed\n     * @param blocks the blocks\n     "
          }
        ],
        "createLongTestData": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextLong()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              }
            ],
            "signature": "private static long[] createLongTestData()",
            "parameters": [],
            "javadoc": "\n     * Creates a set of long values to test the hash utility methods.\n     *\n     * @return the data\n     "
          }
        ],
        "createRandomBlocks": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextInt(int, int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "9",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.Arrays.copyOf(int[], int)",
                "arguments": [
                  {
                    "variable_name": "blocks",
                    "variable_type": "int[]"
                  },
                  {
                    "variable_name": "count",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "private static int[] createRandomBlocks(int)",
            "parameters": [
              {
                "variable_name": "maxLength",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Creates the random blocks of data to process up to max length.\n     *\n     * @param maxLength the max length\n     * @return the blocks\n     "
          }
        ],
        "negativeBytes": [
          {
            "call_methods": [],
            "signature": "private static boolean negativeBytes(byte[], int, int)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "start",
                "variable_type": "int"
              },
              {
                "variable_name": "length",
                "variable_type": "int"
              }
            ],
            "javadoc": "\n     * Check if the bytes are negative in the given range.\n     *\n     * @param bytes the bytes\n     * @param start the start\n     * @param length the length\n     * @return true, if negative bytes exist\n     "
          }
        ],
        "testHash128": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(long[], long[])",
                "arguments": [
                  {
                    "variable_name": "new long[] { -5614308156300707300L, -4165733009867452172L }",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "MurmurHash3.hash128(RANDOM_BYTES)",
                    "variable_type": "long[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(byte[])",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testHash128()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash128(byte[])} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash128String": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.lang.Character.toChars(int, char[], int)",
                "arguments": [
                  {
                    "variable_name": "codePoint",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "chars",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "pos",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextInt(int, int)",
                "arguments": [
                  {
                    "variable_name": "minSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "maxSize",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "codePoints",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.copyValueOf(char[], int, int)",
                "arguments": [
                  {
                    "variable_name": "chars",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "pos",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(long[], long[])",
                "arguments": [
                  {
                    "variable_name": "h1",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "h2",
                    "variable_type": "long[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testHash128String()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash128(String)} algorithm. This only tests it can return\n     * the same value as {@link MurmurHash3#hash128(byte[], int, int, int)} if the string\n     * is converted to bytes using the method {@link String#getBytes()}.\n     *\n     * <p>The test uses random strings created with random unicode code points.</p>\n     "
          }
        ],
        "testHash128WithOffsetLengthAndNegativeSeed": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(long[], long[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed)",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "\"Length: \" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              }
            ],
            "signature": "public void testHash128WithOffsetLengthAndNegativeSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash128(byte[], int, int, int)} algorithm.\n     *\n     * <p>Explicit test for a negative seed. The original implementation has a sign extension error\n     * for negative seeds. This test is here to maintain behavioral compatibility of the\n     * broken deprecated method.\n     "
          }
        ],
        "testHash128WithOffsetLengthAndSeed": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(long[], long[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed)",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "\"Length: \" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              }
            ],
            "signature": "public void testHash128WithOffsetLengthAndSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash128(byte[], int, int, int)} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash128x64": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[])",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(long[], long[])",
                "arguments": [
                  {
                    "variable_name": "new long[] { 1972113670104592209L, 5171809317673151911L }",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "MurmurHash3.hash128x64(RANDOM_BYTES)",
                    "variable_type": "long[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testHash128x64()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash128x64(byte[])} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash128x64WithOffsetLengthAndNegativeSeed": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(long[], long[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed)",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "\"Length: \" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHash128x64WithOffsetLengthAndNegativeSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash128x64(byte[], int, int, int)} algorithm.\n     *\n     * <p>Explicit test for a negative seed. The original implementation has a sign extension error\n     * for negative seeds.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash128x64WithOffsetLengthAndSeed": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128x64(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(long[], long[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed)",
                    "variable_type": "long[]"
                  },
                  {
                    "variable_name": "\"Length: \" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHash128x64WithOffsetLengthAndSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash128x64(byte[], int, int, int)} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash32": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1905657630",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(RANDOM_BYTES)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[])",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(bytes)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.negativeBytes(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i / 4 * 4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i % 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHash32()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash32(byte[])} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash32Long": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(long)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.putLong(int, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "MurmurHash3.hash32x86(bytes, offset, length, seed)",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(i)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.createLongTestData()",
                "arguments": [],
                "return_type": "long[]"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testHash32Long()",
            "parameters": [],
            "javadoc": "\n     * Test the convenience method {@link MurmurHash3#hash32(long)} works as documented.\n     "
          }
        ],
        "testHash32LongLong": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.putLong(int, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "MurmurHash3.hash32x86(bytes, offset, length, seed)",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(i, j)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.createLongTestData()",
                "arguments": [],
                "return_type": "long[]"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(long, long)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "j",
                    "variable_type": "long"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testHash32LongLong()",
            "parameters": [],
            "javadoc": "\n     * Test the convenience method {@link MurmurHash3#hash32(long, long)} works as documented.\n     "
          }
        ],
        "testHash32LongLongSeed": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.putLong(int, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "MurmurHash3.hash32x86(bytes, offset, length, seed)",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(i, j, seed)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.createLongTestData()",
                "arguments": [],
                "return_type": "long[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(long, long, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "j",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testHash32LongLongSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the convenience method {@link MurmurHash3#hash32(long, long, int)} works as documented.\n     "
          }
        ],
        "testHash32LongSeed": [
          {
            "call_methods": [
              {
                "signature": "java.nio.ByteBuffer.putLong(int, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "MurmurHash3.hash32x86(bytes, offset, length, seed)",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(i, seed)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.createLongTestData()",
                "arguments": [],
                "return_type": "long[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(long, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testHash32LongSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the convenience method {@link MurmurHash3#hash32(long, int)} works as documented.\n     "
          }
        ],
        "testHash32String": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.lang.Character.toChars(int, char[], int)",
                "arguments": [
                  {
                    "variable_name": "codePoint",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "chars",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "pos",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextInt(int, int)",
                "arguments": [
                  {
                    "variable_name": "minSize",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "maxSize",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "codePoints",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.String.copyValueOf(char[], int, int)",
                "arguments": [
                  {
                    "variable_name": "chars",
                    "variable_type": "char[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "pos",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "h1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "h2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testHash32String()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash32(String)} algorithm. This only tests it can return the same value as {@link MurmurHash3#hash32(byte[], int, int, int)}\n     * if the string is converted to bytes using the method {@link String#getBytes()}.\n     *\n     * <p>\n     * The test uses random strings created with random unicode code points.\n     * </p>\n     "
          }
        ],
        "testHash32WithLength": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1905657630",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(RANDOM_BYTES, i)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "RANDOM_BYTES.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.negativeBytes(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i / 4 * 4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i % 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHash32WithLength()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash32(byte[], int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash32WithLengthAndSeed": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1693958011",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length, seed)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(RANDOM_BYTES, i, seed)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "RANDOM_BYTES.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.negativeBytes(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i / 4 * 4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i % 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHash32WithLengthAndSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash32(byte[], int, int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash32WithOffsetLengthAndSeed": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(RANDOM_BYTES, offset, i, seed)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(RANDOM_BYTES, offset, i, seed)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.negativeBytes(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset + i / 4 * 4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i % 4",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testHash32WithOffsetLengthAndSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash32(byte[], int, int, int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash32WithTrailingNegativeSignedBytesIsInvalid": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "new byte[] { -1 }",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-43192051",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32(new byte[] { -1 }, 0, 1, 0)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHash32WithTrailingNegativeSignedBytesIsInvalid()",
            "parameters": [],
            "javadoc": "\n     * Test to demonstrate the errors in {@link MurmurHash3#hash32(byte[], int, int, int)} if the final 1, 2, or 3 bytes are negative.\n     "
          }
        ],
        "testHash32x86": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[])",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1546271276",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32x86(RANDOM_BYTES)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testHash32x86()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash32x86(byte[])} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash32x86WithOffsetLengthAndSeed": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "answers[i]",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32x86(RANDOM_BYTES, offset, i, seed)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testHash32x86WithOffsetLengthAndSeed()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash32x86(byte[], int, int, int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>\n     "
          }
        ],
        "testHash32x86WithTrailingNegativeSignedBytes": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "-43192051",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "MurmurHash3.hash32x86(new byte[] { -1 }, 0, 1, 0)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash32x86(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "new byte[] { -1 }",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testHash32x86WithTrailingNegativeSignedBytes()",
            "parameters": [],
            "javadoc": "\n     * Test to demonstrate {@link MurmurHash3#hash32x86(byte[], int, int, int)} is OK if the final 1, 2, or 3 bytes are negative.\n     "
          }
        ],
        "testHash64": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "5785358552565094607L",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "TEST_HASH64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(byte[])",
                "arguments": [
                  {
                    "variable_name": "origin",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testHash64()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash64(byte[])} algorithm. Unknown origin of test data. It may be from the Apache Hive project.\n     "
          }
        ],
        "testHash64InNotEqualToHash128": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(long, long, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "hash[0]",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "h1",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "\"Did not expect hash64 to match upper bits of hash128\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "RANDOM_BYTES",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash128(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "public void testHash64InNotEqualToHash128()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash64(byte[])} method is Murmur3-like but does not match the bits returned from {@link MurmurHash3#hash128(byte[])}.\n     *\n     * <p>\n     * The hash64 method is not in the MurmurHash3 reference code and has been inherited from the port from Apache Hive.\n     * <p>\n     "
          }
        ],
        "testHash64WithOffsetAndLength": [
          {
            "call_methods": [
              {
                "signature": "java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)",
                "arguments": [
                  {
                    "variable_name": "origin",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "originOffset",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "150",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "origin.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "originOffset",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 123",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "5785358552565094607L",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "hash",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "originOffset",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "150",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "origin.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.binary.StringUtils.getBytesUtf8(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "TEST_HASH64",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testHash64WithOffsetAndLength()",
            "parameters": [],
            "javadoc": "\n     * Test the {@link MurmurHash3#hash64(byte[], int, int)} algorithm. Unknown origin of test data. It may be from the Apache Hive project.\n     "
          }
        ],
        "testHash64WithPrimitives": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(byte[], int, int, int)",
                "arguments": [
                  {
                    "variable_name": "shortBytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "offset",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "shortBytes.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.nextLong()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "java.nio.ByteBuffer.putInt(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "in",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(long)",
                "arguments": [
                  {
                    "variable_name": "ln",
                    "variable_type": "long"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.nio.ByteBuffer.putLong(int, long)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "ln",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(int)",
                "arguments": [
                  {
                    "variable_name": "in",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.nio.ByteBuffer.putShort(int, short)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "sn",
                    "variable_type": "short"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.hash64(short)",
                "arguments": [
                  {
                    "variable_name": "sn",
                    "variable_type": "short"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "MurmurHash3.hash64(shortBytes, offset, shortBytes.length, seed)",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "MurmurHash3.hash64(sn)",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.nio.ByteBuffer.array()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.nio.ByteBuffer.allocate(int)",
                "arguments": [
                  {
                    "variable_name": "Short.BYTES",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.nio.ByteBuffer"
              }
            ],
            "signature": "public void testHash64WithPrimitives()",
            "parameters": [],
            "javadoc": "\n     * Test the hash64() helper methods that work directly on primitives work as documented. This test the methods return the same value as\n     * {@link MurmurHash3#hash64(byte[])} with the byte[] created from the same primitive data via a {@link ByteBuffer}.\n     "
          }
        ],
        "testIncrementalHash32": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.assertIncrementalHash32x86(byte[], int, int...)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "createRandomBlocks(bytes.length)",
                    "variable_type": "int..."
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.createRandomBlocks(int)",
                "arguments": [
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.assertIncrementalHash32(byte[], int, int...)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int..."
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int..."
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIncrementalHash32()",
            "parameters": [],
            "javadoc": "\n     * Test {@link IncrementalHash32} returns the same values as {@link MurmurHash3#hash32(byte[], int, int, int)}.\n     "
          }
        ],
        "testIncrementalHash32x86": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.assertIncrementalHash32x86(byte[], int, int...)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "seed",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int..."
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int..."
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3Test.createRandomBlocks(int)",
                "arguments": [
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int[]"
              }
            ],
            "signature": "public void testIncrementalHash32x86()",
            "parameters": [],
            "javadoc": "\n     * Test {@link IncrementalHash32x86} returns the same values as {@link MurmurHash3#hash32x86(byte[], int, int, int)}.\n     "
          }
        ],
        "testIncrementalHashWithUnprocessedBytesAndHugeLengthArray": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bytes != null",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Cannot allocate array of length \" + hugeLength",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "unprocessedSize + hugeLength < 4",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"This should overflow to negative\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.add(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "unprocessedSize",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.MurmurHash3.IncrementalHash32x86.start(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIncrementalHashWithUnprocessedBytesAndHugeLengthArray()",
            "parameters": [],
            "javadoc": "\n     * This test hits an edge case where a very large number of bytes is added to the incremental hash. The data is constructed so that an integer counter of\n     * unprocessed bytes will overflow. If this is not handled correctly then the code throws an exception when it copies more data into the unprocessed bytes\n     * array.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Test for {@link MurmurHash3}.\n "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32CTest": {
      "fields": [
        {
          "variable_name": "crc",
          "variable_type": "org.apache.commons.codec.digest.PureJavaCrc32C"
        },
        {
          "variable_name": "data",
          "variable_type": "byte"
        }
      ],
      "constructors": [],
      "methods": {
        "check": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32C.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "data.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32C.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32C.getValue()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "Integer.toHexString(expected)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Integer.toHexString(actual)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Integer.toHexString(int)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private void check(int)",
            "parameters": [
              {
                "variable_name": "expected",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testDecreasing": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32CTest.check(int)",
                "arguments": [
                  {
                    "variable_name": "0x113fdb5c",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecreasing()",
            "parameters": []
          }
        ],
        "testIncreasing": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32CTest.check(int)",
                "arguments": [
                  {
                    "variable_name": "0x46dd794e",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIncreasing()",
            "parameters": []
          }
        ],
        "testOnes": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 0xFF",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32CTest.check(int)",
                "arguments": [
                  {
                    "variable_name": "0x62a8ab43",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testOnes()",
            "parameters": []
          }
        ],
        "testZeros": [
          {
            "call_methods": [
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 0",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32CTest.check(int)",
                "arguments": [
                  {
                    "variable_name": "0x8a9136aa",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testZeros()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link PureJavaCrc32C}. Test data was derived from https://tools.ietf.org/html/rfc3720#appendix-B.4\n "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32Test": {
      "fields": [
        {
          "variable_name": "theirs",
          "variable_type": "java.util.zip.CRC32"
        },
        {
          "variable_name": "ours",
          "variable_type": "org.apache.commons.codec.digest.PureJavaCrc32"
        }
      ],
      "constructors": [],
      "methods": {
        "checkOnBytes": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Long.toHexString(long)",
                "arguments": [
                  {
                    "variable_name": "theirs.getValue()",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.zip.CRC32.getValue()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.util.zip.CRC32.update(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"theirs:\\t\" + Long.toHexString(theirs.getValue()) + \"\\nours:\\t\" + Long.toHexString(ours.getValue())",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.zip.CRC32.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32.update(int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.checkSame()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.util.zip.CRC32.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32.getValue()",
                "arguments": [],
                "return_type": "long"
              }
            ],
            "signature": "private void checkOnBytes(byte[], boolean)",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "print",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "checkSame": [
          {
            "call_methods": [
              {
                "signature": "java.util.zip.CRC32.getValue()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(long, long)",
                "arguments": [
                  {
                    "variable_name": "theirs.getValue()",
                    "variable_type": "long"
                  },
                  {
                    "variable_name": "ours.getValue()",
                    "variable_type": "long"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32.getValue()",
                "arguments": [],
                "return_type": "long"
              }
            ],
            "signature": "private void checkSame()",
            "parameters": []
          }
        ],
        "testCorrectness": [
          {
            "call_methods": [
              {
                "signature": "java.util.zip.CRC32.update(int)",
                "arguments": [
                  {
                    "variable_name": "104",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32.update(int)",
                "arguments": [
                  {
                    "variable_name": "104",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.checkOnBytes(byte[], boolean)",
                "arguments": [
                  {
                    "variable_name": "new byte[] { 40, 60, 97, -70 }",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.checkSame()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "randomBytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Random.nextInt(int)",
                "arguments": [
                  {
                    "variable_name": "2048",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testCorrectness()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Unit test to verify that the pure-Java CRC32 algorithm gives the same results as the built-in implementation.\n *\n * Copied from Hadoop 2.6.3 (Renamed TestPureJavaCrc32 to PureJavaCrc32Test).\n "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest": {
      "fields": [
        {
          "variable_name": "MAX_LEN",
          "variable_type": "int"
        },
        {
          "variable_name": "BYTES_PER_SIZE",
          "variable_type": "int"
        },
        {
          "variable_name": "zip",
          "variable_type": "java.lang.Class<? extends java.util.zip.Checksum>"
        },
        {
          "variable_name": "CRCS",
          "variable_type": "java.util.List<java.lang.Class<? extends java.util.zip.Checksum>>"
        }
      ],
      "constructors": [],
      "methods": {
        "doBench": [
          {
            "call_methods": [
              {
                "signature": "java.lang.reflect.Constructor.newInstance(java.lang.Object...)",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "java.util.zip.Checksum.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "size",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Thread.join()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Thread.start()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Class.getConstructor(java.lang.Class<?>...)",
                "arguments": [],
                "return_type": "java.lang.reflect.Constructor<T>"
              },
              {
                "signature": "java.util.zip.Checksum.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Class.getSimpleName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.System.nanoTime()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "java.util.zip.Checksum.getValue()",
                "arguments": [],
                "return_type": "long"
              }
            ],
            "signature": "private static BenchResult doBench(Class<? extends Checksum>, int, byte[], int)",
            "parameters": [
              {
                "variable_name": "clazz",
                "variable_type": "java.lang.Class<? extends java.util.zip.Checksum>"
              },
              {
                "variable_name": "numThreads",
                "variable_type": "int"
              },
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "size",
                "variable_type": "int"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.printCell(java.lang.String, int, java.io.PrintStream)",
                "arguments": [
                  {
                    "variable_name": "numBytesStr",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "out",
                    "variable_type": "java.io.PrintStream"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.System.gc()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"The first class is \" + c.getName() + \" but not \" + zip.getName()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "java.util.List.add(E)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.io.PrintStream.printf(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"\\n\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.io.PrintStream"
              },
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"%9.1f\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "result.mbps",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.List.size()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "java.io.PrintStream.print(char)",
                "arguments": [
                  {
                    "variable_name": "'|'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Class.getSimpleName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.valueOf(int)",
                "arguments": [
                  {
                    "variable_name": "size",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.List.get(int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "E"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.doBench(java.lang.Class<? extends java.util.zip.Checksum>, int, byte[], int)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "java.lang.Class<? extends java.util.zip.Checksum>"
                  },
                  {
                    "variable_name": "numThreads",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "size",
                    "variable_type": "int"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.BenchResult"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static void doBench(List<Class<? extends Checksum>>, byte[], int, PrintStream)",
            "parameters": [
              {
                "variable_name": "crcs",
                "variable_type": "java.util.List<java.lang.Class<? extends java.util.zip.Checksum>>"
              },
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              },
              {
                "variable_name": "size",
                "variable_type": "int"
              },
              {
                "variable_name": "out",
                "variable_type": "java.io.PrintStream"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.doBench(java.util.List<java.lang.Class<? extends java.util.zip.Checksum>>, byte[], int, java.io.PrintStream)",
                "arguments": [
                  {
                    "variable_name": "crcs",
                    "variable_type": "java.util.List<java.lang.Class<? extends java.util.zip.Checksum>>"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "size",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "out",
                    "variable_type": "java.io.PrintStream"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Random.nextBytes(byte[])",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.PrintStream.printf(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"\\nPerformance Table (The unit is MB/sec; #T = #Theads)\\n\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.io.PrintStream"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.doBench(java.lang.Class<? extends java.util.zip.Checksum>, int, byte[], int)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "java.lang.Class<? extends java.util.zip.Checksum>"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.BenchResult"
              }
            ],
            "signature": "private static void doBench(List<Class<? extends Checksum>>, PrintStream)",
            "parameters": [
              {
                "variable_name": "crcs",
                "variable_type": "java.util.List<java.lang.Class<? extends java.util.zip.Checksum>>"
              },
              {
                "variable_name": "out",
                "variable_type": "java.io.PrintStream"
              }
            ]
          }
        ],
        "main": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.printSystemProperties(java.io.PrintStream)",
                "arguments": [
                  {
                    "variable_name": "System.out",
                    "variable_type": "java.io.PrintStream"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.doBench(java.util.List<java.lang.Class<? extends java.util.zip.Checksum>>, java.io.PrintStream)",
                "arguments": [
                  {
                    "variable_name": "CRCS",
                    "variable_type": "java.util.List<java.lang.Class<? extends java.util.zip.Checksum>>"
                  },
                  {
                    "variable_name": "System.out",
                    "variable_type": "java.io.PrintStream"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static void main(String[])",
            "parameters": [
              {
                "variable_name": "args",
                "variable_type": "java.lang.String[]"
              }
            ]
          }
        ],
        "printCell": [
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.printf(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\" %\" + w + \"s |\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.io.PrintStream"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private static void printCell(String, int, PrintStream)",
            "parameters": [
              {
                "variable_name": "s",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "width",
                "variable_type": "int"
              },
              {
                "variable_name": "out",
                "variable_type": "java.io.PrintStream"
              }
            ]
          }
        ],
        "printSystemProperties": [
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "n + \" = \" + p.getProperty(n)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Properties.getProperty(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "n",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.System.getProperties()",
                "arguments": [],
                "return_type": "java.util.Properties"
              }
            ],
            "signature": "private static void printSystemProperties(PrintStream)",
            "parameters": [
              {
                "variable_name": "out",
                "variable_type": "java.io.PrintStream"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Performance tests to compare performance of the Pure Java implementation to the built-in java.util.zip implementation. This can be run from the command\n     * line with:\n     *\n     * java -cp path/to/test/classes:path/to/common/classes \\ 'org.apache.hadoop.util.TestPureJavaCrc32$PerformanceTest'\n     *\n     * The output is in JIRA table format.\n     "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32Test.PerformanceTest.BenchResult": {
      "fields": [
        {
          "variable_name": "value",
          "variable_type": "long"
        },
        {
          "variable_name": "mbps",
          "variable_type": "double"
        }
      ],
      "constructors": [
        {
          "body": " BenchResult(final long value, final double mbps)\n{\r\n    this.value = value;\r\n    this.mbps = mbps;\r\n}",
          "signature": "BenchResult(long, double)",
          "parameters": [
            {
              "variable_name": "value",
              "variable_type": "long"
            },
            {
              "variable_name": "mbps",
              "variable_type": "double"
            }
          ]
        }
      ],
      "methods": {},
      "is_interface": false
    },
    "org.apache.commons.codec.digest.PureJavaCrc32Test.Table": {
      "fields": [
        {
          "variable_name": "tables",
          "variable_type": "int"
        }
      ],
      "constructors": [
        {
          "body": "private Table(final int nBits, final int nTables, final long polynomial)\n{\r\n    tables = new int[nTables][];\r\n    final int size = 1 << nBits;\r\n    for (int i = 0; i < tables.length; i++) {\r\n        tables[i] = new int[size];\r\n    }\r\n    // compute the first table\r\n    final int[] first = tables[0];\r\n    for (int i = 0; i < first.length; i++) {\r\n        int crc = i;\r\n        for (int j = 0; j < nBits; j++) {\r\n            if ((crc & 1) == 1) {\r\n                crc >>>= 1;\r\n                crc ^= polynomial;\r\n            } else {\r\n                crc >>>= 1;\r\n            }\r\n        }\r\n        first[i] = crc;\r\n    }\r\n    // compute the remaining tables\r\n    final int mask = first.length - 1;\r\n    for (int j = 1; j < tables.length; j++) {\r\n        final int[] previous = tables[j - 1];\r\n        final int[] current = tables[j];\r\n        for (int i = 0; i < current.length; i++) {\r\n            current[i] = previous[i] >>> nBits ^ first[previous[i] & mask];\r\n        }\r\n    }\r\n}",
          "signature": "Table(int, int, long)",
          "parameters": [
            {
              "variable_name": "nBits",
              "variable_type": "int"
            },
            {
              "variable_name": "nTables",
              "variable_type": "int"
            },
            {
              "variable_name": "polynomial",
              "variable_type": "long"
            }
          ]
        }
      ],
      "methods": {
        "main": [
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Usage: \" + Table.class.getName() + \" <polynomial>\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.Table.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Long.parseLong(java.lang.String, int)",
                "arguments": [
                  {
                    "variable_name": "args[0]",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "16",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.System.exit(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static void main(String[])",
            "parameters": [
              {
                "variable_name": "args",
                "variable_type": "java.lang.String[]"
              }
            ],
            "javadoc": " Generate CRC-32 lookup tables "
          }
        ],
        "toString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"T%d_\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "Integer.numberOfTrailingZeros(tables[0].length)",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Integer.numberOfTrailingZeros(int)",
                "arguments": [
                  {
                    "variable_name": "tables[0].length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "String.format(startFormat, j, j)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.length()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.digest.PureJavaCrc32Test.Table.toStrings(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "tableFormat",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.lang.AbstractStringBuilder.setCharAt(int, char)",
                "arguments": [
                  {
                    "variable_name": "b.length() - 2",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "'\\n'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public String toString()",
            "parameters": []
          }
        ],
        "toStrings": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"    /* \" + nameFormat + \" */\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "j",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "String.format(\"    /* \" + nameFormat + \" */\", j)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": " String[] toStrings(String)",
            "parameters": [
              {
                "variable_name": "nameFormat",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n     * Generate a table to perform checksums based on the same CRC-32 polynomial that java.util.zip.CRC32 uses.\n     "
    },
    "org.apache.commons.codec.digest.Sha256CryptTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testSha256CryptBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$5$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(new byte[0], \"$5$foo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"t\\u00e4st\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$5$./$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha256CryptBytes()",
            "parameters": []
          }
        ],
        "testSha256CryptExplicitCall": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\\\\$5\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Sha2Crypt.sha256Crypt(\"secret\".getBytes()).matches(\"^\\\\$5\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha256CryptExplicitCall()",
            "parameters": []
          }
        ],
        "testSha256CryptNullData": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Sha2Crypt.sha256Crypt((byte[]) null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testSha256CryptNullData()",
            "parameters": []
          }
        ],
        "testSha256CryptStrings": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(\"\", \"$5$foo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$5$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha256CryptStrings()",
            "parameters": []
          }
        ],
        "testSha256CryptWithEmptySalt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Sha2Crypt.sha256Crypt(\"secret\".getBytes(), \"\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha256CryptWithEmptySalt()",
            "parameters": []
          }
        ],
        "testSha256LargestThanBlocksize": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[buffer.length]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], int, int, byte)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "200",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "(byte) 'A'",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Sha2Crypt.sha256Crypt(buffer, \"$5$abc\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$5$abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha256LargestThanBlocksize()",
            "parameters": []
          }
        ],
        "testSha2CryptRounds": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Sha2Crypt.sha256Crypt(\"secret\".getBytes(StandardCharsets.UTF_8), \"$5$rounds=50$abcd$\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$5$rounds=50$abcd$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha2CryptRounds()",
            "parameters": []
          }
        ],
        "testSha2CryptRoundsThreadLocalRandom": [
          {
            "call_methods": [
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$5$rounds=50$abcd$\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "random",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Sha2Crypt.sha256Crypt(\"secret\".getBytes(StandardCharsets.UTF_8), \"$5$rounds=50$abcd$\", random)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha2CryptRoundsThreadLocalRandom()",
            "parameters": []
          }
        ],
        "testZeroOutInput": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[buffer.length]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 'A'",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testZeroOutInput()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.Sha2CryptTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testCtor": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new Sha2Crypt()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCtor()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.Sha512CryptTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testSha256LargetThanBlocksize": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[buffer.length]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], int, int, byte)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "200",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "(byte) 'A'",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$6$abc\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Sha2Crypt.sha512Crypt(buffer, \"$6$abc\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha256LargetThanBlocksize()",
            "parameters": []
          }
        ],
        "testSha2CryptRounds": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Sha2Crypt.sha256Crypt(\"secret\".getBytes(StandardCharsets.UTF_8), \"$5$rounds=50$abcd$\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha256Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$5$rounds=50$abcd$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha2CryptRounds()",
            "parameters": []
          }
        ],
        "testSha2CryptWrongSalt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Sha2Crypt.sha512Crypt(\"secret\".getBytes(StandardCharsets.UTF_8), \"xx\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"xx\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha2CryptWrongSalt()",
            "parameters": []
          }
        ],
        "testSha512CryptBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"$6$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(new byte[0], \"$6$foo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"t\\u00e4st\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$6$./$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha512CryptBytes()",
            "parameters": []
          }
        ],
        "testSha512CryptExplicitCall": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Sha2Crypt.sha512Crypt(\"secret\".getBytes()).matches(\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha512CryptExplicitCall()",
            "parameters": []
          }
        ],
        "testSha512CryptExplicitCallThreadLocalRandom": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.concurrent.ThreadLocalRandom.current()",
                "arguments": [],
                "return_type": "java.util.concurrent.ThreadLocalRandom"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String, java.util.Random)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "threadLocalRandom",
                    "variable_type": "java.util.Random"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "Sha2Crypt.sha512Crypt(\"secret\".getBytes(), null, threadLocalRandom).matches(\"^\\\\$6\\\\$[a-zA-Z0-9./]{0,16}\\\\$.{1,}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSha512CryptExplicitCallThreadLocalRandom()",
            "parameters": []
          }
        ],
        "testSha512CryptNullData": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Sha2Crypt.sha512Crypt((byte[]) null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha512CryptNullData()",
            "parameters": []
          }
        ],
        "testSha512CryptNullSalt": [
          {
            "call_methods": [],
            "signature": "public void testSha512CryptNullSalt()",
            "parameters": []
          }
        ],
        "testSha512CryptStrings": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(\"\", \"$6$foo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$6$foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha512CryptStrings()",
            "parameters": []
          }
        ],
        "testSha512CryptWithEmptySalt": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Sha2Crypt.sha512Crypt(\"secret\".getBytes(), \"\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSha512CryptWithEmptySalt()",
            "parameters": []
          }
        ],
        "testZeroOutInput": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "new byte[buffer.length]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.fill(byte[], byte)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "(byte) 'A'",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Sha2Crypt.sha512Crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testZeroOutInput()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.UnixCryptTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testCtor": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new UnixCrypt()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCtor()",
            "parameters": []
          }
        ],
        "testUnixCryptBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new byte[0]",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"12\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"12UFlHxel6uMM\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(new byte[0], \"12\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"t\\u00e4st\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"./\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUnixCryptBytes()",
            "parameters": []
          }
        ],
        "testUnixCryptExplicitCall": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^[a-zA-Z0-9./]{13}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\".getBytes()",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "UnixCrypt.crypt(\"secret\".getBytes()).matches(\"^[a-zA-Z0-9./]{13}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUnixCryptExplicitCall()",
            "parameters": [],
            "javadoc": "\n     * Some salts are invalid for crypt(3) but not for unixCrypt().\n     "
          }
        ],
        "testUnixCryptInvalidSalt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> UnixCrypt.crypt(\"secret\", \"$a\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"$a\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUnixCryptInvalidSalt()",
            "parameters": [],
            "javadoc": "\n     * Unimplemented \"$foo$\" salt prefixes would be treated as UnixCrypt salt.\n     "
          }
        ],
        "testUnixCryptNullData": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(byte[])",
                "arguments": [
                  {
                    "variable_name": "(byte[]) null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "NullPointerException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> UnixCrypt.crypt((byte[]) null)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testUnixCryptNullData()",
            "parameters": []
          }
        ],
        "testUnixCryptStrings": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"xxWAum7tHdIUw\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Crypt.crypt(\"secret\", \"xx\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.Crypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"xx\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUnixCryptStrings()",
            "parameters": []
          }
        ],
        "testUnixCryptWithEmptySalt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> UnixCrypt.crypt(\"secret\", \"\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUnixCryptWithEmptySalt()",
            "parameters": []
          }
        ],
        "testUnixCryptWithHalfSalt": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> UnixCrypt.crypt(\"secret\", \"x\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"secret\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"x\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUnixCryptWithHalfSalt()",
            "parameters": [],
            "javadoc": "\n     * Single character salts are illegal!\n     * E.g. with glibc 2.13, crypt(\"secret\", \"x\") = \"xxZREZpkHZpkI\" but\n     * crypt(\"secret\", \"xx\") = \"xxWAum7tHdIUw\" which makes it unverifiable.\n     "
          }
        ],
        "testUnixCryptWithoutSalt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.digest.UnixCrypt.crypt(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"foo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"^[a-zA-Z0-9./]{13}$\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotSame(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "hash",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "hash2",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "hash.matches(\"^[a-zA-Z0-9./]{13}$\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUnixCryptWithoutSalt()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.XXHash32OverflowTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testIncrementalHashWithUnprocessedBytesAndHugeLengthArray": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assumptions.assumeTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bytes != null",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Cannot allocate array of length \" + hugeLength",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "unprocessedSize + hugeLength < bufferSize",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"This should overflow to negative\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "bytes",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "unprocessedSize",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIncrementalHashWithUnprocessedBytesAndHugeLengthArray()",
            "parameters": [],
            "javadoc": "\n     * This test hits an edge case where a very large number of bytes is added to the incremental\n     * hash. The data is constructed so that an integer counter of unprocessed bytes will\n     * overflow. If this is not handled correctly then the code throws an exception when it\n     * copies more data into the unprocessed bytes array.\n     "
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.digest.XXHash32Test": {
      "fields": [
        {
          "variable_name": "file",
          "variable_type": "java.io.File"
        },
        {
          "variable_name": "expectedChecksum",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "copy": [
          {
            "call_methods": [
              {
                "signature": "java.io.InputStream.read(byte[])",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "java.io.OutputStream.write(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "buffer",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "n",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private static long copy(InputStream, OutputStream, int)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.io.InputStream"
              },
              {
                "variable_name": "output",
                "variable_type": "java.io.OutputStream"
              },
              {
                "variable_name": "bufferSize",
                "variable_type": "int"
              }
            ]
          }
        ],
        "data": [
          {
            "call_methods": [
              {
                "signature": "java.util.stream.Stream.of(T...)",
                "arguments": [
                  {
                    "variable_name": "// reference checksums created with xxh32sum\r\n// https://cyan4973.github.io/xxHash/\r\nArguments.of(\"org/apache/commons/codec/bla.tar\", \"fbb5c8d1\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"org/apache/commons/codec/bla.tar.xz\", \"4106a208\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"org/apache/commons/codec/small.bin\", \"f66c26f8\")",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.stream.Stream<T>"
              },
              {
                "signature": "org.junit.jupiter.params.provider.Arguments.of(java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"org/apache/commons/codec/bla.tar\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "\"fbb5c8d1\"",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "org.junit.jupiter.params.provider.Arguments"
              }
            ],
            "signature": "public static Stream<Arguments> data()",
            "parameters": []
          }
        ],
        "toByteArray": [
          {
            "call_methods": [
              {
                "signature": "java.io.ByteArrayOutputStream.toByteArray()",
                "arguments": [],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32Test.copy(java.io.InputStream, java.io.OutputStream, int)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.io.InputStream"
                  },
                  {
                    "variable_name": "output",
                    "variable_type": "java.io.OutputStream"
                  },
                  {
                    "variable_name": "10240",
                    "variable_type": "int"
                  }
                ],
                "return_type": "long"
              }
            ],
            "signature": "private static byte[] toByteArray(InputStream)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.io.InputStream"
              }
            ]
          }
        ],
        "initData": [
          {
            "call_methods": [
              {
                "signature": "java.net.URL.toURI()",
                "arguments": [],
                "return_type": "java.net.URI"
              },
              {
                "signature": "java.lang.Class.getClassLoader()",
                "arguments": [],
                "return_type": "java.lang.ClassLoader"
              },
              {
                "signature": "java.lang.ClassLoader.getResource(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "path",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.net.URL"
              }
            ],
            "signature": "public void initData(String, String)",
            "parameters": [
              {
                "variable_name": "path",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "c",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "verifyChecksum": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Long.toHexString(long)",
                "arguments": [
                  {
                    "variable_name": "h.getValue()",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.getValue()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32Test.initData(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "path",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expectedChecksum",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Long.toHexString(h.getValue())",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"checksum for \" + file.getName()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.File.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32Test.toByteArray(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void verifyChecksum(String, String)",
            "parameters": [
              {
                "variable_name": "path",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "c",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "verifyIncrementalChecksum": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Long.toHexString(long)",
                "arguments": [
                  {
                    "variable_name": "h.getValue()",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.getValue()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.reset()",
                "arguments": [],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32Test.initData(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "path",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "c",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.update(int)",
                "arguments": [
                  {
                    "variable_name": "b[0]",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32.update(byte[], int, int)",
                "arguments": [
                  {
                    "variable_name": "b",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "b.length - 2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expectedChecksum",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Long.toHexString(h.getValue())",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"checksum for \" + file.getName()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.File.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.digest.XXHash32Test.toByteArray(java.io.InputStream)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.io.InputStream"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void verifyIncrementalChecksum(String, String)",
            "parameters": [
              {
                "variable_name": "path",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "c",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.EncoderExceptionTest": {
      "fields": [
        {
          "variable_name": "MSG",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "t",
          "variable_type": "java.lang.Throwable"
        }
      ],
      "constructors": [],
      "methods": {
        "testConstructor0": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructor0()",
            "parameters": []
          }
        ],
        "testConstructorString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "MSG",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "e.getCause()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructorString()",
            "parameters": []
          }
        ],
        "testConstructorStringThrowable": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "MSG",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConstructorStringThrowable()",
            "parameters": []
          }
        ],
        "testConstructorThrowable": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.Throwable.getMessage()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Object.getClass()",
                "arguments": [],
                "return_type": "java.lang.Class<?>"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "t.getClass().getName()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "e.getMessage()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Class.getName()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testConstructorThrowable()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link EncoderException}.\n "
    },
    "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest": {
      "fields": [
        {
          "variable_name": "TEST_CHARS",
          "variable_type": "char"
        }
      ],
      "constructors": [],
      "methods": {
        "assertNotEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNotEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "bmpm.encode(value)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private void assertNotEmpty(BeiderMorseEncoder, String)",
            "parameters": [
              {
                "variable_name": "bmpm",
                "variable_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "variable_name": "value",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "createGenericApproxEncoder": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(org.apache.commons.codec.language.bm.RuleType)",
                "arguments": [
                  {
                    "variable_name": "RuleType.APPROX",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setNameType(org.apache.commons.codec.language.bm.NameType)",
                "arguments": [
                  {
                    "variable_name": "NameType.GENERIC",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private BeiderMorseEncoder createGenericApproxEncoder()",
            "parameters": []
          }
        ],
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected StringEncoder createStringEncoder()",
            "parameters": []
          }
        ],
        "testAllChars": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Character.toString(c)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.Character.toString(char)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testAllChars()",
            "parameters": [],
            "javadoc": "\n     * Tests we do not blow up.\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testAsciiEncodeNotEmpty1Letter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.assertNotEmpty(org.apache.commons.codec.language.bm.BeiderMorseEncoder, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bmpm",
                    "variable_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
                  },
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toUpperCase()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "signature": "java.lang.Character.toString(char)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testAsciiEncodeNotEmpty1Letter()",
            "parameters": []
          }
        ],
        "testAsciiEncodeNotEmpty2Letters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.assertNotEmpty(org.apache.commons.codec.language.bm.BeiderMorseEncoder, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bmpm",
                    "variable_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
                  },
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toUpperCase()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              }
            ],
            "signature": "public void testAsciiEncodeNotEmpty2Letters()",
            "parameters": []
          }
        ],
        "testEncodeAtzNotEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.assertNotEmpty(org.apache.commons.codec.language.bm.BeiderMorseEncoder, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bmpm",
                    "variable_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
                  },
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              }
            ],
            "signature": "public void testEncodeAtzNotEmpty()",
            "parameters": []
          }
        ],
        "testEncodeGna": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"gna\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeGna()",
            "parameters": [],
            "javadoc": "\n     * Tests https://issues.apache.org/jira/browse/CODEC-125?focusedCommentId=13071566&page=com.atlassian.jira.plugin.system.issuetabpanels:\n     * comment-tabpanel#comment-13071566\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testInvalidLangIllegalArgumentException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Rule.getInstance(NameType.GENERIC, RuleType.APPROX, \"noSuchLanguage\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.getInstance(org.apache.commons.codec.language.bm.NameType, org.apache.commons.codec.language.bm.RuleType, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "NameType.GENERIC",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  },
                  {
                    "variable_name": "RuleType.APPROX",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  },
                  {
                    "variable_name": "\"noSuchLanguage\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.util.List<org.apache.commons.codec.language.bm.Rule>"
              }
            ],
            "signature": "public void testInvalidLangIllegalArgumentException()",
            "parameters": []
          }
        ],
        "testInvalidLangIllegalStateException": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Lang.loadFromResource(java.lang.String, org.apache.commons.codec.language.bm.Languages)",
                "arguments": [
                  {
                    "variable_name": "\"thisIsAMadeUpResourceName\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "Languages.getInstance(NameType.GENERIC)",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Lang"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.getInstance(org.apache.commons.codec.language.bm.NameType)",
                "arguments": [
                  {
                    "variable_name": "NameType.GENERIC",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Lang.loadFromResource(\"thisIsAMadeUpResourceName\", Languages.getInstance(NameType.GENERIC))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testInvalidLangIllegalStateException()",
            "parameters": []
          }
        ],
        "testInvalidLanguageIllegalArgumentException": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.getInstance(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"thereIsNoSuchLanguage\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> Languages.getInstance(\"thereIsNoSuchLanguage\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testInvalidLanguageIllegalArgumentException()",
            "parameters": []
          }
        ],
        "testLongestEnglishSurname": [
          {
            "call_methods": [
              {
                "signature": "java.time.Duration.ofMillis(long)",
                "arguments": [
                  {
                    "variable_name": "10000L",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.time.Duration"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTimeout(java.time.Duration, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "Duration.ofMillis(10000L)",
                    "variable_type": "java.time.Duration"
                  },
                  {
                    "variable_name": "() -> bmpm.encode(\"MacGhilleseatheanaich\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"MacGhilleseatheanaich\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testLongestEnglishSurname()",
            "parameters": []
          }
        ],
        "testNegativeIndexForRuleMatchIndexOutOfBoundsException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IndexOutOfBoundsException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> r.patternAndContextMatches(\"bob\", -1)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.patternAndContextMatches(java.lang.CharSequence, int)",
                "arguments": [
                  {
                    "variable_name": "\"bob\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "-1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testNegativeIndexForRuleMatchIndexOutOfBoundsException()",
            "parameters": []
          }
        ],
        "testOOM": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\\\|\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "phonemes.isEmpty()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(org.apache.commons.codec.language.bm.RuleType)",
                "arguments": [
                  {
                    "variable_name": "RuleType.EXACT",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setMaxPhonemes(int)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.isEmpty()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setNameType(org.apache.commons.codec.language.bm.NameType)",
                "arguments": [
                  {
                    "variable_name": "NameType.GENERIC",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "phrase",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "phonemeArr.length <= 10",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testOOM()",
            "parameters": []
          }
        ],
        "testSetConcat": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bmpm.isConcat()",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Should be able to set concat to false\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.isConcat()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setConcat(boolean)",
                "arguments": [
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSetConcat()",
            "parameters": []
          }
        ],
        "testSetNameTypeAsh": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.getNameType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setNameType(org.apache.commons.codec.language.bm.NameType)",
                "arguments": [
                  {
                    "variable_name": "NameType.ASHKENAZI",
                    "variable_type": "org.apache.commons.codec.language.bm.NameType"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "NameType.ASHKENAZI",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "bmpm.getNameType()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Name type should have been set to ash\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSetNameTypeAsh()",
            "parameters": []
          }
        ],
        "testSetRuleTypeExact": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.getRuleType()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(org.apache.commons.codec.language.bm.RuleType)",
                "arguments": [
                  {
                    "variable_name": "RuleType.EXACT",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "RuleType.EXACT",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "bmpm.getRuleType()",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Rule type should have been set to exact\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSetRuleTypeExact()",
            "parameters": []
          }
        ],
        "testSetRuleTypeToRulesIllegalArgumentException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> bmpm.setRuleType(RuleType.RULES)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.setRuleType(org.apache.commons.codec.language.bm.RuleType)",
                "arguments": [
                  {
                    "variable_name": "RuleType.RULES",
                    "variable_type": "org.apache.commons.codec.language.bm.RuleType"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSetRuleTypeToRulesIllegalArgumentException()",
            "parameters": []
          }
        ],
        "testSpeedCheck": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "TEST_CHARS[0]",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "stringBuffer.toString()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSpeedCheck()",
            "parameters": [],
            "javadoc": "\n     * (Un)luckily, the worse performing test because of the data in the test characters.\n     *\n     * @throws EncoderException for some failure scenarios\n     "
          }
        ],
        "testSpeedCheck2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "phrase.subSequence(0, i)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "signature": "java.lang.String.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSpeedCheck2()",
            "parameters": []
          }
        ],
        "testSpeedCheck3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoder.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "phrase.subSequence(0, i)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest.createGenericApproxEncoder()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.BeiderMorseEncoder"
              },
              {
                "signature": "java.lang.String.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testSpeedCheck3()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests BeiderMorseEncoder.\n "
    },
    "org.apache.commons.codec.language.bm.CacheSubSequencePerformanceTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "cacheSubSequence": [
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "index",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "java.lang.CharSequence.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "start",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "end",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private CharSequence cacheSubSequence(CharSequence)",
            "parameters": [
              {
                "variable_name": "cached",
                "variable_type": "java.lang.CharSequence"
              }
            ]
          }
        ],
        "test": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.CacheSubSequencePerformanceTest.cacheSubSequence(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "\"Angelo\"",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.CacheSubSequencePerformanceTest.test(java.lang.CharSequence, int)",
                "arguments": [
                  {
                    "variable_name": "\"Angelo\"",
                    "variable_type": "java.lang.CharSequence"
                  },
                  {
                    "variable_name": "times",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.io.PrintStream.print(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Test with String : \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void test()",
            "parameters": []
          },
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "i",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "j",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "java.lang.CharSequence.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "private void test(CharSequence)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.CharSequence"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "System.currentTimeMillis() - beginTimeMillis + \" millis\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.System.currentTimeMillis()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.CacheSubSequencePerformanceTest.test(java.lang.CharSequence)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.CharSequence"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void test(CharSequence, int)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.CharSequence"
              },
              {
                "variable_name": "times",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.language.bm.LanguageGuessingTest": {
      "fields": [
        {
          "variable_name": "lang",
          "variable_type": "org.apache.commons.codec.language.bm.Lang"
        }
      ],
      "constructors": [],
      "methods": {
        "data": [
          {
            "call_methods": [
              {
                "signature": "java.util.stream.Stream.of(T...)",
                "arguments": [
                  {
                    "variable_name": "Arguments.of(\"Renault\", \"french\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Mickiewicz\", \"polish\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// this also hits german and greek latin\r\nArguments.of(\"Thompson\", \"english\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// Nuez\r\nArguments.of(\"Nu\\u00f1ez\", \"spanish\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Carvalho\", \"portuguese\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// apek\r\nArguments.of(\"\\u010capek\", \"czech\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Sjneijder\", \"dutch\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Klausewitz\", \"german\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// Kk\r\nArguments.of(\"K\\u00fc\\u00e7\\u00fck\", \"turkish\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Giacometti\", \"italian\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Nagy\", \"hungarian\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// Ceauescu\r\nArguments.of(\"Ceau\\u015fescu\", \"romanian\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Angelopoulos\", \"greeklatin\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// \r\nArguments.of(\"\\u0391\\u03b3\\u03b3\\u03b5\\u03bb\\u03cc\\u03c0\\u03bf\\u03c5\\u03bb\\u03bf\\u03c2\", \"greek\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// \r\nArguments.of(\"\\u041f\\u0443\\u0448\\u043a\\u0438\\u043d\", \"cyrillic\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// \r\nArguments.of(\"\\u05db\\u05d4\\u05df\", \"hebrew\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// cz\r\nArguments.of(\"\\u00e1cz\", \"any\")",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "// tz\r\nArguments.of(\"\\u00e1tz\", \"any\")",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.stream.Stream<T>"
              },
              {
                "signature": "org.junit.jupiter.params.provider.Arguments.of(java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"Renault\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "\"french\"",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "org.junit.jupiter.params.provider.Arguments"
              }
            ],
            "signature": "public static Stream<Arguments> data()",
            "parameters": []
          }
        ],
        "testLanguageGuessing": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "guesses.contains(language)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"language predicted for name '\" + name + \"' is wrong: \" + guesses + \" should contain '\" + language + \"'\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Lang.guessLanguages(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.contains(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "language",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testLanguageGuessing(String, String)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "language",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests guessLanguages API.\n "
    },
    "org.apache.commons.codec.language.bm.PhoneticEnginePerformanceTest": {
      "fields": [
        {
          "variable_name": "LOOP",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "test": [
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "String.format(\"Time for encoding %,d times the input '%s': %,d millis.\", LOOP, input, totalMillis)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.format(java.lang.String, java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"Time for encoding %,d times the input '%s': %,d millis.\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "LOOP",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "totalMillis",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.System.currentTimeMillis()",
                "arguments": [],
                "return_type": "long"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void test()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests performance for {@link PhoneticEngine}.\n * <p>\n * See <a href=\"https://issues.apache.org/jira/browse/CODEC-174\">[CODEC-174] Improve performance of Beider Morse\n * encoder</a>.\n * </p>\n * <p>\n * Results for November 7, 2013, project SVN revision 1539678.\n * </p>\n * <p>\n * Environment:\n * </p>\n * <ul>\n * <li>java version \"1.7.0_45\"</li>\n * <li>Java(TM) SE Runtime Environment (build 1.7.0_45-b18)</li>\n * <li>Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)</li>\n * <li>OS name: \"windows 7\", version: \"6.1\", arch: \"amd64\", family: \"windows\")</li>\n * </ul>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 33,039 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,297 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,857 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>31,561 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,665 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,215 millis.</li>\n * </ol>\n * <p>\n * On this file's revision 1539678, with patch <a\n * href=\"https://issues.apache.org/jira/secure/attachment/12611963/CODEC-174-change-rules-storage-to-Map.patch\"\n * >CODEC-174-change-rules-storage-to-Map</a>:\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 18,196 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,858 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,644 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>13,591 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,861 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,696 millis.</li>\n * </ol>\n * <p>\n * Patch applied, committed revision 1539783.\n * </p>\n * <p>\n * On this file's revision 1539783, with patch <a\n * href=\"https://issues.apache.org/jira/secure/attachment/12611962/CODEC-174-delete-subsequence-cache.patch\"\n * >CODEC-174-delete-subsequence-cache.patch</a>:\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,547 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>13,501 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,528 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 17,110 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,910 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 16,969 millis.</li>\n * </ol>\n * <p>\n * Patch not applied.\n * </p>\n * <p>\n * On this file's revision 1539787, with patch <a\n * href=\"https://issues.apache.org/jira/secure/attachment/12612178/CODEC-174-reuse-set-in-PhonemeBuilder.patch\"\n * >CODEC-174-reuse-set-in-PhonemeBuilder.patch</a>:\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,724 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,451 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,742 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>13,186 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,600 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 16,405 millis.</li>\n * </ol>\n * <p>\n * Patch applied, committed revision 1539788.\n * </p>\n * <p>\n * Before patch https://issues.apache.org/jira/secure/attachment/12613371/CODEC-174-refactor-restrictTo-method-in-SomeLanguages.patch\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,133 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,064 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>12,838 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 12,970 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,122 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,293 millis.</li>\n * </ol>\n * <p>\n * After patch https://issues.apache.org/jira/secure/attachment/12613371/CODEC-174-refactor-restrictTo-method-in-SomeLanguages.patch\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,576 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,506 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,361 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>11,142 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,430 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,297 millis.</li>\n * </ol>\n * <p>\n * Patch applied, committed revision 1541234.\n * </p>\n "
    },
    "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "encode": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.get(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"nameType\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.NameType.valueOf(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "nameTypeArg",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\",\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "languageSetArg.split(\",\")",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.equals(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"auto\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.RuleType.valueOf(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ruleTypeArg",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String, org.apache.commons.codec.language.bm.Languages.LanguageSet)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "languageSet",
                    "variable_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Languages.LanguageSet.from(java.util.Set<java.lang.String>)",
                "arguments": [
                  {
                    "variable_name": "new HashSet<>(Arrays.asList(languageSetArg.split(\",\")))",
                    "variable_type": "java.util.Set<java.lang.String>"
                  }
                ],
                "return_type": "org.apache.commons.codec.language.bm.Languages.LanguageSet"
              }
            ],
            "signature": "private static String encode(Map<String, String>, boolean, String)",
            "parameters": [
              {
                "variable_name": "args",
                "variable_type": "java.util.Map<java.lang.String, java.lang.String>"
              },
              {
                "variable_name": "concat",
                "variable_type": "boolean"
              },
              {
                "variable_name": "input",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * This code is similar in style to code found in Solr:\n     * solr/core/src/java/org/apache/solr/analysis/BeiderMorseFilterFactory.java\n     *\n     * Making a JUnit test out of it to protect Solr from possible future\n     * regressions in Commons-Codec.\n     "
          }
        ],
        "testCompatibilityWithOriginalVersion": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.put(K, V)",
                "arguments": [
                  {
                    "variable_name": "\"nameType\"",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "\"GENERIC\"",
                    "variable_type": "V"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.encode(java.util.Map<java.lang.String, java.lang.String>, boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "args",
                    "variable_type": "java.util.Map<java.lang.String, java.lang.String>"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"abram\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encode(args, true, \"abram\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCompatibilityWithOriginalVersion()",
            "parameters": []
          }
        ],
        "testSolrASHKENAZI": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.put(K, V)",
                "arguments": [
                  {
                    "variable_name": "\"nameType\"",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "\"ASHKENAZI\"",
                    "variable_type": "V"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.encode(java.util.Map<java.lang.String, java.lang.String>, boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "args",
                    "variable_type": "java.util.Map<java.lang.String, java.lang.String>"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Angelo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encode(args, true, \"Angelo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSolrASHKENAZI()",
            "parameters": []
          }
        ],
        "testSolrGENERIC": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.put(K, V)",
                "arguments": [
                  {
                    "variable_name": "\"nameType\"",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "\"GENERIC\"",
                    "variable_type": "V"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.encode(java.util.Map<java.lang.String, java.lang.String>, boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "args",
                    "variable_type": "java.util.Map<java.lang.String, java.lang.String>"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Angelo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encode(args, true, \"Angelo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSolrGENERIC()",
            "parameters": []
          }
        ],
        "testSolrSEPHARDIC": [
          {
            "call_methods": [
              {
                "signature": "java.util.Map.put(K, V)",
                "arguments": [
                  {
                    "variable_name": "\"nameType\"",
                    "variable_type": "K"
                  },
                  {
                    "variable_name": "\"SEPHARDIC\"",
                    "variable_type": "V"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest.encode(java.util.Map<java.lang.String, java.lang.String>, boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "args",
                    "variable_type": "java.util.Map<java.lang.String, java.lang.String>"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Angelo\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encode(args, true, \"Angelo\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSolrSEPHARDIC()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests PhoneticEngine and Languages.LanguageSet in ways very similar to code found in solr-3.6.0.\n "
    },
    "org.apache.commons.codec.language.bm.PhoneticEngineTest": {
      "fields": [
        {
          "variable_name": "TEN",
          "variable_type": "java.lang.Integer"
        }
      ],
      "constructors": [],
      "methods": {
        "data": [
          {
            "call_methods": [
              {
                "signature": "java.util.stream.Stream.of(T...)",
                "arguments": [
                  {
                    "variable_name": "Arguments.of(\"Renault\", \"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\", NameType.GENERIC, RuleType.APPROX, Boolean.TRUE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Renault\", \"rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinolt|rinult\", NameType.ASHKENAZI, RuleType.APPROX, Boolean.TRUE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Renault\", \"rinDlt\", NameType.ASHKENAZI, RuleType.APPROX, Boolean.TRUE, Integer.valueOf(1))",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Renault\", \"rinDlt\", NameType.SEPHARDIC, RuleType.APPROX, Boolean.TRUE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"SntJohn-Smith\", \"sntjonsmit\", NameType.GENERIC, RuleType.EXACT, Boolean.TRUE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"d'ortley\", \"(ortlaj|ortlej)-(dortlaj|dortlej)\", NameType.GENERIC, RuleType.EXACT, Boolean.TRUE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"van helsing\", \"(elSink|elsink|helSink|helsink|helzink|xelsink)-(banhelsink|fanhelsink|fanhelzink|vanhelsink|vanhelzink|vanjelsink)\", NameType.GENERIC, RuleType.EXACT, Boolean.FALSE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Judenburg\", \"iudnbYrk|iudnbirk|iudnburk|xudnbirk|xudnburk|zudnbirk|zudnburk\", NameType.GENERIC, RuleType.APPROX, Boolean.TRUE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"Judenburg\", \"iudnbYrk|iudnbirk|iudnburk|xudnbirk|xudnburk|zudnbirk|zudnburk\", NameType.GENERIC, RuleType.APPROX, Boolean.TRUE, Integer.MAX_VALUE)",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.stream.Stream<T>"
              },
              {
                "signature": "org.junit.jupiter.params.provider.Arguments.of(java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"Renault\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "\"rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "NameType.GENERIC",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "RuleType.APPROX",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "Boolean.TRUE",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "TEN",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "org.junit.jupiter.params.provider.Arguments"
              },
              {
                "signature": "java.lang.Integer.valueOf(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.Integer"
              }
            ],
            "signature": "public static Stream<Arguments> data()",
            "parameters": []
          }
        ],
        "invalidData": [
          {
            "call_methods": [
              {
                "signature": "java.util.stream.Stream.of(T...)",
                "arguments": [
                  {
                    "variable_name": "Arguments.of(\"bar\", \"bar|bor|var|vor\", NameType.ASHKENAZI, RuleType.APPROX, Boolean.FALSE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"al\", \"|al\", NameType.SEPHARDIC, RuleType.APPROX, Boolean.FALSE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"da\", \"da|di\", NameType.GENERIC, RuleType.EXACT, Boolean.FALSE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"'''\", \"\", NameType.SEPHARDIC, RuleType.APPROX, Boolean.FALSE, TEN)",
                    "variable_type": "T..."
                  },
                  {
                    "variable_name": "Arguments.of(\"'''\", \"\", NameType.SEPHARDIC, RuleType.APPROX, Boolean.FALSE, Integer.MAX_VALUE)",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.stream.Stream<T>"
              },
              {
                "signature": "org.junit.jupiter.params.provider.Arguments.of(java.lang.Object...)",
                "arguments": [
                  {
                    "variable_name": "\"bar\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "\"bar|bor|var|vor\"",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "NameType.ASHKENAZI",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "RuleType.APPROX",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "Boolean.FALSE",
                    "variable_type": "java.lang.Object..."
                  },
                  {
                    "variable_name": "TEN",
                    "variable_type": "java.lang.Object..."
                  }
                ],
                "return_type": "org.junit.jupiter.params.provider.Arguments"
              }
            ],
            "signature": "public static Stream<Arguments> invalidData()",
            "parameters": []
          }
        ],
        "testEncode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.split(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\\\|\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String[]"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "phoneticExpected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "phoneticActual",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"phoneme incorrect\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "split.length <= maxPhonemes",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncode(String, String, NameType, RuleType, boolean, int)",
            "parameters": [
              {
                "variable_name": "name",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "phoneticExpected",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "ruleType",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "concat",
                "variable_type": "boolean"
              },
              {
                "variable_name": "maxPhonemes",
                "variable_type": "int"
              }
            ]
          }
        ],
        "testInvalidEncode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.PhoneticEngine.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "engine.encode(input)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "phoneticExpected",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testInvalidEncode(String, String, NameType, RuleType, boolean, int)",
            "parameters": [
              {
                "variable_name": "input",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "phoneticExpected",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "nameType",
                "variable_type": "org.apache.commons.codec.language.bm.NameType"
              },
              {
                "variable_name": "ruleType",
                "variable_type": "org.apache.commons.codec.language.bm.RuleType"
              },
              {
                "variable_name": "concat",
                "variable_type": "boolean"
              },
              {
                "variable_name": "maxPhonemes",
                "variable_type": "int"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests PhoneticEngine.\n "
    },
    "org.apache.commons.codec.language.bm.RuleTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "makePhonemes": [
          {
            "call_methods": [],
            "signature": "private Rule.Phoneme[][] makePhonemes()",
            "parameters": []
          }
        ],
        "testPhonemeComparedToLaterIsNegative": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "Integer.valueOf(c).intValue() < 0",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Comparing \" + phs[i].getPhonemeText() + \" to \" + phs[j].getPhonemeText() + \" should be negative\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemeText()",
                "arguments": [],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "java.lang.Integer.valueOf(int)",
                "arguments": [
                  {
                    "variable_name": "c",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.Integer"
              },
              {
                "signature": "java.lang.Integer.intValue()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.RuleTest.makePhonemes()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.Rule.Phoneme[][]"
              },
              {
                "signature": "java.util.Comparator.compare(T, T)",
                "arguments": [
                  {
                    "variable_name": "phs[i]",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "phs[j]",
                    "variable_type": "T"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testPhonemeComparedToLaterIsNegative()",
            "parameters": []
          }
        ],
        "testPhonemeComparedToSelfIsZero": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemeText()",
                "arguments": [],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "Rule.Phoneme.COMPARATOR.compare(ph, ph)",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Phoneme compared to itself should be zero: \" + ph.getPhonemeText()",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.RuleTest.makePhonemes()",
                "arguments": [],
                "return_type": "org.apache.commons.codec.language.bm.Rule.Phoneme[][]"
              },
              {
                "signature": "java.util.Comparator.compare(T, T)",
                "arguments": [
                  {
                    "variable_name": "ph",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "ph",
                    "variable_type": "T"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testPhonemeComparedToSelfIsZero()",
            "parameters": []
          }
        ],
        "testSubSequenceWorks": [
          {
            "call_methods": [
              {
                "signature": "java.lang.CharSequence.charAt(int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(char, char)",
                "arguments": [
                  {
                    "variable_name": "'a'",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "a.getPhonemeText().charAt(0)",
                    "variable_type": "char"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.CharSequence.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.CharSequence.subSequence(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "org.apache.commons.codec.language.bm.Rule.Phoneme.getPhonemeText()",
                "arguments": [],
                "return_type": "java.lang.CharSequence"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ab\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "a_b.getPhonemeText().subSequence(0, 2).toString()",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSubSequenceWorks()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests Rule.\n "
    },
    "org.apache.commons.codec.language.Caverphone1Test": {
      "fields": [],
      "constructors": [],
      "methods": {
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected Caverphone1 createStringEncoder()",
            "parameters": []
          }
        ],
        "testCaverphoneRevisitedCommonCodeAT1111": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"AT1111\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"add\", \"aid\", \"at\", \"art\", \"eat\", \"earth\", \"head\", \"hit\", \"hot\", \"hold\", \"hard\", \"heart\", \"it\", \"out\", \"old\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCaverphoneRevisitedCommonCodeAT1111()",
            "parameters": [],
            "javadoc": "\n     * Tests example adapted from version 2.0  https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * AT1111 words: add, aid, at, art, eat, earth, head, hit, hot, hold, hard, heart, it, out, old\n     *\n     * @throws EncoderException for some failure scenarios.\n     "
          }
        ],
        "testEndMb": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEndMb()",
            "parameters": []
          }
        ],
        "testIsCaverphoneEquals": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "caverphone.isEncodeEqual(\"Peter\", \"Stevenson\")",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Caverphone encodings should not be equal\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "caverphone.isEncodeEqual(\"Peter\", \"Peady\")",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Caverphone encodings should be equal\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Peter\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Stevenson\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testIsCaverphoneEquals()",
            "parameters": [],
            "javadoc": "\n     * Tests some examples from version 2.0 https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios.\n     "
          }
        ],
        "testSpecificationV1Examples": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSpecificationV1Examples()",
            "parameters": [],
            "javadoc": "\n     * Tests example from https://caversham.otago.ac.nz/files/working/ctp060902.pdf\n     *\n     * @throws EncoderException for some failure scenarios.\n     "
          }
        ],
        "testWikipediaExamples": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWikipediaExamples()",
            "parameters": [],
            "javadoc": "\n     * Tests examples from https://en.wikipedia.org/wiki/Caverphone\n     *\n     * @throws EncoderException for some failure scenarios.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests Caverphone1.\n "
    },
    "org.apache.commons.codec.language.Caverphone2Test": {
      "fields": [],
      "constructors": [],
      "methods": {
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected Caverphone2 createStringEncoder()",
            "parameters": []
          }
        ],
        "testCaverphoneRevisitedCommonCodeAT11111111": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"AT11111111\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"add\", \"aid\", \"at\", \"art\", \"eat\", \"earth\", \"head\", \"hit\", \"hot\", \"hold\", \"hard\", \"heart\", \"it\", \"out\", \"old\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCaverphoneRevisitedCommonCodeAT11111111()",
            "parameters": [],
            "javadoc": "\n     * See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * AT11111111 words: add, aid, at, art, eat, earth, head, hit, hot, hold, hard, heart, it, out, old\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testCaverphoneRevisitedExamples": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCaverphoneRevisitedExamples()",
            "parameters": [],
            "javadoc": "\n     * See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testCaverphoneRevisitedRandomNameKLN1111111": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"KLN1111111\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Cailean\", \"Calan\", \"Calen\", \"Callahan\", \"Callan\", \"Callean\", \"Carleen\", \"Carlen\", \"Carlene\", \"Carlin\", \"Carline\", \"Carlyn\", \"Carlynn\", \"Carlynne\", \"Charlean\", \"Charleen\", \"Charlene\", \"Charline\", \"Cherlyn\", \"Chirlin\", \"Clein\", \"Cleon\", \"Cline\", \"Cohleen\", \"Colan\", \"Coleen\", \"Colene\", \"Colin\", \"Colleen\", \"Collen\", \"Collin\", \"Colline\", \"Colon\", \"Cullan\", \"Cullen\", \"Cullin\", \"Gaelan\", \"Galan\", \"Galen\", \"Garlan\", \"Garlen\", \"Gaulin\", \"Gayleen\", \"Gaylene\", \"Giliane\", \"Gillan\", \"Gillian\", \"Glen\", \"Glenn\", \"Glyn\", \"Glynn\", \"Gollin\", \"Gorlin\", \"Kalin\", \"Karlan\", \"Karleen\", \"Karlen\", \"Karlene\", \"Karlin\", \"Karlyn\", \"Kaylyn\", \"Keelin\", \"Kellen\", \"Kellene\", \"Kellyann\", \"Kellyn\", \"Khalin\", \"Kilan\", \"Kilian\", \"Killen\", \"Killian\", \"Killion\", \"Klein\", \"Kleon\", \"Kline\", \"Koerlin\", \"Kylen\", \"Kylynn\", \"Quillan\", \"Quillon\", \"Qulllon\", \"Xylon\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCaverphoneRevisitedRandomNameKLN1111111()",
            "parameters": [],
            "javadoc": "\n     * See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testCaverphoneRevisitedRandomNameTN11111111": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"TN11111111\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Dan\", \"Dane\", \"Dann\", \"Darn\", \"Daune\", \"Dawn\", \"Ddene\", \"Dean\", \"Deane\", \"Deanne\", \"DeeAnn\", \"Deeann\", \"Deeanne\", \"Deeyn\", \"Den\", \"Dene\", \"Denn\", \"Deonne\", \"Diahann\", \"Dian\", \"Diane\", \"Diann\", \"Dianne\", \"Diannne\", \"Dine\", \"Dion\", \"Dione\", \"Dionne\", \"Doane\", \"Doehne\", \"Don\", \"Donn\", \"Doone\", \"Dorn\", \"Down\", \"Downe\", \"Duane\", \"Dun\", \"Dunn\", \"Duyne\", \"Dyan\", \"Dyane\", \"Dyann\", \"Dyanne\", \"Dyun\", \"Tan\", \"Tann\", \"Teahan\", \"Ten\", \"Tenn\", \"Terhune\", \"Thain\", \"Thaine\", \"Thane\", \"Thanh\", \"Thayne\", \"Theone\", \"Thin\", \"Thorn\", \"Thorne\", \"Thun\", \"Thynne\", \"Tien\", \"Tine\", \"Tjon\", \"Town\", \"Towne\", \"Turne\", \"Tyne\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCaverphoneRevisitedRandomNameTN11111111()",
            "parameters": [],
            "javadoc": "\n     * See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testCaverphoneRevisitedRandomNameTTA1111111": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"TTA1111111\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Darda\", \"Datha\", \"Dedie\", \"Deedee\", \"Deerdre\", \"Deidre\", \"Deirdre\", \"Detta\", \"Didi\", \"Didier\", \"Dido\", \"Dierdre\", \"Dieter\", \"Dita\", \"Ditter\", \"Dodi\", \"Dodie\", \"Dody\", \"Doherty\", \"Dorthea\", \"Dorthy\", \"Doti\", \"Dotti\", \"Dottie\", \"Dotty\", \"Doty\", \"Doughty\", \"Douty\", \"Dowdell\", \"Duthie\", \"Tada\", \"Taddeo\", \"Tadeo\", \"Tadio\", \"Tati\", \"Teador\", \"Tedda\", \"Tedder\", \"Teddi\", \"Teddie\", \"Teddy\", \"Tedi\", \"Tedie\", \"Teeter\", \"Teodoor\", \"Teodor\", \"Terti\", \"Theda\", \"Theodor\", \"Theodore\", \"Theta\", \"Thilda\", \"Thordia\", \"Tilda\", \"Tildi\", \"Tildie\", \"Tildy\", \"Tita\", \"Tito\", \"Tjader\", \"Toddie\", \"Toddy\", \"Torto\", \"Tuddor\", \"Tudor\", \"Turtle\", \"Tuttle\", \"Tutto\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCaverphoneRevisitedRandomNameTTA1111111()",
            "parameters": [],
            "javadoc": "\n     * See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testCaverphoneRevisitedRandomWords": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"RTA1111111\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"rather\", \"ready\", \"writer\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SSA1111111\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"social\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCaverphoneRevisitedRandomWords()",
            "parameters": [],
            "javadoc": "\n     * See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testEndMb": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEndMb()",
            "parameters": []
          }
        ],
        "testIsCaverphoneEquals": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "caverphone.isEncodeEqual(\"Peter\", \"Stevenson\")",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Caverphone encodings should not be equal\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "caverphone.isEncodeEqual(\"Peter\", \"Peady\")",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Caverphone encodings should be equal\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.AbstractCaverphone.isEncodeEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Peter\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Stevenson\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testIsCaverphoneEquals()",
            "parameters": []
          }
        ],
        "testSpecificationExamples": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSpecificationExamples()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests Caverphone2.\n "
    },
    "org.apache.commons.codec.language.ColognePhoneticTest": {
      "fields": [
        {
          "variable_name": "TESTSET",
          "variable_type": "java.util.Set<java.lang.String>"
        },
        {
          "variable_name": "MATCHES",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "finishTests": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhoneticTest.hasTestCase(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "m",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "m + \" has no test case\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "errors",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Not expecting any missing test cases\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public static void finishTests()",
            "parameters": []
          }
        ],
        "hasTestCase": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.matches(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "re",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "private static boolean hasTestCase(String)",
            "parameters": [
              {
                "variable_name": "re",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "main": [
          {
            "call_methods": [
              {
                "signature": "java.io.PrintStream.println(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"'\" + arg + \"' = '\" + code + \"'\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "arg",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public static void main(String[])",
            "parameters": [
              {
                "variable_name": "args",
                "variable_type": "java.lang.String[]"
              }
            ]
          }
        ],
        "checkEncoding": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.replace(char, char)",
                "arguments": [
                  {
                    "variable_name": "''",
                    "variable_type": "char"
                  },
                  {
                    "variable_name": "'U'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.String.toUpperCase(java.util.Locale)",
                "arguments": [
                  {
                    "variable_name": "Locale.GERMAN",
                    "variable_type": "java.util.Locale"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.util.Set.add(E)",
                "arguments": [
                  {
                    "variable_name": "source.toUpperCase(Locale.GERMAN).replace('', 'A').replace('', 'O').replace('', 'U')",
                    "variable_type": "E"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void checkEncoding(String, String)",
            "parameters": [
              {
                "variable_name": "expected",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected ColognePhonetic createStringEncoder()",
            "parameters": []
          }
        ],
        "testAabjoe": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhoneticTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"01\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Aabjoe\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testAabjoe()",
            "parameters": []
          }
        ],
        "testAaclan": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhoneticTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"0856\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Aaclan\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testAaclan()",
            "parameters": []
          }
        ],
        "testAychlmajrForCodec122": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.ColognePhoneticTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"04567\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Aychlmajr\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testAychlmajrForCodec122()",
            "parameters": [],
            "javadoc": "\n     * Tests [CODEC-122]\n     *\n     * @throws EncoderException for some failure scenarios\n     "
          }
        ],
        "testCanFail": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "AssertionFailedError.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> this.checkEncoding(\"/\", \"Fehler\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhoneticTest.checkEncoding(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"/\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Fehler\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCanFail()",
            "parameters": []
          }
        ],
        "testEdgeCases": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEdgeCases()",
            "parameters": []
          }
        ],
        "testExamples": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testExamples()",
            "parameters": []
          }
        ],
        "testHyphen": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodings(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHyphen()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encodeEqual",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "element[1] + \" != \" + element[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.ColognePhonetic.isEncodeEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "element[1]",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "element[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testIsEncodeEquals()",
            "parameters": []
          }
        ],
        "testSpecialCharsBetweenSameLetters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"28282\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSpecialCharsBetweenSameLetters()",
            "parameters": []
          }
        ],
        "testVariationsMella": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"65\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testVariationsMella()",
            "parameters": []
          }
        ],
        "testVariationsMeyer": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"67\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "data",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testVariationsMeyer()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests the {@code ColognePhonetic} class.\n *\n * <p>\n * Keep this file in UTF-8 encoding for proper Javadoc processing.\n * </p>\n "
    },
    "org.apache.commons.codec.language.DaitchMokotoffSoundexTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected DaitchMokotoffSoundex createStringEncoder()",
            "parameters": []
          }
        ],
        "encode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "private String encode(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "soundex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "private String soundex(String)",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testAccentedCharacterFolding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"294795\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "soundex(\"Straburg\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Straburg\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testAccentedCharacterFolding()",
            "parameters": []
          }
        ],
        "testAdjacentCodes": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"054800\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "soundex(\"AKSSOL\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"AKSSOL\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testAdjacentCodes()",
            "parameters": []
          }
        ],
        "testEncodeBasic": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"AUERBACH\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"097400\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encode(\"AUERBACH\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeBasic()",
            "parameters": []
          }
        ],
        "testEncodeIgnoreApostrophes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"079600\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"OBrien\", \"'OBrien\", \"O'Brien\", \"OB'rien\", \"OBr'ien\", \"OBri'en\", \"OBrie'n\", \"OBrien'\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeIgnoreApostrophes()",
            "parameters": []
          }
        ],
        "testEncodeIgnoreHyphens": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"565463\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"KINGSMITH\", \"-KINGSMITH\", \"K-INGSMITH\", \"KI-NGSMITH\", \"KIN-GSMITH\", \"KING-SMITH\", \"KINGS-MITH\", \"KINGSM-ITH\", \"KINGSMI-TH\", \"KINGSMIT-H\", \"KINGSMITH-\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeIgnoreHyphens()",
            "parameters": [],
            "javadoc": "\n     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testEncodeIgnoreTrimmable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\" \\t\\n\\r Washington \\t\\n\\r \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"746536\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encode(\" \\t\\n\\r Washington \\t\\n\\r \")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeIgnoreTrimmable()",
            "parameters": []
          }
        ],
        "testSoundexBasic": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"583600\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "soundex(\"GOLDEN\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"GOLDEN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSoundexBasic()",
            "parameters": [],
            "javadoc": "\n     * Examples from http://www.jewishgen.org/infofiles/soundex.html\n     "
          }
        ],
        "testSoundexBasic2": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"467000|567000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "soundex(\"Ceniow\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Ceniow\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSoundexBasic2()",
            "parameters": [],
            "javadoc": "\n     * Examples from http://www.avotaynu.com/soundex.htm\n     "
          }
        ],
        "testSoundexBasic3": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"734000|739400\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "soundex(\"Peters\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Peters\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSoundexBasic3()",
            "parameters": [],
            "javadoc": "\n     * Examples from https://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex\n     "
          }
        ],
        "testSpecialRomanianCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"364000|464000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "soundex(\"amas\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DaitchMokotoffSoundexTest.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"amas\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSpecialRomanianCharacters()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link DaitchMokotoffSoundex}.\n * <p>\n * Keep this file in UTF-8 encoding for proper Javadoc processing.\n * </p>\n "
    },
    "org.apache.commons.codec.language.DoubleMetaphone2Test": {
      "fields": [
        {
          "variable_name": "ALTERNATE_INDEX",
          "variable_type": "int"
        },
        {
          "variable_name": "PRIMARY_INDEX",
          "variable_type": "int"
        },
        {
          "variable_name": "TEST_DATA",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "checkDoubleMetaphone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "alternate",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "TEST_DATA[i][typeIndex]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().doubleMetaphone(value, alternate)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Test [\" + i + \"]=\" + value",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void checkDoubleMetaphone(int, boolean)",
            "parameters": [
              {
                "variable_name": "typeIndex",
                "variable_type": "int"
              },
              {
                "variable_name": "alternate",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected DoubleMetaphone createStringEncoder()",
            "parameters": []
          }
        ],
        "testDoubleMetaphoneAlternate": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone2Test.checkDoubleMetaphone(int, boolean)",
                "arguments": [
                  {
                    "variable_name": "ALTERNATE_INDEX",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDoubleMetaphoneAlternate()",
            "parameters": [],
            "javadoc": "\n     * Test alternative encoding.\n     "
          }
        ],
        "testDoubleMetaphonePrimary": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone2Test.checkDoubleMetaphone(int, boolean)",
                "arguments": [
                  {
                    "variable_name": "PRIMARY_INDEX",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDoubleMetaphonePrimary()",
            "parameters": [],
            "javadoc": "\n     * Test primary encoding.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link DoubleMetaphone}.\n * <p>\n * The test data was extracted from Stephen Woodbridge's <a\n * href=\"https://swoodbridge.com/DoubleMetaPhone/surnames.txt\">PHP test program</a>.\n *\n * @see <a href=\"https://swoodbridge.com/DoubleMetaPhone/surnames.txt\">PHP test program</a>\n "
    },
    "org.apache.commons.codec.language.DoubleMetaphoneTest": {
      "fields": [
        {
          "variable_name": "FIXTURE",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "MATCHES",
          "variable_type": "java.lang.String"
        }
      ],
      "constructors": [],
      "methods": {
        "assertDoubleMetaphone": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Unexpected exception: \" + e",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(source)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) source",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "private void assertDoubleMetaphone(String, String)",
            "parameters": [
              {
                "variable_name": "expected",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Tests encoding APIs in one place.\n     "
          }
        ],
        "assertDoubleMetaphoneAlt": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().doubleMetaphone(source, true)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void assertDoubleMetaphoneAlt(String, String)",
            "parameters": [
              {
                "variable_name": "expected",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              }
            ],
            "javadoc": "\n     * Tests encoding APIs in one place.\n     "
          }
        ],
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected DoubleMetaphone createStringEncoder()",
            "parameters": []
          }
        ],
        "doubleMetaphoneEqualTest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name0",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.validateFixture(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "pairs",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "name0",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "useAlternate",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, useAlternate)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "failMsg",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public void doubleMetaphoneEqualTest(String[][], boolean)",
            "parameters": [
              {
                "variable_name": "pairs",
                "variable_type": "java.lang.String[][]"
              },
              {
                "variable_name": "useAlternate",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "doubleMetaphoneNotEqualTest": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Brain\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Band\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "\"Brain\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Band\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "alternate",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isDoubleMetaphoneEqual(\"Brain\", \"Band\", alternate)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public void doubleMetaphoneNotEqualTest(boolean)",
            "parameters": [
              {
                "variable_name": "alternate",
                "variable_type": "boolean"
              }
            ]
          }
        ],
        "testCCedilla": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\u00e7\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"S\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isDoubleMetaphoneEqual(\"\\u00e7\", \"S\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCCedilla()",
            "parameters": []
          }
        ],
        "testCodec184": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "new DoubleMetaphone().isDoubleMetaphoneEqual(\"aa\", \"\", false)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "new DoubleMetaphone().isDoubleMetaphoneEqual(\"\", \"\", false)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodec184()",
            "parameters": []
          }
        ],
        "testCodec320": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "\"ANGHELINA\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"ANKL\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "new DoubleMetaphone().isDoubleMetaphoneEqual(\"ANGHELINA\", \"ANKL\", false)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCodec320()",
            "parameters": []
          }
        ],
        "testDoubleMetaphone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.assertDoubleMetaphone(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"TSTN\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"testing\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.assertDoubleMetaphoneAlt(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"TSTN\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"testing\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDoubleMetaphone()",
            "parameters": []
          }
        ],
        "testEmpty": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().doubleMetaphone(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEmpty()",
            "parameters": []
          }
        ],
        "testIsDoubleMetaphoneEqualBasic": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.doubleMetaphoneEqualTest(java.lang.String[][], boolean)",
                "arguments": [
                  {
                    "variable_name": "testFixture",
                    "variable_type": "java.lang.String[][]"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsDoubleMetaphoneEqualBasic()",
            "parameters": []
          }
        ],
        "testIsDoubleMetaphoneEqualExtended1": [
          {
            "call_methods": [],
            "signature": "public void testIsDoubleMetaphoneEqualExtended1()",
            "parameters": [],
            "javadoc": "\n     * Example in the original article but failures in this Java impl:\n     "
          }
        ],
        "testIsDoubleMetaphoneEqualExtended2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.doubleMetaphoneEqualTest(java.lang.String[][], boolean)",
                "arguments": [
                  {
                    "variable_name": "testFixture",
                    "variable_type": "java.lang.String[][]"
                  },
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsDoubleMetaphoneEqualExtended2()",
            "parameters": []
          }
        ],
        "testIsDoubleMetaphoneEqualExtended3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.validateFixture(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "FIXTURE",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "name0",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.StringBuilder.append(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"private static final String[][] MATCHES = {\" + cr",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "java.lang.System.lineSeparator()",
                "arguments": [],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testIsDoubleMetaphoneEqualExtended3()",
            "parameters": [],
            "javadoc": "\n     * Used to generate the MATCHES array and test possible matches from the\n     * FIXTURE array.\n     "
          }
        ],
        "testIsDoubleMetaphoneEqualWithMATCHES": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.validateFixture(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "MATCHES",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "name0",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Expected match [\" + i + \"] \" + name0 + \" and \" + name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public void testIsDoubleMetaphoneEqualWithMATCHES()",
            "parameters": []
          }
        ],
        "testIsDoubleMetaphoneNotEqual": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphoneTest.doubleMetaphoneNotEqualTest(boolean)",
                "arguments": [
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsDoubleMetaphoneNotEqual()",
            "parameters": []
          }
        ],
        "testNTilde": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.isDoubleMetaphoneEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\\u00f1\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"N\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isDoubleMetaphoneEqual(\"\\u00f1\", \"N\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNTilde()",
            "parameters": []
          }
        ],
        "testSetMaxCodeLength": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.getMaxCodeLen()",
                "arguments": [],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.setMaxCodeLen(int)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.DoubleMetaphone.doubleMetaphone(java.lang.String, boolean)",
                "arguments": [
                  {
                    "variable_name": "value",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "doubleMetaphone.getMaxCodeLen()",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Default Max Code Length\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"JMPT\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "doubleMetaphone.doubleMetaphone(value, false)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Default Primary\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSetMaxCodeLength()",
            "parameters": [],
            "javadoc": "\n     * Test setting maximum length\n     "
          }
        ],
        "validateFixture": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Test fixture is empty\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public void validateFixture(String[][])",
            "parameters": [
              {
                "variable_name": "pairs",
                "variable_type": "java.lang.String[][]"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link DoubleMetaphone}.\n *\n * <p>Keep this file in UTF-8 encoding for proper Javadoc processing.</p>\n *\n * @see \"http://www.cuj.com/documents/s=8038/cuj0006philips/\"\n "
    },
    "org.apache.commons.codec.language.MatchRatingApproachEncoderTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected MatchRatingApproachEncoder createStringEncoder()",
            "parameters": []
          }
        ],
        "testAccentRemoval_AllLower_SuccessfullyRemoved": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"aeiou\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\"\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_AllLower_SuccessfullyRemoved()",
            "parameters": []
          }
        ],
        "testAccentRemoval_ComprehensiveAccentMix_AllSuccessfullyRemoved": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"E,E,E,E,U,U,I,I,A,A,O,e,e,e,e,u,u,i,i,a,a,o,c\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\",,,,,,,,,,,,,,,,,,,,,,\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\",,,,,,,,,,,,,,,,,,,,,,\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_ComprehensiveAccentMix_AllSuccessfullyRemoved()",
            "parameters": []
          }
        ],
        "testAccentRemoval_GerSpanFrenMix_SuccessfullyRemoved": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"aeouAEOUnNa\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\"\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_GerSpanFrenMix_SuccessfullyRemoved()",
            "parameters": []
          }
        ],
        "testAccentRemoval_MixedWithUnusualChars_SuccessfullyRemovedAndUnusualCharactersInvariant": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"A-e'i.,o&u\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\"-e'.,&\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"-e'.,&\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_MixedWithUnusualChars_SuccessfullyRemovedAndUnusualCharactersInvariant()",
            "parameters": []
          }
        ],
        "testAccentRemoval_NINO_NoChange": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\"\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_NINO_NoChange()",
            "parameters": []
          }
        ],
        "testAccentRemoval_NullValue_ReturnNullSuccessfully": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_NullValue_ReturnNullSuccessfully()",
            "parameters": []
          }
        ],
        "testAccentRemoval_UpperAndLower_SuccessfullyRemovedAndCaseInvariant": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AeiOuu\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\"euu\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"euu\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_UpperAndLower_SuccessfullyRemovedAndCaseInvariant()",
            "parameters": []
          }
        ],
        "testAccentRemoval_WithSpaces_SuccessfullyRemovedAndSpacesInvariant": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ae io  u\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\"   \")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"   \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemoval_WithSpaces_SuccessfullyRemovedAndSpacesInvariant()",
            "parameters": []
          }
        ],
        "testAccentRemovalNormalString_NoChange": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"Colorless green ideas sleep furiously\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeAccents(\"Colorless green ideas sleep furiously\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeAccents(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Colorless green ideas sleep furiously\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testAccentRemovalNormalString_NoChange()",
            "parameters": []
          }
        ],
        "testCleanName_SuccessfullyClean": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.cleanName(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"This-s   a t.,es &t\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"THISISATEST\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().cleanName(\"This-s   a t.,es &t\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCleanName_SuccessfullyClean()",
            "parameters": []
          }
        ],
        "testCompare_BRIAN_BRYAN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Brian\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Bryan\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Brian\", \"Bryan\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_BRIAN_BRYAN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_BURNS_BOURNE_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Burns\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Bourne\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Burns\", \"Bourne\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_BURNS_BOURNE_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_CATHERINE_KATHRYN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Catherine\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Kathryn\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Catherine\", \"Kathryn\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_CATHERINE_KATHRYN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_COLM_COLIN_WithAccentsAndSymbolsAndSpaces_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Clm.   \"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"C-oln\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Clm.   \", \"C-oln\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_COLM_COLIN_WithAccentsAndSymbolsAndSpaces_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Forenames_SEAN_JOHN_MatchExpected": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Sean\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"John\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Sean\", \"John\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Forenames_SEAN_JOHN_MatchExpected()",
            "parameters": []
          }
        ],
        "testCompare_Forenames_SEAN_PETE_NoMatchExpected": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Sean\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Pete\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Sean\", \"Pete\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_Forenames_SEAN_PETE_NoMatchExpected()",
            "parameters": []
          }
        ],
        "testCompare_Forenames_UNA_OONAGH_ShouldSuccessfullyMatchButDoesNot": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"na\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Oonagh\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"na\", \"Oonagh\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_Forenames_UNA_OONAGH_ShouldSuccessfullyMatchButDoesNot()",
            "parameters": []
          }
        ],
        "testCompare_FRANCISZEK_FRANCES_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Franciszek\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Frances\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Franciszek\", \"Frances\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_FRANCISZEK_FRANCES_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_KARL_ALESSANDRO_DoesNotMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Karl\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Alessandro\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Karl\", \"Alessandro\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_KARL_ALESSANDRO_DoesNotMatch()",
            "parameters": []
          }
        ],
        "testCompare_LongSurnames_MORIARTY_OMUIRCHEARTAIGH_DoesNotSuccessfulMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Moriarty\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"OMuircheartaigh\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Moriarty\", \"OMuircheartaigh\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_LongSurnames_MORIARTY_OMUIRCHEARTAIGH_DoesNotSuccessfulMatch()",
            "parameters": []
          }
        ],
        "testCompare_LongSurnames_OMUIRCHEARTAIGH_OMIREADHAIGH_SuccessfulMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"o'muireadhaigh\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\" 'Muircheartaigh \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"o'muireadhaigh\", \" 'Muircheartaigh \")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_LongSurnames_OMUIRCHEARTAIGH_OMIREADHAIGH_SuccessfulMatch()",
            "parameters": []
          }
        ],
        "testCompare_MCGOWAN_MCGEOGHEGAN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"McGowan\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Mc Geoghegan\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"McGowan\", \"Mc Geoghegan\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_MCGOWAN_MCGEOGHEGAN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_MICKY_MICHAEL_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Micky\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Michael\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Micky\", \"Michael\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_MICKY_MICHAEL_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_OONA_OONAGH_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Oona\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Oonagh\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Oona\", \"Oonagh\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_OONA_OONAGH_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_PETERSON_PETERS_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Peterson\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Peters\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Peterson\", \"Peters\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_PETERSON_PETERS_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_SAM_SAMUEL_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Sam\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Samuel\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Sam\", \"Samuel\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_SAM_SAMUEL_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_SEAN_SHAUN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"San\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Shaun\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"San\", \"Shaun\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_SEAN_SHAUN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_ShortNames_AL_ED_WorksButNoMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Al\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Ed\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Al\", \"Ed\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_ShortNames_AL_ED_WorksButNoMatch()",
            "parameters": []
          }
        ],
        "testCompare_SmallInput_CARK_Kl_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Kl\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Karl\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Kl\", \"Karl\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_SmallInput_CARK_Kl_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_SMITH_SMYTH_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"smith\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"smyth\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"smith\", \"smyth\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_SMITH_SMYTH_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_SOPHIE_SOFIA_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Sophie\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Sofia\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Sophie\", \"Sofia\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_SOPHIE_SOFIA_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_STEPHEN_STEFAN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Stephen\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Stefan\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Stephen\", \"Stefan\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_STEPHEN_STEFAN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_STEPHEN_STEVEN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Stephen\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Steven\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Stephen\", \"Steven\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_STEPHEN_STEVEN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_STEVEN_STEFAN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Steven\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Stefan\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Steven\", \"Stefan\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_STEVEN_STEFAN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_AUERBACH_UHRBACH_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Auerbach\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Uhrbach\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Auerbach\", \"Uhrbach\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_AUERBACH_UHRBACH_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_COOPERFLYNN_SUPERLYN_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Cooper-Flynn\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Super-Lyn\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Cooper-Flynn\", \"Super-Lyn\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_COOPERFLYNN_SUPERLYN_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_HAILEY_HALLEY_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hailey\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Halley\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Hailey\", \"Halley\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_HAILEY_HALLEY_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_LEWINSKY_LEVINSKI_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"LEWINSKY\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"LEVINSKI\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"LEWINSKY\", \"LEVINSKI\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_LEWINSKY_LEVINSKI_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_LIPSHITZ_LIPPSZYC_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"LIPSHITZ\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"LIPPSZYC\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"LIPSHITZ\", \"LIPPSZYC\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_LIPSHITZ_LIPPSZYC_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_MOSKOWITZ_MOSKOVITZ_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Moskowitz\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Moskovitz\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Moskowitz\", \"Moskovitz\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_MOSKOWITZ_MOSKOVITZ_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_OSULLIVAN_OSUILLEABHAIN_SuccessfulMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"O'Sullivan\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\" ' Silleabhin\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"O'Sullivan\", \" ' Silleabhin\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_OSULLIVAN_OSUILLEABHAIN_SuccessfulMatch()",
            "parameters": []
          }
        ],
        "testCompare_Surname_PRZEMYSL_PSHEMESHIL_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\" P rz e m y s l\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\" P sh e m e sh i l\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\" P rz e m y s l\", \" P sh e m e sh i l\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_PRZEMYSL_PSHEMESHIL_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_ROSOCHOWACIEC_ROSOKHOVATSETS_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"R o s o ch o w a c ie c\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\" R o s o k ho v a ts e ts\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"R o s o ch o w a c ie c\", \" R o s o k ho v a ts e ts\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_ROSOCHOWACIEC_ROSOKHOVATSETS_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_Surname_SZLAMAWICZ_SHLAMOVITZ_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SZLAMAWICZ\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"SHLAMOVITZ\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"SZLAMAWICZ\", \"SHLAMOVITZ\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_Surname_SZLAMAWICZ_SHLAMOVITZ_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_SurnameCornerCase_Nulls_NoMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(null, null)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_SurnameCornerCase_Nulls_NoMatch()",
            "parameters": []
          }
        ],
        "testCompare_Surnames_MURPHY_LYNCH_NoMatchExpected": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Murphy\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Lynch\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Murphy\", \"Lynch\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_Surnames_MURPHY_LYNCH_NoMatchExpected()",
            "parameters": []
          }
        ],
        "testCompare_SurnamesCornerCase_MURPHY_NoSpace_NoMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Murphy\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Murphy\", \"\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_SurnamesCornerCase_MURPHY_NoSpace_NoMatch()",
            "parameters": []
          }
        ],
        "testCompare_SurnamesCornerCase_MURPHY_Space_NoMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Murphy\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\" \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Murphy\", \" \")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompare_SurnamesCornerCase_MURPHY_Space_NoMatch()",
            "parameters": []
          }
        ],
        "testCompare_TOMASZ_TOM_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Tomasz\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"tom\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Tomasz\", \"tom\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_TOMASZ_TOM_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompare_ZACH_ZAKARIA_SuccessfullyMatched": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Zach\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"Zacharia\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Zach\", \"Zacharia\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompare_ZACH_ZAKARIA_SuccessfullyMatched()",
            "parameters": []
          }
        ],
        "testCompareNameNullSpace_ReturnsFalseSuccessfully": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\" \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "getStringEncoder().isEncodeEquals(null, \" \")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompareNameNullSpace_ReturnsFalseSuccessfully()",
            "parameters": []
          }
        ],
        "testCompareNameSameNames_ReturnsFalseSuccessfully": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"John\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"John\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "getStringEncoder().isEncodeEquals(\"John\", \"John\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testCompareNameSameNames_ReturnsFalseSuccessfully()",
            "parameters": []
          }
        ],
        "testCompareNameToSingleLetter_KARL_C_DoesNotMatch": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Karl\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"C\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"Karl\", \"C\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testCompareNameToSingleLetter_KARL_C_DoesNotMatch()",
            "parameters": []
          }
        ],
        "testGetEncoding_HARPER_HRPR": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"HARPER\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"HRPR\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"HARPER\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testGetEncoding_HARPER_HRPR()",
            "parameters": []
          }
        ],
        "testGetEncoding_NoSpace_to_Nothing": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testGetEncoding_NoSpace_to_Nothing()",
            "parameters": []
          }
        ],
        "testGetEncoding_Null_to_Nothing": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testGetEncoding_Null_to_Nothing()",
            "parameters": []
          }
        ],
        "testGetEncoding_One_Letter_to_Nothing": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"E\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"E\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testGetEncoding_One_Letter_to_Nothing()",
            "parameters": []
          }
        ],
        "testGetEncoding_SMITH_to_SMTH": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Smith\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"SMTH\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Smith\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testGetEncoding_SMITH_to_SMTH()",
            "parameters": []
          }
        ],
        "testGetEncoding_SMYTH_to_SMYTH": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Smyth\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"SMYTH\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Smyth\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testGetEncoding_SMYTH_to_SMYTH()",
            "parameters": []
          }
        ],
        "testGetEncoding_Space_to_Nothing": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\" \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\" \")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testGetEncoding_Space_to_Nothing()",
            "parameters": []
          }
        ],
        "testGetFirstLast3__ALEXANDER_Returns_Aleder": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"Aleder\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getFirst3Last3(\"Alexzander\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Alexzander\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testGetFirstLast3__ALEXANDER_Returns_Aleder()",
            "parameters": []
          }
        ],
        "testGetFirstLast3_PETE_Returns_PETE": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"PETE\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getFirst3Last3(\"PETE\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getFirst3Last3(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"PETE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testGetFirstLast3_PETE_Returns_PETE()",
            "parameters": []
          }
        ],
        "testGetMinRating_1_Returns5_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(1)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testGetMinRating_1_Returns5_Successfully()",
            "parameters": []
          }
        ],
        "testgetMinRating_10_Returns3_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(10)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "10",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testgetMinRating_10_Returns3_Successfully()",
            "parameters": []
          }
        ],
        "testgetMinRating_11_Returns_3_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(11)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "11",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testgetMinRating_11_Returns_3_Successfully()",
            "parameters": []
          }
        ],
        "testGetMinRating_13_Returns_1_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "1",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(13)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "13",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testGetMinRating_13_Returns_1_Successfully()",
            "parameters": []
          }
        ],
        "testGetMinRating_2_Returns5_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(2)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "2",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testGetMinRating_2_Returns5_Successfully()",
            "parameters": []
          }
        ],
        "testgetMinRating_5_Returns4_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(5)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testgetMinRating_5_Returns4_Successfully()",
            "parameters": []
          }
        ],
        "testgetMinRating_5_Returns4_Successfully2": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(5)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "5",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testgetMinRating_5_Returns4_Successfully2()",
            "parameters": []
          }
        ],
        "testgetMinRating_6_Returns4_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(6)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testgetMinRating_6_Returns4_Successfully()",
            "parameters": []
          }
        ],
        "testGetMinRating_7_Return4_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(7)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "7",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testGetMinRating_7_Return4_Successfully()",
            "parameters": []
          }
        ],
        "testgetMinRating_7_Returns4_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(7)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "7",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testgetMinRating_7_Returns4_Successfully()",
            "parameters": []
          }
        ],
        "testgetMinRating_8_Returns3_Successfully": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().getMinRating(8)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.getMinRating(int)",
                "arguments": [
                  {
                    "variable_name": "8",
                    "variable_type": "int"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testgetMinRating_8_Returns3_Successfully()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals_CornerCase_FirstNameJust1Letter_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"t\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"t\", \"test\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEquals_CornerCase_FirstNameJust1Letter_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals_CornerCase_FirstNameJustSpace_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\" \"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\" \", \"test\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEquals_CornerCase_FirstNameJustSpace_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals_CornerCase_FirstNameNothing_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"\", \"test\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEquals_CornerCase_FirstNameNothing_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals_CornerCase_FirstNameNull_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(null, \"test\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEquals_CornerCase_FirstNameNull_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals_CornerCase_SecondNameJustSpace_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\" \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"test\", \" \")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEquals_CornerCase_SecondNameJustSpace_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals_CornerCase_SecondNameNothing_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"test\", \"\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEquals_CornerCase_SecondNameNothing_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsEncodeEquals_CornerCase_SecondNameNull_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"test\", null)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEquals_CornerCase_SecondNameNull_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsEncodeEqualsSecondNameJust1Letter_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isEncodeEquals(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"t\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isEncodeEquals(\"test\", \"t\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsEncodeEqualsSecondNameJust1Letter_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testIsVowel_CapitalA_ReturnsTrue": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"A\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isVowel(\"A\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testIsVowel_CapitalA_ReturnsTrue()",
            "parameters": []
          }
        ],
        "testIsVowel_SingleVowel_ReturnsTrue": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"I\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isVowel(\"I\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testIsVowel_SingleVowel_ReturnsTrue()",
            "parameters": []
          }
        ],
        "testIsVowel_SmallD_ReturnsFalse": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.isVowel(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"d\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isVowel(\"d\")",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testIsVowel_SmallD_ReturnsFalse()",
            "parameters": []
          }
        ],
        "testLeftToRightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"ALEXANDER\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"ALEXANDRA\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "4",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().leftToRightThenRightToLeftProcessing(\"ALEXANDER\", \"ALEXANDRA\")",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testLeftToRightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4()",
            "parameters": []
          }
        ],
        "testLeftToRightThenRightToLeft_EINSTEIN_MICHAELA_Returns0": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.leftToRightThenRightToLeftProcessing(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"EINSTEIN\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"MICHAELA\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().leftToRightThenRightToLeftProcessing(\"EINSTEIN\", \"MICHAELA\")",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public final void testLeftToRightThenRightToLeft_EINSTEIN_MICHAELA_Returns0()",
            "parameters": []
          }
        ],
        "testPunctuationOnly": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\".,-\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().encode(\".,-\")",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testPunctuationOnly()",
            "parameters": []
          }
        ],
        "testRemoveDoubleConsonants_MISSISSIPPI_RemovedSuccessfully": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"MISISIPI\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeDoubleConsonants(\"MISSISSIPPI\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"MISSISSIPPI\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testRemoveDoubleConsonants_MISSISSIPPI_RemovedSuccessfully()",
            "parameters": []
          }
        ],
        "testRemoveDoubleDoubleVowel_BEETLE_NotRemoved": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"BEETLE\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeDoubleConsonants(\"BEETLE\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"BEETLE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testRemoveDoubleDoubleVowel_BEETLE_NotRemoved()",
            "parameters": []
          }
        ],
        "testRemoveSingleDoubleConsonants_BUBLE_RemovedSuccessfully": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"BUBLE\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeDoubleConsonants(\"BUBBLE\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeDoubleConsonants(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"BUBBLE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testRemoveSingleDoubleConsonants_BUBLE_RemovedSuccessfully()",
            "parameters": []
          }
        ],
        "testRemoveVowel__AIDAN_Returns_ADN": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ADN\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeVowels(\"AIDAN\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"AIDAN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testRemoveVowel__AIDAN_Returns_ADN()",
            "parameters": []
          }
        ],
        "testRemoveVowel__DECLAN_Returns_DCLN": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"DCLN\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeVowels(\"DECLAN\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"DECLAN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testRemoveVowel__DECLAN_Returns_DCLN()",
            "parameters": []
          }
        ],
        "testRemoveVowel_ALESSANDRA_Returns_ALSSNDR": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"ALSSNDR\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().removeVowels(\"ALESSANDRA\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.removeVowels(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"ALESSANDRA\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public final void testRemoveVowel_ALESSANDRA_Returns_ALSSNDR()",
            "parameters": []
          }
        ],
        "testVowelAndPunctuationOnly": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"uoiea.,-AEIOU\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().encode(\"uoiea.,-AEIOU\")",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"U\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testVowelAndPunctuationOnly()",
            "parameters": []
          }
        ],
        "testVowelOnly": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MatchRatingApproachEncoder.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"aeiouAEIOU\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().encode(\"aeiouAEIOU\")",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"A\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public final void testVowelOnly()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Series of tests for the Match Rating Approach algorithm.\n *\n * General naming nomenclature for the test is of the form:\n * GeneralMetadataOnTheTestArea_ActualTestValues_ExpectedResult\n *\n * An unusual value is indicated by the term \"corner case\"\n "
    },
    "org.apache.commons.codec.language.MetaphoneTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "assertIsMetaphoneEqual": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isMetaphoneEqual(source, matche)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "\"Source: \" + source + \", should have same Metaphone as: \" + matche",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "source",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "matche",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isMetaphoneEqual(matche, matche2)",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void assertIsMetaphoneEqual(String, String[])",
            "parameters": [
              {
                "variable_name": "source",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "matches",
                "variable_type": "java.lang.String[]"
              }
            ]
          }
        ],
        "assertMetaphoneEqual": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.validateFixture(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "pairs",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "this.getStringEncoder().isMetaphoneEqual(name0, name1)",
                    "variable_type": "boolean"
                  },
                  {
                    "variable_name": "failMsg",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.isMetaphoneEqual(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "name0",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "name1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void assertMetaphoneEqual(String[][])",
            "parameters": [
              {
                "variable_name": "pairs",
                "variable_type": "java.lang.String[][]"
              }
            ]
          }
        ],
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected Metaphone createStringEncoder()",
            "parameters": []
          }
        ],
        "testDiscardOfSCEOrSCIOrSCY": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SCIENCE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"SNS\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"SCIENCE\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDiscardOfSCEOrSCIOrSCY()",
            "parameters": []
          }
        ],
        "testDiscardOfSilentGN": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"GNU\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"N\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"GNU\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDiscardOfSilentGN()",
            "parameters": []
          }
        ],
        "testDiscardOfSilentHAfterG": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"GHENT\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"KNT\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"GHENT\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDiscardOfSilentHAfterG()",
            "parameters": []
          }
        ],
        "testExceedLength": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"AXEAXE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AKSK\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"AXEAXE\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testExceedLength()",
            "parameters": []
          }
        ],
        "testIsMetaphoneEqual1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertMetaphoneEqual(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "new String[][] { { \"Case\", \"case\" }, { \"CASE\", \"Case\" }, { \"caSe\", \"cAsE\" }, { \"quick\", \"cookie\" } }",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqual1()",
            "parameters": []
          }
        ],
        "testIsMetaphoneEqual2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertMetaphoneEqual(java.lang.String[][])",
                "arguments": [
                  {
                    "variable_name": "new String[][] { { \"Lawrence\", \"Lorenza\" }, { \"Gary\", \"Cahra\" } }",
                    "variable_type": "java.lang.String[][]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqual2()",
            "parameters": [],
            "javadoc": "\n     * Matches computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualAero": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Aero\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Eure\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualAero()",
            "parameters": [],
            "javadoc": "\n     * Initial AE case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualAlbert": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Albert\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Ailbert\", \"Alberik\", \"Albert\", \"Alberto\", \"Albrecht\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualAlbert()",
            "parameters": [],
            "javadoc": "\n     * Initial A, not followed by an E case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualGary": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Gary\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Cahra\", \"Cara\", \"Carey\", \"Cari\", \"Caria\", \"Carie\", \"Caro\", \"Carree\", \"Carri\", \"Carrie\", \"Carry\", \"Cary\", \"Cora\", \"Corey\", \"Cori\", \"Corie\", \"Correy\", \"Corri\", \"Corrie\", \"Corry\", \"Cory\", \"Gray\", \"Kara\", \"Kare\", \"Karee\", \"Kari\", \"Karia\", \"Karie\", \"Karrah\", \"Karrie\", \"Karry\", \"Kary\", \"Keri\", \"Kerri\", \"Kerrie\", \"Kerry\", \"Kira\", \"Kiri\", \"Kora\", \"Kore\", \"Kori\", \"Korie\", \"Korrie\", \"Korry\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualGary()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualJohn": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"John\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Gena\", \"Gene\", \"Genia\", \"Genna\", \"Genni\", \"Gennie\", \"Genny\", \"Giana\", \"Gianna\", \"Gina\", \"Ginni\", \"Ginnie\", \"Ginny\", \"Jaine\", \"Jan\", \"Jana\", \"Jane\", \"Janey\", \"Jania\", \"Janie\", \"Janna\", \"Jany\", \"Jayne\", \"Jean\", \"Jeana\", \"Jeane\", \"Jeanie\", \"Jeanna\", \"Jeanne\", \"Jeannie\", \"Jen\", \"Jena\", \"Jeni\", \"Jenn\", \"Jenna\", \"Jennee\", \"Jenni\", \"Jennie\", \"Jenny\", \"Jinny\", \"Jo Ann\", \"Jo-Ann\", \"Jo-Anne\", \"Joan\", \"Joana\", \"Joane\", \"Joanie\", \"Joann\", \"Joanna\", \"Joanne\", \"Joeann\", \"Johna\", \"Johnna\", \"Joni\", \"Jonie\", \"Juana\", \"June\", \"Junia\", \"Junie\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualJohn()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualKnight": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Knight\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Hynda\", \"Nada\", \"Nadia\", \"Nady\", \"Nat\", \"Nata\", \"Natty\", \"Neda\", \"Nedda\", \"Nedi\", \"Netta\", \"Netti\", \"Nettie\", \"Netty\", \"Nita\", \"Nydia\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualKnight()",
            "parameters": [],
            "javadoc": "\n     * Initial KN case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualMary": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Mary\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Mair\", \"Maire\", \"Mara\", \"Mareah\", \"Mari\", \"Maria\", \"Marie\", \"Mary\", \"Maura\", \"Maure\", \"Meara\", \"Merrie\", \"Merry\", \"Mira\", \"Moira\", \"Mora\", \"Moria\", \"Moyra\", \"Muire\", \"Myra\", \"Myrah\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualMary()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualParis": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Paris\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Pearcy\", \"Perris\", \"Piercy\", \"Pierz\", \"Pryse\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualParis()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualPeter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Peter\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Peadar\", \"Peder\", \"Pedro\", \"Peter\", \"Petr\", \"Peyter\", \"Pieter\", \"Pietro\", \"Piotr\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualPeter()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualRay": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Ray\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Ray\", \"Rey\", \"Roi\", \"Roy\", \"Ruy\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualRay()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualSusan": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Susan\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Siusan\", \"Sosanna\", \"Susan\", \"Susana\", \"Susann\", \"Susanna\", \"Susannah\", \"Susanne\", \"Suzann\", \"Suzanna\", \"Suzanne\", \"Zuzana\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualSusan()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualWhite": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"White\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Wade\", \"Wait\", \"Waite\", \"Wat\", \"Whit\", \"Wiatt\", \"Wit\", \"Wittie\", \"Witty\", \"Wood\", \"Woodie\", \"Woody\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualWhite()",
            "parameters": [],
            "javadoc": "\n     * Initial WH case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualWright": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Wright\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Rota\", \"Rudd\", \"Ryde\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualWright()",
            "parameters": [],
            "javadoc": "\n     * Initial WR case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testIsMetaphoneEqualXalan": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.MetaphoneTest.assertIsMetaphoneEqual(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"Xalan\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Celene\", \"Celina\", \"Celine\", \"Selena\", \"Selene\", \"Selina\", \"Seline\", \"Suellen\", \"Xylina\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testIsMetaphoneEqualXalan()",
            "parameters": [],
            "javadoc": "\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm\n     "
          }
        ],
        "testMetaphone": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"howl\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"HL\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"howl\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMetaphone()",
            "parameters": []
          }
        ],
        "testPHTOF": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"PHISH\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"FX\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"PHISH\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testPHTOF()",
            "parameters": []
          }
        ],
        "testSetMaxLengthWithTruncation": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"AXEAXEAXE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.language.Metaphone.setMaxCodeLen(int)",
                "arguments": [
                  {
                    "variable_name": "6",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"AKSKSK\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"AXEAXEAXE\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSetMaxLengthWithTruncation()",
            "parameters": []
          }
        ],
        "testSHAndSIOAndSIAToX": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SHOT\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"XT\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"SHOT\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSHAndSIOAndSIAToX()",
            "parameters": []
          }
        ],
        "testTCH": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"RETCH\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"RX\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"RETCH\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testTCH()",
            "parameters": []
          }
        ],
        "testTIOAndTIAToX": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"OTIA\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"OX\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"OTIA\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testTIOAndTIAToX()",
            "parameters": []
          }
        ],
        "testTranslateOfSCHAndCH": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"SCHEDULE\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"SKTL\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"SCHEDULE\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testTranslateOfSCHAndCH()",
            "parameters": []
          }
        ],
        "testTranslateToJOfDGEOrDGIOrDGY": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"DODGY\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"TJ\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"DODGY\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testTranslateToJOfDGEOrDGIOrDGY()",
            "parameters": []
          }
        ],
        "testWhy": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"WHY\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"WHY\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWhy()",
            "parameters": [],
            "javadoc": "\n     * Tests (CODEC-57) Metaphone.metaphone(String) returns an empty string when passed the word \"why\"\n     "
          }
        ],
        "testWordEndingInMB": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"COMB\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"KM\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"COMB\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWordEndingInMB()",
            "parameters": []
          }
        ],
        "testWordsWithCIA": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Metaphone.metaphone(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"CIAPO\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"XP\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().metaphone(\"CIAPO\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWordsWithCIA()",
            "parameters": []
          }
        ],
        "validateFixture": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.fail(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Test fixture is empty\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "V"
              }
            ],
            "signature": "public void validateFixture(String[][])",
            "parameters": [
              {
                "variable_name": "pairs",
                "variable_type": "java.lang.String[][]"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n "
    },
    "org.apache.commons.codec.language.NysiisTest": {
      "fields": [
        {
          "variable_name": "fullNysiis",
          "variable_type": "org.apache.commons.codec.language.Nysiis"
        }
      ],
      "constructors": [],
      "methods": {
        "assertEncodings": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Nysiis.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "arr[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "arr[1]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.fullNysiis.encode(arr[0])",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Problem with \" + arr[0]",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void assertEncodings(String[]...)",
            "parameters": [
              {
                "variable_name": "testValues",
                "variable_type": "java.lang.String[]"
              }
            ],
            "javadoc": "\n     * Takes an array of String pairs where each pair's first element is the input and the second element the expected\n     * encoding.\n     *\n     * @param testValues\n     *            an array of String pairs where each pair's first element is the input and the second element the\n     *            expected encoding.\n     "
          }
        ],
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected Nysiis createStringEncoder()",
            "parameters": []
          }
        ],
        "encodeAll": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Nysiis.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "string",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expectedEncoding",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "getStringEncoder().encode(string)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Problem with \" + string",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "private void encodeAll(String[], String)",
            "parameters": [
              {
                "variable_name": "strings",
                "variable_type": "java.lang.String[]"
              },
              {
                "variable_name": "expectedEncoding",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testBran": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Brian\", \"Brown\", \"Brun\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"BRAN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBran()",
            "parameters": []
          }
        ],
        "testCap": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Capp\", \"Cope\", \"Copp\", \"Kipp\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"CAP\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testCap()",
            "parameters": []
          }
        ],
        "testDad": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Dent\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"DAD\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDad()",
            "parameters": []
          }
        ],
        "testDan": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Dane\", \"Dean\", \"Dionne\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"DAN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDan()",
            "parameters": []
          }
        ],
        "testDropBy": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "// 1. Transcode first characters of name\r\nnew String[] { \"MACINTOSH\", \"MCANT\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// violates 4j: the second N should not be added, as the first\r\n//              key char is already a N\r\n// Original: NNAT; modified: NATH\r\nnew String[] { \"KNUTH\", \"NAT\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// O and E are transcoded to A because of rule 4a\r\n// H also to A because of rule 4h\r\n// the N gets mysteriously lost, maybe because of a wrongly implemented rule 4h\r\n// that skips the next char in such a case?\r\n// the remaining A is removed because of rule 7\r\n// Original: C\r\nnew String[] { \"KOEHN\", \"CAN\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// violates 4j: see also KNUTH\r\n// Original: FFALAP[SAN]\r\nnew String[] { \"PHILLIPSON\", \"FALAPSAN\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// violates 4j: see also KNUTH\r\n// Original: FFASTA[R]\r\nnew String[] { \"PFEISTER\", \"FASTAR\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// violates 4j: see also KNUTH\r\n// Original: SSANAF[T]\r\nnew String[] { \"SCHOENHOEFT\", \"SANAFT\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// 2. Transcode last characters of name:\r\nnew String[] { \"MCKEE\", \"MCY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"MACKIE\", \"MCY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"HEITSCHMIDT\", \"HATSNAD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"BART\", \"BAD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"HURD\", \"HAD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"HUNT\", \"HAD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"WESTERLUND\", \"WASTARLAD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// 4. Transcode remaining characters by following these rules,\r\n//    incrementing by one character each time:\r\nnew String[] { \"CASSTEVENS\", \"CASTAFAN\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"VASQUEZ\", \"VASG\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"FRAZIER\", \"FRASAR\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"BOWMAN\", \"BANAN\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"MCKNIGHT\", \"MCNAGT\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"RICKERT\", \"RACAD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// violates 5: the last S is not removed\r\n// when comparing to DEUTS, which is phonetically similar\r\n// the result it also DAT, which is correct for DEUTSCH too imo\r\n// Original: DATS\r\nnew String[] { \"DEUTSCH\", \"DAT\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"WESTPHAL\", \"WASTFAL\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// violates 4h: the H should be transcoded to S and thus ignored as\r\n// the first key character is also S\r\n// Original: SHRAVA[R]\r\nnew String[] { \"SHRIVER\", \"SRAVAR\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// same as KOEHN, the L gets mysteriously lost\r\n// Original: C\r\nnew String[] { \"KUHL\", \"CAL\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"RAWSON\", \"RASAN\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// If last character is S, remove it\r\nnew String[] { \"JILES\", \"JAL\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// violates 6: if the last two characters are AY, remove A\r\n// Original: CARAY\r\nnew String[] { \"CARRAWAY\", \"CARY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"YAMADA\", \"YANAD\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testDropBy()",
            "parameters": [],
            "javadoc": "\n     * Tests data gathered from around the internet.\n     *\n     * @see <a href=\"http://www.dropby.com/NYSIISTextStrings.html\">http://www.dropby.com/NYSIISTextStrings.html</a>"
          }
        ],
        "testFal": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Phil\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"FAL\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testFal()",
            "parameters": []
          }
        ],
        "testOthers": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"O'Daniel\", \"ODANAL\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"O'Donnel\", \"ODANAL\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"Cory\", \"CARY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"Corey\", \"CARY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"Kory\", \"CARY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "//\r\nnew String[] { \"FUZZY\", \"FASY\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testOthers()",
            "parameters": [],
            "javadoc": "\n     * Tests data gathered from around the internets."
          }
        ],
        "testRule1": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"MACX\", \"MCX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"KNX\", \"NX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"KX\", \"CX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"PHX\", \"FX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"PFX\", \"FX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"SCHX\", \"SX\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testRule1()",
            "parameters": [],
            "javadoc": "\n     * Tests rule 1: Translate first characters of name: MAC  MCC, KN  N, K  C, PH, PF  FF, SCH  SSS"
          }
        ],
        "testRule2": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"XEE\", \"XY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XIE\", \"XY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XDT\", \"XD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XRT\", \"XD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XRD\", \"XD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XNT\", \"XD\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XND\", \"XD\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testRule2()",
            "parameters": [],
            "javadoc": "\n     * Tests rule 2: Translate last characters of name: EE  Y, IE  Y, DT, RT, RD, NT, ND  D"
          }
        ],
        "testRule4Dot1": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"XEV\", \"XAF\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XAX\", \"XAX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XEX\", \"XAX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XIX\", \"XAX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XOX\", \"XAX\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XUX\", \"XAX\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testRule4Dot1()",
            "parameters": [],
            "javadoc": "\n     * Tests rule 4.1: EV  AF else A, E, I, O, U  A"
          }
        ],
        "testRule4Dot2": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"XQ\", \"XG\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XZ\", \"X\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XM\", \"XN\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testRule4Dot2()",
            "parameters": [],
            "javadoc": "\n     * Tests rule 4.2: Q  G, Z  S, M  N"
          }
        ],
        "testRule5": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"XS\", \"X\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "new String[] { \"XSS\", \"X\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testRule5()",
            "parameters": [],
            "javadoc": "\n     * Tests rule 5: If last character is S, remove it."
          }
        ],
        "testRule6": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"XAY\", \"XY\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// Rules 5, 6\r\nnew String[] { \"XAYS\", \"XY\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testRule6()",
            "parameters": [],
            "javadoc": "\n     * Tests rule 6: If last characters are AY, replace with Y."
          }
        ],
        "testRule7": [
          {
            "call_methods": [
              {
                "signature": "assertEncodings",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"XA\", \"X\" }",
                    "variable_type": "unresolved"
                  },
                  {
                    "variable_name": "// Rules 5, 7\r\nnew String[] { \"XAS\", \"X\" }",
                    "variable_type": "unresolved"
                  }
                ],
                "return_type": "unresolved"
              }
            ],
            "signature": "public void testRule7()",
            "parameters": [],
            "javadoc": "\n     * Tests rule 7: If last character is A, remove it."
          }
        ],
        "testSnad": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Schmidt\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"SNAD\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSnad()",
            "parameters": []
          }
        ],
        "testSnat": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Smith\", \"Schmit\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"SNAT\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSnat()",
            "parameters": []
          }
        ],
        "testSpecialBranches": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Kobwick\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"CABWAC\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSpecialBranches()",
            "parameters": []
          }
        ],
        "testTranan": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.NysiisTest.encodeAll(java.lang.String[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String[] { \"Trueman\", \"Truman\" }",
                    "variable_type": "java.lang.String[]"
                  },
                  {
                    "variable_name": "\"TRANAN\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testTranan()",
            "parameters": []
          }
        ],
        "testTrueVariant": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Nysiis.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"WESTERLUND\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"WASTAR\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "encoded.length() <= 6",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.length()",
                "arguments": [],
                "return_type": "int"
              }
            ],
            "signature": "public void testTrueVariant()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link Nysiis}\n "
    },
    "org.apache.commons.codec.language.RefinedSoundexTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected RefinedSoundex createStringEncoder()",
            "parameters": []
          }
        ],
        "testDifference": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().difference(null, null)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.difference(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public void testDifference()",
            "parameters": []
          }
        ],
        "testEncode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"testing\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"T6036084\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"testing\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncode()",
            "parameters": []
          }
        ],
        "testGetMappingCodeNonLetter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.getMappingCode(char)",
                "arguments": [
                  {
                    "variable_name": "'#'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "char"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "code",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Code does not equals zero\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGetMappingCodeNonLetter()",
            "parameters": []
          }
        ],
        "testInvalidSoundexCharacter": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "new String(invalid)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "new RefinedSoundex().encode(new String(invalid))",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"A0136024043780159360205050136024043780159360205053\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testInvalidSoundexCharacter()",
            "parameters": []
          }
        ],
        "testNewInstance": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"dogs\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"D6043\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new RefinedSoundex().soundex(\"dogs\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNewInstance()",
            "parameters": []
          }
        ],
        "testNewInstance2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"dogs\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"D6043\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new RefinedSoundex(RefinedSoundex.US_ENGLISH_MAPPING_STRING.toCharArray()).soundex(\"dogs\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testNewInstance2()",
            "parameters": []
          }
        ],
        "testNewInstance3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.RefinedSoundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"dogs\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"D6043\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new RefinedSoundex(RefinedSoundex.US_ENGLISH_MAPPING_STRING).soundex(\"dogs\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNewInstance3()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests RefinedSoundex.\n "
    },
    "org.apache.commons.codec.language.SoundexTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "createStringEncoder": [
          {
            "call_methods": [],
            "signature": "protected Soundex createStringEncoder()",
            "parameters": []
          }
        ],
        "testB650": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"B650\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"BARHAM\", \"BARONE\", \"BARRON\", \"BERNA\", \"BIRNEY\", \"BIRNIE\", \"BOOROM\", \"BOREN\", \"BORN\", \"BOURN\", \"BOURNE\", \"BOWRON\", \"BRAIN\", \"BRAME\", \"BRANN\", \"BRAUN\", \"BREEN\", \"BRIEN\", \"BRIM\", \"BRIMM\", \"BRINN\", \"BRION\", \"BROOM\", \"BROOME\", \"BROWN\", \"BROWNE\", \"BRUEN\", \"BRUHN\", \"BRUIN\", \"BRUMM\", \"BRUN\", \"BRUNO\", \"BRYAN\", \"BURIAN\", \"BURN\", \"BURNEY\", \"BYRAM\", \"BYRNE\", \"BYRON\", \"BYRUM\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testB650()",
            "parameters": []
          }
        ],
        "testBadCharacters": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"HOL>MES\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"H452\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"HOL>MES\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBadCharacters()",
            "parameters": []
          }
        ],
        "testDifference": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "this.getStringEncoder().difference(null, null)",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.Soundex.difference(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              }
            ],
            "signature": "public void testDifference()",
            "parameters": []
          }
        ],
        "testEncodeBasic": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"testing\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"T235\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"testing\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeBasic()",
            "parameters": []
          }
        ],
        "testEncodeBatch2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Allricht\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"A462\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Allricht\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeBatch2()",
            "parameters": [],
            "javadoc": "\n     * Examples from http://www.bradandkathy.com/genealogy/overviewofsoundex.html\n     "
          }
        ],
        "testEncodeBatch3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Washington\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"W252\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Washington\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeBatch3()",
            "parameters": [],
            "javadoc": "\n     * Examples from http://www.archives.gov/research_room/genealogy/census/soundex.html\n     "
          }
        ],
        "testEncodeBatch4": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"HOLMES\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"H452\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"HOLMES\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeBatch4()",
            "parameters": [],
            "javadoc": "\n     * Examples from: http://www.myatt.demon.co.uk/sxalg.htm\n     "
          }
        ],
        "testEncodeIgnoreApostrophes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"O165\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"OBrien\", \"'OBrien\", \"O'Brien\", \"OB'rien\", \"OBr'ien\", \"OBri'en\", \"OBrie'n\", \"OBrien'\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeIgnoreApostrophes()",
            "parameters": []
          }
        ],
        "testEncodeIgnoreHyphens": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"K525\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"KINGSMITH\", \"-KINGSMITH\", \"K-INGSMITH\", \"KI-NGSMITH\", \"KIN-GSMITH\", \"KING-SMITH\", \"KINGS-MITH\", \"KINGSM-ITH\", \"KINGSMI-TH\", \"KINGSMIT-H\", \"KINGSMITH-\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeIgnoreHyphens()",
            "parameters": [],
            "javadoc": "\n     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testEncodeIgnoreTrimmable": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\" \\t\\n\\r Washington \\t\\n\\r \"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"W252\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\" \\t\\n\\r Washington \\t\\n\\r \")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeIgnoreTrimmable()",
            "parameters": []
          }
        ],
        "testGenealogy": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Heggenburger\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"H251\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "s.encode(\"Heggenburger\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testGenealogy()",
            "parameters": []
          }
        ],
        "testHWRuleEx1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Ashcraft\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"A261\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Ashcraft\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHWRuleEx1()",
            "parameters": [],
            "javadoc": "\n     * Consonants from the same code group separated by W or H are treated as one.\n     "
          }
        ],
        "testHWRuleEx2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"BOOTHDAVIS\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"B312\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"BOOTHDAVIS\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHWRuleEx2()",
            "parameters": [],
            "javadoc": "\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * Test data from http://www.myatt.demon.co.uk/sxalg.htm\n     "
          }
        ],
        "testHWRuleEx3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Sgler\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"S460\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"SAILOR\", \"SALYER\", \"SAYLOR\", \"SCHALLER\", \"SCHELLER\", \"SCHILLER\", \"SCHOOLER\", \"SCHULER\", \"SCHUYLER\", \"SEILER\", \"SEYLER\", \"SHOLAR\", \"SHULER\", \"SILAR\", \"SILER\", \"SILLER\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"S460\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Sgler\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testHWRuleEx3()",
            "parameters": [],
            "javadoc": "\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testMsSqlServer1": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Smith\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"S530\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Smith\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMsSqlServer1()",
            "parameters": [],
            "javadoc": "\n     * Examples for MS SQLServer from\n     * https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp\n     "
          }
        ],
        "testMsSqlServer2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.checkEncodingVariations(java.lang.String, java.lang.String[])",
                "arguments": [
                  {
                    "variable_name": "\"E625\"",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "new String[] { \"Erickson\", \"Erickson\", \"Erikson\", \"Ericson\", \"Ericksen\", \"Ericsen\" }",
                    "variable_type": "java.lang.String[]"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMsSqlServer2()",
            "parameters": [],
            "javadoc": "\n     * Examples for MS SQLServer from\n     * https://support.microsoft.com/default.aspx?scid=https://support.microsoft.com:80/support\n     * /kb/articles/Q100/3/65.asp&NoWebContent=1\n     *\n     * @throws EncoderException for some failure scenarios     "
          }
        ],
        "testMsSqlServer3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Ann\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"A500\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Ann\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testMsSqlServer3()",
            "parameters": [],
            "javadoc": "\n     * Examples for MS SQLServer from https://databases.about.com/library/weekly/aa042901a.htm\n     "
          }
        ],
        "testNewInstance": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Williams\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"W452\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new Soundex().soundex(\"Williams\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNewInstance()",
            "parameters": [],
            "javadoc": "\n     * https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56\n     "
          }
        ],
        "testNewInstance2": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Williams\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"W452\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new Soundex(Soundex.US_ENGLISH_MAPPING_STRING.toCharArray()).soundex(\"Williams\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.toCharArray()",
                "arguments": [],
                "return_type": "char[]"
              }
            ],
            "signature": "public void testNewInstance2()",
            "parameters": []
          }
        ],
        "testNewInstance3": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Williams\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"W452\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new Soundex(Soundex.US_ENGLISH_MAPPING_STRING).soundex(\"Williams\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNewInstance3()",
            "parameters": []
          }
        ],
        "testSimplifiedSoundex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"WILLIAMS\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"W452\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "s.encode(\"WILLIAMS\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSimplifiedSoundex()",
            "parameters": []
          }
        ],
        "testSoundexUtilsConstructable": [
          {
            "call_methods": [],
            "signature": "public void testSoundexUtilsConstructable()",
            "parameters": []
          }
        ],
        "testSoundexUtilsNullBehaviour": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "SoundexUtils.differenceEncoded(null, \"\")",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.differenceEncoded(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "int"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "SoundexUtils.clean(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "SoundexUtils.clean(\"\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.language.SoundexUtils.clean(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testSoundexUtilsNullBehaviour()",
            "parameters": []
          }
        ],
        "testUsEnglishStatic": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.soundex(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Williams\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"W452\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "Soundex.US_ENGLISH.soundex(\"Williams\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUsEnglishStatic()",
            "parameters": [],
            "javadoc": "\n     * https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56\n     "
          }
        ],
        "testUsMappingEWithAcute": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> getStringEncoder().encode(\"\\u00e9\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"e\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"E000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"e\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Character.isLetter(char)",
                "arguments": [
                  {
                    "variable_name": "'\\u00e9'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testUsMappingEWithAcute()",
            "parameters": [],
            "javadoc": "\n     * Fancy characters are not mapped by the default US mapping.\n     *\n     * https://issues.apache.org/jira/browse/CODEC-30\n     "
          }
        ],
        "testUsMappingOWithDiaeresis": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> getStringEncoder().encode(\"\\u00f6\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"o\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"O000\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"o\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.Character.isLetter(char)",
                "arguments": [
                  {
                    "variable_name": "'\\u00f6'",
                    "variable_type": "char"
                  }
                ],
                "return_type": "boolean"
              }
            ],
            "signature": "public void testUsMappingOWithDiaeresis()",
            "parameters": [],
            "javadoc": "\n     * Fancy characters are not mapped by the default US mapping.\n     *\n     * https://issues.apache.org/jira/browse/CODEC-30\n     "
          }
        ],
        "testWikipediaAmericanSoundex": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.language.Soundex.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Robert\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.AbstractStringEncoderTest.getStringEncoder()",
                "arguments": [],
                "return_type": "T"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"R163\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "this.getStringEncoder().encode(\"Robert\")",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testWikipediaAmericanSoundex()",
            "parameters": [],
            "javadoc": "\n     * Tests example from https://en.wikipedia.org/wiki/Soundex#American_Soundex as of 2015-03-22.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests {@link Soundex}.\n *\n * <p>Keep this file in UTF-8 encoding for proper Javadoc processing.</p>\n "
    },
    "org.apache.commons.codec.net.BCodecTest": {
      "fields": [
        {
          "variable_name": "BASE64_IMPOSSIBLE_CASES",
          "variable_type": "java.lang.String"
        },
        {
          "variable_name": "SWISS_GERMAN_STUFF_UNICODE",
          "variable_type": "int"
        },
        {
          "variable_name": "RUSSIAN_STUFF_UNICODE",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "constructString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "(char) unicodeChar",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "private String constructString(int[])",
            "parameters": [
              {
                "variable_name": "unicodeChars",
                "variable_type": "int[]"
              }
            ]
          }
        ],
        "testBase64ImpossibleSamplesDefault": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBase64ImpossibleSamplesDefault()",
            "parameters": []
          }
        ],
        "testBase64ImpossibleSamplesLenient": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBase64ImpossibleSamplesLenient()",
            "parameters": []
          }
        ],
        "testBase64ImpossibleSamplesStrict": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> codec.decode(s)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.isStrictDecoding()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "codec.isStrictDecoding()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBase64ImpossibleSamplesStrict()",
            "parameters": []
          }
        ],
        "testBasicEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=?UTF-8?B?SGVsbG8gdGhlcmU=?=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic B encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBasicEncodeDecode()",
            "parameters": []
          }
        ],
        "testDecodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) decoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Decoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> bcodec.decode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"what not\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic B decoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeObjects()",
            "parameters": []
          }
        ],
        "testDecodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeStringWithNull()",
            "parameters": []
          }
        ],
        "testEncodeDecodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bcodec.encode((String) null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Null string B encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeDecodeNull()",
            "parameters": []
          }
        ],
        "testEncodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Encoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) plain",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> bcodec.encode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Trying to url encode a Double object should cause an exception.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=?UTF-8?B?d2hhdCBub3Q=?=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic B encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeObjects()",
            "parameters": []
          }
        ],
        "testEncodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"charset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeStringWithNull()",
            "parameters": []
          }
        ],
        "testInvalidEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "UnsupportedCharsetException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new BCodec(\"NONSENSE\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testInvalidEncoding()",
            "parameters": []
          }
        ],
        "testNullInput": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.doDecoding(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.doEncoding(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "bcodec.doDecoding(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNullInput()",
            "parameters": []
          }
        ],
        "testUTF8RoundTrip": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.BCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ru_msg",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "bcodec.encode(ru_msg)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"=?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "bcodec.encode(ru_msg)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.BCodecTest.constructString(int[])",
                "arguments": [
                  {
                    "variable_name": "RUSSIAN_STUFF_UNICODE",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUTF8RoundTrip()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Quoted-printable codec test cases\n "
    },
    "org.apache.commons.codec.net.PercentCodecTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testBasicEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "input.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedS",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic PercentCodec encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBasicEncodeDecode()",
            "parameters": []
          }
        ],
        "testBasicSpace": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[])",
                "arguments": [
                  {
                    "variable_name": "\"%20\".getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "input.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testBasicSpace()",
            "parameters": []
          }
        ],
        "testConfigurablePercentEncoder": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "input.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"%61%62%63123_-.*%CE%B1%CE%B2\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedS",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Configurable PercentCodec encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testConfigurablePercentEncoder()",
            "parameters": []
          }
        ],
        "testDecodeInvalidEncodedResultDecoding": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Class.isInstance(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "e",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "boolean"
              },
              {
                "signature": "java.lang.Throwable.getCause()",
                "arguments": [],
                "return_type": "java.lang.Throwable"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "inputS.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "Arrays.copyOf(encoded, encoded.length - 1)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "java.util.Arrays.copyOf(byte[], int)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "encoded.length - 1",
                    "variable_type": "int"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class.isInstance(e) && ArrayIndexOutOfBoundsException.class.isInstance(e.getCause())",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeInvalidEncodedResultDecoding()",
            "parameters": []
          }
        ],
        "testDecodeNullObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "percentCodec.decode((Object) null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeNullObject()",
            "parameters": []
          }
        ],
        "testDecodeUnsupportedObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> percentCodec.decode(\"test\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testDecodeUnsupportedObject()",
            "parameters": []
          }
        ],
        "testEncodeNullObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "percentCodec.encode((Object) null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeNullObject()",
            "parameters": []
          }
        ],
        "testEncodeUnsupportedObject": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> percentCodec.encode(\"test\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"test\"",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              }
            ],
            "signature": "public void testEncodeUnsupportedObject()",
            "parameters": []
          }
        ],
        "testInvalidByte": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "IllegalArgumentException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new PercentCodec(invalid, true)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testInvalidByte()",
            "parameters": []
          }
        ],
        "testPercentEncoderDecoderWithNullOrEmptyInput": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertArrayEquals(byte[], byte[], java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "percentCodec.decode(emptyInput)",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "emptyInput",
                    "variable_type": "byte[]"
                  },
                  {
                    "variable_name": "\"Empty input value decoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "percentCodec.encode(null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Null input value encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyInput",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "emptyInput",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "percentCodec.encode(emptyInput)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "emptyInput",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Empty input value encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testPercentEncoderDecoderWithNullOrEmptyInput()",
            "parameters": []
          }
        ],
        "testPercentEncoderDecoderWithPlusForSpace": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "input.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"a+b+c+d\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedS",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"PercentCodec plus for space encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testPercentEncoderDecoderWithPlusForSpace()",
            "parameters": []
          }
        ],
        "testSafeCharEncodeDecodeObject": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) input.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedS",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic PercentCodec safe char encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSafeCharEncodeDecodeObject()",
            "parameters": []
          }
        ],
        "testUnsafeCharEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "input.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.PercentCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"%CE%B1%CE%B2%CE%B3%CE%B4%CE%B5%CE%B6%25 \"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encodedS",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic PercentCodec unsafe char encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUnsafeCharEncodeDecode()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Percent codec test cases.\n "
    },
    "org.apache.commons.codec.net.QCodecTest": {
      "fields": [
        {
          "variable_name": "SWISS_GERMAN_STUFF_UNICODE",
          "variable_type": "int"
        },
        {
          "variable_name": "RUSSIAN_STUFF_UNICODE",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "constructString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "(char) unicodeChar",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "private String constructString(int[])",
            "parameters": [
              {
                "variable_name": "unicodeChars",
                "variable_type": "int[]"
              }
            ]
          }
        ],
        "testBasicEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=?UTF-8?Q?=3D Hello there =3D=0D=0A?=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic Q encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testBasicEncodeDecode()",
            "parameters": []
          }
        ],
        "testDecodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Decoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) decoded",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> qcodec.decode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Trying to url encode a Double object should cause an exception.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"1+1 = 2\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic Q decoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeObjects()",
            "parameters": []
          }
        ],
        "testDecodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeStringWithNull()",
            "parameters": []
          }
        ],
        "testEncodeDecodeBlanks": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QCodec.setEncodeBlanks(boolean)",
                "arguments": [
                  {
                    "variable_name": "false",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded1",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded1",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Blanks encoding with the Q codec test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeDecodeBlanks()",
            "parameters": []
          }
        ],
        "testEncodeDecodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qcodec.encode((String) null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Null string Q encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeDecodeNull()",
            "parameters": []
          }
        ],
        "testEncodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Encoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> qcodec.encode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Trying to url encode a Double object should cause an exception.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) plain",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=?UTF-8?Q?1+1 =3D 2?=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic Q encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeObjects()",
            "parameters": []
          }
        ],
        "testEncodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"charset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeStringWithNull()",
            "parameters": []
          }
        ],
        "testInvalidEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "UnsupportedCharsetException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new QCodec(\"NONSENSE\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testInvalidEncoding()",
            "parameters": []
          }
        ],
        "testLetUsMakeCloverHappy": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QCodec.isEncodeBlanks()",
                "arguments": [],
                "return_type": "boolean"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.setEncodeBlanks(boolean)",
                "arguments": [
                  {
                    "variable_name": "true",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertFalse(boolean)",
                "arguments": [
                  {
                    "variable_name": "qcodec.isEncodeBlanks()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertTrue(boolean)",
                "arguments": [
                  {
                    "variable_name": "qcodec.isEncodeBlanks()",
                    "variable_type": "boolean"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testLetUsMakeCloverHappy()",
            "parameters": []
          }
        ],
        "testNullInput": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "qcodec.doDecoding(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.doDecoding(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.doEncoding(byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testNullInput()",
            "parameters": []
          }
        ],
        "testUnsafeEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=?UTF-8?Q?=3F=5F=3D=0D=0A?=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Unsafe chars Q encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUnsafeEncodeDecode()",
            "parameters": []
          }
        ],
        "testUTF8RoundTrip": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QCodecTest.constructString(int[])",
                "arguments": [
                  {
                    "variable_name": "RUSSIAN_STUFF_UNICODE",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qcodec.encode(ru_msg)",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"=?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?=\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "qcodec.encode(ru_msg)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ru_msg",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUTF8RoundTrip()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Quoted-printable codec test cases\n "
    },
    "org.apache.commons.codec.net.QuotedPrintableCodecTest": {
      "fields": [
        {
          "variable_name": "SWISS_GERMAN_STUFF_UNICODE",
          "variable_type": "int"
        },
        {
          "variable_name": "RUSSIAN_STUFF_UNICODE",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "constructString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "(char) unicodeChar",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "private String constructString(int[])",
            "parameters": [
              {
                "variable_name": "unicodeChars",
                "variable_type": "int[]"
              }
            ]
          }
        ],
        "testBasicEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=3D Hello there =3D=0D=0A\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic quoted-printable encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBasicEncodeDecode()",
            "parameters": []
          }
        ],
        "testDecodeInvalid": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> qpcodec.decode(\"=\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeInvalid()",
            "parameters": []
          }
        ],
        "testDecodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Decoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> qpcodec.decode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Trying to url encode a Double object should cause an exception.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) plain",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"1+1 = 2\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic quoted-printable decoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeObjects()",
            "parameters": []
          }
        ],
        "testDecodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"charset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeStringWithNull()",
            "parameters": []
          }
        ],
        "testDecodeWithNullArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(byte[])",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeWithNullArray()",
            "parameters": []
          }
        ],
        "testDefaultEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encoded1",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded2",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"UnicodeBig\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDefaultEncoding()",
            "parameters": []
          }
        ],
        "testEncodeDecodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qpcodec.encode((String) null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Null string quoted-printable encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeDecodeNull()",
            "parameters": []
          }
        ],
        "testEncodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Encoding a null string should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeNull()",
            "parameters": []
          }
        ],
        "testEncodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Encoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) plain",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> qpcodec.encode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Trying to url encode a Double object should cause an exception.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"1+1 =3D 2\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic quoted-printable encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeObjects()",
            "parameters": []
          }
        ],
        "testEncodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"charset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeStringWithNull()",
            "parameters": []
          }
        ],
        "testEncodeUrlWithNullBitSet": [
          {
            "call_methods": [
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"1+1 =3D 2\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic quoted-printable encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encodeQuotedPrintable(java.util.BitSet, byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.util.BitSet"
                  },
                  {
                    "variable_name": "plain.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeUrlWithNullBitSet()",
            "parameters": []
          }
        ],
        "testFinalBytes": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "new QuotedPrintableCodec(true).encode(plain)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testFinalBytes()",
            "parameters": []
          }
        ],
        "testInvalidEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "UnsupportedCharsetException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new QuotedPrintableCodec(\"NONSENSE\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              }
            ],
            "signature": "public void testInvalidEncoding()",
            "parameters": []
          }
        ],
        "testSafeCharEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Safe chars quoted-printable encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSafeCharEncodeDecode()",
            "parameters": []
          }
        ],
        "testSkipNotEncodedCRLF": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qpdata",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "qpcodec.decode(qpdata)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSkipNotEncodedCRLF()",
            "parameters": []
          }
        ],
        "testSoftLineBreakDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qpdata",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "qpcodec.decode(qpdata)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSoftLineBreakDecode()",
            "parameters": []
          }
        ],
        "testSoftLineBreakEncode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qpdata",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "qpdata",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "qpcodec.encode(expected)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSoftLineBreakEncode()",
            "parameters": []
          }
        ],
        "testTooShortByteArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"AA\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qpcodec.encode(\"AA\")",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testTooShortByteArray()",
            "parameters": []
          }
        ],
        "testTrailingSpecial": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "qpcodec.encode(plain)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testTrailingSpecial()",
            "parameters": []
          }
        ],
        "testUltimateSoftBreak": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "expected",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "qpcodec.encode(plain)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUltimateSoftBreak()",
            "parameters": []
          }
        ],
        "testUnsafeEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"=3D=0D=0A\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Unsafe chars quoted-printable encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUnsafeEncodeDecode()",
            "parameters": []
          }
        ],
        "testUTF8RoundTrip": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodecTest.constructString(int[])",
                "arguments": [
                  {
                    "variable_name": "RUSSIAN_STUFF_UNICODE",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"=D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "qpcodec.encode(ru_msg, CharEncoding.UTF_8)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.decode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "qpcodec.encode(ru_msg, CharEncoding.UTF_8)",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_8",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.QuotedPrintableCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ru_msg",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_8",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUTF8RoundTrip()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Quoted-printable codec test cases\n "
    },
    "org.apache.commons.codec.net.RFC1522CodecTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "assertExpectedDecoderException": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> new RFC1522TestCodec().decodeText(s)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.decodeText(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "s",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "private void assertExpectedDecoderException(String)",
            "parameters": [
              {
                "variable_name": "s",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "testDecodeInvalid": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522CodecTest.assertExpectedDecoderException(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"whatever\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeInvalid()",
            "parameters": []
          }
        ],
        "testNullInput": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_8",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.decodeText(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "testCodec.decodeText(null)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testNullInput()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * RFC 1522 compliant codec test cases\n "
    },
    "org.apache.commons.codec.net.RFC1522CodecTest.RFC1522TestCodec": {
      "fields": [],
      "constructors": [
        {
          "body": " RFC1522TestCodec()\n{\r\n    super(StandardCharsets.UTF_8);\r\n}",
          "signature": "RFC1522TestCodec()",
          "parameters": []
        }
      ],
      "methods": {
        "doDecoding": [
          {
            "call_methods": [],
            "signature": "protected byte[] doDecoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "doEncoding": [
          {
            "call_methods": [],
            "signature": "protected byte[] doEncoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "getEncoding": [
          {
            "call_methods": [],
            "signature": "protected String getEncoding()",
            "parameters": []
          }
        ]
      },
      "is_interface": false
    },
    "org.apache.commons.codec.net.RFC1522OverrideTestCodec": {
      "fields": [],
      "constructors": [
        {
          "body": " RFC1522OverrideTestCodec()\n{\r\n    super(StandardCharsets.UTF_8);\r\n}",
          "signature": "RFC1522OverrideTestCodec()",
          "parameters": []
        }
      ],
      "methods": {
        "decodeText": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.decodeText(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "protected String decodeText(String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "doDecoding": [
          {
            "call_methods": [],
            "signature": "protected byte[] doDecoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "doEncoding": [
          {
            "call_methods": [],
            "signature": "protected byte[] doEncoding(byte[])",
            "parameters": [
              {
                "variable_name": "bytes",
                "variable_type": "byte[]"
              }
            ]
          }
        ],
        "encodeText": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "charset",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "protected String encodeText(String, Charset)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charset",
                "variable_type": "java.nio.charset.Charset"
              }
            ]
          },
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.RFC1522Codec.encodeText(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "text",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "charsetName",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "protected String encodeText(String, String)",
            "parameters": [
              {
                "variable_name": "text",
                "variable_type": "java.lang.String"
              },
              {
                "variable_name": "charsetName",
                "variable_type": "java.lang.String"
              }
            ]
          }
        ],
        "getEncoding": [
          {
            "call_methods": [],
            "signature": "protected String getEncoding()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests overriding the package private RFC1522Codec.\n "
    },
    "org.apache.commons.codec.net.URLCodecTest": {
      "fields": [
        {
          "variable_name": "SWISS_GERMAN_STUFF_UNICODE",
          "variable_type": "int"
        },
        {
          "variable_name": "RUSSIAN_STUFF_UNICODE",
          "variable_type": "int"
        }
      ],
      "constructors": [],
      "methods": {
        "constructString": [
          {
            "call_methods": [
              {
                "signature": "java.lang.StringBuilder.toString()",
                "arguments": [],
                "return_type": "java.lang.String"
              },
              {
                "signature": "java.lang.StringBuilder.append(char)",
                "arguments": [
                  {
                    "variable_name": "(char) unicodeChar",
                    "variable_type": "char"
                  }
                ],
                "return_type": "java.lang.StringBuilder"
              }
            ],
            "signature": "private String constructString(int[])",
            "parameters": [
              {
                "variable_name": "unicodeChars",
                "variable_type": "int[]"
              }
            ]
          }
        ],
        "testBasicEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello+there%21\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic URL encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testBasicEncodeDecode()",
            "parameters": []
          }
        ],
        "testDecodeInvalid": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> urlCodec.decode(\"%\")",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"%\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeInvalid()",
            "parameters": []
          }
        ],
        "testDecodeInvalidContent": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.ISO_8859_1",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int)",
                "arguments": [
                  {
                    "variable_name": "input.length",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "output.length",
                    "variable_type": "int"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(byte[])",
                "arguments": [
                  {
                    "variable_name": "input",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(byte, byte)",
                "arguments": [
                  {
                    "variable_name": "input[i]",
                    "variable_type": "byte"
                  },
                  {
                    "variable_name": "output[i]",
                    "variable_type": "byte"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.constructString(int[])",
                "arguments": [
                  {
                    "variable_name": "SWISS_GERMAN_STUFF_UNICODE",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeInvalidContent()",
            "parameters": []
          }
        ],
        "testDecodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) plain",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Decoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "DecoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> urlCodec.decode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Trying to url encode a Double object should cause an exception.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello there!\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "decoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic URL decoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeObjects()",
            "parameters": []
          }
        ],
        "testDecodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"charset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDecodeStringWithNull()",
            "parameters": []
          }
        ],
        "testDecodeWithNullArray": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decodeUrl(byte[])",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testDecodeWithNullArray()",
            "parameters": []
          }
        ],
        "testDefaultEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "encoded1",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded2",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"UnicodeBig\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testDefaultEncoding()",
            "parameters": []
          }
        ],
        "testEncodeDecodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "urlCodec.encode((String) null)",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Null string URL encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "(String) null",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeDecodeNull()",
            "parameters": []
          }
        ],
        "testEncodeNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Encoding a null string should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(byte[])",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              }
            ],
            "signature": "public void testEncodeNull()",
            "parameters": []
          }
        ],
        "testEncodeObjects": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Encoding a null Object should return null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "(Object) plain",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "java.lang.Object"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> urlCodec.encode(Double.valueOf(3.0d))",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"Trying to url encode a Double object should cause an exception.\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello+there%21\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic URL encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeObjects()",
            "parameters": []
          }
        ],
        "testEncodeStringWithNull": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertNull(java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "result",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result should be null\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "test",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "\"charset\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testEncodeStringWithNull()",
            "parameters": []
          }
        ],
        "testEncodeUrlWithNullBitSet": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.lang.String.getBytes(java.nio.charset.Charset)",
                "arguments": [
                  {
                    "variable_name": "StandardCharsets.UTF_8",
                    "variable_type": "java.nio.charset.Charset"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encodeUrl(java.util.BitSet, byte[])",
                "arguments": [
                  {
                    "variable_name": "null",
                    "variable_type": "java.util.BitSet"
                  },
                  {
                    "variable_name": "plain.getBytes(StandardCharsets.UTF_8)",
                    "variable_type": "byte[]"
                  }
                ],
                "return_type": "byte[]"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"Hello+there%21\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Basic URL encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testEncodeUrlWithNullBitSet()",
            "parameters": []
          }
        ],
        "testInvalidEncoding": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertThrows(java.lang.Class<T>, org.junit.jupiter.api.function.Executable, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "EncoderException.class",
                    "variable_type": "java.lang.Class<T>"
                  },
                  {
                    "variable_name": "() -> urlCodec.encode(plain)",
                    "variable_type": "org.junit.jupiter.api.function.Executable"
                  },
                  {
                    "variable_name": "\"We set the encoding to a bogus NONSENSE value\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "T"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testInvalidEncoding()",
            "parameters": []
          }
        ],
        "testSafeCharEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Safe chars URL encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testSafeCharEncodeDecode()",
            "parameters": []
          }
        ],
        "testUnsafeEncodeDecode": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "plain",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "\"%7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "encoded",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Unsafe chars URL encoding test\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testUnsafeEncodeDecode()",
            "parameters": []
          }
        ],
        "testUTF8RoundTrip": [
          {
            "call_methods": [
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.validateState(org.apache.commons.codec.net.URLCodec)",
                "arguments": [
                  {
                    "variable_name": "urlCodec",
                    "variable_type": "org.apache.commons.codec.net.URLCodec"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object)",
                "arguments": [
                  {
                    "variable_name": "\"%D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82\"",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "urlCodec.encode(ru_msg, CharEncoding.UTF_8)",
                    "variable_type": "java.lang.Object"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.decode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "urlCodec.encode(ru_msg, CharEncoding.UTF_8)",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_8",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodecTest.constructString(int[])",
                "arguments": [
                  {
                    "variable_name": "RUSSIAN_STUFF_UNICODE",
                    "variable_type": "int[]"
                  }
                ],
                "return_type": "java.lang.String"
              },
              {
                "signature": "org.apache.commons.codec.net.URLCodec.encode(java.lang.String, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "ru_msg",
                    "variable_type": "java.lang.String"
                  },
                  {
                    "variable_name": "CharEncoding.UTF_8",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "java.lang.String"
              }
            ],
            "signature": "public void testUTF8RoundTrip()",
            "parameters": []
          }
        ],
        "validateState": [
          {
            "call_methods": [],
            "signature": "private void validateState(URLCodec)",
            "parameters": [
              {
                "variable_name": "urlCodec",
                "variable_type": "org.apache.commons.codec.net.URLCodec"
              }
            ]
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * URL codec test cases\n "
    },
    "org.apache.commons.codec.net.UtilsTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testConstructor": [
          {
            "call_methods": [],
            "signature": "public void testConstructor()",
            "parameters": [],
            "javadoc": "\n     * We could make the constructor private but there does not seem to be a point to jumping through extra code hoops\n     * to restrict instantiation right now.\n     "
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Tests Utils.\n * <p>\n * Methods currently get 100%/100% line/branch code coverage from other tests classes.\n * </p>\n "
    },
    "org.apache.commons.codec.StringEncoderComparatorTest": {
      "fields": [],
      "constructors": [],
      "methods": {
        "testComparatorWithDoubleMetaphone": [
          {
            "call_methods": [
              {
                "signature": "java.util.List.sort(java.util.Comparator<? super E>)",
                "arguments": [
                  {
                    "variable_name": "sCompare",
                    "variable_type": "java.util.Comparator<? super E>"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Arrays.asList(T...)",
                "arguments": [
                  {
                    "variable_name": "testArray",
                    "variable_type": "T..."
                  }
                ],
                "return_type": "java.util.List<T>"
              },
              {
                "signature": "java.util.List.toArray(T[])",
                "arguments": [
                  {
                    "variable_name": "ArrayUtils.EMPTY_STRING_ARRAY",
                    "variable_type": "T[]"
                  }
                ],
                "return_type": "T[]"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(java.lang.Object, java.lang.Object, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "controlArray[i]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "resultArray[i]",
                    "variable_type": "java.lang.Object"
                  },
                  {
                    "variable_name": "\"Result Array not Equal to Control Array at index: \" + i",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              }
            ],
            "signature": "public void testComparatorWithDoubleMetaphone()",
            "parameters": []
          }
        ],
        "testComparatorWithDoubleMetaphoneAndInvalidInput": [
          {
            "call_methods": [
              {
                "signature": "java.lang.Long.valueOf(long)",
                "arguments": [
                  {
                    "variable_name": "3",
                    "variable_type": "long"
                  }
                ],
                "return_type": "java.lang.Long"
              },
              {
                "signature": "java.lang.Double.valueOf(double)",
                "arguments": [
                  {
                    "variable_name": "3.0d",
                    "variable_type": "double"
                  }
                ],
                "return_type": "java.lang.Double"
              },
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "compare",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"Trying to compare objects that make no sense to the underlying encoder\" + \" should return a zero compare code\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Comparator.compare(T, T)",
                "arguments": [
                  {
                    "variable_name": "Double.valueOf(3.0d)",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "Long.valueOf(3)",
                    "variable_type": "T"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testComparatorWithDoubleMetaphoneAndInvalidInput()",
            "parameters": []
          }
        ],
        "testComparatorWithSoundex": [
          {
            "call_methods": [
              {
                "signature": "org.junit.jupiter.api.Assertions.assertEquals(int, int, java.lang.String)",
                "arguments": [
                  {
                    "variable_name": "0",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "sCompare.compare(\"O'Brien\", \"O'Brian\")",
                    "variable_type": "int"
                  },
                  {
                    "variable_name": "\"O'Brien and O'Brian didn't come out with the same Soundex, something must be wrong here\"",
                    "variable_type": "java.lang.String"
                  }
                ],
                "return_type": "void"
              },
              {
                "signature": "java.util.Comparator.compare(T, T)",
                "arguments": [
                  {
                    "variable_name": "\"O'Brien\"",
                    "variable_type": "T"
                  },
                  {
                    "variable_name": "\"O'Brian\"",
                    "variable_type": "T"
                  }
                ],
                "return_type": "int"
              }
            ],
            "signature": "public void testComparatorWithSoundex()",
            "parameters": []
          }
        ]
      },
      "is_interface": false,
      "javadoc": "\n * Test cases for the StingEncoderComparator.\n "
    }
  }
}