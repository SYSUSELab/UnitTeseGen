import os
import javalang
from typing import List, Dict, Tuple

import utils

class CodeSearcher:
    def __init__(self, project_path: str):
        self.project_path = project_path

    def get_test_classes(self, class_url: str):
        """
        搜索Java项目中指定类的测试类
        """
        test_source = f"{self.project_path}/{class_url}".replace("test/", "test-original/")
        content = None
        if os.path.exists(test_source):
            content = utils.load_text(test_source)
        return content

    def search_class_usage(self, target_class: str) -> List[Dict]:
        """
        搜索Java项目中指定类的变量声明并提取上下文
        Args:
            target_class: 要搜索的类名
        Returns:
            包含变量声明信息的列表，每个元素是包含文件路径、行号和上下文的字典
        """
        project_source = f"{self.project_path}/src" #/main/java"
        results = []
        
        # go through all Java files in the project directory
        for root, _, files in os.walk(project_source):
            # skip test files generated by LLM
            if "src/test/java" in root: continue
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    try:
                        # parse java source code
                        content = utils.load_text(file_path)
                        tree = javalang.parse.parse(content)
                        lines = content.splitlines()
                        # Traverse AST to find variable declarations
                        for path, node in tree.filter(javalang.tree.ClassCreator):
                            line_num = 0
                            # get the line number of the variable declaration
                            for p in path:
                                if hasattr(p, 'position') and p.position:
                                    line_num = p.position.line
                            if node.type.name == target_class:
                                # 提取上下文（声明前后各3行）
                                context_start = max(0, line_num - 4)
                                context_end = min(len(lines), line_num + 3)
                                context = lines[context_start:context_end]
                                results.append({
                                    'file': file_path,
                                    'line': line_num,
                                    'context': '\n'.join(context)
                                })
                                                
                        # # 遍历AST查找变量声明
                        # for path, node in tree.filter(javalang.tree.FieldDeclaration):
                        #     # 获取变量类型和修饰符
                        #     var_type = node.type.name if node.type else None
                            
                        #     if var_type == target_class:
                        #         line_num = 0
                        #         for p in path:
                        #             if hasattr(p, 'position') and p.position:
                        #                 line_num = p.position.line
                                    
                        #         context_start = max(0, line_num - 4)
                        #         context_end = min(len(lines), line_num + 3)
                        #         context = lines[context_start:context_end]
                        #         results.append({
                        #             'file': file_path,
                        #             'line': line_num,
                        #             'context': '\n'.join(context)
                        #         })

                    except Exception as e:
                        print(f"error occured while processing file {file_path}: {str(e)}")
        return results

    def search_method_usage(self, target_method: str) -> List[Dict]:
        """
        搜索Java项目中指定方法名的使用情况并提取上下文
        Args:
            target_method: 要搜索的方法名
            
        Returns:
            包含方法使用信息的列表，每个元素是包含文件路径、行号和上下文的字典
        """
        project_source = f"{self.project_path}/src" #/main/java"
        results = []
        
        # go through all Java files in the project directory
        for root, _, files in os.walk(project_source):
            for file in files:
                # skip test files generated by LLM
                if "src/test/java" in root: continue
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    try:
                        # parse java source code
                        content = utils.load_text(file_path)
                        tree = javalang.parse.parse(content)
                        lines = content.splitlines()
                        # Traverse AST to find method invocations
                        for path, node in tree.filter(javalang.tree.MethodInvocation):
                            if node.member == target_method:
                                line_num = node.position.line if node.position else 0
                                # exstract context (3 lines before and after)
                                context_start = max(0, line_num - 4)
                                context_end = min(len(lines), line_num + 3)
                                context = lines[context_start:context_end]
                                results.append({
                                    'file': file_path,
                                    'line': line_num,
                                    'context': '\n'.join(context)
                                })
                    except Exception as e:
                        print(f"处理文件 {file_path} 时出错: {str(e)}")
        return results
    
    def collect_construct_context(self, class_name, class_url):
        source = f"{self.project_path}/{class_url}"
        context = {}
        if os.path.exists(source):
            content = utils.load_text(source)
            lines = content.splitlines()

            # 解析Java源代码为语法树，并确保每个节点都有position属性
            tree = javalang.parse.parse(content)
            construct_functions = []
            for path, node in tree.filter(javalang.tree.ConstructorDeclaration):
                if node.name == class_name:
                    if node.position:
                        # 获取构造函数的起始行和结束行
                        start_line = node.position.line - 1                   
                        body_text = '\n'.join(lines[start_line-1:])  # 从构造函数开始的行
                        brace_count = 0
                        end_line = start_line
                    
                        for i, char in enumerate(body_text):
                            if char == '{':
                                brace_count += 1
                            elif char == '}':
                                brace_count -= 1
                                if brace_count == 0 and i > 0:  # 找到匹配的右大括号
                                    # 计算结束行号
                                    line_count = body_text[:i].count('\n') + start_line
                                    end_line = line_count
                                    break
                        # 提取构造函数的完整内容
                        constructor_content = '\n'.join(lines[start_line-1:end_line])
                    else:
                        start_line = 0
                        end_line = 5
                    
                    body = lines[start_line:end_line]
                    print(start_line, end_line)
                    print(body)
                    # print(node.body[-1])
                    # print(node.children)
                    construct_functions.append('\n'.join(body))
            context["construct function"] = construct_functions
        else:
            print(f"exception: source code of {class_name} not found")
        return context

    def collect_usage_context(self, class_name, class_url, method_name):
        
        return

def print_search_results(results: List[Dict]) -> None:
    """
    打印搜索结果
    Args:
        results: 搜索结果列表
    """
    if not results:
        print("未找到方法的使用")
        return
        
    for result in results:
        print(f"\n文件: {result['file']}")
        print(f"行号: {result['line']}")
        print("上下文:")
        print("-" * 50)
        print(result['context'])
        print("-" * 50)


if __name__ == "__main__":
    project_path = "../dataset/puts/commons-csv"
    method_name = "nextToken"
    searcher = CodeSearcher(project_path)
    # results = searcher.search_method_usage(method_name)
    class_name = "CSVFormat" #"Lexer"
    # results = searcher.search_class_usage(class_name)
    class_url = "src/main/java/org/apache/commons/csv/CSVFormat.java"
    results = searcher.collect_construct_context(class_name, class_url)
    # print(results)